/*
* Copyright (C) 2020 Beijing Jinyi Data Technology Co., Ltd. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
/*!
    \file generator_cpp.cpp
    \brief Fast binary encoding C++ generator implementation
    \author Ivan Shynkarenka
    \date 20.04.2018
    \copyright MIT License
*/
#include "generator_cpp.h"
#include "generator_cpp_fixture.h"

namespace FBE {

void GeneratorCpp::Generate(const std::shared_ptr<Package>& package)
{
    // Generate common files
    GenerateFBE_Header(_output);
    GenerateFBE_Source(_output);

    // Generate common models files
    GenerateFBEModels_Header(_output);
    GenerateFBEModels_Inline(_output);
    GenerateFBEModels_Source(_output);

    if (Ptr()) {
        GenerateFBEPtr_Header(_output);
        GenerateFBECustomModels_Header(_output);
        GenerateFBECustomModels_Inline(_output);

        // Generate package files
        GeneratePtrPackage_Header(package);
        GeneratePtrPackage_Source(package);
        // Generate package models files
        GeneratePtrPackageModels_Header(package);
        GeneratePtrPackageModels_Source(package);
        return;
    }

    if (Final())
    {
        GenerateFBEFinalModels_Header(_output);
        GenerateFBEFinalModels_Inline(_output);
        GenerateFBEFinalModels_Source(_output);
    }

    // Generate common protocol files
    if (Proto())
    {
        GenerateFBEProtocol_Header(_output);
        GenerateFBEProtocol_Source(_output);
    }

    // Generate common JSON files
    if (JSON())
        GenerateFBEJson_Header(_output);

    // Generate package files
    GeneratePackage_Header(package);
    GeneratePackage_Source(package);
    if (JSON())
        GeneratePackage_Json(package);

    // Generate package models files
    GeneratePackageModels_Header(package);
    GeneratePackageModels_Source(package);
    if (Final())
    {
        GeneratePackageFinalModels_Header(package);
        GeneratePackageFinalModels_Source(package);
    }

    // Generate package protocol files
    if (Proto())
    {
        GeneratePackageProtocol_Header(package, false);
        GeneratePackageProtocol_Source(package, false);
        if (Final())
        {
            GeneratePackageProtocol_Header(package, true);
            GeneratePackageProtocol_Source(package, true);
        }
    }
}

void GeneratorCpp::GenerateBannerComments(const std::string& source) {
    std::string code = R"CODE(//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: _INPUT_
// FBE version: _VERSION_
//------------------------------------------------------------------------------
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_INPUT_"), source);
    code = std::regex_replace(code, std::regex("_VERSION_"), version);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateHeader(const std::string& source)
{
    GenerateBannerComments(source);
    std::string code = R"CODE(
#pragma once

#ifdef isset
#undef isset
#endif

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateInline(const std::string& source)
{
    GenerateBannerComments(source);
}

void GeneratorCpp::GenerateSource(const std::string& source)
{
    GenerateBannerComments(source);
}

void GeneratorCpp::GenerateWarningsHeader()
{
    std::string code = R"CODE(
#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4065) // C4065: switch statement contains 'default' but no 'case' labels
#endif
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateWarningsFooter()
{
    std::string code = R"CODE(
#if defined(_MSC_VER)
#pragma warning(pop)
#endif
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFooter()
{
}

void GeneratorCpp::GenerateImports()
{
    std::string code = GeneratorCPPFixture::GenerateImports();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate logging protocol definitions
    if (Logging())
    {
        WriteLine();
        WriteLineIndent("#define LOGGING_PROTOCOL 1");
        WriteLineIndent("#include <logging/logger.h>");
    }
}

void GeneratorCpp::GenerateImportsSource()
{
    std::string code = GeneratorCPPFixture::GenerateImportsSource();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateImports(const std::string& source)
{
    WriteLine();
    WriteLineIndent("#include \"" + source + "\"");
}

void GeneratorCpp::GenerateImports(const std::shared_ptr<Package>& p)
{
    // Generate common imports
    WriteLine();
    WriteLineIndent("#include \"fbe.h\"");
    if (Arena()) {
        WriteLineIndent("#include \"" + ArenaHeader() + "\"");
    }

    // Generate packages import
    if (p->import)
    {
        WriteLine();
        for (const auto& import : p->import->imports)
            WriteLineIndent("#include \"" + ConvertFileName(*import, FileType::Struct, true, ImportPtr()) + "\"");
    }

    // Generate domain namespace using
    WriteLine();
    WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");
    WriteLineIndent("using namespace FBE;");
    if (Arena()) {
        WriteLineIndent("using allocator_type = pmr::polymorphic_allocator<char>;");
    }
    if (p->import)
    {
        for (const auto& import : p->import->imports)
            WriteLineIndent("using namespace ::" + ConvertNamespace(*import) + ";");
    }
    WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));

    // Generate FBE namespace using
    WriteLine();
    WriteLineIndent("namespace FBE {");
    WriteLineIndent("using namespace ::" + ConvertNamespace(*p->name) + ";");
    WriteLineIndent("} // namespace FBE");
}

void GeneratorCpp::GenerateImportsModels(const std::shared_ptr<Package>& p, bool final, bool ptr)
{
    // Generate common imports
    WriteLine();
    WriteLineIndent("#include \"" + ConvertFileName(*p->name, FileType::Struct, true, ptr) + "\""); // import structs

    // Generate packages import
    if (p->import)
    {
        WriteLine();
        for (const auto& import : p->import->imports)
            WriteLineIndent("#include \"" + ConvertFileName(*import, FileType::Model, true, ImportPtr(), final) + "\"");
    }
}

void GeneratorCpp::GenerateImportsProtocol(const std::shared_ptr<Package>& p, bool final)
{
    // Generate common imports
    WriteLine();
    WriteLineIndent("#include \"" + *p->name + (final ? "_final" : "") + "_models.h\"");

    // Generate packages import
    if (p->import)
    {
        WriteLine();
        for (const auto& import : p->import->imports)
            WriteLineIndent("#include \"" + *import + (final ? "_final" : "") + "_protocol.h\"");
    }
}

void GeneratorCpp::GenerateImportsJson()
{
    WriteLine();
    WriteLineIndent("#define RAPIDJSON_HAS_STDSTRING 1");
    WriteLineIndent("#include <rapidjson/document.h>");
    WriteLineIndent("#include <rapidjson/prettywriter.h>");
}

void GeneratorCpp::GenerateImportsJson(const std::shared_ptr<Package>& p)
{
    // Generate common imports
    WriteLine();
    WriteLineIndent("#include \"fbe_json.h\"");

    // Generate common imports
    WriteLine();
    WriteLineIndent("#include \"" + *p->name + ".h\"");

    // Generate packages import
    if (p->import)
    {
        WriteLine();
        for (const auto& import : p->import->imports)
            WriteLineIndent("#include \"" + *import + "_json.h\"");
    }
}

void GeneratorCpp::GenerateUnalignedAccessor_Header()
{
    std::string code = R"CODE(
template <typename T>
inline auto unaligned_load(void const* ptr) noexcept -> T {
    // using memcpy so we don't get into unaligned load problems.
    // compiler should optimize this very well anyways.
    T t;
    std::memcpy(&t, ptr, sizeof(T));
    return t;
};

template <typename T>
inline void unaligned_store(void *ptr, T v) { memcpy(ptr, &v, sizeof(T)); }
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateImportHelper_Header()
{
    std::string code = R"CODE(
template<typename T> struct is_variant : std::false_type {};

template<typename ...Args>
struct is_variant<std::variant<Args...>> : std::true_type {};

template<typename T>
inline constexpr bool is_variant_v=is_variant<T>::value;

template<typename T, typename Alloc>
auto assign_member(Alloc alloc) -> T {
    return T(alloc);
}

template<typename T, typename Alloc>
requires std::is_enum_v<T> || is_variant_v<T>
auto assign_member([[maybe_unused]] Alloc alloc) -> T {
    return T();
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateVariantVisitHelper_Header()
{
    std::string code = R"CODE(
template<class... Ts> struct overloaded : Ts... { using Ts::operator()...; };

template<class... Ts> overloaded(Ts...) -> overloaded<Ts...>;  // deduction guide
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateBufferWrapper_Header()
{
    std::string code = GeneratorCPPFixture::GenerateBufferWrapper_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateBufferWrapper_Source()
{
    std::string code = GeneratorCPPFixture::GenerateBufferWrapper_Source();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());
    Write(code);
}

void GeneratorCpp::GeneratePMRBufferWrapper_Header()
{
    std::string code = GeneratorCPPFixture::GeneratePMRBufferWrapper_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GeneratePMRBufferWrapper_Source()
{
    std::string code = GeneratorCPPFixture::GeneratePMRBufferWrapper_Source();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());
    Write(code);
}

void GeneratorCpp::GenerateDecimalWrapper_Header()
{
    std::string code = GeneratorCPPFixture::GenerateDecimalWrapper_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFlagsWrapper_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFlagsWrapper_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateTimeWrapper_Header()
{
    std::string code = GeneratorCPPFixture::GenerateTimeWrapper_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateTimeWrapper_Source()
{
    std::string code = GeneratorCPPFixture::GenerateTimeWrapper_Source();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateUUIDWrapper_Header()
{
    std::string code = GeneratorCPPFixture::GenerateUUIDWrapper_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateUUIDWrapper_Source()
{
    std::string code = GeneratorCPPFixture::GenerateUUIDWrapper_Source();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEBuffer_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEBuffer_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEBuffer_Source()
{
    std::string code = GeneratorCPPFixture::GenerateFBEBuffer_Source();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEBaseModel_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEBaseModel_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModel_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModel_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModel_Inline()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModel_Inline();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelDecimal_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelDecimal_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelDecimal_Source()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelDecimal_Source();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelUUID_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelUUID_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelUUID_Source()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelUUID_Source();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelBytes_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelBytes_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelBytes_Source()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelBytes_Source();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelPMRBytes_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelPMRBytes_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelPMRBytes_Source()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelPMRBytes_Source();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelMemoryString_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelMemoryString_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelMemoryArenaString_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelMemoryArenaString_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelMemoryString_Source()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelMemoryString_Source();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelMemoryArenaString_Source()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelMemoryArenaString_Source();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelOptional_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelOptional_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelOptional_Inline()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelOptional_Inline();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelArray_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelArray_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelArray_Inline()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelArray_Inline();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelVector_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelVector_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelVector_Inline()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelVector_Inline();


    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());
    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelMap_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelMap_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());
    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelMap_Inline()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelMap_Inline();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());
    Write(code);
}

void GeneratorCpp::GenerateFBEFinalModel_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFinalModel_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFinalModel_Inline()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFinalModel_Inline();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelDecimal_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFinalModelDecimal_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelDecimal_Source()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFinalModelDecimal_Source();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelUUID_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFinalModelUUID_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelUUID_Source()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFinalModelUUID_Source();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelBytes_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFinalModelBytes_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelBytes_Source()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFinalModelBytes_Source();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelString_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFinalModelString_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelString_Source()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFinalModelString_Source();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelOptional_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFinalModelOptional_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelOptional_Inline()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFinalModelOptional_Inline();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelArray_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFinalModelArray_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelArray_Inline()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFinalModelArray_Inline();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelVector_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFinalModelVector_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelVector_Inline()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFinalModelVector_Inline();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelMap_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFinalModelMap_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelMap_Inline()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFinalModelMap_Inline();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBESender_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBESender_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBESender_Source()
{
    std::string code = GeneratorCPPFixture::GenerateFBESender_Source();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEReceiver_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEReceiver_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEReceiver_Source()
{
    std::string code = GeneratorCPPFixture::GenerateFBEReceiver_Source();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEJson()
{
    std::string code = GeneratorCPPFixture::GenerateFBEJson();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBE_Header(const fs::path& path)
{
    // Create package path
    create_dir(path);

    // Generate the common file
    fs::path common = path / "fbe.h";
    WriteBegin();

    // Generate common header
    GenerateHeader("FBE");

    // Generate imports
    GenerateImports();

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");

    // Generate common body
    GenerateUnalignedAccessor_Header();
    GenerateImportHelper_Header();
    GenerateVariantVisitHelper_Header();
    GenerateBufferWrapper_Header();
    GeneratePMRBufferWrapper_Header();
    GenerateDecimalWrapper_Header();
    GenerateFlagsWrapper_Header();
    GenerateTimeWrapper_Header();
    GenerateUUIDWrapper_Header();
    GenerateFBEBuffer_Header();
    GenerateFBEBaseModel_Header();

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate common footer
    GenerateFooter();

    // Store the common file
    WriteEnd();
    Store(common);
}

void GeneratorCpp::GenerateFBE_Source(const fs::path& path)
{
    // Create package path
    create_dir(path);

    // Generate the common file
    fs::path common = path / "fbe.cpp";
    WriteBegin();

    // Generate common source
    GenerateSource("FBE");

    // Generate imports
    GenerateImports("fbe.h");

    // Generate imports source
    GenerateImportsSource();

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");

    // Generate common body
    GenerateBufferWrapper_Source();
    GeneratePMRBufferWrapper_Source();
    GenerateTimeWrapper_Source();
    GenerateUUIDWrapper_Source();
    GenerateFBEBuffer_Source();

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate common footer
    GenerateFooter();

    // Store the common file
    WriteEnd();
    Store(common);
}

void GeneratorCpp::GenerateFBEModels_Header(const fs::path& path)
{
    // Create package path
    create_dir(path);

    // Generate the field models file
    fs::path common = path / "fbe_models.h";
    WriteBegin();

    // Generate field models header
    GenerateHeader("FBE");

    // Generate imports
    GenerateImports("fbe.h");

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");

    // Generate field models
    GenerateFBEFieldModel_Header();
    GenerateFBEFieldModelDecimal_Header();
    GenerateFBEFieldModelUUID_Header();
    GenerateFBEFieldModelBytes_Header();
    GenerateFBEFieldModelPMRBytes_Header();
//    GenerateFBEFieldModelString_Header();
//    GenerateFBEFieldModelPMRString_Header();
    GenerateFBEFieldModelMemoryString_Header();
    GenerateFBEFieldModelMemoryArenaString_Header();
    GenerateFBEFieldModelOptional_Header();
    GenerateFBEFieldModelArray_Header();
    GenerateFBEFieldModelVector_Header();
    GenerateFBEFieldModelMap_Header();

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate inline import
    GenerateImports("fbe_models.inl");

    // Generate field models footer
    GenerateFooter();

    // Store the field models file
    WriteEnd();
    Store(common);
}

void GeneratorCpp::GenerateFBEModels_Inline(const fs::path& path)
{
    // Create package path
    create_dir(path);

    // Generate the field models file
    fs::path common = path / "fbe_models.inl";
    WriteBegin();

    // Generate field models inline
    GenerateInline("FBE");

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");

    // Generate field models
    GenerateFBEFieldModel_Inline();
    GenerateFBEFieldModelOptional_Inline();
    GenerateFBEFieldModelArray_Inline();
    GenerateFBEFieldModelVector_Inline();
    GenerateFBEFieldModelMap_Inline();

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate field models footer
    GenerateFooter();

    // Store the field models file
    WriteEnd();
    Store(common);
}

void GeneratorCpp::GenerateFBEModels_Source(const fs::path& path)
{
    // Create package path
    create_dir(path);

    // Generate the field models file
    fs::path common = path / "fbe_models.cpp";
    WriteBegin();

    // Generate field models source
    GenerateSource("FBE");

    // Generate imports
    GenerateImports("fbe_models.h");

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");

    // Generate field models
    GenerateFBEFieldModelDecimal_Source();
    GenerateFBEFieldModelUUID_Source();
    GenerateFBEFieldModelBytes_Source();
    GenerateFBEFieldModelPMRBytes_Source();
//    GenerateFBEFieldModelString_Source();
//    GenerateFBEFieldModelPMRString_Source();
    GenerateFBEFieldModelMemoryString_Source();
    GenerateFBEFieldModelMemoryArenaString_Source();

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate field models footer
    GenerateFooter();

    // Store the field models file
    WriteEnd();
    Store(common);
}

void GeneratorCpp::GenerateFBEFinalModels_Header(const fs::path& path)
{
    // Create package path
    create_dir(path);

    // Generate the final models file
    fs::path common = path / "fbe_final_models.h";
    WriteBegin();

    // Generate final models header
    GenerateHeader("FBE");

    // Generate imports
    GenerateImports("fbe.h");

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");

    // Generate final models
    GenerateFBEFinalModel_Header();
    GenerateFBEFinalModelDecimal_Header();
    GenerateFBEFinalModelUUID_Header();
    GenerateFBEFinalModelBytes_Header();
    GenerateFBEFinalModelString_Header();
    GenerateFBEFinalModelOptional_Header();
    GenerateFBEFinalModelArray_Header();
    GenerateFBEFinalModelVector_Header();
    GenerateFBEFinalModelMap_Header();

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate inline import
    GenerateImports("fbe_final_models.inl");

    // Generate final models footer
    GenerateFooter();

    // Store the final models file
    WriteEnd();
    Store(common);
}

void GeneratorCpp::GenerateFBEFinalModels_Inline(const fs::path& path)
{
    // Create package path
    create_dir(path);

    // Generate the final models file
    fs::path common = path / "fbe_final_models.inl";
    WriteBegin();

    // Generate final models inline
    GenerateInline("FBE");

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");

    // Generate final models
    GenerateFBEFinalModel_Inline();
    GenerateFBEFinalModelOptional_Inline();
    GenerateFBEFinalModelArray_Inline();
    GenerateFBEFinalModelVector_Inline();
    GenerateFBEFinalModelMap_Inline();

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate final models footer
    GenerateFooter();

    // Store the final models file
    WriteEnd();
    Store(common);
}

void GeneratorCpp::GenerateFBEFinalModels_Source(const fs::path& path)
{
    // Create package path
    create_dir(path);

    // Generate the final models file
    fs::path common = path / "fbe_final_models.cpp";
    WriteBegin();

    // Generate final models source
    GenerateSource("FBE");

    // Generate imports
    GenerateImports("fbe_final_models.h");

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");

    // Generate final models
    GenerateFBEFinalModelDecimal_Source();
    GenerateFBEFinalModelUUID_Source();
    GenerateFBEFinalModelBytes_Source();
    GenerateFBEFinalModelString_Source();

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate final models footer
    GenerateFooter();

    // Store the final models file
    WriteEnd();
    Store(common);
}

void GeneratorCpp::GenerateFBEProtocol_Header(const fs::path& path)
{
    // Create package path
    create_dir(path);

    // Generate the protocol file
    fs::path common = path / "fbe_protocol.h";
    WriteBegin();

    // Generate protocol header
    GenerateHeader("FBE");

    // Generate imports
    GenerateImports("fbe.h");

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");

    // Generate protocol
    GenerateFBESender_Header();
    GenerateFBEReceiver_Header();

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate protocol footer
    GenerateFooter();

    // Store the protocol file
    WriteEnd();
    Store(common);
}

void GeneratorCpp::GenerateFBEProtocol_Source(const fs::path& path)
{
    // Create package path
    create_dir(path);

    // Generate the protocol file
    fs::path common = path / "fbe_protocol.cpp";
    WriteBegin();

    // Generate protocol source
    GenerateSource("FBE");

    // Generate imports
    GenerateImports("fbe_protocol.h");

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");

    // Generate protocol
    GenerateFBESender_Source();
    GenerateFBEReceiver_Source();

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate protocol footer
    GenerateFooter();

    // Store the protocol file
    WriteEnd();
    Store(common);
}

void GeneratorCpp::GenerateFBEJson_Header(const fs::path& path)
{
    // Create package path
    create_dir(path);

    // Generate the JSON file
    fs::path common = path / "fbe_json.h";
    WriteBegin();

    // Generate JSON header
    GenerateHeader("FBE");

    // Generate imports
    GenerateImports("fbe.h");
    GenerateImportsJson();

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");

    // Generate JSON
    GenerateFBEJson();

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate JSON footer
    GenerateFooter();

    // Store the JSON file
    WriteEnd();
    Store(common);
}

void GeneratorCpp::GeneratePackage_Header(const std::shared_ptr<Package>& p)
{
    fs::path output = _output;

    // Create package path
    create_dir(output);

    // Generate the output file
    output /= ConvertFileName(*p->name, FileType::Struct, true);
    WriteBegin();

    // Generate package header
    GenerateHeader(fs::path(_input).filename().string());

    // Generate imports
    GenerateImports(p);

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

    // Generate namespace body
    if (p->body)
    {
        // Generate child enums
        for (const auto& e : p->body->enums)
            GenerateEnum(p, e);

        // Generate child flags
        for (const auto& f : p->body->flags)
            GenerateFlags(p, f);

        if (!p->body->variants.empty()) {
            // forward declarations
            GeneratorStructForwardDeclaration(p->body->structs);
            for (const auto& v : p->body->variants)
            {
                GenerateVariantAlias(p, v);
            }
        }

        // Generate child structs
        for (const auto& s : p->body->structs)
            GenerateStruct_Header(p, s);
    }

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));

    // Generate package footer
    GenerateFooter();

    // Store the output file
    WriteEnd();
    Store(output);
}

void GeneratorCpp::GeneratorStructForwardDeclaration(const std::vector<std::shared_ptr<StructType>>& structs) {
    WriteLineIndent("// forward declaration");
    for (auto& s: structs){
        WriteLine(std::string("struct ") + *s->name + ";");
    }
}

void GeneratorCpp::GeneratePackage_Source(const std::shared_ptr<Package>& p)
{
    fs::path output = _output;

    // Create package path
    create_dir(output);

    // Generate the output file
    output /= ConvertFileName(*p->name, FileType::Struct, false);
    WriteBegin();

    // Generate package source
    GenerateSource(fs::path(_input).filename().string());

    // Generate imports
    GenerateImports(ConvertFileName(*p->name, FileType::Struct, true));

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

    // Generate namespace body
    if (p->body)
    {
        // Generate child enums
        for (const auto& e : p->body->enums)
        {
            // Generate enum output stream
            GenerateEnumOutputStream(e);

            // Generate enum logging stream
            if (Logging())
                GenerateEnumLoggingStream(e);
        }

        // Generate child flags
        for (const auto& f : p->body->flags)
        {
            // Generate flags output stream
            GenerateFlagsOutputStream(f);

            // Generate flags logging stream
            if (Logging())
                GenerateFlagsLoggingStream(f);
        }

        if (!p->body->variants.empty()) {
            for (const auto& v : p->body->variants)
            {
                GenerateVariantOutputStream(p, v);
            }
            WriteLine();
        }

        // Generate child structs
        for (const auto& s : p->body->structs)
        {
            GenerateStruct_Source(p, s);

            // Generate struct output stream
            GenerateStructOutputStream(p, s);

            // Generate struct logging stream
            if (Logging())
                GenerateStructLoggingStream(p, s);
        }
    }

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));

    // Generate package footer
    GenerateFooter();

    // Store the output file
    WriteEnd();
    Store(output);
}

void GeneratorCpp::GeneratePackage_Json(const std::shared_ptr<Package>& p)
{
    fs::path output = _output;

    // Create package path
    create_dir(output);

    // Generate the output file
    output /= *p->name + "_json.h";
    WriteBegin();

    // Generate package header
    GenerateHeader(fs::path(_input).filename().string());

    // Generate imports
    GenerateImportsJson(p);

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");
    WriteLine();
    WriteLineIndent("namespace JSON {");

    // Generate namespace body
    if (p->body)
    {
        // Generate child enums
        for (const auto& e : p->body->enums)
            GenerateEnumJson(p, e);

        // Generate child flags
        for (const auto& f : p->body->flags)
            GenerateFlagsJson(p, f);

        // Generate child structs
        for (const auto& s : p->body->structs)
            GenerateStructJson(p, s);
    }

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace JSON");
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate package footer
    GenerateFooter();

    // Store the output file
    WriteEnd();
    Store(output);
}

void GeneratorCpp::GeneratePackageModels_Header(const std::shared_ptr<Package>& p)
{
    fs::path output = _output;

    // Create package path
    create_dir(output);

    // Generate the output file
    output /= ConvertFileName(*p->name, FileType::Model, true);
    WriteBegin();

    // Generate package models header
    GenerateHeader(fs::path(_input).filename().string());

    // Generate imports
    GenerateImports("fbe_models.h");
    GenerateImportsModels(p, false, false);

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");

    // Generate namespace body
    if (p->body)
    {
        // Generate child enums
        for (const auto& e : p->body->enums)
        {
            // Generate enum field model
            GenerateEnumFieldModel(p, e);
        }

        // Generate child flags
        for (const auto& f : p->body->flags)
        {
            // Generate flags field model
            GenerateFlagsFieldModel(p, f);
        }

        // Generate variant
        for(const auto& v : p->body->variants) {
            GenerateVariantFieldModel_Header(p, v);
        }

        // Generate child structs
        for (const auto& s : p->body->structs)
        {
            // Generate struct field models
            GenerateStructFieldModel_Header(p, s);
            GenerateStructModel_Header(p, s);
        }
    }

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate package footer
    GenerateFooter();

    // Store the output file
    WriteEnd();
    Store(output);
}

void GeneratorCpp::GeneratePackageModels_Source(const std::shared_ptr<Package>& p)
{
    fs::path output = _output;

    // Create package path
    create_dir(output);

    // Generate the output file
    output /= ConvertFileName(*p->name, FileType::Model, false);
    WriteBegin();

    // Generate package models source
    GenerateSource(fs::path(_input).filename().string());

    // Generate imports
    GenerateImports(ConvertFileName(*p->name, FileType::Model, true));

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");

    // Generate namespace body
    if (p->body)
    {
        // Generate variant
        for(const auto& v : p->body->variants) {
            GenerateVariantFieldModel_Source(p, v);
        }

        // Generate child structs
        for (const auto& s : p->body->structs)
        {
            // Generate struct field models
            GenerateStructFieldModel_Source(p, s);
            GenerateStructModel_Source(p, s);
        }
    }

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate package footer
    GenerateFooter();

    // Store the output file
    WriteEnd();
    Store(output);
}

void GeneratorCpp::GeneratePackageFinalModels_Header(const std::shared_ptr<Package>& p)
{
    fs::path output = _output;

    // Create package path
    create_dir(output);

    // Generate the output file
    output /= *p->name + "_final_models.h";
    WriteBegin();

    // Generate package final models header
    GenerateHeader(fs::path(_input).filename().string());

    // Generate imports
    GenerateImports("fbe_final_models.h");
    GenerateImportsModels(p, true, false);

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");

    // Generate namespace body
    if (p->body)
    {
        // Generate child enums
        for (const auto& e : p->body->enums)
        {
            // Generate enum final model
            GenerateEnumFinalModel(p, e);
        }

        // Generate child flags
        for (const auto& f : p->body->flags)
        {
            // Generate flags final model
            GenerateFlagsFinalModel(p, f);
        }

        // Generate child structs
        for (const auto& s : p->body->structs)
        {
            // Generate struct final models
            GenerateStructFinalModel_Header(p, s);
            GenerateStructModelFinal_Header(p, s);
        }
    }

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate package footer
    GenerateFooter();

    // Store the output file
    WriteEnd();
    Store(output);
}

void GeneratorCpp::GeneratePackageFinalModels_Source(const std::shared_ptr<Package>& p)
{
    fs::path output = _output;

    // Create package path
    create_dir(output);

    // Generate the output file
    output /= *p->name + "_final_models.cpp";
    WriteBegin();

    // Generate package final models source
    GenerateSource(fs::path(_input).filename().string());

    // Generate imports
    GenerateImports(*p->name + "_final_models.h");

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");

    // Generate namespace body
    if (p->body)
    {
        // Generate child structs
        for (const auto& s : p->body->structs)
        {
            // Generate struct final models
            GenerateStructFinalModel_Source(p, s);
            GenerateStructModelFinal_Source(p, s);
        }
    }

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate package footer
    GenerateFooter();

    // Store the output file
    WriteEnd();
    Store(output);
}

void GeneratorCpp::GeneratePackageProtocol_Header(const std::shared_ptr<Package>& p, bool final)
{
    fs::path output = _output;

    // Create package path
    create_dir(output);

    // Generate the output file
    output /= *p->name + (final ? "_final" : "") + "_protocol.h";
    WriteBegin();

    // Generate package protocol header
    GenerateHeader(fs::path(_input).filename().string());

    // Generate imports
    GenerateImports("fbe_protocol.h");
    GenerateImportsProtocol(p, final);

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");
    WriteLine();
    WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

    // Generate protocol version
    GenerateProtocolVersion(p);

    // Generate sender & receiver
    GenerateSender_Header(p, final);
    GenerateReceiver_Header(p, final);
    if (!final)
        GenerateProxy_Header(p, final);
    GenerateClient_Header(p, final);

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate package footer
    GenerateFooter();

    // Store the output file
    WriteEnd();
    Store(output);
}

void GeneratorCpp::GeneratePackageProtocol_Source(const std::shared_ptr<Package>& p, bool final)
{
    fs::path output = _output;

    // Create package path
    create_dir(output);

    // Generate the output file
    output /= *p->name + (final ? "_final" : "") + "_protocol.cpp";
    WriteBegin();

    // Generate package protocol source
    GenerateSource(fs::path(_input).filename().string());

    // Generate warnings header
    GenerateWarningsHeader();

    // Generate imports
    GenerateImports(*p->name + (final ? "_final" : "") + "_protocol.h");

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");
    WriteLine();
    WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

    // Generate sender & receiver
    GenerateSender_Source(p, final);
    GenerateReceiver_Source(p, final);
    if (!final)
        GenerateProxy_Source(p, final);
    GenerateClient_Source(p, final);

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate warnings footer
    GenerateWarningsFooter();

    // Generate package footer
    GenerateFooter();

    // Store the output file
    WriteEnd();
    Store(output);
}

void GeneratorCpp::GenerateEnum(const std::shared_ptr<Package>& p, const std::shared_ptr<EnumType>& e)
{
    // Generate enum begin
    WriteLine();
    WriteIndent("enum class " + std::string(e->attributes->deprecated ? "[[deprecated]] " : "") + *e->name);
    if (e->base && !e->base->empty())
        Write(" : " + ConvertEnumType(*e->base));
    WriteLine();
    WriteLineIndent("{");
    Indent(1);

    std::string enum_type = (e->base && !e->base->empty()) ? *e->base : "int32";

    // Generate enum body
    if (e->body)
    {
        for (const auto& value : e->body->values)
        {
            WriteIndent(*value->name);
            if (value->attributes->deprecated)
                Write(" [[deprecated]]");
            if (value->value)
            {
                if (value->value->constant && !value->value->constant->empty())
                    Write(" = " + ConvertConstant(enum_type, *value->value->constant, false));
                else if (value->value->reference && !value->value->reference->empty())
                    Write(" = " + ConvertConstant("", *value->value->reference, false));
            }
            WriteLine(",");
        }
    }

    // Generate enum end
    Indent(-1);
    WriteLineIndent("};");

    // Generate enum output stream operator declaration
    WriteLine();
    WriteLineIndent("std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] " + *e->name + " value);");

    // Generate enum logging stream operator declaration
    WriteLine();
    WriteLineIndent("#if defined(LOGGING_PROTOCOL)");
    WriteLineIndent("CppLogging::Record& operator<<(CppLogging::Record& record, " + *e->name + " value);");
    WriteLineIndent("#endif");
}

void GeneratorCpp::GenerateEnumOutputStream(const std::shared_ptr<EnumType>& e)
{
    // Generate enum output stream operator begin
    WriteLine();
    WriteLineIndent("std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] " + *e->name + " value)");
    WriteLineIndent("{");
    Indent(1);

    // Generate enum output stream operator body
    if (e->body && !e->body->values.empty())
    {
        for (auto it = e->body->values.begin(); it != e->body->values.end(); ++it)
            WriteLineIndent("if (value == " + *e->name + "::" + *(*it)->name + ")" + " return stream << \"" + *(*it)->name + "\";");
        WriteLineIndent("return stream << \"<unknown>\";");
    }
    else
        WriteLineIndent("return stream << \"<empty>\";");

    // Generate enum output stream operator end
    Indent(-1);
    WriteLineIndent("}");
}

void GeneratorCpp::GenerateEnumLoggingStream(const std::shared_ptr<EnumType>& e)
{
    // Generate enum logging stream operator begin
    WriteLine();
    WriteLineIndent("#if defined(LOGGING_PROTOCOL)");
    WriteLineIndent("CppLogging::Record& operator<<(CppLogging::Record& record, " + *e->name + " value)");
    WriteLineIndent("{");
    Indent(1);

    // Generate enum logging stream operator body
    if (e->body && !e->body->values.empty())
    {
        for (auto it = e->body->values.begin(); it != e->body->values.end(); ++it)
            WriteLineIndent("if (value == " + *e->name + "::" + *(*it)->name + ")" + " return record.StoreCustom(\"" + *(*it)->name + "\");");
        WriteLineIndent("return record.StoreCustom(\"<unknown>\");");
    }
    else
        WriteLineIndent("return record.StoreCustom(\"<empty>\");");

    // Generate enum logging stream operator end
    Indent(-1);
    WriteLineIndent("}");
    WriteLineIndent("#endif");
}

void GeneratorCpp::GenerateEnumJson(const std::shared_ptr<Package>& p, const std::shared_ptr<EnumType>& e)
{
    std::string enum_name = "::" + ConvertNamespace(*p->name) + "::" + *e->name;
    std::string enum_type = (e->base && !e->base->empty()) ? *e->base : "int32";
    std::string enum_base_type = ConvertEnumType(enum_type);

    std::string json = R"CODE(
template <class TWriter>
struct ValueWriter<TWriter, _ENUM_NAME_>
{
    static bool to_json(TWriter& writer, const _ENUM_NAME_& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (_ENUM_TYPE_)value);
    }
};

template <class TJson>
struct ValueReader<TJson, _ENUM_NAME_>
{
    static bool from_json(const TJson& json, _ENUM_NAME_& value)
    {
        _ENUM_TYPE_ raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (_ENUM_NAME_)raw;
        return true;
    }
};
)CODE";

    // Prepare enum template
    json = std::regex_replace(json, std::regex("_ENUM_NAME_"), enum_name);
    json = std::regex_replace(json, std::regex("_ENUM_TYPE_"), enum_base_type);
    json = std::regex_replace(json, std::regex("\n"), EndLine());

    // Generate enum JSON
    Write(json);
}

void GeneratorCpp::GenerateEnumFieldModel(const std::shared_ptr<Package>& p, const std::shared_ptr<EnumType>& e)
{
    std::string enum_name = "::" + ConvertNamespace(*p->name) + "::" + *e->name;
    std::string enum_type = (e->base && !e->base->empty()) ? *e->base : "int32";
    std::string enum_base_type = ConvertEnumType(enum_type);

    std::string code = R"CODE(
// Fast Binary Encoding _ENUM_NAME_ field model
template <>
class FieldModel<_ENUM_NAME_> : public FieldModelBase<_ENUM_NAME_, _ENUM_TYPE_>
{
public:
    using FieldModelBase<_ENUM_NAME_, _ENUM_TYPE_>::FieldModelBase;
};
)CODE";

    // Prepare enum template
    code = std::regex_replace(code, std::regex("_ENUM_NAME_"), enum_name);
    code = std::regex_replace(code, std::regex("_ENUM_TYPE_"), enum_base_type);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    // Generate enum field model
    Write(code);
}

void GeneratorCpp::GenerateEnumFinalModel(const std::shared_ptr<Package>& p, const std::shared_ptr<EnumType>& e)
{
    std::string enum_name = "::" + ConvertNamespace(*p->name) + "::" + *e->name;
    std::string enum_type = (e->base && !e->base->empty()) ? *e->base : "int32";
    std::string enum_base_type = ConvertEnumType(enum_type);

    std::string code = R"CODE(
// Fast Binary Encoding _ENUM_NAME_ final model
template <>
class FinalModel<_ENUM_NAME_> : public FinalModelBase<_ENUM_NAME_, _ENUM_TYPE_>
{
public:
    using FinalModelBase<_ENUM_NAME_, _ENUM_TYPE_>::FinalModelBase;
};
)CODE";

    // Prepare enum template
    code = std::regex_replace(code, std::regex("_ENUM_NAME_"), enum_name);
    code = std::regex_replace(code, std::regex("_ENUM_TYPE_"), enum_base_type);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    // Generate enum final model
    Write(code);
}

void GeneratorCpp::GenerateFlags(const std::shared_ptr<Package>& p, const std::shared_ptr<FlagsType>& f)
{
    // Generate flags begin
    WriteLine();
    WriteIndent("enum class " + std::string(f->attributes->deprecated ? "[[deprecated]] " : "") + *f->name);
    if (f->base && !f->base->empty())
        Write(" : " + ConvertEnumType(*f->base));
    WriteLine();
    WriteLineIndent("{");
    Indent(1);

    std::string flags_type = (f->base && !f->base->empty()) ? *f->base : "int32";

    // Generate flags body
    if (f->body)
    {
        for (const auto& value : f->body->values)
        {
            WriteIndent(*value->name);
            if (value->attributes->deprecated)
                Write(" [[deprecated]]");
            if (value->value)
            {
                if (value->value->constant && !value->value->constant->empty())
                    Write(" = " + ConvertConstant(flags_type, *value->value->constant, false));
                else if (value->value->reference && !value->value->reference->empty())
                    Write(" = " + ConvertConstant("", *value->value->reference, false));
            }
            WriteLine(",");
        }
    }

    // Generate flags end
    Indent(-1);
    WriteLineIndent("};");
    WriteLine();
    WriteLineIndent("FBE_ENUM_FLAGS(" + *f->name + ")");

    // Generate flags output stream operator declaration
    WriteLine();
    WriteLineIndent("std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] " + *f->name + " value);");

    // Generate flags logging stream operator declaration
    WriteLine();
    WriteLineIndent("#if defined(LOGGING_PROTOCOL)");
    WriteLineIndent("CppLogging::Record& operator<<(CppLogging::Record& record, " + *f->name + " value);");
    WriteLineIndent("#endif");
}

void GeneratorCpp::GenerateFlagsOutputStream(const std::shared_ptr<FlagsType>& f)
{
    // Generate flags output stream operator begin
    WriteLine();
    WriteLineIndent("std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] " + *f->name + " value)");
    WriteLineIndent("{");
    Indent(1);

    // Generate flags output stream operator body
    if (f->body && !f->body->values.empty())
    {
        WriteLineIndent("bool first = true;");
        for (auto it = f->body->values.begin(); it != f->body->values.end(); ++it)
        {
            WriteLineIndent("if ((value & " + *f->name + "::" + *(*it)->name + ") && ((value & " + *f->name + "::" + *(*it)->name + ") == " + *f->name + "::" + *(*it)->name + "))");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent("stream << (first ? \"\" : \"|\") << \"" + *(*it)->name + "\";");
            WriteLineIndent("first = false;");
            Indent(-1);
            WriteLineIndent("}");
        }
    }
    WriteLineIndent("return stream;");

    // Generate flags output stream operator end
    Indent(-1);
    WriteLineIndent("}");
}

void GeneratorCpp::GenerateFlagsLoggingStream(const std::shared_ptr<FlagsType>& f)
{
    // Generate flags logging stream operator begin
    WriteLine();
    WriteLineIndent("#if defined(LOGGING_PROTOCOL)");
    WriteLineIndent("CppLogging::Record& operator<<(CppLogging::Record& record, " + *f->name + " value)");
    WriteLineIndent("{");
    Indent(1);

    // Generate flags output stream operator body
    WriteLineIndent("const size_t begin = record.StoreListBegin();");
    if (f->body && !f->body->values.empty())
    {
        WriteLineIndent("bool first = true;");
        for (auto it = f->body->values.begin(); it != f->body->values.end(); ++it)
        {
            WriteLineIndent("if ((value & " + *f->name + "::" + *(*it)->name + ") && ((value & " + *f->name + "::" + *(*it)->name + ") == " + *f->name + "::" + *(*it)->name + "))");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent("record.StoreList((first ? \"\" : \"|\")).StoreList(\"" + *(*it)->name + "\");");
            WriteLineIndent("first = false;");
            Indent(-1);
            WriteLineIndent("}");
        }
    }
    WriteLineIndent("return record.StoreListEnd(begin);");

    // Generate flags logging stream operator end
    Indent(-1);
    WriteLineIndent("}");
    WriteLineIndent("#endif");
}

void GeneratorCpp::GenerateFlagsJson(const std::shared_ptr<Package>& p, const std::shared_ptr<FlagsType>& f)
{
    std::string flags_name = "::" + ConvertNamespace(*p->name) + "::" + *f->name;
    std::string flags_type = (f->base && !f->base->empty()) ? *f->base : "int32";
    std::string flags_base_type = ConvertEnumType(flags_type);

    std::string json = R"CODE(
template <class TWriter>
struct ValueWriter<TWriter, _FLAGS_NAME_>
{
    static bool to_json(TWriter& writer, const _FLAGS_NAME_& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (_FLAGS_TYPE_)value);
    }
};

template <class TJson>
struct ValueReader<TJson, _FLAGS_NAME_>
{
    static bool from_json(const TJson& json, _FLAGS_NAME_& value)
    {
        _FLAGS_TYPE_ raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (_FLAGS_NAME_)raw;
        return true;
    }
};
)CODE";

    // Prepare flags template
    json = std::regex_replace(json, std::regex("_FLAGS_NAME_"), flags_name);
    json = std::regex_replace(json, std::regex("_FLAGS_TYPE_"), flags_base_type);
    json = std::regex_replace(json, std::regex("\n"), EndLine());

    // Generate flags JSON
    Write(json);
}

void GeneratorCpp::GenerateFlagsFieldModel(const std::shared_ptr<Package>& p, const std::shared_ptr<FlagsType>& f)
{
    std::string flags_name = "::" + ConvertNamespace(*p->name) + "::" + *f->name;
    std::string flags_type = (f->base && !f->base->empty()) ? *f->base : "int32";
    std::string flags_base_type = ConvertEnumType(flags_type);

    std::string code = R"CODE(
// Fast Binary Encoding _FLAGS_NAME_ field model
template <>
class FieldModel<_FLAGS_NAME_> : public FieldModelBase<_FLAGS_NAME_, _FLAGS_TYPE_>
{
public:
    using FieldModelBase<_FLAGS_NAME_, _FLAGS_TYPE_>::FieldModelBase;
};
)CODE";

    // Prepare flags template
    code = std::regex_replace(code, std::regex("_FLAGS_NAME_"), flags_name);
    code = std::regex_replace(code, std::regex("_FLAGS_TYPE_"), flags_base_type);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    // Generate flags field model
    Write(code);
}

void GeneratorCpp::GenerateFlagsFinalModel(const std::shared_ptr<Package>& p, const std::shared_ptr<FlagsType>& f)
{
    std::string flags_name = "::" + ConvertNamespace(*p->name) + "::" + *f->name;
    std::string flags_type = (f->base && !f->base->empty()) ? *f->base : "int32";
    std::string flags_base_type = ConvertEnumType(flags_type);

    std::string code = R"CODE(
// Fast Binary Encoding _FLAGS_NAME_ final model
template <>
class FinalModel<_FLAGS_NAME_> : public FinalModelBase<_FLAGS_NAME_, _FLAGS_TYPE_>
{
public:
    using FinalModelBase<_FLAGS_NAME_, _FLAGS_TYPE_>::FinalModelBase;
};
)CODE";

    // Prepare flags template
    code = std::regex_replace(code, std::regex("_FLAGS_NAME_"), flags_name);
    code = std::regex_replace(code, std::regex("_FLAGS_TYPE_"), flags_base_type);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    // Generate flags final model
    Write(code);
}

void GeneratorCpp::GenerateVariantAlias(const std::shared_ptr<Package>& p, const std::shared_ptr<VariantType>& v)
{
    WriteLine();
    std::string code = "using " + *v->name + " = std::variant<";
    bool first = true;
    for (auto value : v->body->values) {
        code += (!first ? ", " : "") + ConvertVariantTypeName(*p->name, *value);
        first = false;
    }
    code += ">;";
    WriteLineIndent(code);
    WriteLineIndent("std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const " + *v->name + "& value);");
    if (Ptr()) {
        // use built-in operator== for varaint type of template-based FBE
        WriteLineIndent("auto is_equal(const " + *v->name + "& lhs" + ", const " + *v->name + "& rhs) -> bool;");
    }
}

void GeneratorCpp::GenerateVariantOutputStream(const std::shared_ptr<Package>& p, const std::shared_ptr<VariantType>& v)
{
    WriteLine();
    WriteLineIndent("std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const " + *v->name + "& value)");
    WriteLineIndent("{");
    Indent(1);

    WriteLineIndent("stream << \"" + *v->name + "(variant|\";");
    WriteLineIndent("[[maybe_unused]] bool first = true;");
    WriteLineIndent("switch (value.index()) {");
    Indent(1);
    for (int i = 0; i < v->body->values.size(); i++) {
        WriteLineIndent("case " + std::to_string(i) + ":");
        Indent(1);
        auto& value = v->body->values.at(i);
        auto get_value = "std::get<" + std::to_string(i) + ">(value)";
        auto fbe_value_type = *value->type + (value->ptr ? "*" : "");
        if (value->vector || value->list) {
            WriteLineIndent(std::string("stream << \"{") + fbe_value_type + "}=[\" << " + get_value + ".size()" + " << \"][\"" + ";");
            WriteLineIndent("for (const auto& it : " + get_value + ")");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent(ConvertOutputStreamValue(*value->type, "it", value->ptr, false, true));
            if (value->ptr) {
                WriteLineIndent("if (it != nullptr)");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("stream << \"->\" << *it;");
                Indent(-1);
                WriteLineIndent("}");
            }
            WriteLineIndent("first = false;");
            Indent(-1);
            WriteLineIndent("}");
            WriteLineIndent("stream << \"]\";");
        } else if (value->map ||value->hash) {
            WriteLineIndent(std::string("stream << \"{") + *value->key + "->" + fbe_value_type + "}=[\" << " + get_value + ".size()" + " << \"][\"" + ";");
            WriteLineIndent("for (const auto& it : " + get_value + ")");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent(ConvertOutputStreamValue(*value->key, "it.first", false, false, true));
            WriteLineIndent("stream << \"->\";");
            WriteLineIndent(ConvertOutputStreamValue(*value->type, "it.second", value->ptr, false, false));
            WriteLineIndent("first = false;");
            Indent(-1);
            WriteLineIndent("}");
            WriteLineIndent("stream << \"]\";");
        } else {
            WriteLineIndent("stream<< \"{" + fbe_value_type + "}\";");
            WriteLineIndent(ConvertOutputStreamValue("", get_value, v->body->values.at(i)->ptr, false, false));
            if (value->ptr) {
                WriteLineIndent("if (" + get_value + " != nullptr)");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("stream << \"->\" << *" + get_value + ";");
                Indent(-1);
                WriteLineIndent("}");
            }
        }
        WriteLineIndent("break;");
        Indent(-1);
    }
    WriteLineIndent("default:");
    Indent(1);
    WriteLineIndent("static_assert(\"unreachable branch\");");
    Indent(-1);
    Indent(-1);
    WriteLineIndent("}");

    WriteLineIndent("stream << \")\";");
    WriteLineIndent("return stream;");
    Indent(-1);
    WriteLineIndent("}");
}

void GeneratorCpp::GenerateStruct_Header(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    // Generate struct response forward declaration
    if (s->response)
    {
        std::string response = *s->response->response;
        bool imported = replace_all(response, ".", "");
        if (!imported)
        {
            WriteLine();
            WriteLineIndent("struct " + response + ";");
        }
    }

    // Generate struct begin
    WriteLine();
    WriteIndent("struct " + std::string(s->attributes->deprecated ? "[[deprecated]] " : "") + *s->name);
    if (s->base && !s->base->empty())
        Write(" : public " + ConvertTypeName(*p->name, *s->base, false));
    WriteLine();
    WriteLineIndent("{");
    Indent(1);

    // Generate struct response type definition
    if (s->response)
    {
        std::string response = *s->response->response;
        replace_all(response, ".", "::");
        WriteLineIndent("typedef " + response + " Response;");
        if (s->body && !s->body->fields.empty())
            WriteLine();
    }

    // Generate struct body
    // Write Arena ArenaTags
    if (Arena())
    {
        for(auto &tag: ArenaTags()){
            WriteLineIndent(tag + ";");
        }
        WriteLine();
    }

    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteIndent();
            if (field->attributes && field->attributes->deprecated)
                Write("[[deprecated]] ");
            WriteLine(ConvertTypeName(*p->name, *field) + " " + *field->name + ";");
        }
        if (!s->body->fields.empty())
            WriteLine();
    }

    // Generate struct FBE type property
    if (s->base && !s->base->empty() && (s->type == 0))
        WriteLineIndent("size_t fbe_type() const noexcept { return " + ConvertTypeName(*p->name, *s->base, false) + "::fbe_type(); }");
    else
        WriteLineIndent("size_t fbe_type() const noexcept { return " + std::to_string(s->type) + "; }");

    // Generate struct default constructor
    bool first = true;
    WriteLine();
    WriteLineIndent(*s->name + "();");

    // Generate cstr with Arena
    if (Arena()) {
        WriteLineIndent("explicit " + *s->name + "(allocator_type alloc);");
    }

    // Generate struct initialization constructor
    if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty()))
    {
        first = true;
        size_t args = 0;
        if (s->base && !s->base->empty())
            ++args;
        if (s->body && !s->body->fields.empty())
            args += s->body->fields.size();
        WriteIndent(((args <= 1) ? "explicit " : "") + *s->name + "(");
        if (s->base && !s->base->empty())
        {
            Write("const " + ConvertTypeName(*p->name, *s->base, false) + "& base");
            first = false;
        }
        if (s->body)
        {
            for (const auto& field : s->body->fields)
            {
                Write(std::string(first ? "" : ", ") + ConvertTypeNameAsArgument(*p->name, *field) + " arg_" + *field->name);
                first = false;
            }
        }
        WriteLine(");");
    }

    // Generate struct copy/mode constructor, destructor and assign operators
    WriteLineIndent(*s->name + "(const " + *s->name + "& other) = default;");
    WriteLineIndent(*s->name + "(" + *s->name + "&& other) = default;");
    WriteLineIndent("~" + *s->name + "() = default;");
    WriteLine();
    WriteLineIndent(*s->name + "& operator=(const " + *s->name + "& other) = default;");
    WriteLineIndent(*s->name + "& operator=(" + *s->name + "&& other) = default;");

    // Generate struct compare operators
    WriteLine();
    WriteLineIndent("bool operator==(const " + *s->name + "& other) const noexcept;");
    WriteLineIndent("bool operator!=(const " + *s->name + "& other) const noexcept { return !operator==(other); }");
    WriteLineIndent("bool operator<(const " + *s->name + "& other) const noexcept;");
    WriteLineIndent("bool operator<=(const " + *s->name + "& other) const noexcept { return operator<(other) || operator==(other); }");
    WriteLineIndent("bool operator>(const " + *s->name + "& other) const noexcept { return !operator<=(other); }");
    WriteLineIndent("bool operator>=(const " + *s->name + "& other) const noexcept { return !operator<(other); }");

    // Generate struct string convert
    WriteLine();
    WriteLineIndent("std::string string() const;");

    // Generate struct output stream operator
    WriteLine();
    WriteLineIndent("friend std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const " + *s->name + "& value);");

    // Generate struct output stream operator
    if (Logging())
    {
        WriteLine();
        WriteLineIndent("#if defined(LOGGING_PROTOCOL)");
        WriteLineIndent("friend CppLogging::Record& operator<<(CppLogging::Record& record, const " + *s->name + "& value);");
        WriteLineIndent("#endif");
    }

    // Generate struct swap methods
    WriteLine();
    WriteLineIndent("void swap(" + *s->name + "& other) noexcept;");
    WriteLineIndent("friend void swap(" + *s->name + "& value1, " + *s->name + "& value2) noexcept { value1.swap(value2); }");

    // Generate struct end
    Indent(-1);
    WriteLineIndent("};");

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));

    // Generate struct hash
    GenerateStructHash(p, s);

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");
}

void GeneratorCpp::GenerateStruct_Source(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    WriteLine();

    // Generate struct default constructor
    bool first = true;
    WriteLineIndent(*s->name + "::" + *s->name + "()");
    Indent(1);
    if (s->base && !s->base->empty())
    {
        WriteLineIndent(": " + ConvertTypeName(*p->name, *s->base, false) + "()");
        first = false;
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLineIndent(std::string(first ? ": " : ", ") + *field->name + "(" + ((field->value || IsPrimitiveType(*field->type, field->optional)) ? ConvertDefault(*p->name, *field) : "") + ")");
            first = false;
        }
    }
    Indent(-1);
    WriteLineIndent("{}");

    // Generate struct constructor with arena
    if (Arena()) {
        first = true;
        WriteLine();
        WriteLineIndent(*s->name + "::" + *s->name + "([[maybe_unused]] allocator_type alloc)");
        Indent(1);
        if (s->base && !s->base->empty())
        {
            WriteLineIndent(": " + ConvertTypeName(*p->name, *s->base, false) + "()");
            first = false;
        }
        if (s->body)
        {
            auto enums = p->body->enums;
            auto flags = p->body->flags;
            for (const auto& field : s->body->fields)
            {
                WriteIndent();
                Write(std::string(first ? ": " : ", ") + *field->name + "(");
                // priority: container > optional > imported type > bytes/string/primitive type/custom type > variant
                if (IsContainerType(*field)) {
                    Write(field->array ? "" : "alloc");
                } else if (field->optional) {
                    Write("std::nullopt");
                } else if (!IsCurrentPackageType(*field->type)) {
                    Write(std::string("assign_member<") + ConvertTypeName(*p->name, *field) + ">(alloc)");
                } else if (*field->type == "bytes" || *field->type == "string") {
                    Write("alloc");
                } else if (field->value || IsPrimitiveType(*field->type, field->optional)) {
                    Write(ConvertDefault(*p->name, *field));
                    // TODO(liuqi): FBE::uuid_t and FBE::decimal_t should support arena
                } else if (*field->type != "uuid" && *field->type != "decimal" && !IsVariantType(p, *field->type) && std::find_if(enums.begin(), enums.end(),
                 [t = *field->type](const std::shared_ptr<EnumType>& e) -> bool { 
                     return *e->name == t; }) == enums.end() && std::find_if(flags.begin(), flags.end(),
                 [t = *field->type](const std::shared_ptr<FlagsType>& e) -> bool { 
                     return *e->name == t; }) == flags.end()) {
                    Write("alloc");
                }
                Write(")");
                WriteLine();
                first = false;
            }
        }
        Indent(-1);
        WriteLineIndent("{}");
    }

    // Generate struct initialization constructor
    if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty()))
    {
        first = true;
        WriteLine();
        WriteIndent(*s->name + "::" + *s->name + "(");
        if (s->base && !s->base->empty())
        {
            Write("const " + ConvertTypeName(*p->name, *s->base, false) + "& base");
            first = false;
        }
        if (s->body)
        {
            for (const auto& field : s->body->fields)
            {
                Write(std::string(first ? "" : ", ") + ConvertTypeNameAsArgument(*p->name, *field) + " arg_" + *field->name);
                first = false;
            }
        }
        WriteLine(")");
        Indent(1);
        first = true;
        if (s->base && !s->base->empty())
        {
            WriteLineIndent(": " + ConvertTypeName(*p->name, *s->base, false) + "(base)");
            first = false;
        }
        if (s->body)
        {
            for (const auto& field : s->body->fields)
            {
                WriteLineIndent(std::string(first ? ": " : ", ") + *field->name + "(arg_" + *field->name + ")");
                first = false;
            }
        }
        Indent(-1);
        WriteLineIndent("{}");
    }

    // Generate struct compare operators
    WriteLine();
    WriteLineIndent("bool " + *s->name + "::operator==([[maybe_unused]] const " + *s->name + "& other) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("return (");
    Indent(1);
    first = true;
    if (s->base && !s->base->empty())
    {
        WriteLineIndent(ConvertTypeName(*p->name, *s->base, false) + "::operator==(other)");
        first = false;
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLineIndent(std::string(first ? "(" : "&& (") + *field->name + " == other." + *field->name + ")");
            first = false;
        }
    }
    if (s->body->fields.empty()) {
        WriteLineIndent("true");
    }
    WriteLineIndent(");");
    Indent(-1);
    Indent(-1);
    WriteLineIndent("}");

    WriteLine();
    WriteLineIndent("bool " + *s->name + "::operator<([[maybe_unused]] const " + *s->name + "& other) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    if (s->base && !s->base->empty())
    {
        WriteLineIndent("if (" + ConvertTypeName(*p->name, *s->base, false) + "::operator<(other))");
        Indent(1);
        WriteLineIndent("return true;");
        Indent(-1);
        WriteLineIndent("if (other." + ConvertTypeName(*p->name, *s->base, false) + "::operator<(*this))");
        Indent(1);
        WriteLineIndent("return false;");
        Indent(-1);
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            if (field->keys)
            {
                WriteLineIndent("if (" + *field->name + " < other." + *field->name + ")");
                Indent(1);
                WriteLineIndent("return true;");
                Indent(-1);
                WriteLineIndent("if (other." + *field->name + " < " + *field->name + ")");
                Indent(1);
                WriteLineIndent("return false;");
                Indent(-1);
            }
        }
    }
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct string method
    WriteLine();
    WriteLineIndent("std::string " + *s->name + "::string() const");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("std::stringstream ss; ss << *this; return ss.str();");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct swap method
    WriteLine();
    WriteLineIndent("void " + *s->name + "::swap([[maybe_unused]] " + *s->name + "& other) noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("using std::swap;");
    if (s->base && !s->base->empty())
        WriteLineIndent(ConvertTypeName(*p->name, *s->base, false) + "::swap(other);");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("swap(" + *field->name + ", other." + *field->name + ");");
    Indent(-1);
    WriteLineIndent("}");
}

void GeneratorCpp::GenerateStructOutputStream(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    // Generate struct output stream operator begin
    WriteLine();
    WriteLineIndent("std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const " + *s->name + "& value)");
    WriteLineIndent("{");
    Indent(1);

    // Generate struct output stream operator body
    WriteLineIndent("stream << \"" + *s->name + "(\";");
    bool first = true;
    if (s->base && !s->base->empty())
    {
        WriteLineIndent("stream << (const " + ConvertTypeName(*p->name, *s->base, false) + "&)value;");
        first = false;
    }
    if (s->body)
    {
        // Generate fields output stream operator calls
        for (const auto& field : s->body->fields)
        {
            if (field->attributes && field->attributes->hidden)
                WriteLineIndent("stream << \"" + std::string(first ? "" : ",") + *field->name + "=***\";");
            else if (field->array)
            {
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("bool first = true;");
                WriteLineIndent("stream << \"" + std::string(first ? "" : ",") + *field->name + "=[" + std::to_string(field->N) + "][\"" + ";");
                WriteLineIndent("for (size_t i = 0; i < " + std::to_string(field->N) + "; ++i)");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent(ConvertOutputStreamValue(*field->type, "value."+ *field->name + "[i]", field->ptr, field->optional, true));
                WriteLineIndent("first = false;");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("stream << \"]\";");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->vector)
            {
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("bool first = true;");
                WriteLineIndent("stream << \"" + std::string(first ? "" : ",") + *field->name + "=[\" << value." + *field->name + ".size()" + " << \"][\"" + ";");
                WriteLineIndent("for (const auto& it : value." + *field->name + ")");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent(ConvertOutputStreamValue(*field->type, "it", field->ptr, field->optional, true));
                WriteLineIndent("first = false;");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("stream << \"]\";");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->list)
            {
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("bool first = true;");
                WriteLineIndent("stream << \"" + std::string(first ? "" : ",") + *field->name + "=[\" << value." + *field->name + ".size()" + "<< \"]<\"" + ";");
                WriteLineIndent("for (const auto& it : value." + *field->name + ")");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent(ConvertOutputStreamValue(*field->type, "it", field->ptr, field->optional, true));
                WriteLineIndent("first = false;");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("stream << \">\";");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->set)
            {
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("bool first = true;");
                WriteLineIndent("stream << \"" + std::string(first ? "" : ",") + *field->name + "=[\" << value." + *field->name + ".size()" + "<< \"]{\"" + ";");
                WriteLineIndent("for (const auto& it : value." + *field->name + ")");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent(ConvertOutputStreamValue(*field->type, "it", field->ptr, field->optional, true));
                WriteLineIndent("first = false;");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("stream << \"}\";");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->map)
            {
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("bool first = true;");
                WriteLineIndent("stream << \"" + std::string(first ? "" : ",") + *field->name + "=[\" << value." + *field->name + ".size()" + "<< \"]<{\"" + ";");
                WriteLineIndent("for (const auto& it : value." + *field->name + ")");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent(ConvertOutputStreamValue(*field->key, "it.first", false, false, true));
                WriteLineIndent("stream << \"->\";");
                WriteLineIndent(ConvertOutputStreamValue(*field->type, "it.second", field->ptr, field->optional, false));
                WriteLineIndent("first = false;");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("stream << \"}>\";");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->hash)
            {
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("bool first = true;");
                WriteLineIndent("stream << \"" + std::string(first ? "" : ",") + *field->name + "=[\" << " + "value." + *field->name + ".size()" + "<< \"][{\"" + ";");
                WriteLineIndent("for (const auto& it : value." + *field->name + ")");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent(ConvertOutputStreamValue(*field->key, "it.first", false, false, true));
                WriteLineIndent("stream << \"->\";");
                WriteLineIndent(ConvertOutputStreamValue(*field->type, "it.second", field->ptr, field->optional, false));
                WriteLineIndent("first = false;");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("stream << \"}]\";");
                Indent(-1);
                WriteLineIndent("}");
            }
            else
                WriteLineIndent("stream << \"" + std::string(first ? "" : ",") + *field->name + "=\"; " + ConvertOutputStreamValue(*field->type, "value." + *field->name, field->ptr, field->optional, false));
            first = false;
        }
    }
    WriteLineIndent("stream << \")\";");
    WriteLineIndent("return stream;");

    // Generate struct output stream operator end
    Indent(-1);
    WriteLineIndent("}");
}

void GeneratorCpp::GenerateStructLoggingStream(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    // Generate struct logging stream operator begin
    WriteLine();
    WriteLineIndent("#if defined(LOGGING_PROTOCOL)");
    WriteLineIndent("CppLogging::Record& operator<<(CppLogging::Record& record, const " + *s->name + "& value)");
    WriteLineIndent("{");
    Indent(1);

    // Generate struct output stream operator body
    WriteLineIndent("const size_t begin = record.StoreListBegin();");
    WriteLineIndent("record.StoreList(\"" + *s->name + "(\");");
    bool first = true;
    if (s->base && !s->base->empty())
    {
        WriteLineIndent("record.StoreList((const " + ConvertTypeName(*p->name, *s->base, false) + "&)value);");
        first = false;
    }
    if (s->body)
    {
        // Generate fields output stream operator calls
        for (const auto& field : s->body->fields)
        {
            if (field->attributes && field->attributes->hidden)
                WriteLineIndent("record.StoreList(\"" + std::string(first ? "" : ",") + *field->name + "=***\");");
            else if (field->array)
            {
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("bool first = true;");
                WriteLineIndent("record.StoreList(\"" + std::string(first ? "" : ",") + *field->name + "=[" + std::to_string(field->N) + "][\");");
                WriteLineIndent("for (size_t i = 0; i < " + std::to_string(field->N) + "; ++i)");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent(ConvertLoggingStreamValue(*field->type, "value." + *field->name + "[i]", field->optional, true));
                WriteLineIndent("first = false;");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("record.StoreList(\"]\");");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->vector)
            {
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("bool first = true;");
                WriteLineIndent("record.StoreList(\"" + std::string(first ? "" : ",") + *field->name + "=[\").StoreList(value." + *field->name + ".size()).StoreList(\"][\");");
                WriteLineIndent("for (const auto& it : value." + *field->name + ")");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent(ConvertLoggingStreamValue(*field->type, "it", field->optional, true));
                WriteLineIndent("first = false;");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("record.StoreList(\"]\");");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->list)
            {
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("bool first = true;");
                WriteLineIndent("record.StoreList(\"" + std::string(first ? "" : ",") + *field->name + "=[\").StoreList(value." + *field->name + ".size()).StoreList(\"]<\");");
                WriteLineIndent("for (const auto& it : value." + *field->name + ")");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent(ConvertLoggingStreamValue(*field->type, "it", field->optional, true));
                WriteLineIndent("first = false;");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("record.StoreList(\">\");");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->set)
            {
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("bool first = true;");
                WriteLineIndent("record.StoreList(\"" + std::string(first ? "" : ",") + *field->name + "=[\").StoreList(value." + *field->name + ".size()).StoreList(\"]{\");");
                WriteLineIndent("for (const auto& it : value." + *field->name + ")");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent(ConvertLoggingStreamValue(*field->type, "it", field->optional, true));
                WriteLineIndent("first = false;");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("record.StoreList(\"}\");");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->map)
            {
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("bool first = true;");
                WriteLineIndent("record.StoreList(\"" + std::string(first ? "" : ",") + *field->name + "=[\").StoreList(value." + *field->name + ".size()).StoreList(\"]<{\");");
                WriteLineIndent("for (const auto& it : value." + *field->name + ")");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent(ConvertLoggingStreamValue(*field->key, "it.first", false, true));
                WriteLineIndent("record.StoreList(\"->\");");
                WriteLineIndent(ConvertLoggingStreamValue(*field->type, "it.second", field->optional, false));
                WriteLineIndent("first = false;");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("record.StoreList(\"}>\");");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->hash)
            {
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("bool first = true;");
                WriteLineIndent("record.StoreList(\"" + std::string(first ? "" : ",") + *field->name + "=[\").StoreList(value." + *field->name + ".size()).StoreList(\"][{\");");
                WriteLineIndent("for (const auto& it : value." + *field->name + ")");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent(ConvertLoggingStreamValue(*field->key, "it.first", false, true));
                WriteLineIndent("record.StoreList(\"->\");");
                WriteLineIndent(ConvertLoggingStreamValue(*field->type, "it.second", field->optional, false));
                WriteLineIndent("first = false;");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("record.StoreList(\"}]\");");
                Indent(-1);
                WriteLineIndent("}");
            }
            else
                WriteLineIndent("record.StoreList(\"" + std::string(first ? "" : ",") + *field->name + "=\"); " + ConvertLoggingStreamValue(*field->type, "value." + *field->name, field->optional, false));
            first = false;
        }
    }
    WriteLineIndent("record.StoreList(\")\");");
    WriteLineIndent("return record.StoreListEnd(begin);");

    // Generate struct logging stream operator end
    Indent(-1);
    WriteLineIndent("}");
    WriteLineIndent("#endif");
}

void GeneratorCpp::GenerateStructHash(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    // Generate struct hash
    WriteLine();
    WriteLineIndent("template<>");
    WriteLineIndent("struct std::hash<" + ConvertNamespace(*p->name) + "::" + *s->name + ">");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("typedef " + ConvertNamespace(*p->name) + "::" + *s->name + " argument_type;");
    WriteLineIndent("typedef size_t result_type;");
    WriteLine();
    WriteLineIndent("result_type operator() ([[maybe_unused]] const argument_type& value) const");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("result_type result = 17;");
    if (s->base && !s->base->empty())
        WriteLineIndent("result = result * 31 + std::hash<" + ConvertTypeName(*p->name, *s->base, false) + ">()(value);");
    if (s->body)
        for (const auto& field : s->body->fields)
            if (field->keys)
                WriteLineIndent("result = result * 31 + std::hash<decltype(value." + *field->name + ")>()(value." + *field->name + ");");
    WriteLineIndent("return result;");
    Indent(-1);
    WriteLineIndent("}");
    Indent(-1);
    WriteLineIndent("};");
}

void GeneratorCpp::GenerateStructJson(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;

    // Generate to_json() function
    WriteLine();
    WriteLineIndent("template <class TWriter>");
    WriteLineIndent("struct ValueWriter<TWriter, " + struct_name + ">");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("static bool to_json(TWriter& writer, const " + struct_name + "& value, bool scope = true)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if (scope)");
    Indent(1);
    WriteLineIndent("if (!writer.StartObject())");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    Indent(-1);
    if (s->base && !s->base->empty())
    {
        WriteLineIndent("if (!FBE::JSON::to_json(writer, (const " + ConvertTypeName(*p->name, *s->base, false) + "&)value, false))");
        Indent(1);
        WriteLineIndent("return false;");
        Indent(-1);
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLineIndent("if (!FBE::JSON::to_json_key(writer, \"" + *field->name + "\") || !FBE::JSON::to_json(writer, value." + *field->name + ", true))");
            Indent(1);
            WriteLineIndent("return false;");
            Indent(-1);
        }
    }
    WriteLineIndent("if (scope)");
    Indent(1);
    WriteLineIndent("if (!writer.EndObject())");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    Indent(-1);
    WriteLineIndent("return true;");
    Indent(-1);
    WriteLineIndent("}");
    Indent(-1);
    WriteLineIndent("};");

    // Generate from_json() function
    WriteLine();
    WriteLineIndent("template <class TJson>");
    WriteLineIndent("struct ValueReader<TJson, " + struct_name + ">");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("static bool from_json(const TJson& json, " + struct_name + "& value, const char* key = nullptr)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if (key != nullptr)");
    Indent(1);
    WriteLineIndent("return FBE::JSON::from_json_child(json, value, key);");
    Indent(-1);
    WriteLineIndent("bool result = true;");
    if (s->base && !s->base->empty())
        WriteLineIndent("result &= FBE::JSON::from_json(json, (" + ConvertTypeName(*p->name, *s->base, false) + "&)value);");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("result &= FBE::JSON::from_json(json, value." + *field->name + ", \"" + *field->name + "\");");
    WriteLineIndent("return result;");
    Indent(-1);
    WriteLineIndent("}");
    Indent(-1);
    WriteLineIndent("};");
}

void GeneratorCpp::GenerateStructFieldModel_Header(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;

    // Generate struct field model begin
    WriteLine();
    WriteLineIndent("// Fast Binary Encoding " + struct_name + " field model");
    WriteLineIndent("template <>");
    WriteLineIndent("class FieldModel<" + struct_name + ">");
    WriteLineIndent("{");
    WriteLineIndent("public:");
    Indent(1);

    // Generate struct field model constructor
    WriteLineIndent("FieldModel(FBEBuffer& buffer, size_t offset) noexcept;");

    // Generate struct field model FBE methods
    WriteLine();
    WriteLineIndent("// Get the field offset");
    WriteLineIndent("size_t fbe_offset() const noexcept { return _offset; }");
    WriteLineIndent("// Get the field size");
    WriteLineIndent("size_t fbe_size() const noexcept { return 4; }");
    WriteLineIndent("// Get the field body size");
    WriteLineIndent("size_t fbe_body() const noexcept;");
    WriteLineIndent("// Get the field extra size");
    WriteLineIndent("size_t fbe_extra() const noexcept;");
    WriteLineIndent("// Get the field type");
    if (s->base && !s->base->empty() && (s->type == 0))
        WriteLineIndent("static constexpr size_t fbe_type() noexcept { return FieldModel<" + ConvertTypeName(*p->name, *s->base, false) + ">::fbe_type(); }");
    else
        WriteLineIndent("static constexpr size_t fbe_type() noexcept { return " + std::to_string(s->type) + "; }");
    WriteLine();
    WriteLineIndent("// Shift the current field offset");
    WriteLineIndent("void fbe_shift(size_t size) noexcept { _offset += size; }");
    WriteLineIndent("// Unshift the current field offset");
    WriteLineIndent("void fbe_unshift(size_t size) noexcept { _offset -= size; }");

    // Generate struct field model verify(), verify_fields() methods
    WriteLine();
    WriteLineIndent("// Check if the struct value is valid");
    WriteLineIndent("bool verify(bool fbe_verify_type = true) const noexcept;");
    WriteLineIndent("// Check if the struct fields are valid");
    WriteLineIndent("bool verify_fields(size_t fbe_struct_size) const noexcept;");

    // Generate struct field model get_begin(), get_end() methods
    WriteLine();
    WriteLineIndent("// Get the struct value (begin phase)");
    WriteLineIndent("size_t get_begin() const noexcept;");
    WriteLineIndent("// Get the struct value (end phase)");
    WriteLineIndent("void get_end(size_t fbe_begin) const noexcept;");

    // Generate struct field model get(), get_fields() methods
    WriteLine();
    WriteLineIndent("// Get the struct value");
    WriteLineIndent("void get(" + struct_name + "& fbe_value) const noexcept;");
    WriteLineIndent("// Get the struct fields values");
    WriteLineIndent("void get_fields(" + struct_name + "& fbe_value, size_t fbe_struct_size) const noexcept;");

    // Generate struct field model set_begin(), set_end() methods
    WriteLine();
    WriteLineIndent("// Set the struct value (begin phase)");
    WriteLineIndent("size_t set_begin();");
    WriteLineIndent("// Set the struct value (end phase)");
    WriteLineIndent("void set_end(size_t fbe_begin);");

    // Generate struct field model set(), set_fields() methods
    WriteLine();
    WriteLineIndent("// Set the struct value");
    WriteLineIndent("void set(const " + struct_name + "& fbe_value) noexcept;");
    WriteLineIndent("// Set the struct fields values");
    WriteLineIndent("void set_fields(const " + struct_name + "& fbe_value) noexcept;");

    // Generate struct field model buffer & offset
    Indent(-1);
    WriteLine();
    WriteLineIndent("private:");
    Indent(1);
    WriteLineIndent("FBEBuffer& _buffer;");
    WriteLineIndent("size_t _offset;");

    // Generate struct field model accessors
    Indent(-1);
    WriteLine();
    WriteLineIndent("public:");
    Indent(1);
    if (s->base && !s->base->empty())
        WriteLineIndent("FieldModel<" + ConvertTypeName(*p->name, *s->base, false) + "> parent;");
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            if (field->array)
                WriteLineIndent("FieldModelArray<" + ConvertTypeName(*p->name, *field->type, field->optional) + ", " + std::to_string(field->N) + "> " + *field->name + ";");
            else if (field->vector || field->list || field->set)
                WriteLineIndent("FieldModelVector<" + ConvertTypeName(*p->name, *field->type, field->optional) + "> " + *field->name + ";");
            else if (field->map || field->hash)
                WriteLineIndent("FieldModelMap<" + ConvertTypeName(*p->name, *field->key, false) + ", " + ConvertTypeName(*p->name, *field->type, field->optional) + "> " + *field->name + ";");
            else
                WriteLineIndent("FieldModel<" + ConvertTypeName(*p->name, *field->type, field->optional) + "> " + *field->name + ";");
        }
    }

    // Generate struct field model end
    Indent(-1);
    WriteLineIndent("};");
}

void GeneratorCpp::GenerateStructFieldModel_Source(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
    std::string model_name = "FieldModel<" + struct_name + ">";

    // Generate struct field model constructor
    WriteLine();
    WriteLineIndent(model_name + "::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)");
    Indent(1);
    std::string prev_offset("4");
    std::string prev_size("4");
    if (s->base && !s->base->empty())
    {
        WriteLineIndent(", parent(buffer, " + prev_offset + " + " + prev_size + ")");
        prev_offset = "parent.fbe_offset()";
        prev_size = "parent.fbe_body() - 4 - 4";
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLineIndent(", " + *field->name + "(buffer, " + prev_offset + " + " + prev_size + ")");
            prev_offset = *field->name + ".fbe_offset()";
            prev_size = *field->name + ".fbe_size()";
        }
    }
    Indent(-1);
    WriteLineIndent("{}");
    WriteLine();

    // Generate struct field model FBE methods
    WriteLineIndent("size_t " + model_name + "::fbe_body() const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("size_t fbe_result = 4 + 4");
    Indent(1);
    if (s->base && !s->base->empty())
        WriteLineIndent("+ parent.fbe_body() - 4 - 4");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("+ " + *field->name + ".fbe_size()");
    WriteLineIndent(";");
    Indent(-1);
    WriteLineIndent("return fbe_result;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("size_t " + model_name + "::fbe_extra() const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());");
    WriteLineIndent("if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("_buffer.shift(fbe_struct_offset);");
    WriteLine();
    WriteLineIndent("size_t fbe_result = fbe_body()");
    Indent(1);
    if (s->base && !s->base->empty())
        WriteLineIndent("+ parent.fbe_extra()");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("+ " + *field->name + ".fbe_extra()");
    WriteLineIndent(";");
    Indent(-1);
    WriteLine();
    WriteLineIndent("_buffer.unshift(fbe_struct_offset);");
    WriteLine();
    WriteLineIndent("return fbe_result;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model verify() method
    WriteLineIndent("bool " + model_name + "::verify(bool fbe_verify_type) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
    Indent(1);
    WriteLineIndent("return true;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());");
    WriteLineIndent("if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);");
    WriteLineIndent("if (fbe_struct_size < (4 + 4))");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);");
    WriteLineIndent("if (fbe_verify_type && (fbe_struct_type != fbe_type()))");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("_buffer.shift(fbe_struct_offset);");
    WriteLineIndent("bool fbe_result = verify_fields(fbe_struct_size);");
    WriteLineIndent("_buffer.unshift(fbe_struct_offset);");
    WriteLineIndent("return fbe_result;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model verify_fields() method
    WriteLineIndent("bool " + model_name + "::verify_fields([[maybe_unused]] size_t fbe_struct_size) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty()))
    {
        WriteLineIndent("size_t fbe_current_size = 4 + 4;");
        if (s->base && !s->base->empty())
        {
            WriteLine();
            WriteLineIndent("if ((fbe_current_size + parent.fbe_body() - 4 - 4) > fbe_struct_size)");
            Indent(1);
            WriteLineIndent("return true;");
            Indent(-1);
            WriteLineIndent("if (!parent.verify_fields(fbe_struct_size))");
            Indent(1);
            WriteLineIndent("return false;");
            Indent(-1);
            WriteLineIndent("fbe_current_size += parent.fbe_body() - 4 - 4;");
        }
        if (s->body)
        {
            for (const auto& field : s->body->fields)
            {
                WriteLine();
                WriteLineIndent("if ((fbe_current_size + " + *field->name + ".fbe_size()) > fbe_struct_size)");
                Indent(1);
                WriteLineIndent("return true;");
                Indent(-1);
                WriteLineIndent("if (!" + *field->name + ".verify())");
                Indent(1);
                WriteLineIndent("return false;");
                Indent(-1);
                WriteLineIndent("fbe_current_size += " + *field->name + ".fbe_size();");
            }
        }
        WriteLine();
    }
    WriteLineIndent("return true;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model get_begin() method
    WriteLineIndent("size_t " + model_name + "::get_begin() const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());");
    WriteLineIndent("assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && \"Model is broken!\");");
    WriteLineIndent("if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);");
    WriteLineIndent("assert((fbe_struct_size >= (4 + 4)) && \"Model is broken!\");");
    WriteLineIndent("if (fbe_struct_size < (4 + 4))");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("_buffer.shift(fbe_struct_offset);");
    WriteLineIndent("return fbe_struct_offset;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model get_end() method
    WriteLineIndent("void " + model_name + "::get_end(size_t fbe_begin) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("_buffer.unshift(fbe_begin);");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model get() method
    WriteLineIndent("void " + model_name + "::get(" + struct_name + "& fbe_value) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("size_t fbe_begin = get_begin();");
    WriteLineIndent("if (fbe_begin == 0)");
    Indent(1);
    WriteLineIndent("return;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());");
    WriteLineIndent("get_fields(fbe_value, fbe_struct_size);");
    WriteLineIndent("get_end(fbe_begin);");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model get_fields() method
    WriteLineIndent("void " + model_name + "::get_fields([[maybe_unused]] " + struct_name + "& fbe_value, [[maybe_unused]] size_t fbe_struct_size) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty()))
    {
        WriteLineIndent("size_t fbe_current_size = 4 + 4;");
        if (s->base && !s->base->empty())
        {
            WriteLine();
            WriteLineIndent("if ((fbe_current_size + parent.fbe_body() - 4 - 4) <= fbe_struct_size)");
            Indent(1);
            WriteLineIndent("parent.get_fields(fbe_value, fbe_struct_size);");
            Indent(-1);
            WriteLineIndent("fbe_current_size += parent.fbe_body() - 4 - 4;");
        }
        if (s->body)
        {
            for (const auto& field : s->body->fields)
            {
                WriteLine();
                WriteLineIndent("if ((fbe_current_size + " + *field->name + ".fbe_size()) <= fbe_struct_size)");
                Indent(1);
                WriteLineIndent(*field->name + ".get(fbe_value." + *field->name + (field->value ? (", " + ConvertConstant(*field->type, *field->value, field->optional)) : "") +");");
                Indent(-1);
                WriteLineIndent("else");
                Indent(1);
                if (field->array)
                {
                    // Do nothing here...
                }
                else if (field->vector || field->list || field->set || field->map || field->hash || ((*field->type == "bytes") && !field->optional))
                    WriteLineIndent("fbe_value." + *field->name + ".clear();");
                else
                    WriteLineIndent("fbe_value." + *field->name + " = " + ConvertDefault(*p->name, *field) + ";");
                Indent(-1);
                WriteLineIndent("fbe_current_size += " + *field->name + ".fbe_size();");
            }
        }
    }
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model set_begin() method
    WriteLineIndent("size_t " + model_name + "::set_begin()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && \"Model is broken!\");");
    WriteLineIndent("if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_struct_size = (uint32_t)fbe_body();");
    WriteLineIndent("uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());");
    WriteLineIndent("assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && \"Model is broken!\");");
    WriteLineIndent("if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);");
    WriteLineIndent("unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);");
    WriteLineIndent("unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, (uint32_t)fbe_type());");
    WriteLine();
    WriteLineIndent("_buffer.shift(fbe_struct_offset);");
    WriteLineIndent("return fbe_struct_offset;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model set_end() method
    WriteLineIndent("void " + model_name + "::set_end(size_t fbe_begin)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("_buffer.unshift(fbe_begin);");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model set() method
    WriteLineIndent("void " + model_name + "::set(const " + struct_name + "& fbe_value) noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("size_t fbe_begin = set_begin();");
    WriteLineIndent("if (fbe_begin == 0)");
    Indent(1);
    WriteLineIndent("return;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("set_fields(fbe_value);");
    WriteLineIndent("set_end(fbe_begin);");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model set_fields() method
    WriteLineIndent("void " + model_name + "::set_fields([[maybe_unused]] const " + struct_name + "& fbe_value) noexcept");
    WriteLineIndent("{");
    Indent(1);
    if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty()))
    {
        if (s->base && !s->base->empty())
            WriteLineIndent("parent.set_fields(fbe_value);");
        if (s->body)
            for (const auto& field : s->body->fields)
                WriteLineIndent(*field->name + ".set(fbe_value." + *field->name + ");");
    }
    Indent(-1);
    WriteLineIndent("}");
}

void GeneratorCpp::GenerateStructModel_Header(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

    std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;

    // Generate struct model begin
    WriteLine();
    WriteLineIndent("// Fast Binary Encoding " + *s->name + " model");
    WriteLineIndent("class " + *s->name + "Model : public FBE::Model");
    WriteLineIndent("{");
    WriteLineIndent("public:");
    Indent(1);

    // Generate struct model constructor
    WriteLineIndent(*s->name + "Model() : model(this->buffer(), 4) {}");
    WriteLineIndent(*s->name + "Model(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}");

    // Generate struct model FBE methods
    WriteLine();
    WriteLineIndent("// Get the model size");
    WriteLineIndent("size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }");
    WriteLineIndent("// Get the model type");
    WriteLineIndent("static constexpr size_t fbe_type() noexcept { return FieldModel<" + struct_name + ">::fbe_type(); }");

    // Generate struct model verify() method
    WriteLine();
    WriteLineIndent("// Check if the struct value is valid");
    WriteLineIndent("bool verify();");

    // Generate struct model create_begin(), create_end() methods
    WriteLine();
    WriteLineIndent("// Create a new model (begin phase)");
    WriteLineIndent("size_t create_begin();");
    WriteLineIndent("// Create a new model (end phase)");
    WriteLineIndent("size_t create_end(size_t fbe_begin);");

    // Generate struct model serialize(), deserialize() methods
    WriteLine();
    WriteLineIndent("// Serialize the struct value");
    WriteLineIndent("size_t serialize(const " + struct_name + "& value);");
    WriteLineIndent("// Deserialize the struct value");
    WriteLineIndent("size_t deserialize(" + struct_name + "& value) const noexcept;");

    // Generate struct model next() method
    WriteLine();
    WriteLineIndent("// Move to the next struct value");
    WriteLineIndent("void next(size_t prev) noexcept { model.fbe_shift(prev); }");

    // Generate struct model accessor
    Indent(-1);
    WriteLine();
    WriteLineIndent("public:");
    Indent(1);
    WriteLineIndent("FieldModel<" + struct_name + "> model;");

    // Generate struct model end
    Indent(-1);
    WriteLineIndent("};");

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));
}

void GeneratorCpp::GenerateStructModel_Source(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

    std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
    std::string model_name = *s->name + "Model";

    // Generate struct model verify() method
    WriteLine();
    WriteLineIndent("bool " + model_name + "::verify()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);");
    WriteLineIndent("if (fbe_full_size < model.fbe_size())");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("return model.verify();");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct model create_begin() method
    WriteLineIndent("size_t " + model_name + "::create_begin()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());");
    WriteLineIndent("return fbe_begin;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct model create_end() method
    WriteLineIndent("size_t " + model_name + "::create_end(size_t fbe_begin)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("size_t fbe_end = this->buffer().size();");
    WriteLineIndent("uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);");
    WriteLineIndent("unaligned_store<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4, fbe_full_size);");
    WriteLineIndent("return fbe_full_size;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct model serialize() method
    WriteLineIndent("size_t " + model_name + "::serialize(const " + struct_name + "& value)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("size_t fbe_begin = create_begin();");
    WriteLineIndent("model.set(value);");
    WriteLineIndent("size_t fbe_full_size = create_end(fbe_begin);");
    WriteLineIndent("return fbe_full_size;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct model deserialize() method
    WriteLineIndent("size_t " + model_name + "::deserialize(" + struct_name + "& value) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);");
    WriteLineIndent("assert((fbe_full_size >= model.fbe_size()) && \"Model is broken!\");");
    WriteLineIndent("if (fbe_full_size < model.fbe_size())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("model.get(value);");
    WriteLineIndent("return fbe_full_size;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));
}

void GeneratorCpp::GenerateStructFinalModel_Header(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;

    // Generate struct final model begin
    WriteLine();
    WriteLineIndent("// Fast Binary Encoding " + struct_name + " final model");
    WriteLineIndent("template <>");
    WriteLineIndent("class FinalModel<" + struct_name + ">");
    WriteLineIndent("{");
    WriteLineIndent("public:");
    Indent(1);

    // Generate struct final model constructor
    WriteLineIndent("FinalModel(FBEBuffer& buffer, size_t offset) noexcept;");

    // Generate struct final model FBE methods
    WriteLine();
    WriteLineIndent("// Get the allocation size");
    WriteLineIndent("size_t fbe_allocation_size(const " + struct_name + "& fbe_value) const noexcept;");
    WriteLineIndent("// Get the final offset");
    WriteLineIndent("size_t fbe_offset() const noexcept { return _offset; }");
    WriteLineIndent("// Set the final offset");
    WriteLineIndent("size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }");
    WriteLineIndent("// Get the final type");
    if (s->base && !s->base->empty() && (s->type == 0))
        WriteLineIndent("static constexpr size_t fbe_type() noexcept { return FinalModel<" + ConvertTypeName(*p->name, *s->base, false) + ">::fbe_type(); }");
    else
        WriteLineIndent("static constexpr size_t fbe_type() noexcept { return " + std::to_string(s->type) + "; }");
    WriteLine();
    WriteLineIndent("// Shift the current final offset");
    WriteLineIndent("void fbe_shift(size_t size) noexcept { _offset += size; }");
    WriteLineIndent("// Unshift the current final offset");
    WriteLineIndent("void fbe_unshift(size_t size) noexcept { _offset -= size; }");

    // Generate struct final model verify(), verify_fields() methods
    WriteLine();
    WriteLineIndent("// Check if the struct value is valid");
    WriteLineIndent("size_t verify() const noexcept;");
    WriteLineIndent("// Check if the struct fields are valid");
    WriteLineIndent("size_t verify_fields() const noexcept;");

    // Generate struct final model get(), get_fields() methods
    WriteLine();
    WriteLineIndent("// Get the struct value");
    WriteLineIndent("size_t get(" + struct_name + "& fbe_value) const noexcept;");
    WriteLineIndent("// Get the struct fields values");
    WriteLineIndent("size_t get_fields(" + struct_name + "& fbe_value) const noexcept;");

    // Generate struct final model set(), set_fields() method
    WriteLine();
    WriteLineIndent("// Set the struct value");
    WriteLineIndent("size_t set(const " + struct_name + "& fbe_value) noexcept;");
    WriteLineIndent("// Set the struct fields values");
    WriteLineIndent("size_t set_fields(const " + struct_name + "& fbe_value) noexcept;");

    // Generate struct final model buffer & offset
    Indent(-1);
    WriteLine();
    WriteLineIndent("private:");
    Indent(1);
    WriteLineIndent("FBEBuffer& _buffer;");
    WriteLineIndent("mutable size_t _offset;");

    // Generate struct final model accessors
    Indent(-1);
    WriteLine();
    WriteLineIndent("public:");
    Indent(1);
    if (s->base && !s->base->empty())
        WriteLineIndent("FinalModel<" + ConvertTypeName(*p->name, *s->base, false) + "> parent;");
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            if (field->array)
                WriteLineIndent("FinalModelArray<" + ConvertTypeName(*p->name, *field->type, field->optional) + ", " + std::to_string(field->N) + "> " + *field->name + ";");
            else if (field->vector || field->list || field->set)
                WriteLineIndent("FinalModelVector<" + ConvertTypeName(*p->name, *field->type, field->optional) + "> " + *field->name + ";");
            else if (field->map || field->hash)
                WriteLineIndent("FinalModelMap<" + ConvertTypeName(*p->name, *field->key, false) + ", " + ConvertTypeName(*p->name, *field->type, field->optional) + "> " + *field->name + ";");
            else
                WriteLineIndent("FinalModel<" + ConvertTypeName(*p->name, *field->type, field->optional) + "> " + *field->name + ";");
        }
    }

    // Generate struct final model end
    Indent(-1);
    WriteLineIndent("};");
}

void GeneratorCpp::GenerateStructFinalModel_Source(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
    std::string model_name = "FinalModel<" + struct_name + ">";

    // Generate struct final model constructor
    WriteLine();
    WriteLineIndent(model_name + "::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)");
    Indent(1);
    if (s->base && !s->base->empty())
        WriteLineIndent(", parent(buffer, 0)");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent(", " + *field->name + "(buffer, 0)");
    Indent(-1);
    WriteLineIndent("{}");
    WriteLine();

    // Generate struct final model FBE methods
    WriteLineIndent("size_t " + model_name + "::fbe_allocation_size(const " + struct_name + "& fbe_value) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("size_t fbe_result = 0");
    Indent(1);
    if (s->base && !s->base->empty())
        WriteLineIndent("+ parent.fbe_allocation_size(fbe_value)");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("+ " + *field->name + ".fbe_allocation_size(fbe_value." + *field->name + ")");
    WriteLineIndent(";");
    Indent(-1);
    WriteLineIndent("return fbe_result;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct final model verify() method
    WriteLineIndent("size_t " + model_name + "::verify() const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("_buffer.shift(fbe_offset());");
    WriteLineIndent("size_t fbe_result = verify_fields();");
    WriteLineIndent("_buffer.unshift(fbe_offset());");
    WriteLineIndent("return fbe_result;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct final model verify_fields() method
    WriteLineIndent("size_t " + model_name + "::verify_fields() const noexcept");
    WriteLineIndent("{");
    Indent(1);
    if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty()))
    {
        WriteLineIndent("size_t fbe_current_offset = 0;");
        WriteLineIndent("size_t fbe_field_size;");
        if (s->base && !s->base->empty())
        {
            WriteLine();
            WriteLineIndent("parent.fbe_offset(fbe_current_offset);");
            WriteLineIndent("fbe_field_size = parent.verify_fields();");
            WriteLineIndent("if (fbe_field_size == std::numeric_limits<std::size_t>::max())");
            Indent(1);
            WriteLineIndent("return std::numeric_limits<std::size_t>::max();");
            Indent(-1);
            WriteLineIndent("fbe_current_offset += fbe_field_size;");
        }
        if (s->body)
        {
            for (const auto& field : s->body->fields)
            {
                WriteLine();
                WriteLineIndent(*field->name + ".fbe_offset(fbe_current_offset);");
                WriteLineIndent("fbe_field_size = " + *field->name + ".verify();");
                WriteLineIndent("if (fbe_field_size == std::numeric_limits<std::size_t>::max())");
                Indent(1);
                WriteLineIndent("return std::numeric_limits<std::size_t>::max();");
                Indent(-1);
                WriteLineIndent("fbe_current_offset += fbe_field_size;");
            }
        }
        WriteLine();
        WriteLineIndent("return fbe_current_offset;");
    }
    else
        WriteLineIndent("return 0;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct final model get() method
    WriteLineIndent("size_t " + model_name + "::get(" + struct_name + "& fbe_value) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("_buffer.shift(fbe_offset());");
    WriteLineIndent("size_t fbe_result = get_fields(fbe_value);");
    WriteLineIndent("_buffer.unshift(fbe_offset());");
    WriteLineIndent("return fbe_result;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct final model get_fields() method
    WriteLineIndent("size_t " + model_name + "::get_fields([[maybe_unused]] " + struct_name + "& fbe_value) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty()))
    {
        WriteLineIndent("size_t fbe_current_offset = 0;");
        WriteLineIndent("size_t fbe_current_size = 0;");
        WriteLineIndent("size_t fbe_field_size;");
        if (s->base && !s->base->empty())
        {
            WriteLine();
            WriteLineIndent("parent.fbe_offset(fbe_current_offset);");
            WriteLineIndent("fbe_field_size = parent.get_fields(fbe_value);");
            WriteLineIndent("fbe_current_offset += fbe_field_size;");
            WriteLineIndent("fbe_current_size += fbe_field_size;");
        }
        if (s->body)
        {
            for (const auto& field : s->body->fields)
            {
                WriteLine();
                WriteLineIndent(*field->name + ".fbe_offset(fbe_current_offset);");
                WriteLineIndent("fbe_field_size = " + *field->name + ".get(fbe_value." + *field->name + ");");
                WriteLineIndent("fbe_current_offset += fbe_field_size;");
                WriteLineIndent("fbe_current_size += fbe_field_size;");
            }
        }
        WriteLine();
        WriteLineIndent("return fbe_current_size;");
    }
    else
        WriteLineIndent("return 0;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct final model set() method
    WriteLineIndent("size_t " + model_name + "::set(const " + struct_name + "& fbe_value) noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("_buffer.shift(fbe_offset());");
    WriteLineIndent("size_t fbe_result = set_fields(fbe_value);");
    WriteLineIndent("_buffer.unshift(fbe_offset());");
    WriteLineIndent("return fbe_result;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct final model set_fields() method
    WriteLineIndent("size_t " + model_name + "::set_fields([[maybe_unused]] const " + struct_name + "& fbe_value) noexcept");
    WriteLineIndent("{");
    Indent(1);
    if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty()))
    {
        WriteLineIndent("size_t fbe_current_offset = 0;");
        WriteLineIndent("size_t fbe_current_size = 0;");
        WriteLineIndent("size_t fbe_field_size;");
        if (s->base && !s->base->empty())
        {
            WriteLine();
            WriteLineIndent("parent.fbe_offset(fbe_current_offset);");
            WriteLineIndent("fbe_field_size = parent.set_fields(fbe_value);");
            WriteLineIndent("fbe_current_offset += fbe_field_size;");
            WriteLineIndent("fbe_current_size += fbe_field_size;");
        }
        if (s->body)
        {
            for (const auto& field : s->body->fields)
            {
                WriteLine();
                WriteLineIndent(*field->name + ".fbe_offset(fbe_current_offset);");
                WriteLineIndent("fbe_field_size = " + *field->name + ".set(fbe_value." + *field->name + ");");
                WriteLineIndent("fbe_current_offset += fbe_field_size;");
                WriteLineIndent("fbe_current_size += fbe_field_size;");
            }
        }
        WriteLine();
        WriteLineIndent("return fbe_current_size;");
    }
    else
        WriteLineIndent("return 0;");
    Indent(-1);
    WriteLineIndent("}");
}

void GeneratorCpp::GenerateStructModelFinal_Header(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

    std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;

    // Generate struct model final begin
    WriteLine();
    WriteLineIndent("// Fast Binary Encoding " + *s->name + " final model");
    WriteLineIndent("class " + *s->name + "FinalModel : public FBE::Model");
    WriteLineIndent("{");
    WriteLineIndent("public:");
    Indent(1);

    // Generate struct model final constructor
    WriteLineIndent(*s->name + "FinalModel() : _model(this->buffer(), 8) {}");
    WriteLineIndent(*s->name + "FinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}");

    // Generate struct model final FBE methods
    WriteLine();
    WriteLineIndent("// Get the model type");
    WriteLineIndent("static constexpr size_t fbe_type() noexcept { return FinalModel<" + struct_name + ">::fbe_type(); }");

    // Generate struct model final verify() method
    WriteLine();
    WriteLineIndent("// Check if the struct value is valid");
    WriteLineIndent("bool verify();");

    // Generate struct model final serialize(), deserialize() methods
    WriteLine();
    WriteLineIndent("// Serialize the struct value");
    WriteLineIndent("size_t serialize(const " + struct_name + "& value);");
    WriteLineIndent("// Deserialize the struct value");
    WriteLineIndent("size_t deserialize(" + struct_name + "& value) const noexcept;");

    // Generate struct model final next() method
    WriteLine();
    WriteLineIndent("// Move to the next struct value");
    WriteLineIndent("void next(size_t prev) noexcept { _model.fbe_shift(prev); }");

    // Generate struct model final accessor
    Indent(-1);
    WriteLine();
    WriteLineIndent("private:");
    Indent(1);
    WriteLineIndent("FinalModel<" + struct_name + "> _model;");

    // Generate struct model final end
    Indent(-1);
    WriteLineIndent("};");

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));
}

void GeneratorCpp::GenerateStructModelFinal_Source(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

    std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
    std::string model_name = *s->name + "FinalModel";

    // Generate struct model final verify() method
    WriteLine();
    WriteLineIndent("bool " + model_name + "::verify()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);");
    WriteLineIndent("size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);");
    WriteLineIndent("if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("return ((8 + _model.verify()) == fbe_struct_size);");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct model final serialize() method
    WriteLineIndent("size_t " + model_name + "::serialize(const " + struct_name + "& value)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("size_t fbe_initial_size = this->buffer().size();");
    WriteLine();
    WriteLineIndent("uint32_t fbe_struct_type = (uint32_t)fbe_type();");
    WriteLineIndent("uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));");
    WriteLineIndent("uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());");
    WriteLineIndent("assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && \"Model is broken!\");");
    WriteLineIndent("if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("fbe_struct_size = (uint32_t)(8 + _model.set(value));");
    WriteLineIndent("this->buffer().resize(fbe_initial_size + fbe_struct_size);");
    WriteLine();
    WriteLineIndent("*((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;");
    WriteLineIndent("*((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;");
    WriteLine();
    WriteLineIndent("return fbe_struct_size;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct model final deserialize() method
    WriteLineIndent("size_t " + model_name + "::deserialize(" + struct_name + "& value) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && \"Model is broken!\");");
    WriteLineIndent("if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);");
    WriteLineIndent("size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);");
    WriteLineIndent("assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && \"Model is broken!\");");
    WriteLineIndent("if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))");
    Indent(1);
    WriteLineIndent("return 8;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("return 8 + _model.get(value);");
    Indent(-1);
    WriteLineIndent("}");

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));
}

void GeneratorCpp::GenerateProtocolVersion(const std::shared_ptr<Package>& p)
{
    // Generate protocol version struct
    WriteLine();
    WriteLineIndent("// Fast Binary Encoding " + *p->name + " protocol version");
    WriteLineIndent("struct ProtocolVersion");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("// Protocol major version");
    WriteLineIndent("static const int major = " + std::to_string(p->version->major) + ";");
    WriteLineIndent("// Protocol minor version");
    WriteLineIndent("static const int minor = " + std::to_string(p->version->minor) + ";");
    Indent(-1);
    WriteLineIndent("};");
}

void GeneratorCpp::GenerateSender_Header(const std::shared_ptr<Package>& p, bool final)
{
    std::string sender = (final ? "FinalSender" : "Sender");
    std::string model = (final ? "FinalModel" : "Model");

    // Generate sender begin
    WriteLine();
    if (final)
        WriteLineIndent("// Fast Binary Encoding " + *p->name + " final sender");
    else
        WriteLineIndent("// Fast Binary Encoding " + *p->name + " sender");
    WriteLineIndent("class " + sender + " : public virtual FBE::Sender");
    if (p->import)
    {
        Indent(1);
        for (const auto& import : p->import->imports)
            WriteLineIndent(", public virtual " + *import + "::" + sender);
        Indent(-1);
    }
    WriteLineIndent("{");
    WriteLineIndent("public:");
    Indent(1);

    // Generate sender constructors
    WriteLineIndent(sender + "()");
    bool first = true;
    if (p->body)
    {
        Indent(1);
        for (const auto& s : p->body->structs)
        {
            if (s->message)
            {
                WriteLineIndent((first ? ": " : ", ") + *s->name + "" + "Model(this->_buffer)");
                first = false;
            }
        }
        Indent(-1);
    }
    WriteLineIndent("{" + std::string(final ? " this->final(true); " : "") + "}");
    WriteLineIndent(sender + "(const " + sender + "&) = delete;");
    WriteLineIndent(sender + "(" + sender + "&&) noexcept = delete;");
    WriteLineIndent("virtual ~" + sender + "() = default;");

    // Generate sender operators
    WriteLine();
    WriteLineIndent(sender + "& operator=(const " + sender + "&) = delete;");
    WriteLineIndent(sender + "& operator=(" + sender + "&&) noexcept = delete;");

    // Generate imported senders accessors
    if (p->import)
    {
        WriteLine();
        WriteLineIndent("// Imported senders");
        for (const auto& import : p->import->imports)
            WriteLineIndent(*import + "::" + sender + "& " + *import + "_sender() noexcept { return *this; }");
    }

    // Generate send() methods
    if (p->body)
    {
        first = true;
        for (const auto& s : p->body->structs)
        {
            if (s->message)
            {
                std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
                if (first)
                    WriteLine();
                WriteLineIndent("size_t send(const " + struct_name + "& value);");
                first = false;
            }
        }
    }

    // Generate sender models accessors
    if (p->body)
    {
        Indent(-1);
        WriteLine();
        WriteLineIndent("public:");
        Indent(1);
        WriteLineIndent("// Sender models accessors");
        for (const auto& s : p->body->structs)
            if (s->message)
                WriteLineIndent("FBE::" + ConvertNamespace(*p->name) + "::" + *s->name + model + " " + *s->name + "Model;");
    }

    // Generate sender end
    Indent(-1);
    WriteLineIndent("};");
}

void GeneratorCpp::GenerateSender_Source(const std::shared_ptr<Package>& p, bool final)
{
    std::string sender = (final ? "FinalSender" : "Sender");

    // Generate send() methods
    if (p->body)
    {
        for (const auto& s : p->body->structs)
        {
            if (s->message)
            {
                std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
                WriteLine();
                WriteLineIndent("size_t " + sender + "::send(const " + struct_name + "& value)");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("// Serialize the value into the FBE stream");
                WriteLineIndent("size_t serialized = " + *s->name + "Model.serialize(value);");
                WriteLineIndent("assert((serialized > 0) && \"" + ConvertNamespace(*p->name) + "::" + *s->name + " serialization failed!\");");
                WriteLineIndent("assert(" + *s->name + "Model.verify() && \"" + ConvertNamespace(*p->name) + "::" + *s->name + " validation failed!\");");
                WriteLine();
                WriteLineIndent("// Log the value");
                WriteLineIndent("if (this->_logging)");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("std::string message = value.string();");
                WriteLineIndent("this->onSendLog(message);");
                Indent(-1);
                WriteLineIndent("}");
                WriteLine();
                WriteLineIndent("// Send the serialized value");
                WriteLineIndent("return this->send_serialized(serialized);");
                Indent(-1);
                WriteLineIndent("}");
            }
        }
    }
}

void GeneratorCpp::GenerateReceiver_Header(const std::shared_ptr<Package>& p, bool final)
{
    std::string receiver = (final ? "FinalReceiver" : "Receiver");
    std::string model = (final ? "FinalModel" : "Model");

    // Generate receiver begin
    WriteLine();
    if (final)
        WriteLineIndent("// Fast Binary Encoding " + *p->name + " final receiver");
    else
        WriteLineIndent("// Fast Binary Encoding " + *p->name + " receiver");
    WriteLineIndent("class " + receiver + " : public virtual FBE::Receiver");
    if (p->import)
    {
        Indent(1);
        for (const auto& import : p->import->imports)
            WriteLineIndent(", public virtual " + *import + "::" + receiver);
        Indent(-1);
    }
    WriteLineIndent("{");
    WriteLineIndent("public:");
    Indent(1);

    // Generate receiver constructors
    WriteLineIndent(receiver + "() {" + std::string(final ? " this->final(true); " : "") + "}");
    WriteLineIndent(receiver + "(const " + receiver + "&) = delete;");
    WriteLineIndent(receiver + "(" + receiver + "&&) = delete;");
    WriteLineIndent("virtual ~" + receiver + "() = default;");

    // Generate receiver operators
    WriteLine();
    WriteLineIndent(receiver + "& operator=(const " + receiver + "&) = delete;");
    WriteLineIndent(receiver + "& operator=(" + receiver + "&&) = delete;");

    // Generate receiver handlers
    if (p->body)
    {
        WriteLine();
        Indent(-1);
        WriteLineIndent("protected:");
        Indent(1);
        WriteLineIndent("// Receive handlers");
        for (const auto& s : p->body->structs)
        {
            if (s->message)
            {
                std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
                WriteLineIndent("virtual void onReceive(const " + struct_name + "& value) {}");
            }
        }
    }

    // Generate receiver message handler
    WriteLine();
    WriteLineIndent("// Receive message handler");
    WriteLineIndent("bool onReceive(size_t type, const void* data, size_t size) override;");

    // Generate receiver models accessors
    if (p->body)
    {
        Indent(-1);
        WriteLine();
        WriteLineIndent("private:");
        Indent(1);
        WriteLineIndent("// Receiver values accessors");
        for (const auto& s : p->body->structs)
        {
            if (s->message)
            {
                std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
                WriteLineIndent(struct_name + " " + *s->name + "Value;");
            }
        }
        WriteLine();
        WriteLineIndent("// Receiver models accessors");
        for (const auto& s : p->body->structs)
            if (s->message)
                WriteLineIndent("FBE::" + ConvertNamespace(*p->name) + "::" + *s->name + model + " " + *s->name + "Model;");
    }

    // Generate receiver end
    Indent(-1);
    WriteLineIndent("};");
}

void GeneratorCpp::GenerateReceiver_Source(const std::shared_ptr<Package>& p, bool final)
{
    std::string receiver = (final ? "FinalReceiver" : "Receiver");
    std::string model = (final ? "FinalModel" : "Model");

    // Generate receiver message handler
    WriteLine();
    WriteLineIndent("bool " + receiver + "::onReceive(size_t type, const void* data, size_t size)");
    WriteLineIndent("{");
    Indent(1);
    if (p->body)
    {
        WriteLineIndent("switch (type)");
        WriteLineIndent("{");
        Indent(1);
        for (const auto& s : p->body->structs)
        {
            if (s->message)
            {
                std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
                WriteLineIndent("case FBE::" + ConvertNamespace(*p->name) + "::" + *s->name + model + "::fbe_type():");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("// Deserialize the value from the FBE stream");
                WriteLineIndent(*s->name + "Model.attach(data, size);");
                WriteLineIndent("assert(" + *s->name + "Model.verify() && \"" + ConvertNamespace(*p->name) + "::" + *s->name + " validation failed!\");");
                WriteLineIndent("[[maybe_unused]] size_t deserialized = " + *s->name + "Model.deserialize(" + *s->name + "Value);");
                WriteLineIndent("assert((deserialized > 0) && \"" + ConvertNamespace(*p->name) + "::" + *s->name + " deserialization failed!\");");
                WriteLine();
                WriteLineIndent("// Log the value");
                WriteLineIndent("if (this->_logging)");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("std::string message = " + *s->name + "Value.string();");
                WriteLineIndent("this->onReceiveLog(message);");
                Indent(-1);
                WriteLineIndent("}");
                WriteLine();
                WriteLineIndent("// Call receive handler with deserialized value");
                WriteLineIndent("onReceive(" + *s->name + "Value);");
                WriteLineIndent("return true;");
                Indent(-1);
                WriteLineIndent("}");
            }
        }
        WriteLineIndent("default: break;");
        Indent(-1);
        WriteLineIndent("}");
    }
    if (p->import)
    {
        WriteLine();
        for (const auto& import : p->import->imports)
        {
            WriteLineIndent("if (" + *import + "::" + receiver + "::onReceive(type, data, size))");
            Indent(1);
            WriteLineIndent("return true;");
            Indent(-1);
        }
    }
    WriteLine();
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLineIndent("}");
}

void GeneratorCpp::GenerateProxy_Header(const std::shared_ptr<Package>& p, bool final)
{
    std::string proxy = (final ? "FinalProxy" : "Proxy");
    std::string model = (final ? "FinalModel" : "Model");

    // Generate proxy begin
    WriteLine();
    if (final)
        WriteLineIndent("// Fast Binary Encoding " + *p->name + " final proxy");
    else
        WriteLineIndent("// Fast Binary Encoding " + *p->name + " proxy");
    WriteLineIndent("class " + proxy + " : public virtual FBE::Receiver");
    if (p->import)
    {
        Indent(1);
        for (const auto& import : p->import->imports)
            WriteLineIndent(", public virtual " + *import + "::" + proxy);
        Indent(-1);
    }
    WriteLineIndent("{");
    WriteLineIndent("public:");
    Indent(1);

    // Generate proxy constructors
    WriteLineIndent(proxy + "() {" + std::string(final ? " this->final(true); " : "") + "}");
    WriteLineIndent(proxy + "(const " + proxy + "&) = delete;");
    WriteLineIndent(proxy + "(" + proxy + "&&) = delete;");
    WriteLineIndent("virtual ~" + proxy + "() = default;");

    // Generate proxy operators
    WriteLine();
    WriteLineIndent(proxy + "& operator=(const " + proxy + "&) = delete;");
    WriteLineIndent(proxy + "& operator=(" + proxy + "&&) = delete;");

    // Generate proxy handlers
    if (p->body)
    {
        WriteLine();
        Indent(-1);
        WriteLineIndent("protected:");
        Indent(1);
        WriteLineIndent("// Proxy handlers");
        for (const auto& s : p->body->structs)
        {
            if (s->message)
            {
                std::string struct_model = "FBE::" + ConvertNamespace(*p->name) + "::" + *s->name + model;
                WriteLineIndent("virtual void onProxy(" + struct_model + "& model, size_t type, const void* data, size_t size) {}");
            }
        }
    }

    // Generate proxy message handler
    WriteLine();
    WriteLineIndent("// Receive message handler");
    WriteLineIndent("bool onReceive(size_t type, const void* data, size_t size) override;");

    // Generate proxy models accessors
    if (p->body)
    {
        Indent(-1);
        WriteLine();
        WriteLineIndent("private:");
        Indent(1);
        WriteLineIndent("// Proxy models accessors");
        for (const auto& s : p->body->structs)
            if (s->message)
                WriteLineIndent("FBE::" + ConvertNamespace(*p->name) + "::" + *s->name + model + " " + *s->name + "Model;");
    }

    // Generate proxy end
    Indent(-1);
    WriteLineIndent("};");
}

void GeneratorCpp::GenerateProxy_Source(const std::shared_ptr<Package>& p, bool final)
{
    std::string proxy = (final ? "FinalProxy" : "Proxy");
    std::string model = (final ? "FinalModel" : "Model");

    // Generate proxy message handler
    WriteLine();
    WriteLineIndent("bool " + proxy + "::onReceive(size_t type, const void* data, size_t size)");
    WriteLineIndent("{");
    Indent(1);
    if (p->body)
    {
        WriteLineIndent("switch (type)");
        WriteLineIndent("{");
        Indent(1);
        for (const auto& s : p->body->structs)
        {
            if (s->message)
            {
                std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
                WriteLineIndent("case FBE::" + ConvertNamespace(*p->name) + "::" + *s->name + model + "::fbe_type():");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("// Attach the FBE stream to the proxy model");
                WriteLineIndent(*s->name + "Model.attach(data, size);");
                WriteLineIndent("assert(" + *s->name + "Model.verify() && \"" + ConvertNamespace(*p->name) + "::" + *s->name + " validation failed!\");");
                WriteLine();
                WriteLineIndent("size_t fbe_begin = " + *s->name + "Model.model.get_begin();");
                WriteLineIndent("if (fbe_begin == 0)");
                Indent(1);
                WriteLineIndent("return false;");
                Indent(-1);
                WriteLineIndent("// Call proxy handler");
                WriteLineIndent("onProxy(" + *s->name + "Model, type, data, size);");
                WriteLineIndent(*s->name + "Model.model.get_end(fbe_begin);");
                WriteLineIndent("return true;");
                Indent(-1);
                WriteLineIndent("}");
            }
        }
        WriteLineIndent("default: break;");
        Indent(-1);
        WriteLineIndent("}");
    }
    if (p->import)
    {
        WriteLine();
        for (const auto& import : p->import->imports)
        {
            WriteLineIndent("if (" + *import + "::" + proxy + "::onReceive(type, data, size))");
            Indent(1);
            WriteLineIndent("return true;");
            Indent(-1);
        }
    }
    WriteLine();
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLineIndent("}");
}

void GeneratorCpp::GenerateClient_Header(const std::shared_ptr<Package>& p, bool final)
{
    std::string client = (final ? "FinalClient" : "Client");
    std::string sender = (final ? "FinalSender" : "Sender");
    std::string receiver = (final ? "FinalReceiver" : "Receiver");

    // Generate client begin
    WriteLine();
    if (final)
        WriteLineIndent("// Fast Binary Encoding " + *p->name + " final client");
    else
        WriteLineIndent("// Fast Binary Encoding " + *p->name + " client");
    WriteLineIndent("class " + client + " : public virtual " + sender + ", protected virtual " + receiver);
    if (p->import)
    {
        Indent(1);
        for (const auto& import : p->import->imports)
            WriteLineIndent(", public virtual " + *import + "::" + client);
        Indent(-1);
    }
    WriteLineIndent("{");
    WriteLineIndent("public:");
    if (p->import)
    {
        Indent(1);
        for (const auto& import : p->import->imports)
            WriteLineIndent("typedef " + *import + "::" + client + " " + *import + client + ";");
        Indent(-1);
        WriteLine();
    }
    Indent(1);

    // Generate client constructors
    WriteLineIndent(client + "() = default;");
    WriteLineIndent(client + "(const " + client + "&) = delete;");
    WriteLineIndent(client + "(" + client + "&&) = delete;");
    WriteLineIndent("virtual ~" + client + "() = default;");

    // Generate client operators
    WriteLine();
    WriteLineIndent(client + "& operator=(const " + client + "&) = delete;");
    WriteLineIndent(client + "& operator=(" + client + "&&) = delete;");

    // Generate imported clients accessors
    if (p->import)
    {
        WriteLine();
        WriteLineIndent("// Imported clients");
        for (const auto& import : p->import->imports)
            WriteLineIndent(*import + "::" + client + "& " + *import + "_client() noexcept { return *this; }");
    }

    // Generate client reset method
    WriteLine();
    WriteLineIndent("// Reset client buffers");
    WriteLineIndent("void reset() { std::scoped_lock locker(this->_lock); reset_requests(); }");

    // Generate watchdog method
    WriteLine();
    WriteLineIndent("// Watchdog for timeouts");
    WriteLineIndent("void watchdog(uint64_t utc) { std::scoped_lock locker(this->_lock); watchdog_requests(utc); }");

    // Collect responses & rejects collections
    std::set<std::string> responses;
    std::map<std::string, bool> rejects;
    if (p->body)
    {
        for (const auto& s : p->body->structs)
        {
            if (s->message && s->request)
            {
                std::string response_name = (s->response) ? ConvertTypeName(*p->name, *s->response->response, false) : "";

                if (!response_name.empty())
                {
                    // Update responses and rejects cache
                    responses.insert(*s->response->response);
                    if (s->rejects)
                        for (const auto& reject : s->rejects->rejects)
                            rejects[*reject.reject] = reject.global;
                }
            }
        }
    }

    // Generate request() methods
    if (p->body)
    {
        WriteLine();
        for (const auto& s : p->body->structs)
        {
            if (s->message && s->request)
            {
                std::string request_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
                std::string response_name = (s->response) ? ConvertTypeName(*p->name, *s->response->response, false) : "";
                std::string response_field = (s->response) ? *s->response->response : "";
                replace_all(response_field, ".", "");

                if (response_name.empty())
                    WriteLineIndent("std::future<void> request(const " + request_name + "& value, size_t timeout = 0);");
                else
                    WriteLineIndent("std::future<" + response_name + "> request(const " + request_name + "& value, size_t timeout = 0);");
            }
        }
    }

    // Generate client protected fields
    Indent(-1);
    WriteLine();
    WriteLineIndent("protected:");
    Indent(1);
    if (!p->import)
    {
        WriteLineIndent("std::mutex _lock;");
        WriteLineIndent("uint64_t _timestamp{0};");
        WriteLine();
    }

    // Generate response handlers
    for (const auto& response : responses)
    {
        std::string response_name = ConvertTypeName(*p->name, response, false);
        WriteLineIndent("virtual bool onReceiveResponse(const " + response_name + "& response);");
    }
    if (!responses.empty())
        WriteLine();

    // Generate remaining response handlers
    if (p->body)
    {
        bool found = false;
        std::set<std::string> cache;
        for (const auto& s : p->body->structs)
        {
            if (s->message)
            {
                std::string struct_response_name = ConvertTypeName(*p->name, *s->name, false);
                std::string struct_response_field = *s->name;

                if ((responses.find(*s->name) == responses.end()) && (cache.find(struct_response_name) == cache.end()))
                {
                    WriteLineIndent("virtual bool onReceiveResponse(const " + struct_response_name + "& response) { return false; }");
                    cache.insert(struct_response_name);
                    found = true;
                }
            }
        }
        if (found)
            WriteLine();
    }

    // Generate reject handlers
    for (const auto& reject : rejects)
    {
        std::string reject_name = ConvertTypeName(*p->name, reject.first, false);
        WriteLineIndent("virtual bool onReceiveReject(const " + reject_name + "& reject);");
    }
    if (!rejects.empty())
        WriteLine();

    // Generate remaining reject handlers
    if (p->body)
    {
        bool found = false;
        std::set<std::string> cache;
        for (const auto& s : p->body->structs)
        {
            if (s->message)
            {
                std::string struct_reject_name = ConvertTypeName(*p->name, *s->name, false);
                if ((rejects.find(*s->name) == rejects.end()) && (cache.find(struct_reject_name) == cache.end()))
                {
                    WriteLineIndent("virtual bool onReceiveReject(const " + struct_reject_name + "& reject) { return false; }");
                    cache.insert(struct_reject_name);
                    found = true;
                }
            }
        }
        if (found)
            WriteLine();
    }

    // Generate notify handlers
    if (p->body)
    {
        bool found = false;
        std::set<std::string> cache;
        for (const auto& s : p->body->structs)
        {
            if (s->message)
            {
                std::string struct_notify_name = ConvertTypeName(*p->name, *s->name, false);
                std::string struct_notify_field = *s->name;
                if (cache.find(struct_notify_name) == cache.end())
                {
                    WriteLineIndent("virtual void onReceiveNotify(const " + struct_notify_name + "& notify) {}");
                    cache.insert(struct_notify_name);
                    found = true;
                }
            }
        }
        if (found)
            WriteLine();
    }

    // Generate receive handlers
    if (p->body)
    {
        bool found = false;
        std::set<std::string> cache;
        for (const auto& s : p->body->structs)
        {
            if (s->message)
            {
                std::string struct_response_name = ConvertTypeName(*p->name, *s->name, false);
                std::string struct_response_field = *s->name;

                if (cache.find(struct_response_name) == cache.end())
                {
                    WriteLineIndent("virtual void onReceive(const " + struct_response_name + "& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }");
                    cache.insert(struct_response_name);
                    found = true;
                }
            }
        }
        if (found)
            WriteLine();
    }

    // Generate reset requests method
    WriteLineIndent("// Reset client requests");
    WriteLineIndent("virtual void reset_requests();");

    // Generate watchdog requests method
    WriteLine();
    WriteLineIndent("// Watchdog client requests for timeouts");
    WriteLineIndent("virtual void watchdog_requests(uint64_t utc);");

    // Generate client private fields
    if (!responses.empty())
    {
        Indent(-1);
        WriteLine();
        WriteLineIndent("private:");
        Indent(1);
        for (const auto& response : responses)
        {
            std::string response_name = ConvertTypeName(*p->name, response, false);
            std::string response_field = response;
            replace_all(response_field, ".", "");

            WriteLineIndent("std::unordered_map<FBE::uuid_t, std::tuple<uint64_t, uint64_t, std::promise<" + response_name + ">>> _requests_by_id_" + response_field + ";");
            WriteLineIndent("std::map<uint64_t, FBE::uuid_t> _requests_by_timestamp_" + response_field + ";");
        }
    }

    // Generate client end
    Indent(-1);
    WriteLineIndent("};");
}

void GeneratorCpp::GenerateClient_Source(const std::shared_ptr<Package>& p, bool final)
{
    std::string client = (final ? "FinalClient" : "Client");
    std::string sender = (final ? "FinalSender" : "Sender");

    // Collect responses & rejects collections
    std::set<std::string> responses;
    std::map<std::string, bool> rejects;
    if (p->body)
    {
        for (const auto& s : p->body->structs)
        {
            if (s->message && s->request)
            {
                std::string response_name = (s->response) ? ConvertTypeName(*p->name, *s->response->response, false) : "";

                if (!response_name.empty())
                {
                    // Update responses and rejects cache
                    responses.insert(*s->response->response);
                    if (s->rejects)
                        for (const auto& reject : s->rejects->rejects)
                            rejects[*reject.reject] = reject.global;
                }
            }
        }
    }

    // Generate request() methods
    if (p->body)
    {
        for (const auto& s : p->body->structs)
        {
            if (s->message && s->request)
            {
                std::string request_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
                std::string response_name = (s->response) ? ConvertTypeName(*p->name, *s->response->response, false) : "";
                std::string response_field = (s->response) ? *s->response->response : "";
                replace_all(response_field, ".", "");

                WriteLine();
                if (response_name.empty())
                {
                    WriteLineIndent("std::future<void> " + client + "::request(const " + request_name + "& value, size_t timeout)");
                    WriteLineIndent("{");
                    Indent(1);
                    WriteLineIndent("std::promise<void> promise;");
                    WriteLineIndent("std::future<void> future = promise.get_future();");
                    WriteLine();
                    WriteLineIndent("// Send the request message");
                    WriteLineIndent("size_t serialized = Sender::send(value);");
                    WriteLineIndent("if (serialized > 0)");
                    Indent(1);
                    WriteLineIndent("promise.set_value();");
                    Indent(-1);
                    WriteLineIndent("else");
                    Indent(1);
                    WriteLineIndent("promise.set_exception(std::make_exception_ptr(std::runtime_error(\"Send request failed!\")));");
                    Indent(-1);
                    WriteLine();
                    WriteLineIndent("return future;");
                    Indent(-1);
                    WriteLineIndent("}");
                }
                else
                {
                    WriteLineIndent("std::future<" + response_name + "> " + client + "::request(const " + request_name + "& value, size_t timeout)");
                    WriteLineIndent("{");
                    Indent(1);
                    WriteLineIndent("std::scoped_lock locker(this->_lock);");
                    WriteLine();
                    WriteLineIndent("std::promise<" + response_name + "> promise;");
                    WriteLineIndent("std::future<" + response_name + "> future = promise.get_future();");
                    WriteLine();
                    WriteLineIndent("uint64_t current = utc();");
                    WriteLine();
                    WriteLineIndent("// Send the request message");
                    WriteLineIndent("size_t serialized = Sender::send(value);");
                    WriteLineIndent("if (serialized > 0)");
                    WriteLineIndent("{");
                    Indent(1);
                    WriteLineIndent("// Calculate the unique timestamp");
                    WriteLineIndent("this->_timestamp = (current <= this->_timestamp) ? this->_timestamp + 1 : current;");
                    WriteLine();
                    WriteLineIndent("// Register the request");
                    WriteLineIndent("_requests_by_id_" + response_field + ".insert(std::make_pair(value.id, std::make_tuple(this->_timestamp, timeout * 1000000, std::move(promise))));");
                    WriteLineIndent("if (timeout > 0)");
                    Indent(1);
                    WriteLineIndent("_requests_by_timestamp_" + response_field + ".insert(std::make_pair(this->_timestamp, value.id));");
                    Indent(-1);
                    Indent(-1);
                    WriteLineIndent("}");
                    WriteLineIndent("else");
                    Indent(1);
                    WriteLineIndent("promise.set_exception(std::make_exception_ptr(std::runtime_error(\"Send request failed!\")));");
                    Indent(-1);
                    WriteLine();
                    WriteLineIndent("return future;");
                    Indent(-1);
                    WriteLineIndent("}");
                }
            }
        }
    }

    // Generate response handlers
    for (const auto& response : responses)
    {
        std::string response_name = ConvertTypeName(*p->name, response, false);
        std::string response_field = response;

        WriteLine();
        WriteLineIndent("bool " + client + "::onReceiveResponse(const " + response_name + "& response)");
        WriteLineIndent("{");
        Indent(1);
        if (p->body)
        {
            std::set<std::string> cache;
            WriteLineIndent("std::scoped_lock locker(this->_lock);");
            WriteLine();
            for (const auto& s : p->body->structs)
            {
                if (s->message && s->response)
                {
                    std::string struct_response_name = ConvertTypeName(*p->name, *s->response->response, false);
                    std::string struct_response_field = *s->response->response;
                    replace_all(struct_response_field, ".", "");

                    if ((struct_response_name == response_name) && (cache.find(struct_response_name) == cache.end()))
                    {
                        WriteLineIndent("auto it_" + struct_response_field + " = _requests_by_id_" + struct_response_field + ".find(response.id);");
                        WriteLineIndent("if (it_" + struct_response_field + " != _requests_by_id_" + struct_response_field + ".end())");
                        WriteLineIndent("{");
                        Indent(1);
                        WriteLineIndent("auto timestamp = std::get<0>(it_" + struct_response_field + "->second);");
                        WriteLineIndent("[[maybe_unused]] auto timespan = std::get<1>(it_" + struct_response_field + "->second);");
                        WriteLineIndent("auto& promise = std::get<2>(it_" + struct_response_field + "->second);");
                        WriteLineIndent("promise.set_value(response);");
                        WriteLineIndent("_requests_by_id_" + struct_response_field + ".erase(response.id);");
                        WriteLineIndent("_requests_by_timestamp_" + struct_response_field + ".erase(timestamp);");
                        WriteLineIndent("return true;");
                        cache.insert(struct_response_name);
                        Indent(-1);
                        WriteLineIndent("}");
                        WriteLine();
                    }
                }
            }
        }
        WriteLineIndent("return false;");
        Indent(-1);
        WriteLineIndent("}");
    }

    // Generate reject handlers
    for (const auto& reject : rejects)
    {
        std::string reject_name = ConvertTypeName(*p->name, reject.first, false);
        std::string reject_field = reject.first;
        bool global = reject.second;
        bool imported = replace_all(reject_field, ".", "");

        WriteLine();
        WriteLineIndent("bool " + client + "::onReceiveReject(const " + reject_name + "& reject)");
        WriteLineIndent("{");
        Indent(1);
        if (global)
        {
            if (p->import)
            {
                for (const auto& import : p->import->imports)
                {
                    WriteLineIndent("if (" + *import + client + "::onReceiveReject(reject))");
                    Indent(1);
                    WriteLineIndent("return true;");
                    Indent(-1);
                }
                WriteLine();
            }
        }
        else if (imported)
        {
            std::string ns = "";
            std::string t = reject.first;
            std::string type = reject.first;

            size_t pos = type.find_last_of('.');
            if (pos != std::string::npos)
            {
                ns.assign(type, 0, pos);
                t.assign(type, pos + 1, type.size() - pos);
            }

            WriteLineIndent("if (" + ns + client + "::onReceiveReject(reject))");
            Indent(1);
            WriteLineIndent("return true;");
            Indent(-1);
            WriteLine();
        }
        if (p->body)
        {
            std::set<std::string> cache;
            WriteLineIndent("std::scoped_lock locker(this->_lock);");
            WriteLine();
            for (const auto& s : p->body->structs)
            {
                if (s->message && s->response && s->rejects)
                {
                    for (const auto& r : s->rejects->rejects)
                    {
                        std::string struct_response_name = ConvertTypeName(*p->name, *s->response->response, false);
                        std::string struct_response_field = *s->response->response;
                        replace_all(struct_response_field, ".", "");

                        std::string struct_reject_name = ConvertTypeName(*p->name, *r.reject, false);
                        std::string struct_reject_field = *r.reject;
                        replace_all(struct_reject_field, ".", "");

                        if ((struct_reject_name == reject_name) && (cache.find(struct_response_field) == cache.end()))
                        {
                            WriteLineIndent("auto it_" + struct_response_field + " = _requests_by_id_" + struct_response_field + ".find(reject.id);");
                            WriteLineIndent("if (it_" + struct_response_field + " != _requests_by_id_" + struct_response_field + ".end())");
                            WriteLineIndent("{");
                            Indent(1);
                            WriteLineIndent("auto timestamp = std::get<0>(it_" + struct_response_field + "->second);");
                            WriteLineIndent("[[maybe_unused]] auto timespan = std::get<1>(it_" + struct_response_field + "->second);");
                            WriteLineIndent("auto& promise = std::get<2>(it_" + struct_response_field + "->second);");
                            WriteLineIndent("promise.set_exception(std::make_exception_ptr(std::runtime_error(reject.string())));");
                            WriteLineIndent("_requests_by_id_" + struct_response_field + ".erase(reject.id);");
                            WriteLineIndent("_requests_by_timestamp_" + struct_response_field + ".erase(timestamp);");
                            WriteLineIndent("return true;");
                            cache.insert(struct_response_field);
                            Indent(-1);
                            WriteLineIndent("}");
                            WriteLine();
                        }
                    }
                }
            }
        }
        WriteLineIndent("return false;");
        Indent(-1);
        WriteLineIndent("}");
    }

    // Generate reset requests method
    WriteLine();
    WriteLineIndent("void " + client + "::reset_requests()");
    WriteLineIndent("{");
    Indent(1);
    if (p->import)
    {
        for (const auto& import : p->import->imports)
            WriteLineIndent(*import + "::" + client + "::reset_requests();");
    }
    else
    {
        WriteLineIndent("Sender::reset();");
        WriteLineIndent("Receiver::reset();");
    }
    for (const auto& response : responses)
    {
        std::string response_name = ConvertTypeName(*p->name, response, false);
        std::string response_field = response;
        replace_all(response_field, ".", "");

        WriteLine();
        WriteLineIndent("for (auto& request : _requests_by_id_" + response_field + ")");
        Indent(1);
        WriteLineIndent("std::get<2>(request.second).set_exception(std::make_exception_ptr(std::runtime_error(\"Reset client!\")));");
        Indent(-1);
        WriteLineIndent("_requests_by_id_" + response_field + ".clear();");
        WriteLineIndent("_requests_by_timestamp_" + response_field + ".clear();");
    }
    Indent(-1);
    WriteLineIndent("}");

    // Generate watchdog requests method
    WriteLine();
    WriteLineIndent("void " + client + "::watchdog_requests(uint64_t utc)");
    WriteLineIndent("{");
    Indent(1);
    if (p->import)
    {
        for (const auto& import : p->import->imports)
            WriteLineIndent(*import + "::" + client + "::watchdog_requests(utc);");
        WriteLine();
    }
    for (const auto& response : responses)
    {
        std::string response_name = ConvertTypeName(*p->name, response, false);
        std::string response_field = response;
        replace_all(response_field, ".", "");

        WriteLineIndent("auto it_request_by_timestamp_" + response_field + " = _requests_by_timestamp_" + response_field + ".begin();");
        WriteLineIndent("while (it_request_by_timestamp_" + response_field + " != _requests_by_timestamp_" + response_field + ".end())");
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent("auto& it_request_by_id_" + response_field + " = _requests_by_id_" + response_field + "[it_request_by_timestamp_" + response_field + "->second];");
        WriteLineIndent("auto id = it_request_by_timestamp_" + response_field + "->second;");
        WriteLineIndent("auto timestamp = std::get<0>(it_request_by_id_" + response_field + ");");
        WriteLineIndent("auto timespan = std::get<1>(it_request_by_id_" + response_field + ");");
        WriteLineIndent("if ((timestamp + timespan) <= utc)");
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent("auto& promise = std::get<2>(it_request_by_id_" + response_field + ");");
        WriteLineIndent("promise.set_exception(std::make_exception_ptr(std::runtime_error(\"Timeout!\")));");
        WriteLineIndent("_requests_by_id_" + response_field + ".erase(id);");
        WriteLineIndent("_requests_by_timestamp_" + response_field + ".erase(timestamp);");
        WriteLineIndent("it_request_by_timestamp_" + response_field + " = _requests_by_timestamp_" + response_field + ".begin();");
        WriteLineIndent("continue;");
        Indent(-1);
        WriteLineIndent("}");
        WriteLineIndent("else");
        Indent(1);
        WriteLineIndent("break;");
        Indent(-1);
        Indent(-1);
        WriteLineIndent("}");
        WriteLine();
    }
    Indent(-1);
    WriteLineIndent("}");
}

void GeneratorCpp::GenerateFBEPtr_Header(const fs::path& path)
{
    // Create package path
    create_dir(path);

    // Generate the common file
    fs::path common = path / "fbe_ptr.h";
    WriteBegin();

    // Generate common header
    GenerateHeader("FBE");

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");

    std::string code = R"CODE(
struct Base
{
    virtual ~Base() = default;
};
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate common footer
    GenerateFooter();

    // Store the common file
    WriteEnd();
    Store(common);
}

void GeneratorCpp::GenerateFBEBaseFieldModel_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEBaseFieldModel_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelStructOptional_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelStructOptional_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelStructOptional_Inline()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelStructOptional_Inline();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelCustomArray_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelCustomArray_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelCustomArray_Inline()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelCustomArray_Inline();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());


    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelCustomVector_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelCustomVector_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelCustomVector_Inline()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelCustomVector_Inline();
    
    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelCustomMap_Header()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelCustomMap_Header();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelCustomMap_Inline()
{
    std::string code = GeneratorCPPFixture::GenerateFBEFieldModelCustomMap_Inline();

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorCpp::GenerateFBECustomModels_Header(const fs::path& path)
{
    // Create package path
    create_dir(path);

    // Generate the field models file
    fs::path common = path / "fbe_custom_models.h";
    WriteBegin();

    // Generate field models header
    GenerateHeader("FBE");

    // Generate imports
    GenerateImports("fbe_models.h");
    GenerateImports("fbe_ptr.h");

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");

    // Generate field models
    GenerateFBEBaseFieldModel_Header();
    GenerateFBEFieldModelCustomArray_Header();
    GenerateFBEFieldModelCustomVector_Header();
    GenerateFBEFieldModelCustomMap_Header();
    GenerateFBEFieldModelStructOptional_Header();

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate inline import
    GenerateImports("fbe_custom_models.inl");

    // Generate field models footer
    GenerateFooter();

    // Store the field models file
    WriteEnd();
    Store(common);
}

void GeneratorCpp::GenerateFBECustomModels_Inline(const fs::path& path)
{
    // Create package path
    create_dir(path);

    // Generate the field models file
    fs::path common = path / "fbe_custom_models.inl";
    WriteBegin();

    // Generate field models inline
    GenerateInline("FBE");

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");

    // Generate field models
    GenerateFBEFieldModelCustomArray_Inline();
    GenerateFBEFieldModelCustomVector_Inline();
    GenerateFBEFieldModelCustomMap_Inline();
    GenerateFBEFieldModelStructOptional_Inline();

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate field models footer
    GenerateFooter();

    // Store the field models file
    WriteEnd();
    Store(common);
}

void GeneratorCpp::GeneratePtrPackage_Header(const std::shared_ptr<Package>& p)
{
    fs::path output = _output;

    // Create package path
    create_dir(output);

    // Generate the output file
    output /= ConvertFileName(*p->name, FileType::Struct, true, true);
    WriteBegin();

    // Generate package header
    GenerateHeader(fs::path(_input).filename().string());

    // Generate imports
    GenerateImports(p);
    GenerateImports("fbe_ptr.h");

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

    // Generate namespace body
    if (p->body)
    {
        // Generate child enums
        for (const auto& e : p->body->enums)
            GenerateEnum(p, e);

        // Generate child flags
        for (const auto& f : p->body->flags)
            GenerateFlags(p, f);

        if (!p->body->variants.empty()) {
            // forward declarations
            GeneratorStructForwardDeclaration(p->body->structs);
            for (const auto& v : p->body->variants)
            {
                GenerateVariantAlias(p, v);
            }
        }

        // Generate child structs
        for (const auto& s : p->body->structs)
            GeneratePtrStruct_Header(p, s);
    }

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));

    // Generate package footer
    GenerateFooter();

    // Store the output file
    WriteEnd();
    Store(output);
}

void GeneratorCpp::GeneratePtrPackage_Source(const std::shared_ptr<Package>& p)
{
    fs::path output = _output;

    // Create package path
    create_dir(output);

    // Generate the output file
    output /= ConvertFileName(*p->name, FileType::Struct, false, true);
    WriteBegin();

    // Generate package source
    GenerateSource(fs::path(_input).filename().string());

    // Generate imports
    GenerateImports(ConvertFileName(*p->name, FileType::Struct, true, true));


    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

    // Generate namespace body
    if (p->body)
    {
        // Generate child enums
        for (const auto& e : p->body->enums)
        {
            // Generate enum output stream
            GenerateEnumOutputStream(e);

            // Generate enum logging stream
            if (Logging())
                GenerateEnumLoggingStream(e);
        }

        // Generate child flags
        for (const auto& f : p->body->flags)
        {
            // Generate flags output stream
            GenerateFlagsOutputStream(f);

            // Generate flags logging stream
            if (Logging())
                GenerateFlagsLoggingStream(f);
        }

        if (!p->body->variants.empty()) {
            for (const auto& v : p->body->variants)
            {
                GenerateVariantIsEqualFunc(p, v);
                GenerateVariantOutputStream(p, v);
            }
        }

        // Generate child structs
        for (const auto& s : p->body->structs)
        {
            GeneratePtrStruct_Source(p, s);

            // Generate struct output stream
            GenerateStructOutputStream(p, s);

            // Generate struct logging stream
            if (Logging())
                GenerateStructLoggingStream(p, s);
        }
    }

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));

    // Generate package footer
    GenerateFooter();

    // Store the output file
    WriteEnd();
    Store(output);
}

void GeneratorCpp::GeneratePtrPackageModels_Header(const std::shared_ptr<Package>& p)
{
    fs::path output = _output;

    // Create package path
    create_dir(output);

    // Generate the output file
    output /= ConvertFileName(*p->name, FileType::Model, true, true);
    WriteBegin();

    // Generate package models header
    GenerateHeader(fs::path(_input).filename().string());

    // Generate imports
    GenerateImports("fbe_custom_models.h");
    GenerateImportsModels(p, false, true);

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");

    // Generate namespace body
    if (p->body)
    {
        // Generate child enums
        for (const auto& e : p->body->enums)
        {
            // Generate enum field model
            GenerateEnumFieldModel(p, e);
        }

        // Generate child flags
        for (const auto& f : p->body->flags)
        {
            // Generate flags field model
            GenerateFlagsFieldModel(p, f);
        }

        // Generate variant
        for(const auto& v : p->body->variants) {
            GenerateVariantFieldModel_Header(p, v);
        }

        // Generate child ptr structs
        for (const auto& s : p->body->structs)
        {
            // Generate struct ptr field models
            GenerateStructFieldPtrModel_Header(p, s);
        }

        // Generate child structs
        for (const auto& s : p->body->structs)
        {
            GeneratePtrStructFieldModel_Header(p, s);
            GeneratePtrStructModel_Header(p, s);
        }
    }

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate package footer
    GenerateFooter();

    // Store the output file
    WriteEnd();
    Store(output);
}

void GeneratorCpp::GeneratePtrPackageModels_Source(const std::shared_ptr<Package>& p)
{
    fs::path output = _output;

    // Create package path
    create_dir(output);

    // Generate the output file
    output /= ConvertFileName(*p->name, FileType::Model, false, true);
    WriteBegin();

    // Generate package models source
    GenerateSource(fs::path(_input).filename().string());

    // Generate imports
    GenerateImports(ConvertFileName(*p->name, FileType::Model, true, true));

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace FBE {");

    // Generate namespace body
    if (p->body)
    {
        // Generate variant
        for(const auto& v : p->body->variants) {
            GenerateVariantFieldModel_Source(p, v);
        }

        // Generate child structs
        for (const auto& s : p->body->structs)
        {
            // Generate struct field models
            GenerateStructFieldPtrModel_Source(p, s);
            GeneratePtrStructFieldModel_Source(p, s);
            GeneratePtrStructModel_Source(p, s);
        }
    }

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace FBE");

    // Generate package footer
    GenerateFooter();

    // Store the output file
    WriteEnd();
    Store(output);
}

void GeneratorCpp::GeneratePtrStruct_Header(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    // Generate struct response forward declaration
    if (s->response)
    {
        std::string response = *s->response->response;
        bool imported = replace_all(response, ".", "");
        if (!imported)
        {
            WriteLine();
            WriteLineIndent("struct " + response + ";");
        }
    }

    // Generate struct forward declaration if has ptr field;
    if (s->body)
    {
        std::set<std::string> unique_type_set;
        for (const auto& field : s->body->fields)
        {
            if (field->ptr)
            {
                if (!IsCurrentPackageType(*field->type) || IsKnownType(*field->type) || *field->type == *s->name) {
                    continue;
                }
                if (unique_type_set.find(*field->type) != unique_type_set.end()) {
                    continue;
                } else {
                    if (IsVariantType(p, *field->type))
                        continue;
                    WriteLine();
                    WriteLineIndent("struct " + *field->type + ";");
                    unique_type_set.insert(*field->type);
                }
            }
        }
    }


    // Generate struct begin
    WriteLine();
    WriteIndent("struct " + std::string(s->attributes->deprecated ? "[[deprecated]] " : "") + *s->name);
    if (s->base && !s->base->empty()) {
        Write(" : public " + ConvertPtrTypeName(*p->name, *s->base));
    } else {
        Write(" : FBE::Base");
    }
    WriteLine();
    WriteLineIndent("{");
    Indent(1);

    // Generate struct response type definition
    if (s->response)
    {
        std::string response = *s->response->response;
        replace_all(response, ".", "::");
        WriteLineIndent("typedef " + response + " Response;");
        if (s->body && !s->body->fields.empty())
            WriteLine();
    }

    // Generate struct body
    if (Arena())
    {
        for(auto &tag: ArenaTags()){
            WriteLineIndent(tag + ";");
        }
        WriteLine();
    }


    // Generate data member
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteIndent();
            if (field->attributes && field->attributes->deprecated)
                Write("[[deprecated]] ");
            WriteLine(ConvertPtrTypeName(*p->name, *field, false) + " " + *field->name + ";");
        }
        if (!s->body->fields.empty())
            WriteLine();
    }

    // Generate struct FBE type property
    if (s->base && !s->base->empty() && (s->type == 0))
        WriteLineIndent("size_t fbe_type() const noexcept { return " + ConvertPtrTypeName(*p->name, *s->base) + "::fbe_type(); }");
    else
        WriteLineIndent("size_t fbe_type() const noexcept { return " + std::to_string(s->type) + "; }");

    // Generate struct default constructor
    bool first = true;
    WriteLine();
    WriteLineIndent(*s->name + "();");

    // Generate cstr with Arena
    if (Arena()) {
        WriteLineIndent("explicit " + *s->name + "(allocator_type alloc);");
    }

    // Generate struct initialization constructor
    if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty()))
    {
        first = true;
        size_t args = 0;
        if (s->base && !s->base->empty())
            ++args;
        if (s->body && !s->body->fields.empty())
            args += s->body->fields.size();
        WriteIndent(((args <= 1) ? "explicit " : "") + *s->name + "(");
        if (s->base && !s->base->empty())
        {
            Write("const " + ConvertPtrTypeName(*p->name, *s->base) + "& base");
            first = false;
        }
        if (s->body)
        {
            for (const auto& field : s->body->fields)
            {
                Write(std::string(first ? "" : ", ") + ConvertPtrTypeNameAsArgument(*p->name, *field) + " arg_" + *field->name);
                first = false;
            }
        }
        WriteLine(");");
    }

    // copy constructor
    WriteLineIndent(*s->name + "(const " + *s->name + "& other) = default;");
    // move constructor
    WriteLineIndent(*s->name + "(" + *s->name + "&& other) noexcept;");
    // destructor
    WriteLineIndent("~" + *s->name + "() override;");
    WriteLine();
    // copy assignment operator
    WriteLineIndent(*s->name + "& operator=(const " + *s->name + "& other) = default;");
    // move assignment operator
    WriteLineIndent(*s->name + "& operator=(" + *s->name + "&& other) noexcept;");

    // Generate struct compare operators
    WriteLine();
    WriteLineIndent("bool operator==(const " + *s->name + "& other) const noexcept;");
    WriteLineIndent("bool operator!=(const " + *s->name + "& other) const noexcept { return !operator==(other); }");
    WriteLineIndent("bool operator<(const " + *s->name + "& other) const noexcept;");
    WriteLineIndent("bool operator<=(const " + *s->name + "& other) const noexcept { return operator<(other) || operator==(other); }");
    WriteLineIndent("bool operator>(const " + *s->name + "& other) const noexcept { return !operator<=(other); }");
    WriteLineIndent("bool operator>=(const " + *s->name + "& other) const noexcept { return !operator<(other); }");

    // Generate struct string convert
    WriteLine();
    WriteLineIndent("std::string string() const;");

    // Generate struct output stream operator
    WriteLine();
    WriteLineIndent("friend std::ostream& operator<<(std::ostream& stream, const " + *s->name + "& value);");

    // Generate struct output stream operator
    if (Logging())
    {
        WriteLine();
        WriteLineIndent("#if defined(LOGGING_PROTOCOL)");
        WriteLineIndent("friend CppLogging::Record& operator<<(CppLogging::Record& record, const " + *s->name + "& value);");
        WriteLineIndent("#endif");
    }

    // Generate struct swap methods
    WriteLine();
    WriteLineIndent("void swap(" + *s->name + "& other) noexcept;");
    WriteLineIndent("friend void swap(" + *s->name + "& value1, " + *s->name + "& value2) noexcept { value1.swap(value2); }");

    // Generate struct end
    Indent(-1);
    WriteLineIndent("};");

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));

    // Generate struct hash
    GenerateStructHash(p, s);

    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");
}

void GeneratorCpp::GeneratePtrStruct_Source(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    WriteLine();

    // Generate struct default constructor
    bool first = true;
    WriteLineIndent(*s->name + "::" + *s->name + "()");
    Indent(1);
    if (s->base && !s->base->empty())
    {
        WriteLineIndent(": " + ConvertPtrTypeName(*p->name, *s->base) + "()");
        first = false;
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteIndent();
            Write(std::string(first ? ": " : ", ") + *field->name + "(");
            if (field->ptr && !IsContainerType(*field)) {
                Write("nullptr");
            } else if (field->value || IsPrimitiveType(*field->type, field->optional)) {
                Write(ConvertDefault(*p->name, *field));
            }
            Write(")");
            WriteLine();
            first = false;
        }
    }
    Indent(-1);
    WriteLineIndent("{}");

    // Generate struct constructor with arena
    if (Arena()) {
        first = true;
        WriteLine();
        WriteLineIndent(*s->name + "::" + *s->name + "([[maybe_unused]] allocator_type alloc)");
        Indent(1);
        if (s->base && !s->base->empty())
        {
            WriteLineIndent(": " + ConvertPtrTypeName(*p->name, *s->base) + "()");
            first = false;
        }
        if (s->body)
        {
            auto enums = p->body->enums;
            auto flags = p->body->flags;
            for (const auto& field : s->body->fields)
            {
                WriteIndent();
                Write(std::string(first ? ": " : ", ") + *field->name + "(");
                // priority: container > optional > imported type > ptr > bytes/string/primitive type/custom type > variant
                if (IsContainerType(*field)) {
                    Write(field->array ? "" : "alloc");
                } else if (field->optional) {
                    Write("std::nullopt");
                } else if (field->ptr) {
                    Write("nullptr");
                } else if (!IsCurrentPackageType(*field->type)) {
                    Write(std::string("assign_member<") + ConvertTypeName(*p->name, *field) + ">(alloc)");
                } else if (*field->type == "bytes" || *field->type == "string") {
                    Write("alloc");
                } else if (field->value || IsPrimitiveType(*field->type, field->optional)) {
                    Write(ConvertDefault(*p->name, *field));
                // only struct(no optional or enum) should be initialized with arena
                } else if (*field->type != "uuid" && *field->type != "decimal" && !IsVariantType(p, *field->type) && std::find_if(enums.begin(), enums.end(),
                 [t = *field->type](const std::shared_ptr<EnumType>& e) -> bool { 
                     return *e->name == t; }) == enums.end() && std::find_if(flags.begin(), flags.end(),
                 [t = *field->type](const std::shared_ptr<FlagsType>& e) -> bool { 
                     return *e->name == t; }) == flags.end()) {
                    Write("alloc");
                }
                Write(")");
                WriteLine();
                first = false;
            }
        }
        Indent(-1);
        WriteLineIndent("{}");
    }

    std::vector<std::string> unique_ptr_members;
    std::vector<std::shared_ptr<StructField>> collection_of_container_ptrs;
    std::vector<std::shared_ptr<StructField>> collection_of_optional_fields;
    // Generate struct initialization constructor
    if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty()))
    {
        first = true;
        WriteLine();
        WriteIndent(*s->name + "::" + *s->name + "(");
        if (s->base && !s->base->empty())
        {
            Write("const " + ConvertPtrTypeName(*p->name, *s->base) + "& base");
            first = false;
        }
        if (s->body)
        {
            for (const auto& field : s->body->fields)
            {
                Write(std::string(first ? "" : ", ") + ConvertPtrTypeNameAsArgument(*p->name, *field) + " arg_" + *field->name);
                first = false;
            }
        }
        WriteLine(")");
        Indent(1);
        first = true;
        if (s->base && !s->base->empty())
        {
            WriteLineIndent(": " + ConvertPtrTypeName(*p->name, *s->base) + "(base)");
            first = false;
        }
        if (s->body)
        {
            for (const auto& field : s->body->fields)
            {
                // 对于指针类型，非容器可以直接处理，容器则需要在body中逐个释放
                if (field->ptr) {
                    if (IsContainerType(*field)) {
                        collection_of_container_ptrs.push_back(field);
                        WriteLineIndent(std::string(first ? ": " : ", ") + *field->name + "()");
                    }
                    else {
                        unique_ptr_members.push_back(*field->name);
                        WriteLineIndent(std::string(first ? ": " : ", ") + *field->name + "(arg_" + *field->name + ".release())");
                    }
                } else if (IsKnownType(*field->type)) {
                    WriteLineIndent(std::string(first ? ": " : ", ") + *field->name + "(arg_" + *field->name + ")");
                } else if (field->optional) {
                    collection_of_optional_fields.push_back(field);
                    WriteLineIndent(std::string(first ? ": " : ", ") + *field->name + "()");
                } else {
                    WriteLineIndent(std::string(first ? ": " : ", ") + *field->name + "(std::move(arg_" + *field->name + "))");
                }
                first = false;
            }
        }
        Indent(-1);
        if (collection_of_container_ptrs.empty() && collection_of_optional_fields.empty()) {
            WriteLineIndent("{}");
        } else {
                WriteLineIndent("{");
                Indent(1);
                for (const auto& field : collection_of_container_ptrs) {
                    if (field->map || field->hash) {
                        WriteLineIndent("for (auto& it: arg_" + *field->name + ")");
                        Indent(1);
                        WriteLineIndent(*field->name + ".emplace(it.first, it.second.release());");
                        Indent(-1);
                    } else if (field->vector) {
                        WriteLineIndent(*field->name + ".reserve(arg_" + *field->name + ".size());");
                        WriteLineIndent("for (auto& it : arg_" + *field->name + ")");
                        Indent(1);
                        // #if defined(USING_STD_VECTOR)
                        // values.emplace_back(std::move(value));
                        // #else
                        // values.template emplace_back<Safety::Unsafe>(std::move(value));
                        // #endif
                        WriteLineIndent("#if defined(USING_STD_VECTOR)");
                        WriteLineIndent(*field->name + ".emplace_back(it.release());");
                        WriteLineIndent("#else");
                        WriteLineIndent(*field->name + ".emplace_back" + (Arena() ? "" : "<Safety::Unsafe>") + "(it.release());");
                        WriteLineIndent("#endif");
                        Indent(-1);
                    } else if (field->list) {
                        WriteLineIndent("for (auto& it : arg_" + *field->name + ")");
                        Indent(1);
                        WriteLineIndent(*field->name + ".emplace_back(it.release());");
                        Indent(-1);
                    } else if (field->array) {
                        WriteLineIndent("for (uint32_t i = 0 ; i < " + std::to_string(field->N) + "; ++i)");
                        Indent(1);
                        WriteLineIndent(*field->name + "[i] = arg_" + *field->name + "[i].release();");
                        Indent(-1);
                    }
                }
                for (const auto&field : collection_of_optional_fields) {
                    WriteLineIndent("if (arg_" + *field->name + ".has_value()) {");
                    Indent(1);
                    WriteLineIndent(*field->name + ".emplace(std::move(arg_" + *field->name + ".value()));");
                    WriteLineIndent("arg_" + *field->name + ".reset();");
                    Indent(-1);
                    WriteLineIndent("}");
                }
                Indent(-1);
                WriteLineIndent("}");
        }
    }

    // Generate struct move constructor
    collection_of_optional_fields.clear();

    WriteLine();
    WriteLineIndent(*s->name + "::" + *s->name + "([[maybe_unused]] " + *s->name + "&& other) noexcept");
    Indent(1);
    // generate the base move
    first = true;
    if (s->base && !s->base->empty())
    {
        WriteLineIndent(": "+ ConvertPtrTypeName(*p->name, *s->base) + "(std::move(other))");
        first = false;
    }
    // generate the field move
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            if (IsContainerType(*field)) {
                WriteLineIndent(std::string(first ? ": " : ", ") + *field->name + "(std::move(other." + *field->name + "))");
            } else if (field->ptr) {
                WriteLineIndent(std::string(first ? ": " : ", ") + *field->name + "(std::exchange(other." + *field->name + ", nullptr))");
            } else if (field->optional) {
                collection_of_optional_fields.push_back(field);
                WriteLineIndent(std::string(first ? ": " : ", ") + *field->name + "()");
            } else if (IsPrimitiveType(*field->type, field->optional)) {
                WriteLineIndent(std::string(first ? ": " : ", ") + *field->name + "(std::exchange(other." + *field->name + ", " + ConvertDefault(*p->name, *field) + "))");
            } else {
                WriteLineIndent(std::string(first ? ": " : ", ") + *field->name + "(std::move(other." + *field->name + "))");
            }
            first = false;
        }
    }
    Indent(-1);
    if (collection_of_optional_fields.empty()) {
        WriteLineIndent("{}");
    } else {
        WriteLineIndent("{");
        Indent(1);
        for (const auto&field : collection_of_optional_fields) {
            WriteLineIndent("if (other." + *field->name + ".has_value()) {");
            Indent(1);
            if (IsPrimitiveType(*field->type, false)) {
                WriteLineIndent(*field->name + ".emplace(other." + *field->name + ".value());");
            } else {
                WriteLineIndent(*field->name + ".emplace(std::move(other." + *field->name + ".value()));");
            }
            WriteLineIndent("other." + *field->name + ".reset();");
            Indent(-1);
            WriteLineIndent("}");
        }
        Indent(-1);
        WriteLineIndent("}");
    }


    WriteLine();
    WriteLineIndent(*s->name + "::~" + *s->name + "()");
    WriteLine("{");
    // destructor
    if (!unique_ptr_members.empty() || !collection_of_container_ptrs.empty()) {

        Indent(1);
        for (const auto& field : unique_ptr_members) {
            WriteLineIndent("if (" + field + ") delete " + field + ";");
        }
        for (const auto& field : collection_of_container_ptrs) {
            if (field->map || field->hash) {
                WriteLineIndent("for (auto& it: " + *field->name + ")");
                Indent(1);
                WriteLineIndent("delete it.second;");
                Indent(-1);
            } else if (field->vector || field->list) {
                WriteLineIndent("for (auto* it : " + *field->name + ")");
                Indent(1);
                WriteLineIndent("delete it;");
                Indent(-1);
            } else if (field->array) {
                WriteLineIndent("for (uint32_t i = 0 ; i < " + std::to_string(field->N) + "; ++i)");
                Indent(1);
                WriteLineIndent(std::string("delete ") + *field->name + "[i];");
                Indent(-1);
            }
        }
        Indent(-1);
    }
    WriteLine("}");

    // Generate struct compare operators
    WriteLine();
    WriteLineIndent("bool " + *s->name + "::operator==([[maybe_unused]] const " + *s->name + "& other) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    if (s->base && !s->base->empty())
    {
        WriteLineIndent("if (" + ConvertPtrTypeName(*p->name, *s->base) + "::operator!=(other))");
        Indent(1);
        WriteLineIndent("return false;");
        Indent(-1);
    }
    if (s->body)
    {
        // disable `key` attribute feature
        // priority: container > ptr = variant > other
        for (const auto& field : s->body->fields)
        {
            auto field_name = *field->name;
            auto other_field_name = "other." + field_name;
            if (IsContainerType(*field)) {
                // container type can be ptr，struct, or variant.
                WriteLineIndent("// compare container " + field_name);
                if (!field->ptr && !IsVariantType(p, *field->type)) {
                    // If the element is a variant type which may be a ptr, it can lead to false-positive equality.
                    // It's hard to figure out the details of variants because of the lack of context.
                    WriteLineIndent("if (" + field_name + " != " + other_field_name + ")");
                    Indent(1);
                    WriteLineIndent("return false;");
                    Indent(-1);
                    continue;
                }
                // first compare size
                WriteLineIndent("if (" + field_name + ".size() != " + other_field_name + ".size())");
                Indent(1);
                WriteLineIndent("return false;");
                Indent(-1);
                if (field->vector || field->array) {
                    // each element in lhs compares equal with element in rhs at the same position
                    WriteLineIndent("for (size_t i = 0; i < " + field_name + ".size(); i++)");
                    WriteLineIndent("{");
                    Indent(1);
                    if (field->ptr) {
                        WriteLineIndent("if (*" + field_name +"[i] != *" + other_field_name + "[i])");
                    } else {
                        WriteLineIndent("if (!is_equal(" + field_name +"[i], " + other_field_name + "[i]))");
                    }
                    Indent(1);
                    WriteLineIndent("return false;");
                    Indent(-1);
                    Indent(-1);
                    WriteLineIndent("}");
                } else if (field->list) {
                    WriteLineIndent("// compare list");
                    WriteLineIndent("for (auto l_iter = " + field_name + ".begin(), r_iter = " + other_field_name + ".begin(); r_iter != " + other_field_name + ".end(); l_iter++, r_iter++) {");
                    Indent(1);
                    if (field->ptr) {
                        WriteLineIndent("if (**l_iter != **r_iter)");
                    } else {
                        WriteLineIndent("if (!is_equal(*l_iter, *r_iter))");
                    }
                    Indent(1);
                    WriteLineIndent("return false;");
                    Indent(-1);
                    Indent(-1);
                    WriteLineIndent("}");
                } else if (field->map || field->hash) {
                    // each element in lhs compares equal with element in rhs at the same position
                    WriteLineIndent("for (auto & [k, v]: " + field_name + ")");
                    WriteLineIndent("{");
                    Indent(1);
                    WriteLineIndent("if (auto pos = " + other_field_name + ".find(k); pos == " + other_field_name + ".end())");
                    Indent(1);
                    WriteLineIndent("return false;");
                    Indent(-1);
                    if (field->ptr) {
                        WriteLineIndent("if (auto other_v = " + other_field_name + ".at(k); *other_v != *v)");
                    } else {
                        WriteLineIndent("if (auto other_v = " + other_field_name + ".at(k); !is_equal(other_v, v))");
                    }
                    Indent(1);
                    WriteLineIndent("return false;");
                    Indent(-1);
                    Indent(-1);
                    WriteLineIndent("}");
                } else {
                    static_assert(true, "unreached condition");
                }
            } else if (field->ptr) {
                WriteLineIndent("// compare ptr " + field_name);
                std::string condition1 = "(" + field_name + "  == nullptr && " + other_field_name + "  != nullptr)";
                std::string condition2 = "(" + field_name + "  != nullptr && " + other_field_name + "  == nullptr)";
                std::string condition3 = "(" + field_name + "  != nullptr && " + other_field_name + "  != nullptr && *" + field_name + " != *" + other_field_name + ")";
                WriteLineIndent("if (" + condition1 + " || " + condition2 + " || " + condition3 + ")");
                Indent(1);
                WriteLineIndent("return false;");
                Indent(-1);
            } else if (IsVariantType(p, *field->type)) {
                WriteLineIndent("// compare variant " + field_name);
                if (field->optional) {
                    std::string condition1 = "(" + field_name + ".has_value() && !" + other_field_name + ".has_value())";
                    std::string condition2 = "(!" + field_name + ".has_value() && " + other_field_name + ".has_value())";
                    std::string condition3 = "(" + field_name + ".has_value() && " + other_field_name + ".has_value() && !is_equal(" + field_name + ".value(), " + other_field_name + ".value()))";
                    WriteLineIndent("if (" + condition1 + " || " + condition2 + " || " + condition3 + ")");
                } else {
                    WriteLineIndent("if (!is_equal(" + field_name + ", " + other_field_name + "))");
                }
                Indent(1);
                WriteLineIndent("return false;");
                Indent(-1);
            } else {
                // optional, struct, variant(imported), enum, flags and other primitive types
                WriteLineIndent("if (" + field_name + " != " + other_field_name + ")");
                Indent(1);
                WriteLineIndent("return false;");
                Indent(-1);
            }
        }
    }
    WriteLineIndent("return true;");

    Indent(-1);
    WriteLineIndent("}");

    WriteLine();
    WriteLineIndent("bool " + *s->name + "::operator<([[maybe_unused]] const " + *s->name + "& other) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    if (s->base && !s->base->empty())
    {
        WriteLineIndent("if (" + ConvertPtrTypeName(*p->name, *s->base) + "::operator<(other))");
        Indent(1);
        WriteLineIndent("return true;");
        Indent(-1);
        WriteLineIndent("if (other." + ConvertPtrTypeName(*p->name, *s->base) + "::operator<(*this))");
        Indent(1);
        WriteLineIndent("return false;");
        Indent(-1);
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            if (field->keys)
            {
                WriteLineIndent("if (" + *field->name + " < other." + *field->name + ")");
                Indent(1);
                WriteLineIndent("return true;");
                Indent(-1);
                WriteLineIndent("if (other." + *field->name + " < " + *field->name + ")");
                Indent(1);
                WriteLineIndent("return false;");
                Indent(-1);
            }
        }
    }
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLineIndent("}");


    // Generate struct move assignment operator
    WriteLine();
    WriteLineIndent(*s->name + "& " + *s->name + "::operator=(" + *s->name + "&& other) noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if (this != &other)");
    WriteLineIndent("{");
    Indent(1);
    // generate the base move
    if (s->base && !s->base->empty())
    {
        WriteLineIndent("Base::operator = (std::move(other))");
    }
    // generate the field move
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            if (IsContainerType(*field)) {
                WriteLineIndent(*field->name + " = std::move(other." + *field->name + ");");
            } else if (field->ptr) {
                WriteLineIndent(*field->name + " = std::exchange(other." + *field->name + ", nullptr);");
            } else if (field->optional) {
                WriteLineIndent("if (other." + *field->name + ".has_value()) {");
                Indent(1);
                if (IsPrimitiveType(*field->type, false)) {
                    WriteLineIndent(*field->name + ".emplace(other." + *field->name + ".value());");
                } else {
                    WriteLineIndent(*field->name + ".emplace(std::move(other." + *field->name + ".value()));");
                }
                WriteLineIndent("other." + *field->name + ".reset();");
                Indent(-1);
                WriteLineIndent("}");
            } else if (IsPrimitiveType(*field->type, field->optional)) {
                WriteLineIndent(*field->name + " = std::exchange(other." + *field->name + ", " + ConvertDefault(*p->name, *field) + ");");

            } else {
                WriteLineIndent(*field->name + " = std::move(other." + *field->name + ");");
            }
            first = false;
        }
    }
    Indent(-1);
    WriteLineIndent("}");
    WriteLineIndent("return *this;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct string method
    WriteLine();
    WriteLineIndent("std::string " + *s->name + "::string() const");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("std::stringstream ss; ss << *this; return ss.str();");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct swap method
    WriteLine();
    WriteLineIndent("void " + *s->name + "::swap([[maybe_unused]] " + *s->name + "& other) noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("using std::swap;");
    if (s->base && !s->base->empty())
        WriteLineIndent(ConvertPtrTypeName(*p->name, *s->base) + "::swap(other);");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("swap(" + *field->name + ", other." + *field->name + ");");
    Indent(-1);
    WriteLineIndent("}");
}

void GeneratorCpp::GenerateVariantIsEqualFunc(const std::shared_ptr<Package>& p, const std::shared_ptr<VariantType>& v)
{
    WriteLine();
    WriteLineIndent("auto is_equal(const " + *v->name + "& lhs" + ", const " + *v->name + "& rhs) -> bool {");
    Indent(1);
    WriteLineIndent("if (lhs.index() != rhs.index())");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLineIndent("switch (lhs.index()) {");
    Indent(1);
    for (size_t index = 0; index < v->body->values.size(); index++) {
        WriteLineIndent("case " + std::to_string(index) + ": {");
        Indent(1);
        auto v_value = v->body->values[index];
        auto is_v_value_variant = IsVariantType(p, *v_value->type);
        auto get_lhs_code = "std::get<" + std::to_string(index) + ">(lhs)";
        auto get_rhs_code = "std::get<" + std::to_string(index) + ">(rhs)";
        if (v_value-> vector) {
            WriteLineIndent("auto& lhs_value = " + get_lhs_code + ";");
            WriteLineIndent("auto& rhs_value = " + get_rhs_code + ";");
            WriteLineIndent("if (lhs_value.size() != rhs_value.size())");
            Indent(1);
            WriteLineIndent("return false;");
            Indent(-1);
            WriteLineIndent("for (size_t i = 0; i < lhs_value.size(); i++)");
            WriteLineIndent("{");
            Indent(1);
            if (v_value->ptr) {
                WriteLineIndent("if (*lhs_value[i] != *rhs_value[i])");
            } else if (is_v_value_variant) {
                WriteLineIndent("if (!is_equal(lhs_value[i], rhs_value[i]))");
            } else {
                WriteLineIndent("if (lhs_value[i] != rhs_value[i])");
            }
            Indent(1);
            WriteLineIndent("return false;");
            Indent(-1);
            Indent(-1);
            WriteLineIndent("}");
            WriteLineIndent("return true;");
        } else if (v_value->map || v_value->hash) {
            WriteLineIndent("auto& lhs_value = " + get_lhs_code + ";");
            WriteLineIndent("auto& rhs_value = " + get_rhs_code + ";");
            WriteLineIndent("if (lhs_value.size() != rhs_value.size())");
            Indent(1);
            WriteLineIndent("return false;");
            Indent(-1);
            // each element in lhs compares equal with element in rhs at the same position
            WriteLineIndent("for (auto & [k, v]: lhs_value)");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent("auto pos = rhs_value.find(k);");
            WriteLineIndent("if (pos == rhs_value.end())");
            Indent(1);
            WriteLineIndent("return false;");
            Indent(-1);
            if (v_value->ptr) {
                WriteLineIndent("if (*pos->second != *v)");
            } else if (is_v_value_variant) {
                WriteLineIndent("if (!is_equal(pos->second, v))");
            } else {
                WriteLineIndent("if (pos->second != v)");
            }
            Indent(1);
            WriteLineIndent("return false;");
            Indent(-1);
            Indent(-1);
            WriteLineIndent("}");
            WriteLineIndent("return true;");
        } else if (v_value->list) {
            WriteLineIndent("for (auto l_iter = " + get_lhs_code + ".begin(), r_iter = " + get_rhs_code + ".begin(); r_iter != " + get_rhs_code + ".end(); l_iter++, r_iter++) {");
            Indent(1);
            if (v_value->ptr) {
                WriteLineIndent("if (**l_iter != **r_iter)");
            } else if (is_v_value_variant) {
                WriteLineIndent("if (!is_equal(*l_iter, *r_iter))");
            } else {
                WriteLineIndent("if (*l_iter != *r_iter)");
            }
            Indent(1);
            WriteLineIndent("return false;");
            Indent(-1);
            Indent(-1);
            WriteLineIndent("}");
            WriteLineIndent("return true;");
        } else if (v_value->ptr) {
            WriteLineIndent("return *" + get_lhs_code + " == *" + get_rhs_code + ";");
        } else if (is_v_value_variant) {
            WriteLineIndent("return is_equal(" + get_lhs_code + ", " + get_rhs_code + ");");
        } else {
            WriteLineIndent("return " + get_lhs_code + " == " + get_rhs_code + ";");
        }
        Indent(-1);
        WriteLineIndent("}");
    }
    WriteLineIndent("default: ");
    Indent(1);
    WriteLineIndent("return true;");
    Indent(-1);
    Indent(-1);
    WriteLineIndent("}");
    Indent(-1);
    WriteLineIndent("}");
}

void GeneratorCpp::GenerateVariantFieldModel_Header(const std::shared_ptr<Package>& p, const std::shared_ptr<VariantType>& v)
{
    std::string variant_name = "::" + ConvertNamespace(*p->name) + "::" + *v->name;
    std::string class_name = "FieldModel<" + variant_name + ">";

    // Generate variant field model begin
    WriteLine();
    WriteLineIndent("template <>");
    WriteLineIndent("class " + class_name);
    WriteLineIndent("{");
    WriteLineIndent("public:");
    Indent(1);

    // Generate variant field model constructor
    WriteLineIndent("FieldModel(FBEBuffer& buffer, size_t offset) noexcept;");

    // Generate variant field model FBE methods
    WriteLine();
    WriteLineIndent("// Get the field offset");
    WriteLineIndent("size_t fbe_offset() const noexcept { return _offset; }");
    WriteLineIndent("// Get the field size");
    WriteLineIndent("size_t fbe_size() const noexcept { return 4; }");
    WriteLineIndent("// Get the field body size");
    WriteLineIndent("size_t fbe_body() const noexcept;");
    WriteLineIndent("// Get the field extra size");
    WriteLineIndent("size_t fbe_extra() const noexcept;");
    WriteLine();
    WriteLineIndent("// Shift the current field offset");
    WriteLineIndent("void fbe_shift(size_t size) noexcept { _offset += size; }");
    WriteLineIndent("// Unshift the current field offset");
    WriteLineIndent("void fbe_unshift(size_t size) noexcept { _offset -= size; }");

    // Generate variant field model verify(), verify_fields() methods
    WriteLine();
    WriteLineIndent("// Check if the variant value is valid");
    WriteLineIndent("bool verify() const noexcept;");

    // Generate variant field model get(), get_fields() methods
    WriteLine();
    WriteLineIndent("// Get the variant value");
    WriteLineIndent("void get(" + variant_name + "& fbe_value) const noexcept;");

    WriteLine();
    WriteLineIndent("// Set the variant value (begin phase)");
    WriteLineIndent("size_t set_begin(size_t variant_type_fbe_size, size_t variant_type_index);");
    WriteLineIndent("// Set the variant value (end phase)");
    WriteLineIndent("void set_end(size_t fbe_begin);");

    // Generate variant field model set(), set_fields() methods
    WriteLine();
    WriteLineIndent("// Set the variant value");
    WriteLineIndent("void set(const " + variant_name + "& fbe_value) noexcept;");

    // Generate variant field model buffer & offset
    Indent(-1);
    WriteLine();
    WriteLineIndent("private:");
    Indent(1);
    WriteLineIndent("FBEBuffer& _buffer;");
    WriteLineIndent("size_t _offset;");
    Indent(-1);
    WriteLineIndent("};");
}

void GeneratorCpp::GenerateVariantFieldModel_Source(const std::shared_ptr<Package>& p, const std::shared_ptr<VariantType>& v)
{
    std::string variant_name = "::" + ConvertNamespace(*p->name) + "::" + *v->name;
    std::string class_name = "FieldModel<" + variant_name + ">";

    // Generate variant field model begin
    WriteLine();
    WriteLineIndent(class_name + "::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)");
    WriteLineIndent("{}");
    WriteLine();

    WriteLineIndent("size_t " + class_name + "::fbe_body() const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("// variant type's fbe_size not included");
    WriteLineIndent("size_t fbe_result = 4;");
    WriteLineIndent("return fbe_result;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    WriteLineIndent("size_t " + class_name + "::fbe_extra() const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());");
    WriteLineIndent("if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("_buffer.shift(fbe_struct_offset);");
    WriteLine();
    WriteLineIndent("size_t fbe_result = fbe_body();");
    Indent(1);
    // TODO(liuqi): calculate contained type's fbe_extra()
    Indent(-1);
    WriteLine();
    WriteLineIndent("_buffer.unshift(fbe_struct_offset);");
    WriteLine();
    WriteLineIndent("return fbe_result;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate variant field model verify(), verify_fields() methods
    WriteLineIndent("bool " + class_name + "::verify() const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
    Indent(1);
    WriteLineIndent("return true;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_variant_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());");
    WriteLineIndent("if ((fbe_variant_offset == 0) || ((_buffer.offset() + fbe_variant_offset + 4) > _buffer.size()))");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    // type
    WriteLineIndent("uint32_t fbe_variant_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_variant_offset);");
    WriteLineIndent("if (fbe_variant_type < 0 || fbe_variant_type >= " + std::to_string(v->body->values.size()) + ")"); 
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("_buffer.shift(fbe_variant_offset);");
    WriteLineIndent("switch(fbe_variant_type) {");
    Indent(1);
    for(auto index = 0; index < v->body->values.size(); index ++) {
        WriteLineIndent("case " + std::to_string(index) + ": {");
        Indent(1);
        auto& value = v->body->values[index];
        WriteLineIndent(ConvertPtrVariantFieldModelType(p, value) + " fbe_model(_buffer, 4);");
        WriteLineIndent("if (!fbe_model.verify())");
        Indent(1);
        WriteLineIndent("return false;");
        Indent(-1);
        WriteLineIndent("break;");
        Indent(-1);
        WriteLineIndent("}");
    }
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("_buffer.unshift(fbe_variant_offset);");
    WriteLineIndent("return true;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model get() method
    WriteLineIndent("void " + class_name + "::get(" + variant_name + "& fbe_value) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
    Indent(1);
    WriteLineIndent("return;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_variant_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());");
    WriteLineIndent("assert(((fbe_variant_offset > 0) && ((_buffer.offset() + fbe_variant_offset + 4) <= _buffer.size())) && \"Model is broken!\");");
    WriteLineIndent("if ((fbe_variant_offset == 0) || ((_buffer.offset() + fbe_variant_offset + 4) > _buffer.size()))");
    Indent(1);
    WriteLineIndent("return;");
    Indent(-1);
    WriteLineIndent("uint32_t vairant_type_index = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_variant_offset);");
    WriteLineIndent("assert(vairant_type_index >= 0 && vairant_type_index < " + std::to_string(v->body->values.size()) + " && \"Model is broken!\");"); 
    WriteLine();
    WriteLineIndent("_buffer.shift(fbe_variant_offset);");
    WriteLine();
    WriteLineIndent("switch(vairant_type_index) {");
    Indent(1);
    for(auto index = 0; index < v->body->values.size(); index ++) {
        WriteLineIndent("case " + std::to_string(index) + ": {");
        Indent(1);
        auto& value = v->body->values[index];
        WriteLineIndent(ConvertPtrVariantFieldModelType(p, value) + " fbe_model(_buffer, 4);");
        // initialize variant
        auto variant_type = ConvertVariantTypeName(*p->name, *value);
        WriteLineIndent("fbe_value.emplace<" + variant_type + ">();");
        WriteLineIndent("auto& value = std::get<" +  std::to_string(index) + ">(fbe_value);");
        WriteLineIndent(std::string("fbe_model.get(") + ((!IsContainerType(*value) && value->ptr) ? "&" : "") + "value);");
        WriteLineIndent("break;");
        Indent(-1);
        WriteLineIndent("}");
    }
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("_buffer.unshift(fbe_variant_offset);");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate variant field model set_begin() method
    // We don't know the type of the variant in advance. So we need to pass variant_type_fbe_size to set_begin to alloc.
    WriteLineIndent("size_t " + class_name + "::set_begin(size_t variant_type_fbe_size, size_t variant_type_index)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && \"Model is broken!\");");
    WriteLineIndent("if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_variant_size = (uint32_t)(fbe_body() + variant_type_fbe_size);");
    WriteLineIndent("uint32_t fbe_variant_offset = (uint32_t)(_buffer.allocate(fbe_variant_size) - _buffer.offset());");
    WriteLineIndent("assert(((fbe_variant_offset > 0) && ((_buffer.offset() + fbe_variant_offset + fbe_variant_size) <= _buffer.size())) && \"Model is broken!\");");
    WriteLineIndent("if ((fbe_variant_offset == 0) || ((_buffer.offset() + fbe_variant_offset + fbe_variant_size) > _buffer.size()))");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_variant_offset);");
    WriteLineIndent("unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_variant_offset, variant_type_index);");
    WriteLine();
    WriteLineIndent("_buffer.shift(fbe_variant_offset);");
    WriteLineIndent("return fbe_variant_offset;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate variant field model set_end() method
    WriteLineIndent("void " + class_name + "::set_end(size_t fbe_begin)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("_buffer.unshift(fbe_begin);");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate variant field model set() method
    WriteLineIndent("// Set the variant value");
    WriteLineIndent("void " + class_name + "::set(const " + variant_name + "& fbe_value) noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && \"Model is broken!\");");
    WriteLineIndent("if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
    Indent(1);
    WriteLineIndent("return;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("std::visit(");
    Indent(1);
    WriteLineIndent("overloaded");
    WriteLineIndent("{");
    Indent(1);
    bool first = true;
    for(auto index = 0; index < v->body->values.size(); index ++) {
        WriteIndent(first ? "" : ", ");
        auto& value = v->body->values[index];
        Write("[this, fbe_variant_index = fbe_value.index()](");
        Write(ConvertVariantTypeNameAsArgument(*p->name, *value));
        WriteLine(" v) {");
        Indent(1);
        WriteLineIndent(ConvertPtrVariantFieldModelType(p, value) + " fbe_model(_buffer, 4);");
        WriteLineIndent("size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);");
        WriteLineIndent("if (fbe_begin == 0)");
        Indent(1);
        WriteLineIndent("return;");
        Indent(-1);
        WriteLineIndent("fbe_model.set(v);");
        WriteLineIndent("set_end(fbe_begin);");
        Indent(-1);
        WriteLineIndent("}");
        first = false;
    }
    Indent(-1);
    WriteLineIndent("},");
    WriteLineIndent("fbe_value");
    Indent(-1);
    WriteLineIndent(");");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
}

void GeneratorCpp::GenerateStructFieldPtrModel_Header(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
    std::string class_name = std::string("FieldModel") + (Arena() ? "PMR" : "") + "Ptr_" + *p->name + "_" + *s->name;


    // Generate struct field ptr model begin
    WriteLine();
    WriteLineIndent("class " + class_name);
    WriteLineIndent("{");
    WriteLineIndent("public:");
    Indent(1);

    // Generate struct field ptr model constructor
    WriteLineIndent(class_name + "(FBEBuffer& buffer, size_t offset) noexcept;");
    WriteLineIndent("~" + class_name + "();");

    // Generate struct field ptr model FBE methods
    WriteLine();
    WriteLineIndent("// Get the field offset");
    WriteLineIndent("size_t fbe_offset() const noexcept { return _offset; }");
    WriteLineIndent("// Get the field size");
    WriteLineIndent("size_t fbe_size() const noexcept { return 5; }");
    WriteLineIndent("// Get the field extra size");
    WriteLineIndent("size_t fbe_extra() const noexcept;");
    WriteLineIndent("// Get the field type");
    WriteLineIndent("static constexpr size_t fbe_type() noexcept { return " + std::to_string(s->type) + "; }");
    WriteLine();
    WriteLineIndent("// Shift the current field offset");
    WriteLineIndent("void fbe_shift(size_t size) noexcept { _offset += size; }");
    WriteLineIndent("// Unshift the current field offset");
    WriteLineIndent("void fbe_unshift(size_t size) noexcept { _offset -= size; }");

    // Generate struct field model verify(), verify_fields() methods
    WriteLine();
    WriteLineIndent("// Check if the struct value is valid");
    WriteLineIndent("bool verify() const noexcept;");
    WriteLineIndent("// Check if the struct ptr is nullptr");
    WriteLineIndent("bool has_value() const noexcept;");

    // Generate struct field model get_begin(), get_end() methods
    WriteLine();
    WriteLineIndent("// Get the struct value (begin phase)");
    WriteLineIndent("size_t get_begin() const noexcept;");
    WriteLineIndent("// Get the struct value (end phase)");
    WriteLineIndent("void get_end(size_t fbe_begin) const noexcept;");

    // Generate struct field model get(), get_fields() methods
    WriteLine();
    WriteLineIndent("// Get the struct value");
    WriteLineIndent("void get(" + struct_name + "** fbe_value) noexcept;");
    WriteLineIndent("// Get the struct fields values");
    WriteLineIndent("void get_fields(" + struct_name + "& fbe_value, size_t fbe_struct_size) noexcept;");

    // Generate struct field model set_begin(), set_end() methods
    WriteLine();
    WriteLineIndent("// Set the struct value (begin phase)");
    WriteLineIndent("size_t set_begin(bool has_value);");
    WriteLineIndent("// Set the struct value (end phase)");
    WriteLineIndent("void set_end(size_t fbe_begin);");

    // Generate struct field model set(), set_fields() methods
    WriteLine();
    WriteLineIndent("// Set the struct value");
    WriteLineIndent("void set(const " + struct_name + "* fbe_value) noexcept;");
    WriteLineIndent("// Set the struct fields values");
    WriteLineIndent("void set_fields(const " + struct_name + "* fbe_value) noexcept;");

    // Generate struct field model buffer & offset
    Indent(-1);
    WriteLine();
    WriteLineIndent("private:");
    Indent(1);
    WriteLineIndent("FBEBuffer& _buffer;");
    WriteLineIndent("size_t _offset;");

    // Generate struct field model accessors
    Indent(-1);
    WriteLine();
    WriteLineIndent("public:");
    Indent(1);
    WriteLineIndent("BaseFieldModel* ptr{nullptr};");

    // Generate struct field model end
    Indent(-1);
    WriteLineIndent("};");
}

void GeneratorCpp::GeneratePtrStructFieldModel_Header(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
    std::string class_name = std::string("FieldModel") + (Arena() ? "PMR_" : "_") + *p->name + "_" + *s->name;

    // Generate struct field model begin
    WriteLine();
    WriteLineIndent("// Fast Binary Encoding " + struct_name + " field model");
    WriteLineIndent("class " + class_name + " : public BaseFieldModel");
    WriteLineIndent("{");
    WriteLineIndent("public:");
    Indent(1);

    // Generate struct field model constructor
    WriteLineIndent(class_name + "(FBEBuffer& buffer, size_t offset) noexcept;");

    // Generate struct field model FBE methods
    WriteLine();
    WriteLineIndent("// Get the field offset");
    WriteLineIndent("size_t fbe_offset() const noexcept override { return _offset; }");
    WriteLineIndent("// Get the field size");
    WriteLineIndent("size_t fbe_size() const noexcept override { return 4; }");
    WriteLineIndent("// Get the field body size");
    WriteLineIndent("size_t fbe_body() const noexcept;");
    WriteLineIndent("// Get the field extra size");
    WriteLineIndent("size_t fbe_extra() const noexcept override;");
    WriteLineIndent("// Get the field type");
    if (s->base && !s->base->empty() && (s->type == 0))
        WriteLineIndent("static constexpr size_t fbe_type() noexcept { return FieldModel<" + ConvertPtrTypeName(*p->name, *s->base) + ">::fbe_type(); }");
    else
        WriteLineIndent("static constexpr size_t fbe_type() noexcept { return " + std::to_string(s->type) + "; }");
    WriteLine();
    WriteLineIndent("// Shift the current field offset");
    WriteLineIndent("void fbe_shift(size_t size) noexcept override { _offset += size; }");
    WriteLineIndent("// Unshift the current field offset");
    WriteLineIndent("void fbe_unshift(size_t size) noexcept override { _offset -= size; }");

    // Generate struct field model verify(), verify_fields() methods
    WriteLine();
    WriteLineIndent("// Check if the struct value is valid");
    WriteLineIndent("bool verify(bool fbe_verify_type = true) const noexcept override;");
    WriteLineIndent("// Check if the struct fields are valid");
    WriteLineIndent("bool verify_fields(size_t fbe_struct_size) const noexcept override;");

    // Generate struct field model get_begin(), get_end() methods
    WriteLine();
    WriteLineIndent("// Get the struct value (begin phase)");
    WriteLineIndent("size_t get_begin() const noexcept override;");
    WriteLineIndent("// Get the struct value (end phase)");
    WriteLineIndent("void get_end(size_t fbe_begin) const noexcept override;");

    // Generate struct field model get(), get_fields() methods
    WriteLine();
    WriteLineIndent("// Get the struct value");
    WriteLineIndent("void get(::FBE::Base& fbe_value) noexcept override;");
    WriteLineIndent("// Get the struct fields values");
    WriteLineIndent("void get_fields(::FBE::Base& fbe_value, size_t fbe_struct_size) noexcept override;");

    // Generate struct field model set_begin(), set_end() methods
    WriteLine();
    WriteLineIndent("// Set the struct value (begin phase)");
    WriteLineIndent("size_t set_begin() override;");
    WriteLineIndent("// Set the struct value (end phase)");
    WriteLineIndent("void set_end(size_t fbe_begin) override;");

    // Generate struct field model set(), set_fields() methods
    WriteLine();
    WriteLineIndent("// Set the struct value");
    WriteLineIndent("void set(const ::FBE::Base& fbe_value) noexcept override;");
    WriteLineIndent("// Set the struct fields values");
    WriteLineIndent("void set_fields(const ::FBE::Base& fbe_value) noexcept override;");

    // Generate struct field model buffer & offset
    Indent(-1);
    WriteLine();
    WriteLineIndent("private:");
    Indent(1);
    WriteLineIndent("FBEBuffer& _buffer;");
    WriteLineIndent("size_t _offset;");

    // Generate struct field model accessors
    Indent(-1);
    WriteLine();
    WriteLineIndent("public:");
    Indent(1);
    if (s->base && !s->base->empty())
        // TODO: check if this is correct
        WriteLineIndent("FieldModel<" + ConvertPtrTypeName(*p->name, *s->base) + "> parent;");
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLineIndent(ConvertPtrFieldModelType(p, field) + " " + *field->name + ";");
        }
    }

    // Generate struct field model end
    Indent(-1);
    WriteLineIndent("};");
}

void GeneratorCpp::GeneratePtrStructFieldModel_Source(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
    std::string class_name = std::string("FieldModel") + (Arena() ? "PMR_" : "_") + *p->name + "_" + *s->name;

    // Generate struct field model constructor
    WriteLine();
    WriteLineIndent(class_name + "::" + class_name + "(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)");
    Indent(1);
    std::string prev_offset("4");
    std::string prev_size("4");
    if (s->base && !s->base->empty())
    {
        WriteLineIndent(", parent(buffer, " + prev_offset + " + " + prev_size + ")");
        prev_offset = "parent.fbe_offset()";
        prev_size = "parent.fbe_body() - 4 - 4";
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLineIndent(", " + *field->name + "(buffer, " + prev_offset + " + " + prev_size + ")");
            prev_offset = *field->name + ".fbe_offset()";
            prev_size = *field->name + ".fbe_size()";
        }
    }
    Indent(-1);
    WriteLineIndent("{}");
    WriteLine();

    // Generate struct field model FBE methods
    WriteLineIndent("size_t " + class_name + "::fbe_body() const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("size_t fbe_result = 4 + 4");
    Indent(1);
    if (s->base && !s->base->empty())
        WriteLineIndent("+ parent.fbe_body() - 4 - 4");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("+ " + *field->name + ".fbe_size()");
    WriteLineIndent(";");
    Indent(-1);
    WriteLineIndent("return fbe_result;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("size_t " + class_name + "::fbe_extra() const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());");
    WriteLineIndent("if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("_buffer.shift(fbe_struct_offset);");
    WriteLine();
    WriteLineIndent("size_t fbe_result = fbe_body()");
    Indent(1);
    if (s->base && !s->base->empty())
        WriteLineIndent("+ parent.fbe_extra()");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("+ " + *field->name + ".fbe_extra()");
    WriteLineIndent(";");
    Indent(-1);
    WriteLine();
    WriteLineIndent("_buffer.unshift(fbe_struct_offset);");
    WriteLine();
    WriteLineIndent("return fbe_result;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model verify() method
    WriteLineIndent("bool " + class_name + "::verify(bool fbe_verify_type) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
    Indent(1);
    WriteLineIndent("return true;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());");
    WriteLineIndent("if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);");
    WriteLineIndent("if (fbe_struct_size < (4 + 4))");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);");
    WriteLineIndent("if (fbe_verify_type && (fbe_struct_type != fbe_type()))");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("_buffer.shift(fbe_struct_offset);");
    WriteLineIndent("bool fbe_result = verify_fields(fbe_struct_size);");
    WriteLineIndent("_buffer.unshift(fbe_struct_offset);");
    WriteLineIndent("return fbe_result;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model verify_fields() method
    WriteLineIndent("bool " + class_name + "::verify_fields([[maybe_unused]] size_t fbe_struct_size) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty()))
    {
        WriteLineIndent("size_t fbe_current_size = 4 + 4;");
        if (s->base && !s->base->empty())
        {
            WriteLine();
            WriteLineIndent("if ((fbe_current_size + parent.fbe_body() - 4 - 4) > fbe_struct_size)");
            Indent(1);
            WriteLineIndent("return true;");
            Indent(-1);
            WriteLineIndent("if (!parent.verify_fields(fbe_struct_size))");
            Indent(1);
            WriteLineIndent("return false;");
            Indent(-1);
            WriteLineIndent("fbe_current_size += parent.fbe_body() - 4 - 4;");
        }
        if (s->body)
        {
            for (const auto& field : s->body->fields)
            {
                WriteLine();
                WriteLineIndent("if ((fbe_current_size + " + *field->name + ".fbe_size()) > fbe_struct_size)");
                Indent(1);
                WriteLineIndent("return true;");
                Indent(-1);
                WriteLineIndent("if (!" + *field->name + ".verify())");
                Indent(1);
                WriteLineIndent("return false;");
                Indent(-1);
                WriteLineIndent("fbe_current_size += " + *field->name + ".fbe_size();");
            }
        }
        WriteLine();
    }
    WriteLineIndent("return true;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model get_begin() method
    WriteLineIndent("size_t " + class_name + "::get_begin() const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());");
    WriteLineIndent("assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && \"Model is broken!\");");
    WriteLineIndent("if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);");
    WriteLineIndent("assert((fbe_struct_size >= (4 + 4)) && \"Model is broken!\");");
    WriteLineIndent("if (fbe_struct_size < (4 + 4))");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("_buffer.shift(fbe_struct_offset);");
    WriteLineIndent("return fbe_struct_offset;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model get_end() method
    WriteLineIndent("void " + class_name + "::get_end(size_t fbe_begin) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("_buffer.unshift(fbe_begin);");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model get() method
    WriteLineIndent("void " + class_name + "::get(::FBE::Base& fbe_value) noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("size_t fbe_begin = get_begin();");
    WriteLineIndent("if (fbe_begin == 0)");
    Indent(1);
    WriteLineIndent("return;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());");
    WriteLineIndent("get_fields(fbe_value, fbe_struct_size);");
    WriteLineIndent("get_end(fbe_begin);");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model get_fields() method
    WriteLineIndent("void " + class_name + "::get_fields([[maybe_unused]] ::FBE::Base& base_fbe_value, [[maybe_unused]] size_t fbe_struct_size) noexcept");
    WriteLineIndent("{");
    Indent(1);
    if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty()))
    {
        WriteLineIndent(struct_name + "& fbe_value = static_cast<" + struct_name + "&>(base_fbe_value);");
        WriteLineIndent("size_t fbe_current_size = 4 + 4;");
        if (s->base && !s->base->empty())
        {
            WriteLine();
            WriteLineIndent("if ((fbe_current_size + parent.fbe_body() - 4 - 4) <= fbe_struct_size)");
            Indent(1);
            WriteLineIndent("parent.get_fields(fbe_value, fbe_struct_size);");
            Indent(-1);
            WriteLineIndent("fbe_current_size += parent.fbe_body() - 4 - 4;");
        }
        if (s->body)
        {
            for (const auto& field : s->body->fields)
            {
                WriteLine();
                WriteLineIndent("if ((fbe_current_size + " + *field->name + ".fbe_size()) <= fbe_struct_size)");
                Indent(1);
                if (!field->ptr || IsContainerType(*field)) {
                    WriteLineIndent("{");
                    Indent(1);
                    WriteLineIndent(*field->name + ".get(fbe_value." + *field->name + ");");
                    Indent(-1);
                    WriteLineIndent("}");
                } else {
                    WriteLineIndent("{");
                    Indent(1);
                    WriteLineIndent(*field->name + ".get(&fbe_value." + *field->name + ");");
                    Indent(-1);
                    WriteLineIndent("}");


                }
                Indent(-1);
                WriteLineIndent("else");
                Indent(1);
                if (field->array)
                {
                    // Do nothing here...
                }
                else if (field->vector || field->list || field->set || field->map || field->hash || ((*field->type == "bytes") && !field->optional))
                    WriteLineIndent("fbe_value." + *field->name + ".clear();");
                else
                    WriteLineIndent("fbe_value." + *field->name + " = " + ConvertDefault(*p->name, *field) + ";");
                Indent(-1);
                WriteLineIndent("fbe_current_size += " + *field->name + ".fbe_size();");
            }
        }
    }
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model set_begin() method
    WriteLineIndent("size_t " + class_name + "::set_begin()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && \"Model is broken!\");");
    WriteLineIndent("if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_struct_size = (uint32_t)fbe_body();");
    WriteLineIndent("uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());");
    WriteLineIndent("assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && \"Model is broken!\");");
    WriteLineIndent("if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);");
    WriteLineIndent("unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);");
    WriteLineIndent("unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());");
    WriteLine();
    WriteLineIndent("_buffer.shift(fbe_struct_offset);");
    WriteLineIndent("return fbe_struct_offset;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model set_end() method
    WriteLineIndent("void " + class_name + "::set_end(size_t fbe_begin)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("_buffer.unshift(fbe_begin);");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model set() method
    WriteLineIndent("void " + class_name + "::set(const ::FBE::Base& fbe_value) noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("size_t fbe_begin = set_begin();");
    WriteLineIndent("if (fbe_begin == 0)");
    Indent(1);
    WriteLineIndent("return;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("set_fields(fbe_value);");
    WriteLineIndent("set_end(fbe_begin);");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model set_fields() method
    WriteLineIndent("void " + class_name + "::set_fields([[maybe_unused]] const ::FBE::Base& base_fbe_value) noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("[[maybe_unused]] const " + struct_name + "& fbe_value = static_cast<const " + struct_name + "&>(base_fbe_value);");
    if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty()))
    {
        if (s->base && !s->base->empty())
            WriteLineIndent("parent.set_fields(fbe_value);");
        if (s->body)
            for (const auto& field : s->body->fields)
            {
                if (IsStructType(p, *field->type) && !field->ptr && !IsContainerType(*field) && !field->optional)
                    WriteLineIndent(*field->name + ".set(static_cast<const ::" + ConvertNamespace(*p->name) + "::" + *field->type + "&>(" + "fbe_value." + *field->name + "));");
                else
                    WriteLineIndent(*field->name + ".set(fbe_value." + *field->name + ");");
            }
    }
    Indent(-1);
    WriteLineIndent("}");
}

void GeneratorCpp::GenerateStructFieldPtrModel_Source(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
    std::string class_name = std::string("FieldModel") + (Arena() ? "PMR" : "") + "Ptr_" + *p->name + "_" + *s->name;

    // Generate struct field model constructor
    WriteLine();
    WriteLineIndent(class_name + "::" + class_name +"(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)");
    WriteLineIndent("{}");
    WriteLine();

    WriteLineIndent(class_name + "::~" + class_name +"()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if (ptr) delete ptr;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field ptr model FBE methods
    WriteLineIndent("size_t " + class_name + "::fbe_extra() const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if (!ptr) return 0;");
    WriteLine();
    WriteLineIndent("if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);");
    WriteLineIndent("if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("_buffer.shift(fbe_ptr_offset);");
    WriteLineIndent("size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();");
    WriteLineIndent("_buffer.unshift(fbe_ptr_offset);");
    WriteLine();
    WriteLineIndent("return fbe_result;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model verify() method
    WriteLineIndent("bool " + class_name + "::verify() const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if (!ptr) return true;");
    WriteLine();
    WriteLineIndent("if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
    Indent(1);
    WriteLineIndent("return true;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));");
    WriteLineIndent("if (fbe_has_value == 0)");
    Indent(1);
    WriteLineIndent("return true;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);");

    WriteLineIndent("if (fbe_optional_offset == 0)");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("_buffer.shift(fbe_optional_offset);");
    WriteLineIndent("bool fbe_result = ptr->verify();");
    WriteLineIndent("_buffer.unshift(fbe_optional_offset);");
    WriteLineIndent("return fbe_result;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model has_value() method
    WriteLineIndent("bool " + class_name + "::has_value() const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));");
    WriteLineIndent("return (fbe_has_value != 0);");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model get_begin() method
    WriteLineIndent("size_t " + class_name + "::get_begin() const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if (!has_value())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);");
    WriteLineIndent("assert((fbe_ptr_offset > 0) && \"Model is broken!\");");
    WriteLineIndent("if (fbe_ptr_offset == 0)");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("_buffer.shift(fbe_ptr_offset);");
    WriteLineIndent("return fbe_ptr_offset;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model get_end() method
    WriteLineIndent("void " + class_name + "::get_end(size_t fbe_begin) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("_buffer.unshift(fbe_begin);");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model get() method
    WriteLineIndent("void " + class_name + "::get(" + struct_name + "** fbe_value) noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("size_t fbe_begin = get_begin();");
    WriteLineIndent("if (fbe_begin == 0)");
    Indent(1);
    WriteLineIndent("return;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("if (ptr) delete ptr;");
    WriteLineIndent(std::string("ptr = new FieldModel") + (Arena() ? "PMR_" : "_") + *p->name + "_" + *s->name + "(_buffer, 0);");
    WriteLine();
    WriteLineIndent(struct_name + " *tempModel = new " + struct_name + "();");
    WriteLineIndent("ptr->get(*tempModel);");
    WriteLineIndent("*fbe_value = tempModel;");
    WriteLine();
    WriteLineIndent("get_end(fbe_begin);");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model set_begin() method
    WriteLineIndent("size_t " + class_name + "::set_begin(bool has_value)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && \"Model is broken!\");");
    WriteLineIndent("if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint8_t fbe_has_value = has_value ? 1 : 0;");
    WriteLineIndent("*((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;");
    WriteLineIndent("if (fbe_has_value == 0)");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_ptr_size = 4;");
    WriteLineIndent("uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());");
    WriteLineIndent("assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && \"Model is broken!\");");
    WriteLineIndent("if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);");

    WriteLine();
    WriteLineIndent("_buffer.shift(fbe_ptr_offset);");
    WriteLineIndent("return fbe_ptr_offset;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model set_end() method
    WriteLineIndent("void " + class_name + "::set_end(size_t fbe_begin)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("_buffer.unshift(fbe_begin);");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct field model set() method
    WriteLineIndent("void " + class_name + "::set(const " + struct_name + "* fbe_value) noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("size_t fbe_begin = set_begin(fbe_value != nullptr);");
    WriteLineIndent("if (fbe_begin == 0)");
    Indent(1);
    WriteLineIndent("return;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("if (fbe_value != nullptr) {");
    Indent(1);
    WriteLineIndent(std::string("BaseFieldModel* temp = new FieldModel") + (Arena() ? "PMR_" : "_") + *p->name + "_" + *s->name + "(_buffer, 0);");
    WriteLineIndent("if (ptr) delete ptr;");
    WriteLineIndent("ptr = temp;");
    WriteLineIndent("ptr->set(*fbe_value);");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("set_end(fbe_begin);");
    Indent(-1);
    WriteLineIndent("}");
}

void GeneratorCpp::GeneratePtrStructModel_Header(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

    std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
    std::string class_name = std::string("FieldModel") + (Arena() ? "PMR_" : "_") + *p->name + "_" + *s->name;

    // Generate struct model begin
    WriteLine();
    WriteLineIndent("// Fast Binary Encoding " + *s->name + " model");
    WriteLineIndent("class " + *s->name + "Model : public FBE::Model");
    WriteLineIndent("{");
    WriteLineIndent("public:");
    Indent(1);

    // Generate struct model constructor
    WriteLineIndent(*s->name + "Model() : model(this->buffer(), 4) {}");
    WriteLineIndent(*s->name + "Model(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}");

    // Generate struct model FBE methods
    WriteLine();
    WriteLineIndent("// Get the model size");
    WriteLineIndent("size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }");
    WriteLineIndent("// Get the model type");
    WriteLineIndent("static constexpr size_t fbe_type() noexcept { return " + class_name + "::fbe_type(); }");

    // Generate struct model verify() method
    WriteLine();
    WriteLineIndent("// Check if the struct value is valid");
    WriteLineIndent("bool verify();");

    // Generate struct model create_begin(), create_end() methods
    WriteLine();
    WriteLineIndent("// Create a new model (begin phase)");
    WriteLineIndent("size_t create_begin();");
    WriteLineIndent("// Create a new model (end phase)");
    WriteLineIndent("size_t create_end(size_t fbe_begin);");

    // Generate struct model serialize(), deserialize() methods
    WriteLine();
    WriteLineIndent("// Serialize the struct value");
    WriteLineIndent("size_t serialize(const " + struct_name + "& value);");
    WriteLineIndent("// Deserialize the struct value");
    WriteLineIndent("size_t deserialize(" + struct_name + "& value) noexcept;");

    // Generate struct model next() method
    WriteLine();
    WriteLineIndent("// Move to the next struct value");
    WriteLineIndent("void next(size_t prev) noexcept { model.fbe_shift(prev); }");

    // Generate struct model accessor
    Indent(-1);
    WriteLine();
    WriteLineIndent("public:");
    Indent(1);
    WriteLineIndent(class_name + " model;");

    // Generate struct model end
    Indent(-1);
    WriteLineIndent("};");

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));
}

void GeneratorCpp::GeneratePtrStructModel_Source(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    // Generate namespace begin
    WriteLine();
    WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

    std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
    std::string model_name = *s->name + "Model";

    // Generate struct model verify() method
    WriteLine();
    WriteLineIndent("bool " + model_name + "::verify()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);");
    WriteLineIndent("if (fbe_full_size < model.fbe_size())");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("return model.verify();");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct model create_begin() method
    WriteLineIndent("size_t " + model_name + "::create_begin()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());");
    WriteLineIndent("return fbe_begin;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct model create_end() method
    WriteLineIndent("size_t " + model_name + "::create_end(size_t fbe_begin)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("size_t fbe_end = this->buffer().size();");
    WriteLineIndent("uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);");
    WriteLineIndent("*((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;");
    WriteLineIndent("return fbe_full_size;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct model serialize() method
    WriteLineIndent("size_t " + model_name + "::serialize(const " + struct_name + "& value)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("size_t fbe_begin = create_begin();");
    WriteLineIndent("model.set(value);");
    WriteLineIndent("size_t fbe_full_size = create_end(fbe_begin);");
    WriteLineIndent("return fbe_full_size;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct model deserialize() method
    WriteLineIndent("size_t " + model_name + "::deserialize(" + struct_name + "& value) noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);");
    WriteLineIndent("assert((fbe_full_size >= model.fbe_size()) && \"Model is broken!\");");
    WriteLineIndent("if (fbe_full_size < model.fbe_size())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("model.get(value);");
    WriteLineIndent("return fbe_full_size;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate namespace end
    WriteLine();
    WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));
}

bool GeneratorCpp::IsKnownType(const std::string& type)
{
    return ((type == "bool") ||
            (type == "byte") || (type == "bytes") ||
            (type == "char") || (type == "wchar") ||
            (type == "int8") || (type == "uint8") ||
            (type == "int16") || (type == "uint16") ||
            (type == "int32") || (type == "uint32") ||
            (type == "int64") || (type == "uint64") ||
            (type == "float") || (type == "double") ||
            (type == "decimal") || (type == "string") ||
            (type == "timestamp") || (type == "uuid"));
}

bool GeneratorCpp::IsPrimitiveType(const std::string& type, bool optional)
{
    if (optional)
        return false;

    return ((type == "bool") || (type == "byte") ||
            (type == "char") || (type == "wchar") ||
            (type == "int8") || (type == "uint8") ||
            (type == "int16") || (type == "uint16") ||
            (type == "int32") || (type == "uint32") ||
            (type == "int64") || (type == "uint64") ||
            (type == "float") || (type == "double") ||
            (type == "timestamp"));
}

std::string GeneratorCpp::ConvertEnumType(const std::string& type)
{
    if (type == "byte")
        return "uint8_t";
    else if (type == "char")
        return "uint8_t";
    else if (type == "wchar")
        return "uint32_t";
    else if (type == "int8")
        return "int8_t";
    else if (type == "uint8")
        return "uint8_t";
    else if (type == "int16")
        return "int16_t";
    else if (type == "uint16")
        return "uint16_t";
    else if (type == "int32")
        return "int32_t";
    else if (type == "uint32")
        return "uint32_t";
    else if (type == "int64")
        return "int64_t";
    else if (type == "uint64")
        return "uint64_t";

    yyerror("Unsupported enum base type - " + type);
    return "";
}

std::string GeneratorCpp::ConvertTypeName(const std::string& package, const std::string& type, bool optional)
{
    if (optional)
        return "std::optional<" + ConvertTypeName(package, type, false) + ">";

    if (type == "bool")
        return "bool";
    else if (type == "byte")
        return "uint8_t";
    else if (type == "bytes")
        return Arena() ? "FBE::pmr_buffer_t" : "FBE::buffer_t";
    else if (type == "char")
        return "char";
    else if (type == "wchar")
        return "wchar_t";
    else if (type == "int8")
        return "int8_t";
    else if (type == "uint8")
        return "uint8_t";
    else if (type == "int16")
        return "int16_t";
    else if (type == "uint16")
        return "uint16_t";
    else if (type == "int32")
        return "int32_t";
    else if (type == "uint32")
        return "uint32_t";
    else if (type == "int64")
        return "int64_t";
    else if (type == "uint64")
        return "uint64_t";
    else if (type == "float")
        return "float";
    else if (type == "double")
        return "double";
    else if (type == "decimal")
        return "FBE::decimal_t";
    else if (type == "string")
        return Arena()? "stdb::memory::arena_string":"stdb::memory::string";
    else if (type == "timestamp")
        return "uint64_t";
    else if (type == "uuid")
        return "FBE::uuid_t";

    // split by .
    auto items = split(type, ".", true);
    if (items.size() == 1)
        return "::" + ConvertNamespace(package) + "::" + type;
    std::string result = "::" + ConvertNamespace(items[0]);
    for (size_t i = 1; i < items.size(); ++i) {
        result += "::" + items[i];
    }
    return result;
}

std::string GeneratorCpp::ConvertTypeName(const std::string& package, const StructField& field)
{
    std::string prefix = "std";
    if (Arena()) {
        prefix = "pmr";
    }
    if (field.array)
        return "std::array<" + ConvertTypeName(package, *field.type, field.optional) + ", " + std::to_string(field.N) + ">";
    else if (field.vector) 
        return (Arena() ? "pmr::vector<" : "FastVec<") + ConvertTypeName(package, *field.type, field.optional) + ">";
    else if (field.list)
        return prefix + "::list<" + ConvertTypeName(package, *field.type, field.optional) + ">";
    else if (field.set)
        return prefix + "::set<" + ConvertTypeName(package, *field.key, false) + ">";
    else if (field.map)
        return prefix + "::map<" + ConvertTypeName(package, *field.key, false) + ", " + ConvertTypeName(package, *field.type, field.optional) +">";
    else if (field.hash)
        return prefix + "::unordered_map<" + ConvertTypeName(package, *field.key, false) + ", " + ConvertTypeName(package, *field.type, field.optional) +">";

    return ConvertTypeName(package, *field.type, field.optional);
}

std::string GeneratorCpp::ConvertTypeNameAsArgument(const std::string& package, const StructField& field)
{
    if (field.optional || field.array || field.vector || field.list || field.set || field.map || field.hash)
        return "const " + ConvertTypeName(package, field) + "&";

    if (IsPrimitiveType(*field.type, false))
        return ConvertTypeName(package, field);

    return "const " + ConvertTypeName(package, field) + "&";
}

std::string GeneratorCpp::ConvertConstant(const std::string& type, const std::string& value, bool optional)
{
    if (value == "true")
        return "true";
    else if (value == "false")
        return "false";
    else if (value == "null")
        return optional ? "std::nullopt" : "std::nullptr";
    else if (value == "min")
    {
        if ((type == "byte") || (type == "uint8") || (type == "uint16") || (type == "uint32") || (type == "uint64"))
            return ConvertConstantPrefix(type) + "0" + ConvertConstantSuffix(type);
        else if (type == "int8")
            return ConvertConstantPrefix(type) + "-128" + ConvertConstantSuffix(type);
        else if (type == "int16")
            return ConvertConstantPrefix(type) + "-32768" + ConvertConstantSuffix(type);
        else if (type == "int32")
            return ConvertConstantPrefix(type) + "-2147483648ll" + ConvertConstantSuffix(type);
        else if (type == "int64")
            return ConvertConstantPrefix(type) + "-9223372036854775808ll" + ConvertConstantSuffix(type);

        yyerror("Unsupported type " + type + " for 'min' constant");
        return "";
    }
    else if (value == "max")
    {
        if (type == "byte")
            return ConvertConstantPrefix(type) + "255" + ConvertConstantSuffix(type);
        else if (type == "int8")
            return ConvertConstantPrefix(type) + "127" + ConvertConstantSuffix(type);
        else if (type == "uint8")
            return ConvertConstantPrefix(type) + "255" + ConvertConstantSuffix(type);
        else if (type == "int16")
            return ConvertConstantPrefix(type) + "32767" + ConvertConstantSuffix(type);
        else if (type == "uint16")
            return ConvertConstantPrefix(type) + "65535" + ConvertConstantSuffix(type);
        else if (type == "int32")
            return ConvertConstantPrefix(type) + "2147483647" + ConvertConstantSuffix(type);
        else if (type == "uint32")
            return ConvertConstantPrefix(type) + "4294967295" + ConvertConstantSuffix(type);
        else if (type == "int64")
            return ConvertConstantPrefix(type) + "9223372036854775807" + ConvertConstantSuffix(type);
        else if (type == "uint64")
            return ConvertConstantPrefix(type) + "18446744073709551615" + ConvertConstantSuffix(type);

        yyerror("Unsupported type " + type + " for 'max' constant");
        return "";
    }
    else if (value == "epoch")
        return "FBE::epoch()";
    else if (value == "utc")
        return "FBE::utc()";
    else if (value == "uuid0")
        return "FBE::uuid_t::nil()";
    else if (value == "uuid1")
        return "FBE::uuid_t::sequential()";
    else if (value == "uuid4")
        return "FBE::uuid_t::random()";

    if (IsKnownType(type))
        return ConvertConstantPrefix(type) + value + ConvertConstantSuffix(type);

    // TODO(liuqi): check using ConvertNamespace
    bool first = true;
    std::string result;
    auto items = split(value, '|', true);
    for (auto& item : items)
    {
        bool pkg = (count_char(item, '.') > 1);
        replace_all(item, ".", "::");
        result += (!first ? " | " : "");
        result += (pkg ? "::" : "") + item;
        first = false;
    }

    return result;
}

std::string GeneratorCpp::ConvertConstantPrefix(const std::string& type)
{
    if (type == "bool")
        return "(bool)";
    else if (type == "byte")
        return "(uint8_t)";
    else if (type == "char")
        return "(char)";
    else if (type == "wchar")
        return "(wchar_t)";
    else if (type == "int8")
        return "(int8_t)";
    else if (type == "uint8")
        return "(uint8_t)";
    else if (type == "int16")
        return "(int16_t)";
    else if (type == "uint16")
        return "(uint16_t)";
    else if (type == "int32")
        return "(int32_t)";
    else if (type == "uint32")
        return "(uint32_t)";
    else if (type == "int64")
        return "(int64_t)";
    else if (type == "uint64")
        return "(uint64_t)";
    else if (type == "float")
        return "(float)";
    else if (type == "double")
        return "(double)";
    else if (type == "decimal")
        return "FBE::decimal_t(";
    else if (type == "timestamp")
        return "(uint64_t)";
    else if (type == "uuid")
        return "FBE::uuid_t(";

    return "";
}

std::string GeneratorCpp::ConvertConstantSuffix(const std::string& type)
{
    if ((type == "byte") || (type == "uint8") || (type == "uint16"))
        return "u";
    else if ((type == "int32") || (type == "int64"))
        return "ll";
    else if ((type == "uint32") || (type == "uint64") || (type == "timestamp"))
        return "ull";
    else if (type == "float")
        return "f";
    else if ((type == "decimal") || (type == "uuid"))
        return ")";

    return "";
}

std::string GeneratorCpp::ConvertDefault(const std::string& package, const std::string& type)
{
    if (type == "bool")
        return "false";
    else if (type == "bytes")
        return "";
    else if (type == "char")
        return "'\\0'";
    else if (type == "wchar")
        return "L'\\0'";
    else if ((type == "byte") || (type == "int8") || (type == "uint8") || (type == "int16") || (type == "uint16") || (type == "int32") || (type == "uint32") || (type == "int64") || (type == "uint64") || (type == "timestamp"))
        return ConvertConstantPrefix(type) + "0" + ConvertConstantSuffix(type);
    else if (type == "float")
        return "0.0f";
    else if (type == "double")
        return "0.0";
    else if (type == "decimal")
        return "FBE::decimal_t()";
    else if (type == "string")
        return "\"\"";
    else if (type == "uuid")
        return "FBE::uuid_t::nil()";

    auto items = split(type, ".", true);
    if (items.size() == 1)
        return  "::" + ConvertNamespace(package) + "::" + type + "()";
    std::string result = "::" + ConvertNamespace(items[0]);
    for (size_t i = 1; i < items.size(); ++i) {
        result += "::" + items[i];
    }
    return result + "()";
}

std::string GeneratorCpp::ConvertDefault(const std::string& package, const StructField& field)
{
    if (field.ptr)
        return "nullptr";
    if (field.value)
        return ConvertConstant(*field.type, *field.value, field.optional);

    if (field.array || field.vector || field.list || field.set || field.map || field.hash || field.ptr)
        return "";
    else if (field.optional)
        return "std::nullopt";

    return ConvertDefault(package, *field.type);
}

std::string GeneratorCpp::ConvertOutputStreamType(const std::string& type, const std::string& name, bool ptr, bool optional)
{
    std::string wrapped_name = name;
    if (ptr) {
      return "\"ptr of other struct: \" << (" + name +
             " == nullptr ? \"nullptr\" : \"true\"" + ")";
    }
    if (type == "bool")
        return "(" + std::string(optional ? "*" : "") + wrapped_name + " ? \"true\" : \"false\"" + ")";
    else if ((type == "byte") || (type == "int8") || (type == "uint8"))
        return "(int)" + std::string(optional ? "*" : "") + wrapped_name;
    else if (type == "bytes")
        return "\"bytes[\" << " + name + std::string(optional ? "->" : ".") + "size() << \"]\"";
    else if (type == "char")
        return "\"'\" << " + std::string(optional ? "*" : "") + name + " << \"'\"";
    else if (type == "wchar")
        return "\"'\" << (char)" + std::string(optional ? "*" : "") + name + " << \"'\"";
    else if ((type == "string") || (type == "uuid"))
        return "\"\\\"\" << " + std::string(optional ? "*" : "") + wrapped_name + " << \"\\\"\"";
    return std::string(optional ? "*" : "") + wrapped_name;
}

std::string GeneratorCpp::ConvertOutputStreamValue(const std::string& type, const std::string& name, bool ptr, bool optional, bool separate)
{
    std::string comma = separate ? "<< std::string(first ? \"\" : \",\") " : "";

    if (optional)
        return "if (" + name + ") stream " + comma + "<< " + ConvertOutputStreamType(type, name, ptr, true) + "; else stream " + comma + "<< \"null\";";
    else
        return "stream " + comma + "<< " + ConvertOutputStreamType(type, name, ptr, false) + ";";
}

std::string GeneratorCpp::ConvertLoggingStreamType(const std::string& type, const std::string& name, bool optional)
{
    if (type == "bool")
        return "StoreList(" + std::string(optional ? "*" : "") + name + " ? \"true\" : \"false\"" + ")";
    else if ((type == "byte") || (type == "int8") || (type == "uint8"))
        return "StoreList((int)" + std::string(optional ? "*" : "") + name + ")";
    else if (type == "bytes")
        return "StoreList(\"bytes[\").StoreList(" + name + std::string(optional ? "->" : ".") + "size()).StoreList(\"]\")";
    else if ((type == "char") || (type == "wchar"))
        return "StoreList(\"'\").StoreList(" + std::string(optional ? "*" : "") + name + ").StoreList(\"'\")";
    else if ((type == "string") || (type == "uuid"))
        return "StoreList(\"\\\"\").StoreList(" + std::string(optional ? "*" : "") + name + ").StoreList(\"\\\"\")";
    else
        return "StoreList(" + std::string(optional ? "*" : "") + name + ")";
}

std::string GeneratorCpp::ConvertLoggingStreamValue(const std::string& type, const std::string& name, bool optional, bool separate)
{
    std::string comma = separate ? "StoreList(first ? \"\" : \",\")." : "";

    if (optional)
        return "if (" + name + ") record." + comma + ConvertLoggingStreamType(type, name, true) + "; else record." + comma + "StoreList(\"null\");";
    else
        return "record." + comma + ConvertLoggingStreamType(type, name, false) + ";";
}

bool GeneratorCpp::IsVariantType(const std::shared_ptr<Package>& p, const std::string& type) {
    auto& variants = p->body->variants;
    return std::find_if(variants.begin(), variants.end(), [&type](const auto& v) -> bool {
        return *v->name == type;
    }) != variants.end();
}

bool GeneratorCpp::IsContainerType(const StructField &field) {
    return (field.array || field.vector || field.list || field.set || field.map || field.hash);
}

bool GeneratorCpp::IsContainerType(const VariantValue &variant) {
    return (variant.vector || variant.list || variant.map || variant.hash);
}

bool GeneratorCpp::IsStructType(const std::shared_ptr<Package>& p, const std::string& field_type) {
    for (const auto &s:  p->body->structs) {
        if (*s->name == field_type) {
            return true;
        }
    }
    return false;
}

std::string GeneratorCpp::ConvertPtrTypeName(const std::string& package, const std::string& type) {
    return ConvertTypeName(package, type, false);
}

// because of the y file. optional and typeptr will not be true in the same, and the ptr will never pointer to primitive type.
std::string GeneratorCpp::ConvertPtrTypeName(const std::string& package, const std::string& type, bool optional, bool typeptr, bool as_argument)
{
    // TODO: conflict with pointer, we need to check. Or omit?
    if (optional)
        return "std::optional<" + ConvertPtrTypeName(package, type) + ">";

    auto ret =  ConvertPtrTypeName(package, type);
    if (typeptr)
    {
        if (as_argument)
            return "std::unique_ptr<" + ret + ">";
        else
            return ret + "*";
    }
    return ret;
}

std::string
GeneratorCpp::ConvertPtrTypeName(const std::string &package, const StructField &field, bool as_argument)
{
    std::string prefix = "std";
    if (Arena()) {
        prefix = "pmr";
    }
    bool typeptr = field.ptr;
    if (field.array)
        return "std::array<" + ConvertPtrTypeName(package, *field.type, field.optional, typeptr, as_argument) + ", " + std::to_string(field.N) + ">";
    else if (field.optional)
        return "std::optional<" + ConvertPtrTypeName(package, *field.type) + ">";
    else if (field.vector)
        return (Arena() ? "pmr::vector<" : "FastVec<") + ConvertPtrTypeName(package, *field.type, field.optional, typeptr, as_argument) + ">";
    else if (field.list)
        return prefix + "::list<" + ConvertPtrTypeName(package, *field.type, field.optional, typeptr, as_argument) + ">";
    else if (field.set)
        return prefix + "::set<" + ConvertPtrTypeName(package, *field.key, false, typeptr, as_argument) + ">";
    else if (field.map)
        return prefix + "::map<" + ConvertPtrTypeName(package, *field.key, false, false, as_argument) + ", " + ConvertPtrTypeName(package, *field.type, field.optional, typeptr, as_argument) +">";
    else if (field.hash)
        return prefix + "::unordered_map<" + ConvertPtrTypeName(package, *field.key, false, false, as_argument) + ", " + ConvertPtrTypeName(package, *field.type, field.optional, typeptr, as_argument) +">";
    auto s = ConvertPtrTypeName(package, *field.type, field.optional, typeptr, as_argument);
    if (Ptr() && !IsKnownType(*field.type) && !field.ptr && as_argument)
        s += "&&";
    return s;
}

std::string GeneratorCpp::ConvertVariantTypeName(const std::string& package, const VariantValue& variant)
{
    std::string prefix = "std";
    if (Arena()) {
        prefix = "pmr";
    }
    if (variant.vector)
        return (Arena() ? "pmr::vector<" : "FastVec<") + ConvertPtrTypeName(package, *variant.type, false, variant.ptr, false) + ">";
    else if (variant.list)
        return prefix + "::list<" + ConvertPtrTypeName(package, *variant.type, false, variant.ptr, false) + ">";
    else if (variant.map)
        return prefix + "::map<" + ConvertPtrTypeName(package, *variant.key, false, false, false) + ", " + ConvertPtrTypeName(package, *variant.type, false, variant.ptr, false) +">";
    else if (variant.hash)
        return prefix + "::unordered_map<" + ConvertPtrTypeName(package, *variant.key, false, false, false) + ", " + ConvertPtrTypeName(package, *variant.type, false, variant.ptr, false) +">";
    return ConvertPtrTypeName(package, *variant.type, false, variant.ptr, false);
}

std::string GeneratorCpp::ConvertVariantTypeNameAsArgument(const std::string& package, const VariantValue& variant)
{
    if (variant.ptr) {
        return "const " + ConvertVariantTypeName(package, variant);
    }
    if (IsContainerType(variant))
        return "const " + ConvertVariantTypeName(package, variant) + "&";
    if (IsPrimitiveType(*variant.type, false)) {
        return ConvertVariantTypeName(package, variant);
    }
    return "const " + ConvertVariantTypeName(package, variant) + "&";
}

// two cases:
// 1. struct should be rvalue references, because we disable copy cstr
// 2. for container of ptrs, use unique_ptr instead.
std::string GeneratorCpp::ConvertPtrTypeNameAsArgument(const std::string& package, const StructField& field)
{
    if (field.ptr || IsPrimitiveType(*field.type, false))
        return ConvertPtrTypeName(package, field, true);
    if (IsKnownType(*field.type))
        return "const " + ConvertPtrTypeName(package, field, true) + "&";

    return ConvertPtrTypeName(package, field, true);
}

// Generates fieldmodel for data members in a struct field.
// only used for ptr-based FBE
std::string GeneratorCpp::ConvertPtrFieldModelType(const std::shared_ptr<Package>& p, const std::shared_ptr<StructField>& field) {
    std::string field_model_type;
    if (IsStructType(p, *field->type) || (ImportPtr() && !IsCurrentPackageType(*field->type))) {
        std::string model_name = std::string("FieldModel") + (Arena() ? "PMR" : "") + (field->ptr ? "Ptr" : "") + "_" +  (IsCurrentPackageType(*field->type) ? (*p->name + "_") : "") + *field->type;
        replace_all(model_name, ".", "_");
        if (IsContainerType(*field)) {
            field_model_type = "FieldModel";
            if (field->array) {
                field_model_type += "CustomArray<" + model_name + ", " + ConvertPtrTypeName(*p->name, *field->type) + ", " + std::to_string(field->N) + ">";
            } else if (field->vector || field->list || field->set) {
                field_model_type += "CustomVector<" + model_name + ", " + ConvertPtrTypeName(*p->name, *field->type) + ">";
            } else if (field->map || field->hash) {
                // TODO: specification是可以指定为key的，但是因为StructField的ptr指针对value，所以我们暂且不支持对key支持pointer
                std::string kType;
                // 1. struct type
                // 2. import-ptr struct type
                if (IsStructType(p, *field->key) || (!IsCurrentPackageType(*field->key) && ImportPtr())) {
                    kType = std::string("FieldModel") + "_" + (IsCurrentPackageType(*field->type) ? (*p->name + "_") : "") + *field->type;
                    replace_all(kType, ".", "_");

                } else {
                    kType = std::string("FieldModel<") + ConvertPtrTypeName(*p->name, *field->key) + ">";
                }
                auto kStruct = ConvertPtrTypeName(*p->name, *field->key);
                auto vStruct = ConvertPtrTypeName(*p->name, *field->type);
                field_model_type += "CustomMap<" + kType + ", " + model_name + ", " + kStruct  + ", " + vStruct + ">";
            }
        } else if (field->optional) {
            field_model_type = "FieldModelStructOptional<" + model_name + ", " + ConvertPtrTypeName(*p->name, *field->type) + ">";
        } else
            field_model_type = model_name;
    } else if (field->array)
        field_model_type = "FieldModelArray<" + ConvertPtrTypeName(*p->name, *field->type, field->optional, field->ptr, false) + ", " + std::to_string(field->N) + ">";
    else if (field->vector || field->list || field->set)
        field_model_type = "FieldModelVector<" + ConvertPtrTypeName(*p->name, *field->type, field->optional, field->ptr, false) + ">";
    else if (field->map || field->hash)
        field_model_type = "FieldModelMap<" + ConvertPtrTypeName(*p->name, *field->key) + ", " + ConvertPtrTypeName(*p->name, *field->type, field->optional, field->ptr, false) + ">";
    else
        field_model_type = "FieldModel<" + ConvertPtrTypeName(*p->name, *field->type, field->optional, field->ptr, false) + ">";
    return field_model_type;
}

std::string GeneratorCpp::ConvertPtrVariantFieldModelType(const std::shared_ptr<Package>& p, const std::shared_ptr<VariantValue>& variant) {
    std::string variant_field_model_type;
    if (Ptr()) {
        if (IsStructType(p, *variant->type) && !IsKnownType(*variant->type)) {
            std::string model_name = std::string("FieldModel") + (Arena() ? "PMR" : "") + (variant->ptr ? "Ptr" : "") + "_" + *p->name + "_" + *variant->type;
            if (IsContainerType(*variant)) {
                variant_field_model_type = "FieldModel";
                if (variant->vector || variant->list)
                    variant_field_model_type += "CustomVector<" + model_name + ", " + ConvertPtrTypeName(*p->name, *variant->type) + ">";
                else if (variant->map || variant->hash){
                    std::string kType = "FieldModel";
                    if (IsKnownType(*variant->key)) {
                        kType += "<" + ConvertPtrTypeName(*p->name, *variant->key) + ">";
                    } else {
                        kType +=  "_" + *p->name + "_" + *variant->type;
                    }
                    auto kStruct = ConvertPtrTypeName(*p->name, *variant->key);
                    auto vStruct = ConvertPtrTypeName(*p->name, *variant->type);
                    variant_field_model_type += "CustomMap<" + kType + ", " + model_name + ", " + kStruct  + ", " + vStruct + ">";
                }
            } else {
                variant_field_model_type += model_name;
            }
        }  else if (variant->vector || variant->list)
            variant_field_model_type = "FieldModelVector<" + ConvertPtrTypeName(*p->name, *variant->type, false, variant->ptr, false) + ">";
        else if (variant->map || variant->hash)
            variant_field_model_type = "FieldModelMap<" + ConvertPtrTypeName(*p->name, *variant->key) + ", " + ConvertPtrTypeName(*p->name, *variant->type, false, variant->ptr, false) + ">";
        else
            variant_field_model_type = "FieldModel<" + ConvertPtrTypeName(*p->name, *variant->type, false, variant->ptr, false) + ">";
    } else if (variant->vector || variant->list) // template based
        variant_field_model_type = "FieldModelVector<" + ConvertTypeName(*p->name, *variant->type, false) + ">";
    else if (variant->map || variant->hash)
        variant_field_model_type = "FieldModelMap<" + ConvertTypeName(*p->name, *variant->key, false) + ", " + ConvertTypeName(*p->name, *variant->type, false) + ">";
    else
        variant_field_model_type = "FieldModel<" + ConvertTypeName(*p->name, *variant->type, false) + ">";
    return variant_field_model_type;
}

bool GeneratorCpp::IsCurrentPackageType(const std::string& field_type, const std::string& delimiter) {
    auto found_delimiter = field_type.find(delimiter);
    return found_delimiter == std::string::npos;
}

std::string GeneratorCpp::ConvertNamespace(const std::string& package) {
    return package + (Arena() ? "_pmr" : ""); // we prefer _pmr over ::pmr to avoid conflicting with STL pmr
}

std::string GeneratorCpp::ConvertFileName(const std::string& package, FileType file_type, bool is_header, bool is_ptr, bool is_final) {
    std::string filename = package + (is_ptr ? "_ptr" : "") + (is_final ? "_final" : "");
    // final is in conflicting with pmr
    if (!is_final && Arena()) {
        filename += "_pmr";
    }
    switch (file_type) {
        case FileType::Struct:
            break;
        case FileType::Model:
            filename += "_models";
            break;
        // case FileType::JSON:
        //     filename += "_json";
        //     break;
        // case FileType::PROTOCOL:
        //     filename += "_protocol";
        //     break;
        default:
            break;
    }
    return filename + (is_header ? ".h" : ".cpp");
}

} // namespace FBE
