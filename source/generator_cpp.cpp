/*
 * Copyright (C) 2020 Beijing Jinyi Data Technology Co., Ltd. All rights
 * reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*!
    \file generator_cpp.cpp
    \brief Fast binary encoding C++ generator implementation
    \author Ivan Shynkarenka
    \date 20.04.2018
    \copyright AGPL-3.0-or-later
*/
#include "generator_cpp.h"
#include "fbe.h"
#include "generator_cpp_fixture.h"
#include <memory>
#include <variant>

namespace FBE {

void GeneratorCpp::Generate(const std::shared_ptr<Package> &package) {
  // Generate common files
  GenerateFBE_Header(_output);
  GenerateFBE_Source(_output);

  // Generate common models files
  GenerateFBEModels_Header(_output);
  GenerateFBEModels_Inline(_output);
  GenerateFBEModels_Source(_output);

  if (Ptr()) {
    GenerateFBEPtr_Header(_output);
    GenerateFBECustomModels_Header(_output);
    GenerateFBECustomModels_Inline(_output);

    // Generate package files
    GeneratePtrPackage_Header(package);
    GeneratePtrPackage_Source(package);
    // Generate package models files
    GeneratePtrPackageModels_Header(package);
    GeneratePtrPackageModels_Source(package);
    return;
  }

  if (Final()) {
    GenerateFBEFinalModels_Header(_output);
    GenerateFBEFinalModels_Inline(_output);
    GenerateFBEFinalModels_Source(_output);
  }

  // Generate common protocol files
  if (Proto()) {
    GenerateFBEProtocol_Header(_output);
    GenerateFBEProtocol_Source(_output);
  }

  // Generate common JSON files
  if (JSON())
    GenerateFBEJson_Header(_output);

  // Generate package files
  GeneratePackage_Header(package);
  GeneratePackage_Source(package);
  if (JSON())
    GeneratePackage_Json(package);

  // Generate package models files
  GeneratePackageModels_Header(package);
  GeneratePackageModels_Source(package);
  if (Final()) {
    GeneratePackageFinalModels_Header(package);
    GeneratePackageFinalModels_Source(package);
  }

  // Generate package protocol files
  if (Proto()) {
    GeneratePackageProtocol_Header(package, false);
    GeneratePackageProtocol_Source(package, false);
    if (Final()) {
      GeneratePackageProtocol_Header(package, true);
      GeneratePackageProtocol_Source(package, true);
    }
  }
}

void GeneratorCpp::GenerateBannerComments(const std::string &source) {
  std::string code =
      R"CODE(//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: _INPUT_
// FBE version: _VERSION_
//------------------------------------------------------------------------------
)CODE";

  // Prepare code template
  code = std::regex_replace(code, std::regex("_INPUT_"), source);
  code = std::regex_replace(code, std::regex("_VERSION_"), version);
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateHeader(const std::string &source) {
  GenerateBannerComments(source);
  std::string code = R"CODE(
#pragma once

#ifdef isset
#undef isset
#endif

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif
)CODE";

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateInline(const std::string &source) {
  GenerateBannerComments(source);
}

void GeneratorCpp::GenerateSource(const std::string &source) {
  GenerateBannerComments(source);
}

void GeneratorCpp::GenerateWarningsHeader() {
  std::string code = R"CODE(
#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable:4065) // C4065: switch statement contains 'default' but no 'case' labels
#endif
)CODE";

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateWarningsFooter() {
  std::string code = R"CODE(
#if defined(_MSC_VER)
#pragma warning(pop)
#endif
)CODE";

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFooter() {}

void GeneratorCpp::GenerateImports() {
  std::string code = GeneratorCPPFixture::GenerateImports();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);

  // Generate logging protocol definitions
  if (Logging()) {
    WriteLine();
    WriteLineIndent("#define LOGGING_PROTOCOL 1");
    WriteLineIndent("#include <logging/logger.h>");
  }
}

void GeneratorCpp::GenerateImportsSource() {
  std::string code = GeneratorCPPFixture::GenerateImportsSource();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateImports(const std::string &source) {
  WriteLine();
  WriteLineIndent("#include \"" + source + "\"");
}

void GeneratorCpp::GenerateImports(const std::shared_ptr<Package> &p) {
  // Generate common imports
  WriteLine();
  WriteLineIndent("#include \"fbe.h\"");
  if (Arena()) {
    WriteLineIndent("#include \"" + ArenaHeader() + "\"");
  }

  // Generate packages import
  if (p->import) {
    WriteLine();
    for (const auto &import : p->import->imports)
      WriteLineIndent(
          "#include \"" +
          ConvertFileName(*import, FileType::Struct, true, ImportPtr()) + "\"");
  }

  // Generate domain namespace using
  WriteLine();
  WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");
  WriteLineIndent("using namespace FBE;");
  if (Arena()) {
    WriteLineIndent(
        "using allocator_type = std::pmr::polymorphic_allocator<char>;");
  }
  WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));

  // Generate FBE namespace using
  WriteLine();
  WriteLineIndent("namespace FBE {");
  WriteLineIndent("using namespace ::" + ConvertNamespace(*p->name) + ";");
  WriteLineIndent("} // namespace FBE");
}

void GeneratorCpp::GenerateImportsModels(const std::shared_ptr<Package> &p,
                                         bool final, bool ptr) {
  // Generate common imports
  WriteLine();
  WriteLineIndent("#include \"" +
                  ConvertFileName(*p->name, FileType::Struct, true, ptr) +
                  "\""); // import structs

  // Generate packages import
  if (p->import) {
    WriteLine();
    for (const auto &import : p->import->imports)
      WriteLineIndent(
          "#include \"" +
          ConvertFileName(*import, FileType::Model, true, ImportPtr(), final) +
          "\"");
  }
}

void GeneratorCpp::GenerateImportsProtocol(const std::shared_ptr<Package> &p,
                                           bool final) {
  // Generate common imports
  WriteLine();
  WriteLineIndent("#include \"" + *p->name + (final ? "_final" : "") +
                  "_models.h\"");

  // Generate packages import
  if (p->import) {
    WriteLine();
    for (const auto &import : p->import->imports)
      WriteLineIndent("#include \"" + *import + (final ? "_final" : "") +
                      "_protocol.h\"");
  }
}

void GeneratorCpp::GenerateImportsJson() {
  WriteLine();
  WriteLineIndent("#define RAPIDJSON_HAS_STDSTRING 1");
  WriteLineIndent("#include <rapidjson/document.h>");
  WriteLineIndent("#include <rapidjson/prettywriter.h>");
}

void GeneratorCpp::GenerateImportsJson(const std::shared_ptr<Package> &p) {
  // Generate common imports
  WriteLine();
  WriteLineIndent("#include \"fbe_json.h\"");

  // Generate common imports
  WriteLine();
  WriteLineIndent("#include \"" + *p->name + ".h\"");

  // Generate packages import
  if (p->import) {
    WriteLine();
    for (const auto &import : p->import->imports)
      WriteLineIndent("#include \"" + *import + "_json.h\"");
  }
}

void GeneratorCpp::GenerateUnalignedAccessor_Header() {
  std::string code = R"CODE(
template <typename T>
[[gnu::always_inline]] inline auto unaligned_load(void const* ptr) noexcept -> T {
    T t;
    std::memcpy(&t, ptr, sizeof(T));
    return t;
}

template <typename T>
[[gnu::always_inline]] inline void unaligned_store(void *ptr, T v) noexcept {
    std::memcpy(ptr, &v, sizeof(T));
}

// Specializations for common types to help compiler optimize
template <>
[[gnu::always_inline]] inline auto unaligned_load<uint8_t>(void const* ptr) noexcept -> uint8_t {
    return *static_cast<const uint8_t*>(ptr);
}

template <>
[[gnu::always_inline]] inline auto unaligned_load<int8_t>(void const* ptr) noexcept -> int8_t {
    return *static_cast<const int8_t*>(ptr);
}

template <>
[[gnu::always_inline]] inline void unaligned_store<uint8_t>(void *ptr, uint8_t v) noexcept {
    *static_cast<uint8_t*>(ptr) = v;
}

template <>
[[gnu::always_inline]] inline void unaligned_store<int8_t>(void *ptr, int8_t v) noexcept {
    *static_cast<int8_t*>(ptr) = v;
}
)CODE";

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateImportHelper_Header() {
  std::string code = R"CODE(
template<typename T> struct is_variant : std::false_type {};

template<typename ...Args>
struct is_variant<std::variant<Args...>> : std::true_type {};

template<typename T>
inline constexpr bool is_variant_v=is_variant<T>::value;

template<typename T, typename Alloc>
auto assign_member(Alloc alloc) -> T {
    return T(alloc);
}

template<typename T, typename Alloc>
requires std::is_enum_v<T> || is_variant_v<T>
auto assign_member([[maybe_unused]] Alloc alloc) -> T {
    return T();
}

template <typename T>
struct model_of {};
)CODE";

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateVariantVisitHelper_Header() {
  std::string code = R"CODE(
template<class... Ts> struct overloaded : Ts... { using Ts::operator()...; };

template<class... Ts> overloaded(Ts...) -> overloaded<Ts...>;  // deduction guide
)CODE";

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateBufferWrapper_Header() {
  std::string code = GeneratorCPPFixture::GenerateBufferWrapper_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateBufferWrapper_Source() {
  std::string code = GeneratorCPPFixture::GenerateBufferWrapper_Source();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());
  Write(code);
}

void GeneratorCpp::GeneratePMRBufferWrapper_Header() {
  std::string code = GeneratorCPPFixture::GeneratePMRBufferWrapper_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GeneratePMRBufferWrapper_Source() {
  std::string code = GeneratorCPPFixture::GeneratePMRBufferWrapper_Source();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());
  Write(code);
}

void GeneratorCpp::GenerateDecimalWrapper_Header() {
  std::string code = GeneratorCPPFixture::GenerateDecimalWrapper_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFlagsWrapper_Header() {
  std::string code = GeneratorCPPFixture::GenerateFlagsWrapper_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateTimeWrapper_Header() {
  std::string code = GeneratorCPPFixture::GenerateTimeWrapper_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateTimeWrapper_Source() {
  std::string code = GeneratorCPPFixture::GenerateTimeWrapper_Source();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateUUIDWrapper_Header() {
  std::string code = GeneratorCPPFixture::GenerateUUIDWrapper_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateUUIDWrapper_Source() {
  std::string code = GeneratorCPPFixture::GenerateUUIDWrapper_Source();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEBuffer_Header() {
  std::string code = GeneratorCPPFixture::GenerateFBEBuffer_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEBuffer_Source() {
  std::string code = GeneratorCPPFixture::GenerateFBEBuffer_Source();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEBaseModel_Header() {
  std::string code = GeneratorCPPFixture::GenerateFBEBaseModel_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModel_Header() {
  std::string code = GeneratorCPPFixture::GenerateFBEFieldModel_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModel_Inline() {
  std::string code = GeneratorCPPFixture::GenerateFBEFieldModel_Inline();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelDecimal_Header() {
  std::string code = GeneratorCPPFixture::GenerateFBEFieldModelDecimal_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelDecimal_Source() {
  std::string code = GeneratorCPPFixture::GenerateFBEFieldModelDecimal_Source();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelUUID_Header() {
  std::string code = GeneratorCPPFixture::GenerateFBEFieldModelUUID_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelUUID_Source() {
  std::string code = GeneratorCPPFixture::GenerateFBEFieldModelUUID_Source();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelBytes_Header() {
  std::string code = GeneratorCPPFixture::GenerateFBEFieldModelBytes_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelBytes_Source() {
  std::string code = GeneratorCPPFixture::GenerateFBEFieldModelBytes_Source();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelPMRBytes_Header() {
  std::string code =
      GeneratorCPPFixture::GenerateFBEFieldModelPMRBytes_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelPMRBytes_Source() {
  std::string code =
      GeneratorCPPFixture::GenerateFBEFieldModelPMRBytes_Source();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelFBEString_Header() {
  std::string code =
      GeneratorCPPFixture::GenerateFBEFieldModelFBEString_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModeArenaString_Header() {
  std::string code =
      GeneratorCPPFixture::GenerateFBEFieldModeArenaString_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelFBEString_Source() {
  std::string code =
      GeneratorCPPFixture::GenerateFBEFieldModelFBEString_Source();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelMemoryArenaString_Source() {
  std::string code =
      GeneratorCPPFixture::GenerateFBEFieldModelMemoryArenaString_Source();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelOptional_Header() {
  std::string code =
      GeneratorCPPFixture::GenerateFBEFieldModelOptional_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelOptional_Inline() {
  std::string code =
      GeneratorCPPFixture::GenerateFBEFieldModelOptional_Inline();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelArray_Header() {
  std::string code = GeneratorCPPFixture::GenerateFBEFieldModelArray_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelArray_Inline() {
  std::string code = GeneratorCPPFixture::GenerateFBEFieldModelArray_Inline();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelVector_Header() {
  std::string code = GeneratorCPPFixture::GenerateFBEFieldModelVector_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelVector_Inline() {
  std::string code = GeneratorCPPFixture::GenerateFBEFieldModelVector_Inline();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());
  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelMap_Header() {
  std::string code = GeneratorCPPFixture::GenerateFBEFieldModelMap_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());
  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelMap_Inline() {
  std::string code = GeneratorCPPFixture::GenerateFBEFieldModelMap_Inline();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());
  Write(code);
}

void GeneratorCpp::GenerateFBEFinalModel_Header() {
  std::string code = GeneratorCPPFixture::GenerateFBEFinalModel_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFinalModel_Inline() {
  std::string code = GeneratorCPPFixture::GenerateFBEFinalModel_Inline();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelDecimal_Header() {
  std::string code = GeneratorCPPFixture::GenerateFBEFinalModelDecimal_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelDecimal_Source() {
  std::string code = GeneratorCPPFixture::GenerateFBEFinalModelDecimal_Source();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelUUID_Header() {
  std::string code = GeneratorCPPFixture::GenerateFBEFinalModelUUID_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelUUID_Source() {
  std::string code = GeneratorCPPFixture::GenerateFBEFinalModelUUID_Source();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelBytes_Header() {
  std::string code = GeneratorCPPFixture::GenerateFBEFinalModelBytes_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelBytes_Source() {
  std::string code = GeneratorCPPFixture::GenerateFBEFinalModelBytes_Source();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelPMRBytes_Header() {
  std::string code =
      GeneratorCPPFixture::GenerateFBEFinalModelPMRBytes_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelPMRBytes_Source() {
  std::string code =
      GeneratorCPPFixture::GenerateFBEFinalModelPMRBytes_Source();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelString_Header() {
  std::string code = GeneratorCPPFixture::GenerateFBEFinalModelString_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelString_Source() {
  std::string code = GeneratorCPPFixture::GenerateFBEFinalModelString_Source();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelArenaString_Header() {
  std::string code =
      GeneratorCPPFixture::GenerateFBEFinalModelArenaString_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelArenaString_Source() {
  std::string code =
      GeneratorCPPFixture::GenerateFBEFinalModelArenaString_Source();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelOptional_Header() {
  std::string code =
      GeneratorCPPFixture::GenerateFBEFinalModelOptional_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelOptional_Inline() {
  std::string code =
      GeneratorCPPFixture::GenerateFBEFinalModelOptional_Inline();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelArray_Header() {
  std::string code = GeneratorCPPFixture::GenerateFBEFinalModelArray_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelArray_Inline() {
  std::string code = GeneratorCPPFixture::GenerateFBEFinalModelArray_Inline();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelVector_Header() {
  std::string code = GeneratorCPPFixture::GenerateFBEFinalModelVector_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelVector_Inline() {
  std::string code = GeneratorCPPFixture::GenerateFBEFinalModelVector_Inline();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelMap_Header() {
  std::string code = GeneratorCPPFixture::GenerateFBEFinalModelMap_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFinalModelMap_Inline() {
  std::string code = GeneratorCPPFixture::GenerateFBEFinalModelMap_Inline();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBESender_Header() {
  std::string code = GeneratorCPPFixture::GenerateFBESender_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBESender_Source() {
  std::string code = GeneratorCPPFixture::GenerateFBESender_Source();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEReceiver_Header() {
  std::string code = GeneratorCPPFixture::GenerateFBEReceiver_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEReceiver_Source() {
  std::string code = GeneratorCPPFixture::GenerateFBEReceiver_Source();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEJson() {
  std::string code = GeneratorCPPFixture::GenerateFBEJson();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBE_Header(const fs::path &path) {
  // Create package path
  create_dir(path);

  // Generate the common file
  fs::path common = path / "fbe.h";
  WriteBegin();

  // Generate common header
  GenerateHeader("FBE");

  // Generate imports
  GenerateImports();

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");

  // Generate common body
  GenerateUnalignedAccessor_Header();
  GenerateImportHelper_Header();
  GenerateVariantVisitHelper_Header();
  GenerateBufferWrapper_Header();
  GeneratePMRBufferWrapper_Header();
  GenerateDecimalWrapper_Header();
  GenerateFlagsWrapper_Header();
  GenerateTimeWrapper_Header();
  GenerateUUIDWrapper_Header();
  GenerateFBEBuffer_Header();
  GenerateFBEBaseModel_Header();

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate common footer
  GenerateFooter();

  // Store the common file
  WriteEnd();
  Store(common);
}

void GeneratorCpp::GenerateFBE_Source(const fs::path &path) {
  // Create package path
  create_dir(path);

  // Generate the common file
  fs::path common = path / "fbe.cpp";
  WriteBegin();

  // Generate common source
  GenerateSource("FBE");

  // Generate imports
  GenerateImports("fbe.h");

  // Generate imports source
  GenerateImportsSource();

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");

  // Generate common body
  GenerateBufferWrapper_Source();
  GeneratePMRBufferWrapper_Source();
  GenerateTimeWrapper_Source();
  GenerateUUIDWrapper_Source();
  GenerateFBEBuffer_Source();

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate common footer
  GenerateFooter();

  // Store the common file
  WriteEnd();
  Store(common);
}

void GeneratorCpp::GenerateFBEModels_Header(const fs::path &path) {
  // Create package path
  create_dir(path);

  // Generate the field models file
  fs::path common = path / "fbe_models.h";
  WriteBegin();

  // Generate field models header
  GenerateHeader("FBE");

  // Generate imports
  GenerateImports("fbe.h");

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");

  // Generate field models
  GenerateFBEFieldModel_Header();
  GenerateFBEFieldModelDecimal_Header();
  GenerateFBEFieldModelUUID_Header();
  GenerateFBEFieldModelBytes_Header();
  GenerateFBEFieldModelPMRBytes_Header();
  //    GenerateFBEFieldModelString_Header();
  //    GenerateFBEFieldModelPMRString_Header();
  GenerateFBEFieldModelFBEString_Header();
  GenerateFBEFieldModeArenaString_Header();
  GenerateFBEFieldModelOptional_Header();
  GenerateFBEFieldModelArray_Header();
  GenerateFBEFieldModelVector_Header();
  GenerateFBEFieldModelMap_Header();

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate inline import
  GenerateImports("fbe_models.inl");

  // Generate field models footer
  GenerateFooter();

  // Store the field models file
  WriteEnd();
  Store(common);
}

void GeneratorCpp::GenerateFBEModels_Inline(const fs::path &path) {
  // Create package path
  create_dir(path);

  // Generate the field models file
  fs::path common = path / "fbe_models.inl";
  WriteBegin();

  // Generate field models inline
  GenerateInline("FBE");

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");

  // Generate field models
  GenerateFBEFieldModel_Inline();
  GenerateFBEFieldModelOptional_Inline();
  GenerateFBEFieldModelArray_Inline();
  GenerateFBEFieldModelVector_Inline();
  GenerateFBEFieldModelMap_Inline();

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate field models footer
  GenerateFooter();

  // Store the field models file
  WriteEnd();
  Store(common);
}

void GeneratorCpp::GenerateFBEModels_Source(const fs::path &path) {
  // Create package path
  create_dir(path);

  // Generate the field models file
  fs::path common = path / "fbe_models.cpp";
  WriteBegin();

  // Generate field models source
  GenerateSource("FBE");

  // Generate imports
  GenerateImports("fbe_models.h");

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");

  // Generate field models
  GenerateFBEFieldModelDecimal_Source();
  GenerateFBEFieldModelUUID_Source();
  GenerateFBEFieldModelBytes_Source();
  GenerateFBEFieldModelPMRBytes_Source();
  //    GenerateFBEFieldModelString_Source();
  //    GenerateFBEFieldModelPMRString_Source();
  GenerateFBEFieldModelFBEString_Source();
  GenerateFBEFieldModelMemoryArenaString_Source();

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate field models footer
  GenerateFooter();

  // Store the field models file
  WriteEnd();
  Store(common);
}

void GeneratorCpp::GenerateFBEFinalModels_Header(const fs::path &path) {
  // Create package path
  create_dir(path);

  // Generate the final models file
  fs::path common = path / "fbe_final_models.h";
  WriteBegin();

  // Generate final models header
  GenerateHeader("FBE");

  // Generate imports
  GenerateImports("fbe.h");

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");

  // Generate final models
  GenerateFBEFinalModel_Header();
  GenerateFBEFinalModelDecimal_Header();
  GenerateFBEFinalModelUUID_Header();
  GenerateFBEFinalModelBytes_Header();
  GenerateFBEFinalModelPMRBytes_Header();
  GenerateFBEFinalModelString_Header();
  GenerateFBEFinalModelArenaString_Header();
  GenerateFBEFinalModelOptional_Header();
  GenerateFBEFinalModelArray_Header();
  GenerateFBEFinalModelVector_Header();
  GenerateFBEFinalModelMap_Header();

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate inline import
  GenerateImports("fbe_final_models.inl");

  // Generate final models footer
  GenerateFooter();

  // Store the final models file
  WriteEnd();
  Store(common);
}

void GeneratorCpp::GenerateFBEFinalModels_Inline(const fs::path &path) {
  // Create package path
  create_dir(path);

  // Generate the final models file
  fs::path common = path / "fbe_final_models.inl";
  WriteBegin();

  // Generate final models inline
  GenerateInline("FBE");

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");

  // Generate final models
  GenerateFBEFinalModel_Inline();
  GenerateFBEFinalModelOptional_Inline();
  GenerateFBEFinalModelArray_Inline();
  GenerateFBEFinalModelVector_Inline();
  GenerateFBEFinalModelMap_Inline();

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate final models footer
  GenerateFooter();

  // Store the final models file
  WriteEnd();
  Store(common);
}

void GeneratorCpp::GenerateFBEFinalModels_Source(const fs::path &path) {
  // Create package path
  create_dir(path);

  // Generate the final models file
  fs::path common = path / "fbe_final_models.cpp";
  WriteBegin();

  // Generate final models source
  GenerateSource("FBE");

  // Generate imports
  GenerateImports("fbe_final_models.h");

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");

  // Generate final models
  GenerateFBEFinalModelDecimal_Source();
  GenerateFBEFinalModelUUID_Source();
  GenerateFBEFinalModelBytes_Source();
  GenerateFBEFinalModelPMRBytes_Source();
  GenerateFBEFinalModelString_Source();
  GenerateFBEFinalModelArenaString_Source();

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate final models footer
  GenerateFooter();

  // Store the final models file
  WriteEnd();
  Store(common);
}

void GeneratorCpp::GenerateFBEProtocol_Header(const fs::path &path) {
  // Create package path
  create_dir(path);

  // Generate the protocol file
  fs::path common = path / "fbe_protocol.h";
  WriteBegin();

  // Generate protocol header
  GenerateHeader("FBE");

  // Generate imports
  GenerateImports("fbe.h");

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");

  // Generate protocol
  GenerateFBESender_Header();
  GenerateFBEReceiver_Header();

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate protocol footer
  GenerateFooter();

  // Store the protocol file
  WriteEnd();
  Store(common);
}

void GeneratorCpp::GenerateFBEProtocol_Source(const fs::path &path) {
  // Create package path
  create_dir(path);

  // Generate the protocol file
  fs::path common = path / "fbe_protocol.cpp";
  WriteBegin();

  // Generate protocol source
  GenerateSource("FBE");

  // Generate imports
  GenerateImports("fbe_protocol.h");

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");

  // Generate protocol
  GenerateFBESender_Source();
  GenerateFBEReceiver_Source();

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate protocol footer
  GenerateFooter();

  // Store the protocol file
  WriteEnd();
  Store(common);
}

void GeneratorCpp::GenerateFBEJson_Header(const fs::path &path) {
  // Create package path
  create_dir(path);

  // Generate the JSON file
  fs::path common = path / "fbe_json.h";
  WriteBegin();

  // Generate JSON header
  GenerateHeader("FBE");

  // Generate imports
  GenerateImports("fbe.h");
  GenerateImportsJson();

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");

  // Generate JSON
  GenerateFBEJson();

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate JSON footer
  GenerateFooter();

  // Store the JSON file
  WriteEnd();
  Store(common);
}

void GeneratorCpp::GeneratePackage_Header(const std::shared_ptr<Package> &p) {
  fs::path output = _output;

  // Create package path
  create_dir(output);

  // Generate the output file
  output /= ConvertFileName(*p->name, FileType::Struct, true);
  WriteBegin();

  // Generate package header
  GenerateHeader(fs::path(_input).filename().string());

  // Generate imports
  GenerateImports(p);

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

  // Generate namespace body
  if (p->body) {
    // Generate child enums
    for (const auto &e : p->body->enums)
      GenerateEnum(p, e);

    // Generate child flags
    for (const auto &f : p->body->flags)
      GenerateFlags(p, f);

    if (!p->body->variants.empty()) {
      // forward declarations
      GeneratorStructForwardDeclaration(p->body->structs);
      for (const auto &v : p->body->variants) {
        GenerateVariantAlias(p, v);
      }
    }

    // Generate child structs
    for (const auto &s : p->body->structs)
      GenerateStruct_Header(p, s);
  }

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));

  // Generate package footer
  GenerateFooter();

  // Store the output file
  WriteEnd();
  Store(output);
}

void GeneratorCpp::GeneratorStructForwardDeclaration(
    const std::vector<std::shared_ptr<StructType>> &structs) {
  WriteLineIndent("// forward declaration");
  for (auto &s : structs) {
    WriteLine(std::string("struct ") + *s->name + ";");
  }
}

void GeneratorCpp::GeneratePackage_Source(const std::shared_ptr<Package> &p) {
  fs::path output = _output;

  // Create package path
  create_dir(output);

  // Generate the output file
  output /= ConvertFileName(*p->name, FileType::Struct, false);
  WriteBegin();

  // Generate package source
  GenerateSource(fs::path(_input).filename().string());

  // Generate imports
  GenerateImports(ConvertFileName(*p->name, FileType::Struct, true));

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

  // Generate namespace body
  if (p->body) {
    // Generate child enums
    for (const auto &e : p->body->enums) {
      // Generate enum output stream
      GenerateEnumOutputStream(e);

      // Generate enum logging stream
      if (Logging())
        GenerateEnumLoggingStream(e);
    }

    // Generate child flags
    for (const auto &f : p->body->flags) {
      // Generate flags output stream
      GenerateFlagsOutputStream(f);

      // Generate flags logging stream
      if (Logging())
        GenerateFlagsLoggingStream(f);
    }

    if (!p->body->variants.empty()) {
      for (const auto &v : p->body->variants) {
        GenerateVariantOutputStream(p, v);
      }
      WriteLine();
    }

    // Generate child structs
    for (const auto &s : p->body->structs) {
      GenerateStruct_Source(p, s);

      // Generate struct output stream
      GenerateStructOutputStream(p, s);

      // Generate struct logging stream
      if (Logging())
        GenerateStructLoggingStream(p, s);
    }
  }

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));

  // Generate package footer
  GenerateFooter();

  // Store the output file
  WriteEnd();
  Store(output);
}

void GeneratorCpp::GeneratePackage_Json(const std::shared_ptr<Package> &p) {
  fs::path output = _output;

  // Create package path
  create_dir(output);

  // Generate the output file
  output /= *p->name + "_json.h";
  WriteBegin();

  // Generate package header
  GenerateHeader(fs::path(_input).filename().string());

  // Generate imports
  GenerateImportsJson(p);

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");
  WriteLine();
  WriteLineIndent("namespace JSON {");

  // Generate namespace body
  if (p->body) {
    // Generate child enums
    for (const auto &e : p->body->enums)
      GenerateEnumJson(p, e);

    // Generate child flags
    for (const auto &f : p->body->flags)
      GenerateFlagsJson(p, f);

    // Generate child structs
    for (const auto &s : p->body->structs)
      GenerateStructJson(p, s);
  }

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace JSON");
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate package footer
  GenerateFooter();

  // Store the output file
  WriteEnd();
  Store(output);
}

void GeneratorCpp::GeneratePackageModels_Header(
    const std::shared_ptr<Package> &p) {
  fs::path output = _output;

  // Create package path
  create_dir(output);

  // Generate the output file
  output /= ConvertFileName(*p->name, FileType::Model, true);
  WriteBegin();

  // Generate package models header
  GenerateHeader(fs::path(_input).filename().string());

  // Generate imports
  GenerateImports("fbe_models.h");
  GenerateImportsModels(p, false, false);

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");

  // Generate namespace body
  if (p->body) {
    // Generate child enums
    for (const auto &e : p->body->enums) {
      // Generate enum field model
      GenerateEnumFieldModel(p, e);
    }

    // Generate child flags
    for (const auto &f : p->body->flags) {
      // Generate flags field model
      GenerateFlagsFieldModel(p, f);
    }

    // Generate variant
    for (const auto &v : p->body->variants) {
      GenerateVariantFieldModel_Header(p, v);
    }

    // Generate child structs
    for (const auto &s : p->body->structs) {
      // Generate struct field models
      GenerateStructFieldModel_Header(p, s);
      GenerateStructModel_Header(p, s);
    }
  }

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate package footer
  GenerateFooter();

  // Store the output file
  WriteEnd();
  Store(output);
}

void GeneratorCpp::GeneratePackageModels_Source(
    const std::shared_ptr<Package> &p) {
  fs::path output = _output;

  // Create package path
  create_dir(output);

  // Generate the output file
  output /= ConvertFileName(*p->name, FileType::Model, false);
  WriteBegin();

  // Generate package models source
  GenerateSource(fs::path(_input).filename().string());

  // Generate imports
  GenerateImports(ConvertFileName(*p->name, FileType::Model, true));

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");

  // Generate namespace body
  if (p->body) {
    // Generate variant
    for (const auto &v : p->body->variants) {
      GenerateVariantFieldModel_Source(p, v);
    }

    // Generate child structs
    for (const auto &s : p->body->structs) {
      // Generate struct field models
      GenerateStructFieldModel_Source(p, s);
      GenerateStructModel_Source(p, s);
    }
  }

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate package footer
  GenerateFooter();

  // Store the output file
  WriteEnd();
  Store(output);
}

void GeneratorCpp::GeneratePackageFinalModels_Header(
    const std::shared_ptr<Package> &p) {
  fs::path output = _output;

  // Create package path
  create_dir(output);

  // Generate the output file
  output /= ConvertFileName(*p->name, FileType::Model, true, false, true);
  WriteBegin();

  // Generate package final models header
  GenerateHeader(fs::path(_input).filename().string());

  // Generate imports
  GenerateImports("fbe_final_models.h");
  GenerateImportsModels(p, true, false);

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");

  // Generate namespace body
  if (p->body) {
    // Generate child enums
    for (const auto &e : p->body->enums) {
      // Generate enum final model
      GenerateEnumFinalModel(p, e);
    }

    // Generate child flags
    for (const auto &f : p->body->flags) {
      // Generate flags final model
      GenerateFlagsFinalModel(p, f);
    }

    // Generate child variants
    for (const auto &v : p->body->variants) {
      // Generate variant final model
      GenerateVariantFinalModel_Header(p, v);
    }

    // Generate child structs
    for (const auto &s : p->body->structs) {
      // Generate struct final models
      GenerateStructFinalModel_Header(p, s);
      GenerateStructModelFinal_Header(p, s);
    }
  }

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate package footer
  GenerateFooter();

  // Store the output file
  WriteEnd();
  Store(output);
}

void GeneratorCpp::GeneratePackageFinalModels_Source(
    const std::shared_ptr<Package> &p) {
  fs::path output = _output;

  // Create package path
  create_dir(output);

  // Generate the output file
  output /= ConvertFileName(*p->name, FileType::Model, false, false, true);
  WriteBegin();

  // Generate package final models source
  GenerateSource(fs::path(_input).filename().string());

  // Generate imports
  GenerateImports(
      ConvertFileName(*p->name, FileType::Model, true, false, true));

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");

  // Generate namespace body
  if (p->body) {
    // Generate child variants
    for (const auto &v : p->body->variants) {
      // Generate variant final model
      GenerateVariantFinalModel_Source(p, v);
    }

    // Generate child structs
    for (const auto &s : p->body->structs) {
      // Generate struct final models
      GenerateStructFinalModel_Source(p, s);
      GenerateStructModelFinal_Source(p, s);
    }
  }

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate package footer
  GenerateFooter();

  // Store the output file
  WriteEnd();
  Store(output);
}

void GeneratorCpp::GeneratePackageProtocol_Header(
    const std::shared_ptr<Package> &p, bool final) {
  fs::path output = _output;

  // Create package path
  create_dir(output);

  // Generate the output file
  output /= *p->name + (final ? "_final" : "") + "_protocol.h";
  WriteBegin();

  // Generate package protocol header
  GenerateHeader(fs::path(_input).filename().string());

  // Generate imports
  GenerateImports("fbe_protocol.h");
  GenerateImportsProtocol(p, final);

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");
  WriteLine();
  WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

  // Generate protocol version
  GenerateProtocolVersion(p);

  // Generate sender & receiver
  GenerateSender_Header(p, final);
  GenerateReceiver_Header(p, final);
  if (!final)
    GenerateProxy_Header(p, final);
  GenerateClient_Header(p, final);

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate package footer
  GenerateFooter();

  // Store the output file
  WriteEnd();
  Store(output);
}

void GeneratorCpp::GeneratePackageProtocol_Source(
    const std::shared_ptr<Package> &p, bool final) {
  fs::path output = _output;

  // Create package path
  create_dir(output);

  // Generate the output file
  output /= *p->name + (final ? "_final" : "") + "_protocol.cpp";
  WriteBegin();

  // Generate package protocol source
  GenerateSource(fs::path(_input).filename().string());

  // Generate warnings header
  GenerateWarningsHeader();

  // Generate imports
  GenerateImports(*p->name + (final ? "_final" : "") + "_protocol.h");

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");
  WriteLine();
  WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

  // Generate sender & receiver
  GenerateSender_Source(p, final);
  GenerateReceiver_Source(p, final);
  if (!final)
    GenerateProxy_Source(p, final);
  GenerateClient_Source(p, final);

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate warnings footer
  GenerateWarningsFooter();

  // Generate package footer
  GenerateFooter();

  // Store the output file
  WriteEnd();
  Store(output);
}

void GeneratorCpp::GenerateEnum(const std::shared_ptr<Package> &p,
                                const std::shared_ptr<EnumType> &e) {
  // Generate enum begin
  WriteLine();
  WriteIndent("enum class " +
              std::string(e->attributes->deprecated ? "[[deprecated]] " : "") +
              *e->name);
  if (e->base && !e->base->empty())
    Write(" : " + ConvertEnumType(*e->base));
  WriteLine();
  WriteLineIndent("{");
  Indent(1);

  std::string enum_type = (e->base && !e->base->empty()) ? *e->base : "int32";

  // Generate enum body
  if (e->body) {
    for (const auto &value : e->body->values) {
      WriteIndent(*value->name);
      if (value->attributes->deprecated)
        Write(" [[deprecated]]");
      if (value->value) {
        if (value->value->constant && !value->value->constant->empty())
          Write(" = " +
                ConvertConstant(enum_type, *value->value->constant, false));
        else if (value->value->reference && !value->value->reference->empty())
          Write(" = " + ConvertConstant("", *value->value->reference, false));
      }
      WriteLine(",");
    }
  }

  // Generate enum end
  Indent(-1);
  WriteLineIndent("};");

  // Generate enum output stream operator declaration
  WriteLine();
  WriteLineIndent(
      "std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] " +
      *e->name + " value);");

  // Generate enum logging stream operator declaration
  WriteLine();
  WriteLineIndent("#if defined(LOGGING_PROTOCOL)");
  WriteLineIndent(
      "CppLogging::Record& operator<<(CppLogging::Record& record, " + *e->name +
      " value);");
  WriteLineIndent("#endif");
}

void GeneratorCpp::GenerateEnumOutputStream(
    const std::shared_ptr<EnumType> &e) {
  // Generate enum output stream operator begin
  WriteLine();
  WriteLineIndent(
      "std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] " +
      *e->name + " value)");
  WriteLineIndent("{");
  Indent(1);

  // Generate enum output stream operator body
  if (e->body && !e->body->values.empty()) {
    for (auto it = e->body->values.begin(); it != e->body->values.end(); ++it)
      WriteLineIndent("if (value == " + *e->name + "::" + *(*it)->name + ")" +
                      " return stream << \"" + *(*it)->name + "\";");
    WriteLineIndent("return stream << \"<unknown>\";");
  } else
    WriteLineIndent("return stream << \"<empty>\";");

  // Generate enum output stream operator end
  Indent(-1);
  WriteLineIndent("}");
}

void GeneratorCpp::GenerateEnumLoggingStream(
    const std::shared_ptr<EnumType> &e) {
  // Generate enum logging stream operator begin
  WriteLine();
  WriteLineIndent("#if defined(LOGGING_PROTOCOL)");
  WriteLineIndent(
      "CppLogging::Record& operator<<(CppLogging::Record& record, " + *e->name +
      " value)");
  WriteLineIndent("{");
  Indent(1);

  // Generate enum logging stream operator body
  if (e->body && !e->body->values.empty()) {
    for (auto it = e->body->values.begin(); it != e->body->values.end(); ++it)
      WriteLineIndent("if (value == " + *e->name + "::" + *(*it)->name + ")" +
                      " return record.StoreCustom(\"" + *(*it)->name + "\");");
    WriteLineIndent("return record.StoreCustom(\"<unknown>\");");
  } else
    WriteLineIndent("return record.StoreCustom(\"<empty>\");");

  // Generate enum logging stream operator end
  Indent(-1);
  WriteLineIndent("}");
  WriteLineIndent("#endif");
}

void GeneratorCpp::GenerateEnumJson(const std::shared_ptr<Package> &p,
                                    const std::shared_ptr<EnumType> &e) {
  std::string enum_name = "::" + ConvertNamespace(*p->name) + "::" + *e->name;
  std::string enum_type = (e->base && !e->base->empty()) ? *e->base : "int32";
  std::string enum_base_type = ConvertEnumType(enum_type);

  std::string json = R"CODE(
template <class TWriter>
struct ValueWriter<TWriter, _ENUM_NAME_>
{
    static bool to_json(TWriter& writer, const _ENUM_NAME_& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (_ENUM_TYPE_)value);
    }
};

template <class TJson>
struct ValueReader<TJson, _ENUM_NAME_>
{
    static bool from_json(const TJson& json, _ENUM_NAME_& value)
    {
        _ENUM_TYPE_ raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (_ENUM_NAME_)raw;
        return true;
    }
};
)CODE";

  // Prepare enum template
  json = std::regex_replace(json, std::regex("_ENUM_NAME_"), enum_name);
  json = std::regex_replace(json, std::regex("_ENUM_TYPE_"), enum_base_type);
  json = std::regex_replace(json, std::regex("\n"), EndLine());

  // Generate enum JSON
  Write(json);
}

void GeneratorCpp::GenerateEnumFieldModel(const std::shared_ptr<Package> &p,
                                          const std::shared_ptr<EnumType> &e) {
  std::string enum_name = "::" + ConvertNamespace(*p->name) + "::" + *e->name;
  std::string enum_type = (e->base && !e->base->empty()) ? *e->base : "int32";
  std::string enum_base_type = ConvertEnumType(enum_type);

  std::string code = R"CODE(
// Fast Binary Encoding _ENUM_NAME_ field model
template <>
class FieldModel<_ENUM_NAME_> : public FieldModelBase<_ENUM_NAME_, _ENUM_TYPE_>
{
public:
    using FieldModelBase<_ENUM_NAME_, _ENUM_TYPE_>::FieldModelBase;
};
)CODE";

  // Prepare enum template
  code = std::regex_replace(code, std::regex("_ENUM_NAME_"), enum_name);
  code = std::regex_replace(code, std::regex("_ENUM_TYPE_"), enum_base_type);
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  // Generate enum field model
  Write(code);
}

void GeneratorCpp::GenerateEnumFinalModel(const std::shared_ptr<Package> &p,
                                          const std::shared_ptr<EnumType> &e) {
  std::string enum_name = "::" + ConvertNamespace(*p->name) + "::" + *e->name;
  std::string enum_type = (e->base && !e->base->empty()) ? *e->base : "int32";
  std::string enum_base_type = ConvertEnumType(enum_type);

  std::string code = R"CODE(
// Fast Binary Encoding _ENUM_NAME_ final model
template <>
class FinalModel<_ENUM_NAME_> : public FinalModelBase<_ENUM_NAME_, _ENUM_TYPE_>
{
public:
    using FinalModelBase<_ENUM_NAME_, _ENUM_TYPE_>::FinalModelBase;
};
)CODE";

  // Prepare enum template
  code = std::regex_replace(code, std::regex("_ENUM_NAME_"), enum_name);
  code = std::regex_replace(code, std::regex("_ENUM_TYPE_"), enum_base_type);
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  // Generate enum final model
  Write(code);
}

void GeneratorCpp::GenerateFlags(const std::shared_ptr<Package> &p,
                                 const std::shared_ptr<FlagsType> &f) {
  // Generate flags begin
  WriteLine();
  WriteIndent("enum class " +
              std::string(f->attributes->deprecated ? "[[deprecated]] " : "") +
              *f->name);
  if (f->base && !f->base->empty())
    Write(" : " + ConvertEnumType(*f->base));
  WriteLine();
  WriteLineIndent("{");
  Indent(1);

  std::string flags_type = (f->base && !f->base->empty()) ? *f->base : "int32";

  // Generate flags body
  if (f->body) {
    for (const auto &value : f->body->values) {
      WriteIndent(*value->name);
      if (value->attributes->deprecated)
        Write(" [[deprecated]]");
      if (value->value) {
        if (value->value->constant && !value->value->constant->empty())
          Write(" = " +
                ConvertConstant(flags_type, *value->value->constant, false));
        else if (value->value->reference && !value->value->reference->empty())
          Write(" = " + ConvertConstant("", *value->value->reference, false));
      }
      WriteLine(",");
    }
  }

  // Generate flags end
  Indent(-1);
  WriteLineIndent("};");
  WriteLine();
  WriteLineIndent("FBE_ENUM_FLAGS(" + *f->name + ")");

  // Generate flags output stream operator declaration
  WriteLine();
  WriteLineIndent(
      "std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] " +
      *f->name + " value);");

  // Generate flags logging stream operator declaration
  WriteLine();
  WriteLineIndent("#if defined(LOGGING_PROTOCOL)");
  WriteLineIndent(
      "CppLogging::Record& operator<<(CppLogging::Record& record, " + *f->name +
      " value);");
  WriteLineIndent("#endif");
}

void GeneratorCpp::GenerateFlagsOutputStream(
    const std::shared_ptr<FlagsType> &f) {
  // Generate flags output stream operator begin
  WriteLine();
  WriteLineIndent(
      "std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] " +
      *f->name + " value)");
  WriteLineIndent("{");
  Indent(1);

  // Generate flags output stream operator body
  if (f->body && !f->body->values.empty()) {
    WriteLineIndent("bool first = true;");
    for (auto it = f->body->values.begin(); it != f->body->values.end(); ++it) {
      WriteLineIndent("if ((value & " + *f->name + "::" + *(*it)->name +
                      ") && ((value & " + *f->name + "::" + *(*it)->name +
                      ") == " + *f->name + "::" + *(*it)->name + "))");
      WriteLineIndent("{");
      Indent(1);
      WriteLineIndent("stream << (first ? \"\" : \"|\") << \"" + *(*it)->name +
                      "\";");
      WriteLineIndent("first = false;");
      Indent(-1);
      WriteLineIndent("}");
    }
  }
  WriteLineIndent("return stream;");

  // Generate flags output stream operator end
  Indent(-1);
  WriteLineIndent("}");
}

void GeneratorCpp::GenerateFlagsLoggingStream(
    const std::shared_ptr<FlagsType> &f) {
  // Generate flags logging stream operator begin
  WriteLine();
  WriteLineIndent("#if defined(LOGGING_PROTOCOL)");
  WriteLineIndent(
      "CppLogging::Record& operator<<(CppLogging::Record& record, " + *f->name +
      " value)");
  WriteLineIndent("{");
  Indent(1);

  // Generate flags output stream operator body
  WriteLineIndent("const size_t begin = record.StoreListBegin();");
  if (f->body && !f->body->values.empty()) {
    WriteLineIndent("bool first = true;");
    for (auto it = f->body->values.begin(); it != f->body->values.end(); ++it) {
      WriteLineIndent("if ((value & " + *f->name + "::" + *(*it)->name +
                      ") && ((value & " + *f->name + "::" + *(*it)->name +
                      ") == " + *f->name + "::" + *(*it)->name + "))");
      WriteLineIndent("{");
      Indent(1);
      WriteLineIndent("record.StoreList((first ? \"\" : \"|\")).StoreList(\"" +
                      *(*it)->name + "\");");
      WriteLineIndent("first = false;");
      Indent(-1);
      WriteLineIndent("}");
    }
  }
  WriteLineIndent("return record.StoreListEnd(begin);");

  // Generate flags logging stream operator end
  Indent(-1);
  WriteLineIndent("}");
  WriteLineIndent("#endif");
}

void GeneratorCpp::GenerateFlagsJson(const std::shared_ptr<Package> &p,
                                     const std::shared_ptr<FlagsType> &f) {
  std::string flags_name = "::" + ConvertNamespace(*p->name) + "::" + *f->name;
  std::string flags_type = (f->base && !f->base->empty()) ? *f->base : "int32";
  std::string flags_base_type = ConvertEnumType(flags_type);

  std::string json = R"CODE(
template <class TWriter>
struct ValueWriter<TWriter, _FLAGS_NAME_>
{
    static bool to_json(TWriter& writer, const _FLAGS_NAME_& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (_FLAGS_TYPE_)value);
    }
};

template <class TJson>
struct ValueReader<TJson, _FLAGS_NAME_>
{
    static bool from_json(const TJson& json, _FLAGS_NAME_& value)
    {
        _FLAGS_TYPE_ raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (_FLAGS_NAME_)raw;
        return true;
    }
};
)CODE";

  // Prepare flags template
  json = std::regex_replace(json, std::regex("_FLAGS_NAME_"), flags_name);
  json = std::regex_replace(json, std::regex("_FLAGS_TYPE_"), flags_base_type);
  json = std::regex_replace(json, std::regex("\n"), EndLine());

  // Generate flags JSON
  Write(json);
}

void GeneratorCpp::GenerateFlagsFieldModel(
    const std::shared_ptr<Package> &p, const std::shared_ptr<FlagsType> &f) {
  std::string flags_name = "::" + ConvertNamespace(*p->name) + "::" + *f->name;
  std::string flags_type = (f->base && !f->base->empty()) ? *f->base : "int32";
  std::string flags_base_type = ConvertEnumType(flags_type);

  std::string code = R"CODE(
// Fast Binary Encoding _FLAGS_NAME_ field model
template <>
class FieldModel<_FLAGS_NAME_> : public FieldModelBase<_FLAGS_NAME_, _FLAGS_TYPE_>
{
public:
    using FieldModelBase<_FLAGS_NAME_, _FLAGS_TYPE_>::FieldModelBase;
};
)CODE";

  // Prepare flags template
  code = std::regex_replace(code, std::regex("_FLAGS_NAME_"), flags_name);
  code = std::regex_replace(code, std::regex("_FLAGS_TYPE_"), flags_base_type);
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  // Generate flags field model
  Write(code);
}

void GeneratorCpp::GenerateFlagsFinalModel(
    const std::shared_ptr<Package> &p, const std::shared_ptr<FlagsType> &f) {
  std::string flags_name = "::" + ConvertNamespace(*p->name) + "::" + *f->name;
  std::string flags_type = (f->base && !f->base->empty()) ? *f->base : "int32";
  std::string flags_base_type = ConvertEnumType(flags_type);

  std::string code = R"CODE(
// Fast Binary Encoding _FLAGS_NAME_ final model
template <>
class FinalModel<_FLAGS_NAME_> : public FinalModelBase<_FLAGS_NAME_, _FLAGS_TYPE_>
{
public:
    using FinalModelBase<_FLAGS_NAME_, _FLAGS_TYPE_>::FinalModelBase;
};
)CODE";

  // Prepare flags template
  code = std::regex_replace(code, std::regex("_FLAGS_NAME_"), flags_name);
  code = std::regex_replace(code, std::regex("_FLAGS_TYPE_"), flags_base_type);
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  // Generate flags final model
  Write(code);
}

void GeneratorCpp::GenerateVariantAlias(const std::shared_ptr<Package> &p,
                                        const std::shared_ptr<VariantType> &v) {
  WriteLine();
  std::string code = "using " + *v->name + " = std::variant<std::monostate";
  for (auto value : v->body->values) {
    code += ", " + ConvertVariantTypeName(*p->name, *value);
  }
  code += ">;";
  WriteLineIndent(code);
  WriteLineIndent(
      "std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const " +
      *v->name + "& value);");
  if (Ptr()) {
    // use built-in operator== for varaint type of template-based FBE
    WriteLineIndent("auto is_equal(const " + *v->name + "& lhs" + ", const " +
                    *v->name + "& rhs) -> bool;");
  }
}

void GeneratorCpp::GenerateVariantOutputStream(
    const std::shared_ptr<Package> &p, const std::shared_ptr<VariantType> &v) {
  WriteLine();
  WriteLineIndent(
      "std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const " +
      *v->name + "& value)");
  WriteLineIndent("{");
  Indent(1);

  WriteLineIndent("stream << \"" + *v->name + "(variant|\";");
  WriteLineIndent("[[maybe_unused]] bool first = true;");
  WriteLineIndent("switch (value.index()) {");
  Indent(1);
  WriteLineIndent("case 0:");
  Indent(1);
  WriteLineIndent("stream << \"{empty}\";");
  WriteLineIndent("break;");
  Indent(-1);
  for (int i = 0; i < v->body->values.size(); i++) {
    WriteLineIndent("case " + std::to_string(i + 1) + ":");
    Indent(1);
    auto &value = v->body->values.at(i);
    auto get_value = "std::get<" + std::to_string(i + 1) + ">(value)";
    auto fbe_value_type = *value->type + (value->ptr ? "*" : "");
    if (value->vector || value->list) {
      WriteLineIndent(std::string("stream << \"{") + fbe_value_type +
                      "}=[\" << " + get_value + ".size()" + " << \"][\"" + ";");
      WriteLineIndent("for ([[maybe_unused]] const auto& it : " + get_value +
                      ")");
      WriteLineIndent("{");
      Indent(1);
      WriteLineIndent(ConvertOutputStreamValue(*value->type, "it", value->ptr,
                                               false, true));
      if (value->ptr) {
        WriteLineIndent("if (it != nullptr)");
        WriteLineIndent("{");
        Indent(1);
        if ((*value->type == "int128") || (*value->type == "uint128")) {
          WriteLineIndent("stream << \"->\" << unimplemented;");
        } else {
          WriteLineIndent("stream << \"->\" << *it;");
        }
        Indent(-1);
        WriteLineIndent("}");
      }
      WriteLineIndent("first = false;");
      Indent(-1);
      WriteLineIndent("}");
      WriteLineIndent("stream << \"]\";");
    } else if (value->map || value->hash) {
      WriteLineIndent(std::string("stream << \"{") + *value->key + "->" +
                      fbe_value_type + "}=[\" << " + get_value + ".size()" +
                      " << \"][\"" + ";");
      WriteLineIndent("for ([[maybe_unused]] const auto& it : " + get_value +
                      ")");
      WriteLineIndent("{");
      Indent(1);
      WriteLineIndent(ConvertOutputStreamValue(*value->key, "it.first", false,
                                               false, true));
      WriteLineIndent("stream << \"->\";");
      WriteLineIndent(ConvertOutputStreamValue(*value->type, "it.second",
                                               value->ptr, false, false));
      WriteLineIndent("first = false;");
      Indent(-1);
      WriteLineIndent("}");
      WriteLineIndent("stream << \"]\";");
    } else {
      WriteLineIndent("stream<< \"{" + fbe_value_type + "}\";");
      if ((fbe_value_type == "int128") || (fbe_value_type == "uint128")) {
        WriteLineIndent("stream << \"unimplemented\";");
      } else {
        WriteLineIndent(ConvertOutputStreamValue(
            "", get_value, v->body->values.at(i)->ptr, false, false));
        if (value->ptr) {
          WriteLineIndent("if (" + get_value + " != nullptr)");
          WriteLineIndent("{");
          Indent(1);
          WriteLineIndent("stream << \"->\" << *" + get_value + ";");
          Indent(-1);
          WriteLineIndent("}");
        }
      }
    }
    WriteLineIndent("break;");
    Indent(-1);
  }
  WriteLineIndent("default:");
  Indent(1);
  WriteLineIndent("static_assert(\"unreachable branch\");");
  Indent(-1);
  Indent(-1);
  WriteLineIndent("}");

  WriteLineIndent("stream << \")\";");
  WriteLineIndent("return stream;");
  Indent(-1);
  WriteLineIndent("}");
}

void GeneratorCpp::GenerateStruct_Header(const std::shared_ptr<Package> &p,
                                         const std::shared_ptr<StructType> &s) {
  // Generate struct response forward declaration
  if (s->response) {
    std::string response = *s->response->response;
    bool imported = replace_all(response, ".", "");
    if (!imported) {
      WriteLine();
      WriteLineIndent("struct " + response + ";");
    }
  }

  // Generate struct begin
  WriteLine();
  WriteIndent("struct " +
              std::string(s->attributes->deprecated ? "[[deprecated]] " : "") +
              *s->name);
  if (s->base && !s->base->empty())
    Write(" : public " + ConvertTypeName(*p->name, *s->base, false));
  WriteLine();
  WriteLineIndent("{");
  Indent(1);

  // Generate struct response type definition
  if (s->response) {
    std::string response = *s->response->response;
    replace_all(response, ".", "::");
    WriteLineIndent("typedef " + response + " Response;");
    if (s->body && !s->body->fields.empty())
      WriteLine();
  }

  // Generate struct body
  // Write Arena ArenaTags
  if (Arena()) {
    for (auto &tag : ArenaTags()) {
      WriteLineIndent(tag + ";");
    }
    WriteLine();
  }

  if (s->body) {
    for (const auto &field : s->body->fields) {
      WriteIndent();
      if (field->attributes && field->attributes->deprecated)
        Write("[[deprecated]] ");
      WriteLine(ConvertTypeName(*p->name, *field) + " " + *field->name + ";");
    }
    if (!s->body->fields.empty())
      WriteLine();
  }

  // Generate struct FBE type property
  if (s->base && !s->base->empty() && (s->type == 0))
    WriteLineIndent("size_t fbe_type() const noexcept { return " +
                    ConvertTypeName(*p->name, *s->base, false) +
                    "::fbe_type(); }");
  else
    WriteLineIndent("size_t fbe_type() const noexcept { return " +
                    std::to_string(s->type) + "; }");

  // Generate struct default constructor
  bool first = true;
  WriteLine();
  WriteLineIndent(*s->name + "();");

  // Generate cstr with Arena
  if (Arena()) {
    WriteLineIndent("explicit " + *s->name + "(allocator_type alloc);");
  }

  // Generate struct initialization constructor
  if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty())) {
    first = true;
    size_t args = 0;
    if (s->base && !s->base->empty())
      ++args;
    if (s->body && !s->body->fields.empty())
      args += s->body->fields.size();
    WriteIndent(((args <= 1) ? "explicit " : "") + *s->name + "(");
    if (s->base && !s->base->empty()) {
      Write("const " + ConvertTypeName(*p->name, *s->base, false) + "& base");
      first = false;
    }
    if (s->body) {
      for (const auto &field : s->body->fields) {
        Write(std::string(first ? "" : ", ") +
              ConvertTypeNameAsArgument(*p->name, *field) + " arg_" +
              *field->name);
        first = false;
      }
    }
    WriteLine(");");
  }

  // Generate struct copy/move constructor, destructor and assign operators
  WriteLineIndent(*s->name + "(const " + *s->name + "& other) = default;");
  WriteLineIndent(*s->name + "(" + *s->name + "&& other) = default;");
  WriteLineIndent("~" + *s->name + "() = default;");
  WriteLine();
  WriteLineIndent(*s->name + "& operator=(const " + *s->name +
                  "& other) = default;");
  WriteLineIndent(*s->name + "& operator=(" + *s->name +
                  "&& other) = default;");

  // Generate struct compare operators
  WriteLine();
  WriteLineIndent("bool operator==(const " + *s->name +
                  "& other) const noexcept;");
  WriteLineIndent("bool operator!=(const " + *s->name +
                  "& other) const noexcept { return !operator==(other); }");
  WriteLineIndent("bool operator<(const " + *s->name +
                  "& other) const noexcept;");
  WriteLineIndent("bool operator<=(const " + *s->name +
                  "& other) const noexcept { return operator<(other) || "
                  "operator==(other); }");
  WriteLineIndent("bool operator>(const " + *s->name +
                  "& other) const noexcept { return !operator<=(other); }");
  WriteLineIndent("bool operator>=(const " + *s->name +
                  "& other) const noexcept { return !operator<(other); }");

  // Generate struct string convert
  WriteLine();
  WriteLineIndent("std::string to_string() const;");

  // Generate struct output stream operator
  WriteLine();
  WriteLineIndent("friend std::ostream& operator<<(std::ostream& stream, "
                  "[[maybe_unused]] const " +
                  *s->name + "& value);");

  // Generate struct output stream operator
  if (Logging()) {
    WriteLine();
    WriteLineIndent("#if defined(LOGGING_PROTOCOL)");
    WriteLineIndent("friend CppLogging::Record& operator<<(CppLogging::Record& "
                    "record, const " +
                    *s->name + "& value);");
    WriteLineIndent("#endif");
  }

  // Generate struct swap methods
  WriteLine();
  WriteLineIndent("void swap(" + *s->name + "& other) noexcept;");
  WriteLineIndent("friend void swap(" + *s->name + "& value1, " + *s->name +
                  "& value2) noexcept { value1.swap(value2); }");

  // Generate struct end
  Indent(-1);
  WriteLineIndent("};");

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));

  // Generate struct hash
  GenerateStructHash(p, s);

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");
}

void GeneratorCpp::GenerateStruct_Source(const std::shared_ptr<Package> &p,
                                         const std::shared_ptr<StructType> &s) {
  WriteLine();

  // Generate struct default constructor
  bool first = true;
  WriteLineIndent(*s->name + "::" + *s->name + "()");
  Indent(1);
  if (s->base && !s->base->empty()) {
    WriteLineIndent(": " + ConvertTypeName(*p->name, *s->base, false) + "()");
    first = false;
  }
  if (s->body) {
    for (const auto &field : s->body->fields) {
      WriteLineIndent(
          std::string(first ? ": " : ", ") + *field->name + "(" +
          ((field->value || IsPrimitiveType(*field->type, field->optional))
               ? ConvertDefault(*p->name, *field)
               : "") +
          ")");
      first = false;
    }
  }
  Indent(-1);
  WriteLineIndent("{}");

  // Generate struct constructor with arena
  if (Arena()) {
    first = true;
    WriteLine();
    WriteLineIndent(*s->name + "::" + *s->name +
                    "([[maybe_unused]] allocator_type alloc)");
    Indent(1);
    if (s->base && !s->base->empty()) {
      WriteLineIndent(": " + ConvertTypeName(*p->name, *s->base, false) + "()");
      first = false;
    }
    if (s->body) {
      auto enums = p->body->enums;
      auto flags = p->body->flags;
      for (const auto &field : s->body->fields) {
        WriteIndent();
        Write(std::string(first ? ": " : ", ") + *field->name + "(");
        // priority: container > optional > imported type >
        // bytes/string/primitive type/custom type > variant
        if (IsContainerType(*field)) {
          Write(field->array ? "" : "alloc");
        } else if (field->optional) {
          Write("std::nullopt");
        } else if (!IsCurrentPackageType(*field->type)) {
          Write(std::string("assign_member<") +
                ConvertTypeName(*p->name, *field) + ">(alloc)");
        } else if (*field->type == "bytes" || *field->type == "string") {
          Write("alloc");
        } else if (field->value ||
                   IsPrimitiveType(*field->type, field->optional)) {
          Write(ConvertDefault(*p->name, *field));
          // TODO(liuqi): FBE::uuid_t and FBE::decimal_t should support arena
        } else if (*field->type != "uuid" && *field->type != "decimal" &&
                   !IsVariantType(p, *field->type) &&
                   std::find_if(
                       enums.begin(), enums.end(),
                       [t = *field->type](const std::shared_ptr<EnumType> &e)
                           -> bool { return *e->name == t; }) == enums.end() &&
                   std::find_if(
                       flags.begin(), flags.end(),
                       [t = *field->type](const std::shared_ptr<FlagsType> &e)
                           -> bool { return *e->name == t; }) == flags.end()) {
          Write("alloc");
        }
        Write(")");
        WriteLine();
        first = false;
      }
    }
    Indent(-1);
    WriteLineIndent("{}");
  }

  // Generate struct initialization constructor
  if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty())) {
    first = true;
    WriteLine();
    WriteIndent(*s->name + "::" + *s->name + "(");
    if (s->base && !s->base->empty()) {
      Write("const " + ConvertTypeName(*p->name, *s->base, false) + "& base");
      first = false;
    }
    if (s->body) {
      for (const auto &field : s->body->fields) {
        Write(std::string(first ? "" : ", ") +
              ConvertTypeNameAsArgument(*p->name, *field) + " arg_" +
              *field->name);
        first = false;
      }
    }
    WriteLine(")");
    Indent(1);
    first = true;
    if (s->base && !s->base->empty()) {
      WriteLineIndent(": " + ConvertTypeName(*p->name, *s->base, false) +
                      "(base)");
      first = false;
    }
    if (s->body) {
      for (const auto &field : s->body->fields) {
        WriteLineIndent(std::string(first ? ": " : ", ") + *field->name +
                        "(arg_" + *field->name + ")");
        first = false;
      }
    }
    Indent(-1);
    WriteLineIndent("{}");
  }

  // Generate struct compare operators
  WriteLine();
  WriteLineIndent("bool " + *s->name + "::operator==([[maybe_unused]] const " +
                  *s->name + "& other) const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("return (");
  Indent(1);
  first = true;
  if (s->base && !s->base->empty()) {
    WriteLineIndent(ConvertTypeName(*p->name, *s->base, false) +
                    "::operator==(other)");
    first = false;
  }
  if (s->body) {
    for (const auto &field : s->body->fields) {
      WriteLineIndent(std::string(first ? "(" : "&& (") + *field->name +
                      " == other." + *field->name + ")");
      first = false;
    }
  }
  if (s->body->fields.empty()) {
    WriteLineIndent("true");
  }
  WriteLineIndent(");");
  Indent(-1);
  Indent(-1);
  WriteLineIndent("}");

  WriteLine();
  WriteLineIndent("bool " + *s->name + "::operator<([[maybe_unused]] const " +
                  *s->name + "& other) const noexcept");
  WriteLineIndent("{");
  Indent(1);
  if (s->base && !s->base->empty()) {
    WriteLineIndent("if (" + ConvertTypeName(*p->name, *s->base, false) +
                    "::operator<(other))");
    Indent(1);
    WriteLineIndent("return true;");
    Indent(-1);
    WriteLineIndent("if (other." + ConvertTypeName(*p->name, *s->base, false) +
                    "::operator<(*this))");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
  }
  if (s->body) {
    for (const auto &field : s->body->fields) {
      if (field->keys) {
        WriteLineIndent("if (" + *field->name + " < other." + *field->name +
                        ")");
        Indent(1);
        WriteLineIndent("return true;");
        Indent(-1);
        WriteLineIndent("if (other." + *field->name + " < " + *field->name +
                        ")");
        Indent(1);
        WriteLineIndent("return false;");
        Indent(-1);
      }
    }
  }
  WriteLineIndent("return false;");
  Indent(-1);
  WriteLineIndent("}");

  // Generate struct to_string method
  WriteLine();
  WriteLineIndent("std::string " + *s->name + "::to_string() const");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("std::stringstream ss; ss << *this; return ss.str();");
  Indent(-1);
  WriteLineIndent("}");

  // Generate struct swap method
  WriteLine();
  WriteLineIndent("void " + *s->name + "::swap([[maybe_unused]] " + *s->name +
                  "& other) noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("using std::swap;");
  if (s->base && !s->base->empty())
    WriteLineIndent(ConvertTypeName(*p->name, *s->base, false) +
                    "::swap(other);");
  if (s->body)
    for (const auto &field : s->body->fields)
      WriteLineIndent("swap(" + *field->name + ", other." + *field->name +
                      ");");
  Indent(-1);
  WriteLineIndent("}");
}

void GeneratorCpp::GenerateStructOutputStream(
    const std::shared_ptr<Package> &p, const std::shared_ptr<StructType> &s) {
  // Generate struct output stream operator begin
  WriteLine();
  WriteLineIndent(
      "std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const " +
      *s->name + "& value)");
  WriteLineIndent("{");
  Indent(1);

  // Generate struct output stream operator body
  WriteLineIndent("stream << \"" + *s->name + "(\";");
  bool first = true;
  if (s->base && !s->base->empty()) {
    WriteLineIndent("stream << (const " +
                    ConvertTypeName(*p->name, *s->base, false) + "&)value;");
    first = false;
  }
  if (s->body) {
    // Generate fields output stream operator calls
    for (const auto &field : s->body->fields) {
      if (field->attributes && field->attributes->hidden)
        WriteLineIndent("stream << \"" + std::string(first ? "" : ",") +
                        *field->name + "=***\";");
      else if (field->array) {
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent("bool first = true;");
        WriteLineIndent("stream << \"" + std::string(first ? "" : ",") +
                        *field->name + "=[" + std::to_string(field->N) +
                        "][\"" + ";");
        WriteLineIndent("for (size_t i = 0; i < " + std::to_string(field->N) +
                        "; ++i)");
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent(ConvertOutputStreamValue(
            *field->type, "value." + *field->name + "[i]", field->ptr,
            field->optional, true));
        WriteLineIndent("first = false;");
        Indent(-1);
        WriteLineIndent("}");
        WriteLineIndent("stream << \"]\";");
        Indent(-1);
        WriteLineIndent("}");
      } else if (field->vector) {
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent("bool first = true;");
        WriteLineIndent("stream << \"" + std::string(first ? "" : ",") +
                        *field->name + "=[\" << value." + *field->name +
                        ".size()" + " << \"][\"" + ";");
        WriteLineIndent("for ([[maybe_unused]] const auto& it : value." +
                        *field->name + ")");
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent(ConvertOutputStreamValue(*field->type, "it", field->ptr,
                                                 field->optional, true));
        WriteLineIndent("first = false;");
        Indent(-1);
        WriteLineIndent("}");
        WriteLineIndent("stream << \"]\";");
        Indent(-1);
        WriteLineIndent("}");
      } else if (field->list) {
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent("bool first = true;");
        WriteLineIndent("stream << \"" + std::string(first ? "" : ",") +
                        *field->name + "=[\" << value." + *field->name +
                        ".size()" + "<< \"]<\"" + ";");
        WriteLineIndent("for ([[maybe_unused]] const auto& it : value." +
                        *field->name + ")");
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent(ConvertOutputStreamValue(*field->type, "it", field->ptr,
                                                 field->optional, true));
        WriteLineIndent("first = false;");
        Indent(-1);
        WriteLineIndent("}");
        WriteLineIndent("stream << \">\";");
        Indent(-1);
        WriteLineIndent("}");
      } else if (field->set) {
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent("bool first = true;");
        WriteLineIndent("stream << \"" + std::string(first ? "" : ",") +
                        *field->name + "=[\" << value." + *field->name +
                        ".size()" + "<< \"]{\"" + ";");
        WriteLineIndent("for ([[maybe_unused]] const auto& it : value." +
                        *field->name + ")");
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent(ConvertOutputStreamValue(*field->type, "it", field->ptr,
                                                 field->optional, true));
        WriteLineIndent("first = false;");
        Indent(-1);
        WriteLineIndent("}");
        WriteLineIndent("stream << \"}\";");
        Indent(-1);
        WriteLineIndent("}");
      } else if (field->map) {
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent("bool first = true;");
        WriteLineIndent("stream << \"" + std::string(first ? "" : ",") +
                        *field->name + "=[\" << value." + *field->name +
                        ".size()" + "<< \"]<{\"" + ";");
        WriteLineIndent("for ([[maybe_unused]] const auto& it : value." +
                        *field->name + ")");
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent(ConvertOutputStreamValue(*field->key, "it.first", false,
                                                 false, true));
        WriteLineIndent("stream << \"->\";");
        WriteLineIndent(ConvertOutputStreamValue(
            *field->type, "it.second", field->ptr, field->optional, false));
        WriteLineIndent("first = false;");
        Indent(-1);
        WriteLineIndent("}");
        WriteLineIndent("stream << \"}>\";");
        Indent(-1);
        WriteLineIndent("}");
      } else if (field->hash) {
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent("bool first = true;");
        WriteLineIndent("stream << \"" + std::string(first ? "" : ",") +
                        *field->name + "=[\" << " + "value." + *field->name +
                        ".size()" + "<< \"][{\"" + ";");
        WriteLineIndent("for ([[maybe_unused]] const auto& it : value." +
                        *field->name + ")");
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent(ConvertOutputStreamValue(*field->key, "it.first", false,
                                                 false, true));
        WriteLineIndent("stream << \"->\";");
        WriteLineIndent(ConvertOutputStreamValue(
            *field->type, "it.second", field->ptr, field->optional, false));
        WriteLineIndent("first = false;");
        Indent(-1);
        WriteLineIndent("}");
        WriteLineIndent("stream << \"}]\";");
        Indent(-1);
        WriteLineIndent("}");
      } else
        WriteLineIndent(
            "stream << \"" + std::string(first ? "" : ",") + *field->name +
            "=\"; " +
            ConvertOutputStreamValue(*field->type, "value." + *field->name,
                                     field->ptr, field->optional, false));
      first = false;
    }
  }
  WriteLineIndent("stream << \")\";");
  WriteLineIndent("return stream;");

  // Generate struct output stream operator end
  Indent(-1);
  WriteLineIndent("}");
}

void GeneratorCpp::GenerateStructLoggingStream(
    const std::shared_ptr<Package> &p, const std::shared_ptr<StructType> &s) {
  // Generate struct logging stream operator begin
  WriteLine();
  WriteLineIndent("#if defined(LOGGING_PROTOCOL)");
  WriteLineIndent(
      "CppLogging::Record& operator<<(CppLogging::Record& record, const " +
      *s->name + "& value)");
  WriteLineIndent("{");
  Indent(1);

  // Generate struct output stream operator body
  WriteLineIndent("const size_t begin = record.StoreListBegin();");
  WriteLineIndent("record.StoreList(\"" + *s->name + "(\");");
  bool first = true;
  if (s->base && !s->base->empty()) {
    WriteLineIndent("record.StoreList((const " +
                    ConvertTypeName(*p->name, *s->base, false) + "&)value);");
    first = false;
  }
  if (s->body) {
    // Generate fields output stream operator calls
    for (const auto &field : s->body->fields) {
      if (field->attributes && field->attributes->hidden)
        WriteLineIndent("record.StoreList(\"" + std::string(first ? "" : ",") +
                        *field->name + "=***\");");
      else if (field->array) {
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent("bool first = true;");
        WriteLineIndent("record.StoreList(\"" + std::string(first ? "" : ",") +
                        *field->name + "=[" + std::to_string(field->N) +
                        "][\");");
        WriteLineIndent("for (size_t i = 0; i < " + std::to_string(field->N) +
                        "; ++i)");
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent(ConvertLoggingStreamValue(
            *field->type, "value." + *field->name + "[i]", field->optional,
            true));
        WriteLineIndent("first = false;");
        Indent(-1);
        WriteLineIndent("}");
        WriteLineIndent("record.StoreList(\"]\");");
        Indent(-1);
        WriteLineIndent("}");
      } else if (field->vector) {
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent("bool first = true;");
        WriteLineIndent("record.StoreList(\"" + std::string(first ? "" : ",") +
                        *field->name + "=[\").StoreList(value." + *field->name +
                        ".size()).StoreList(\"][\");");
        WriteLineIndent("for (const auto& it : value." + *field->name + ")");
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent(ConvertLoggingStreamValue(*field->type, "it",
                                                  field->optional, true));
        WriteLineIndent("first = false;");
        Indent(-1);
        WriteLineIndent("}");
        WriteLineIndent("record.StoreList(\"]\");");
        Indent(-1);
        WriteLineIndent("}");
      } else if (field->list) {
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent("bool first = true;");
        WriteLineIndent("record.StoreList(\"" + std::string(first ? "" : ",") +
                        *field->name + "=[\").StoreList(value." + *field->name +
                        ".size()).StoreList(\"]<\");");
        WriteLineIndent("for (const auto& it : value." + *field->name + ")");
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent(ConvertLoggingStreamValue(*field->type, "it",
                                                  field->optional, true));
        WriteLineIndent("first = false;");
        Indent(-1);
        WriteLineIndent("}");
        WriteLineIndent("record.StoreList(\">\");");
        Indent(-1);
        WriteLineIndent("}");
      } else if (field->set) {
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent("bool first = true;");
        WriteLineIndent("record.StoreList(\"" + std::string(first ? "" : ",") +
                        *field->name + "=[\").StoreList(value." + *field->name +
                        ".size()).StoreList(\"]{\");");
        WriteLineIndent("for (const auto& it : value." + *field->name + ")");
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent(ConvertLoggingStreamValue(*field->type, "it",
                                                  field->optional, true));
        WriteLineIndent("first = false;");
        Indent(-1);
        WriteLineIndent("}");
        WriteLineIndent("record.StoreList(\"}\");");
        Indent(-1);
        WriteLineIndent("}");
      } else if (field->map) {
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent("bool first = true;");
        WriteLineIndent("record.StoreList(\"" + std::string(first ? "" : ",") +
                        *field->name + "=[\").StoreList(value." + *field->name +
                        ".size()).StoreList(\"]<{\");");
        WriteLineIndent("for (const auto& it : value." + *field->name + ")");
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent(
            ConvertLoggingStreamValue(*field->key, "it.first", false, true));
        WriteLineIndent("record.StoreList(\"->\");");
        WriteLineIndent(ConvertLoggingStreamValue(*field->type, "it.second",
                                                  field->optional, false));
        WriteLineIndent("first = false;");
        Indent(-1);
        WriteLineIndent("}");
        WriteLineIndent("record.StoreList(\"}>\");");
        Indent(-1);
        WriteLineIndent("}");
      } else if (field->hash) {
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent("bool first = true;");
        WriteLineIndent("record.StoreList(\"" + std::string(first ? "" : ",") +
                        *field->name + "=[\").StoreList(value." + *field->name +
                        ".size()).StoreList(\"][{\");");
        WriteLineIndent("for (const auto& it : value." + *field->name + ")");
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent(
            ConvertLoggingStreamValue(*field->key, "it.first", false, true));
        WriteLineIndent("record.StoreList(\"->\");");
        WriteLineIndent(ConvertLoggingStreamValue(*field->type, "it.second",
                                                  field->optional, false));
        WriteLineIndent("first = false;");
        Indent(-1);
        WriteLineIndent("}");
        WriteLineIndent("record.StoreList(\"}]\");");
        Indent(-1);
        WriteLineIndent("}");
      } else
        WriteLineIndent("record.StoreList(\"" + std::string(first ? "" : ",") +
                        *field->name + "=\"); " +
                        ConvertLoggingStreamValue(*field->type,
                                                  "value." + *field->name,
                                                  field->optional, false));
      first = false;
    }
  }
  WriteLineIndent("record.StoreList(\")\");");
  WriteLineIndent("return record.StoreListEnd(begin);");

  // Generate struct logging stream operator end
  Indent(-1);
  WriteLineIndent("}");
  WriteLineIndent("#endif");
}

void GeneratorCpp::GenerateStructHash(const std::shared_ptr<Package> &p,
                                      const std::shared_ptr<StructType> &s) {
  // Generate struct hash
  WriteLine();
  WriteLineIndent("template<>");
  WriteLineIndent("struct std::hash<" + ConvertNamespace(*p->name) +
                  "::" + *s->name + ">");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("typedef " + ConvertNamespace(*p->name) + "::" + *s->name +
                  " argument_type;");
  WriteLineIndent("typedef size_t result_type;");
  WriteLine();
  WriteLineIndent("result_type operator() ([[maybe_unused]] const "
                  "argument_type& value) const");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("result_type result = 17;");
  if (s->base && !s->base->empty())
    WriteLineIndent("result = result * 31 + std::hash<" +
                    ConvertTypeName(*p->name, *s->base, false) + ">()(value);");
  if (s->body)
    for (const auto &field : s->body->fields)
      if (field->keys)
        WriteLineIndent("result = result * 31 + std::hash<decltype(value." +
                        *field->name + ")>()(value." + *field->name + ");");
  WriteLineIndent("return result;");
  Indent(-1);
  WriteLineIndent("}");
  Indent(-1);
  WriteLineIndent("};");
}

void GeneratorCpp::GenerateStructJson(const std::shared_ptr<Package> &p,
                                      const std::shared_ptr<StructType> &s) {
  std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;

  // Generate to_json() function
  WriteLine();
  WriteLineIndent("template <class TWriter>");
  WriteLineIndent("struct ValueWriter<TWriter, " + struct_name + ">");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("static bool to_json(TWriter& writer, const " + struct_name +
                  "& value, bool scope = true)");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("if (scope)");
  Indent(1);
  WriteLineIndent("if (!writer.StartObject())");
  Indent(1);
  WriteLineIndent("return false;");
  Indent(-1);
  Indent(-1);
  if (s->base && !s->base->empty()) {
    WriteLineIndent("if (!FBE::JSON::to_json(writer, (const " +
                    ConvertTypeName(*p->name, *s->base, false) +
                    "&)value, false))");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
  }
  if (s->body) {
    for (const auto &field : s->body->fields) {
      WriteLineIndent("if (!FBE::JSON::to_json_key(writer, \"" + *field->name +
                      "\") || !FBE::JSON::to_json(writer, value." +
                      *field->name + ", true))");
      Indent(1);
      WriteLineIndent("return false;");
      Indent(-1);
    }
  }
  WriteLineIndent("if (scope)");
  Indent(1);
  WriteLineIndent("if (!writer.EndObject())");
  Indent(1);
  WriteLineIndent("return false;");
  Indent(-1);
  Indent(-1);
  WriteLineIndent("return true;");
  Indent(-1);
  WriteLineIndent("}");
  Indent(-1);
  WriteLineIndent("};");

  // Generate from_json() function
  WriteLine();
  WriteLineIndent("template <class TJson>");
  WriteLineIndent("struct ValueReader<TJson, " + struct_name + ">");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("static bool from_json(const TJson& json, " + struct_name +
                  "& value, const char* key = nullptr)");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("if (key != nullptr)");
  Indent(1);
  WriteLineIndent("return FBE::JSON::from_json_child(json, value, key);");
  Indent(-1);
  WriteLineIndent("bool result = true;");
  if (s->base && !s->base->empty())
    WriteLineIndent("result &= FBE::JSON::from_json(json, (" +
                    ConvertTypeName(*p->name, *s->base, false) + "&)value);");
  if (s->body)
    for (const auto &field : s->body->fields)
      WriteLineIndent("result &= FBE::JSON::from_json(json, value." +
                      *field->name + ", \"" + *field->name + "\");");
  WriteLineIndent("return result;");
  Indent(-1);
  WriteLineIndent("}");
  Indent(-1);
  WriteLineIndent("};");
}

void GeneratorCpp::GenerateStructFieldModel_Header(
    const std::shared_ptr<Package> &p, const std::shared_ptr<StructType> &s) {
  std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;

  // Generate struct field model begin
  WriteLine();
  WriteLineIndent("// Fast Binary Encoding " + struct_name + " field model");
  WriteLineIndent("template <>");
  WriteLineIndent("class FieldModel<" + struct_name + ">");
  WriteLineIndent("{");
  WriteLineIndent("public:");
  Indent(1);

  // Generate struct field model constructor
  WriteLineIndent("FieldModel(FBEBuffer& buffer, size_t offset) noexcept;");

  // Generate struct field model FBE methods
  WriteLine();
  WriteLineIndent("// Get the field offset");
  WriteLineIndent("size_t fbe_offset() const noexcept { return _offset; }");
  WriteLineIndent("// Get the field size");
  WriteLineIndent("size_t fbe_size() const noexcept { return 4; }");
  WriteLineIndent("// Get the field body size");
  WriteLineIndent("size_t fbe_body() const noexcept;");
  WriteLineIndent("// Get the field extra size");
  WriteLineIndent("size_t fbe_extra() const noexcept;");
  WriteLineIndent("// Get the field type");
  if (s->base && !s->base->empty() && (s->type == 0))
    WriteLineIndent(
        "static constexpr size_t fbe_type() noexcept { return FieldModel<" +
        ConvertTypeName(*p->name, *s->base, false) + ">::fbe_type(); }");
  else
    WriteLineIndent("static constexpr size_t fbe_type() noexcept { return " +
                    std::to_string(s->type) + "; }");
  WriteLine();
  WriteLineIndent("// Shift the current field offset");
  WriteLineIndent("void fbe_shift(size_t size) noexcept { _offset += size; }");
  WriteLineIndent("// Unshift the current field offset");
  WriteLineIndent(
      "void fbe_unshift(size_t size) noexcept { _offset -= size; }");

  // Generate struct field model verify(), verify_fields() methods
  WriteLine();
  WriteLineIndent("// Check if the struct value is valid");
  WriteLineIndent("bool verify(bool fbe_verify_type = true) const noexcept;");
  WriteLineIndent("// Check if the struct fields are valid");
  WriteLineIndent("bool verify_fields(size_t fbe_struct_size) const noexcept;");

  // Generate struct field model get_begin(), get_end() methods
  WriteLine();
  WriteLineIndent("// Get the struct value (begin phase)");
  WriteLineIndent("size_t get_begin() const noexcept;");
  WriteLineIndent("// Get the struct value (end phase)");
  WriteLineIndent("void get_end(size_t fbe_begin) const noexcept;");

  // Generate struct field model get(), get_fields() methods
  WriteLine();
  WriteLineIndent("// Get the struct value");
  WriteLineIndent(
      "void get(" + struct_name +
      "& fbe_value, std::pmr::memory_resource* resource) const noexcept;");
  WriteLineIndent("// Get the struct fields values");
  WriteLineIndent("void get_fields(" + struct_name +
                  "& fbe_value, size_t fbe_struct_size, "
                  "std::pmr::memory_resource* resource) const noexcept;");

  // Generate struct field model set_begin(), set_end() methods
  WriteLine();
  WriteLineIndent("// Set the struct value (begin phase)");
  WriteLineIndent("size_t set_begin();");
  WriteLineIndent("// Set the struct value (end phase)");
  WriteLineIndent("void set_end(size_t fbe_begin);");

  // Generate struct field model set(), set_fields() methods
  WriteLine();
  WriteLineIndent("// Set the struct value");
  WriteLineIndent(
      "void set(const " + struct_name +
      "& fbe_value, std::pmr::memory_resource* resource) noexcept;");
  WriteLineIndent("// Set the struct fields values");
  WriteLineIndent(
      "void set_fields(const " + struct_name +
      "& fbe_value, std::pmr::memory_resource* resource) noexcept;");

  // Generate struct field model buffer & offset
  Indent(-1);
  WriteLine();
  WriteLineIndent("private:");
  Indent(1);
  WriteLineIndent("FBEBuffer& _buffer;");
  WriteLineIndent("size_t _offset;");

  // Generate struct field model accessors
  Indent(-1);
  WriteLine();
  WriteLineIndent("public:");
  Indent(1);
  if (s->base && !s->base->empty())
    WriteLineIndent("FieldModel<" + ConvertTypeName(*p->name, *s->base, false) +
                    "> parent;");
  if (s->body) {
    for (const auto &field : s->body->fields) {
      if (field->array)
        WriteLineIndent(
            "FieldModelArray<" +
            ConvertTypeName(*p->name, *field->type, field->optional) + ", " +
            std::to_string(field->N) + "> " + *field->name + ";");
      else if (field->vector || field->list || field->set)
        WriteLineIndent(
            "FieldModelVector<" +
            ConvertTypeName(*p->name, *field->type, field->optional) + "> " +
            *field->name + ";");
      else if (field->map || field->hash)
        WriteLineIndent(
            "FieldModelMap<" + ConvertTypeName(*p->name, *field->key, false) +
            ", " + ConvertTypeName(*p->name, *field->type, field->optional) +
            "> " + *field->name + ";");
      else
        WriteLineIndent(
            "FieldModel<" +
            ConvertTypeName(*p->name, *field->type, field->optional) + "> " +
            *field->name + ";");
    }
  }

  // Generate struct field model end
  Indent(-1);
  WriteLineIndent("};");
}

void GeneratorCpp::GenerateStructFieldModel_Source(
    const std::shared_ptr<Package> &p, const std::shared_ptr<StructType> &s) {
  std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
  std::string model_name = "FieldModel<" + struct_name + ">";

  // Generate struct field model constructor
  WriteLine();
  WriteLineIndent(model_name + "::FieldModel(FBEBuffer& buffer, size_t offset) "
                               "noexcept : _buffer(buffer), _offset(offset)");
  Indent(1);
  std::string prev_offset("4");
  std::string prev_size("4");
  if (s->base && !s->base->empty()) {
    WriteLineIndent(", parent(buffer, " + prev_offset + " + " + prev_size +
                    ")");
    prev_offset = "parent.fbe_offset()";
    prev_size = "parent.fbe_body() - 4 - 4";
  }
  if (s->body) {
    for (const auto &field : s->body->fields) {
      WriteLineIndent(", " + *field->name + "(buffer, " + prev_offset + " + " +
                      prev_size + ")");
      prev_offset = *field->name + ".fbe_offset()";
      prev_size = *field->name + ".fbe_size()";
    }
  }
  Indent(-1);
  WriteLineIndent("{}");
  WriteLine();

  // Generate struct field model FBE methods
  WriteLineIndent("size_t " + model_name + "::fbe_body() const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("size_t fbe_result = 4 + 4");
  Indent(1);
  if (s->base && !s->base->empty())
    WriteLineIndent("+ parent.fbe_body() - 4 - 4");
  if (s->body)
    for (const auto &field : s->body->fields)
      WriteLineIndent("+ " + *field->name + ".fbe_size()");
  WriteLineIndent(";");
  Indent(-1);
  WriteLineIndent("return fbe_result;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();
  WriteLineIndent("size_t " + model_name + "::fbe_extra() const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent(
      "if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + "
      "_buffer.offset() + fbe_offset());");
  WriteLineIndent("if ((fbe_struct_offset == 0) || ((_buffer.offset() + "
                  "fbe_struct_offset + 4) > _buffer.size()))");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("_buffer.shift(fbe_struct_offset);");
  WriteLine();
  WriteLineIndent("size_t fbe_result = fbe_body()");
  Indent(1);
  if (s->base && !s->base->empty())
    WriteLineIndent("+ parent.fbe_extra()");
  if (s->body)
    for (const auto &field : s->body->fields)
      WriteLineIndent("+ " + *field->name + ".fbe_extra()");
  WriteLineIndent(";");
  Indent(-1);
  WriteLine();
  WriteLineIndent("_buffer.unshift(fbe_struct_offset);");
  WriteLine();
  WriteLineIndent("return fbe_result;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model verify() method
  WriteLineIndent("bool " + model_name +
                  "::verify(bool fbe_verify_type) const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent(
      "if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
  Indent(1);
  WriteLineIndent("return true;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + "
      "_buffer.offset() + fbe_offset());");
  WriteLineIndent("if ((fbe_struct_offset == 0) || ((_buffer.offset() + "
                  "fbe_struct_offset + 4 + 4) > _buffer.size()))");
  Indent(1);
  WriteLineIndent("return false;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + "
      "_buffer.offset() + fbe_struct_offset);");
  WriteLineIndent("if (fbe_struct_size < (4 + 4))");
  Indent(1);
  WriteLineIndent("return false;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + "
      "_buffer.offset() + fbe_struct_offset + 4);");
  WriteLineIndent("if (fbe_verify_type && (fbe_struct_type != fbe_type()))");
  Indent(1);
  WriteLineIndent("return false;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("_buffer.shift(fbe_struct_offset);");
  WriteLineIndent("bool fbe_result = verify_fields(fbe_struct_size);");
  WriteLineIndent("_buffer.unshift(fbe_struct_offset);");
  WriteLineIndent("return fbe_result;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model verify_fields() method
  WriteLineIndent("bool " + model_name +
                  "::verify_fields([[maybe_unused]] size_t fbe_struct_size) "
                  "const noexcept");
  WriteLineIndent("{");
  Indent(1);
  if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty())) {
    WriteLineIndent("size_t fbe_current_size = 4 + 4;");
    if (s->base && !s->base->empty()) {
      WriteLine();
      WriteLineIndent("if ((fbe_current_size + parent.fbe_body() - 4 - 4) > "
                      "fbe_struct_size)");
      Indent(1);
      WriteLineIndent("return true;");
      Indent(-1);
      WriteLineIndent("if (!parent.verify_fields(fbe_struct_size))");
      Indent(1);
      WriteLineIndent("return false;");
      Indent(-1);
      WriteLineIndent("fbe_current_size += parent.fbe_body() - 4 - 4;");
    }
    if (s->body) {
      for (const auto &field : s->body->fields) {
        WriteLine();
        WriteLineIndent("if ((fbe_current_size + " + *field->name +
                        ".fbe_size()) > fbe_struct_size)");
        Indent(1);
        WriteLineIndent("return true;");
        Indent(-1);
        WriteLineIndent("if (!" + *field->name + ".verify())");
        Indent(1);
        WriteLineIndent("return false;");
        Indent(-1);
        WriteLineIndent("fbe_current_size += " + *field->name + ".fbe_size();");
      }
    }
    WriteLine();
  }
  WriteLineIndent("return true;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model get_begin() method
  WriteLineIndent("size_t " + model_name + "::get_begin() const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent(
      "if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + "
      "_buffer.offset() + fbe_offset());");
  WriteLineIndent("assert(((fbe_struct_offset > 0) && ((_buffer.offset() + "
                  "fbe_struct_offset + 4 + 4) <= _buffer.size())) && \"Model "
                  "is broken!\");");
  WriteLineIndent("if ((fbe_struct_offset == 0) || ((_buffer.offset() + "
                  "fbe_struct_offset + 4 + 4) > _buffer.size()))");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + "
      "_buffer.offset() + fbe_struct_offset);");
  WriteLineIndent(
      "assert((fbe_struct_size >= (4 + 4)) && \"Model is broken!\");");
  WriteLineIndent("if (fbe_struct_size < (4 + 4))");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("_buffer.shift(fbe_struct_offset);");
  WriteLineIndent("return fbe_struct_offset;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model get_end() method
  WriteLineIndent("void " + model_name +
                  "::get_end(size_t fbe_begin) const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("_buffer.unshift(fbe_begin);");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model get() method
  WriteLineIndent(
      "void " + model_name + "::get(" + struct_name +
      "& fbe_value, std::pmr::memory_resource* resource) const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("size_t fbe_begin = get_begin();");
  WriteLineIndent("if (fbe_begin == 0)");
  Indent(1);
  WriteLineIndent("return;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + "
      "_buffer.offset());");
  WriteLineIndent("get_fields(fbe_value, fbe_struct_size, resource);");
  WriteLineIndent("get_end(fbe_begin);");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model get_fields() method
  WriteLineIndent("void " + model_name + "::get_fields([[maybe_unused]] " +
                  struct_name +
                  "& fbe_value, [[maybe_unused]] size_t fbe_struct_size, "
                  "std::pmr::memory_resource* resource) const noexcept");
  WriteLineIndent("{");
  Indent(1);
  if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty())) {
    WriteLineIndent("size_t fbe_current_size = 4 + 4;");
    if (s->base && !s->base->empty()) {
      WriteLine();
      WriteLineIndent("if ((fbe_current_size + parent.fbe_body() - 4 - 4) <= "
                      "fbe_struct_size)");
      Indent(1);
      WriteLineIndent(
          "parent.get_fields(fbe_value, fbe_struct_size, resource);");
      Indent(-1);
      WriteLineIndent("fbe_current_size += parent.fbe_body() - 4 - 4;");
    }
    if (s->body) {
      for (const auto &field : s->body->fields) {
        WriteLine();
        WriteLineIndent("if ((fbe_current_size + " + *field->name +
                        ".fbe_size()) <= fbe_struct_size)");
        Indent(1);
        WriteLineIndent(*field->name + ".get(fbe_value." + *field->name +
                        (field->value
                             ? (", resource, " +
                                ConvertConstant(*field->type, *field->value,
                                                field->optional))
                             : ", resource") +
                        ");");
        Indent(-1);
        WriteLineIndent("else");
        Indent(1);
        if (field->array) {
          // Do nothing here...
        } else if (field->vector || field->list || field->set || field->map ||
                   field->hash ||
                   ((*field->type == "bytes") && !field->optional))
          WriteLineIndent("fbe_value." + *field->name + ".clear();");
        else
          WriteLineIndent("fbe_value." + *field->name + " = " +
                          ConvertDefault(*p->name, *field) + ";");
        Indent(-1);
        WriteLineIndent("fbe_current_size += " + *field->name + ".fbe_size();");
      }
    }
  }
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model set_begin() method
  WriteLineIndent("size_t " + model_name + "::set_begin()");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= "
                  "_buffer.size()) && \"Model is broken!\");");
  WriteLineIndent(
      "if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("uint32_t fbe_struct_size = (uint32_t)fbe_body();");
  WriteLineIndent(
      "uint32_t fbe_struct_offset = "
      "(uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());");
  WriteLineIndent("assert(((fbe_struct_offset > 0) && ((_buffer.offset() + "
                  "fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "
                  "\"Model is broken!\");");
  WriteLineIndent("if ((fbe_struct_offset == 0) || ((_buffer.offset() + "
                  "fbe_struct_offset + fbe_struct_size) > _buffer.size()))");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() "
                  "+ fbe_offset(), fbe_struct_offset);");
  WriteLineIndent("unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() "
                  "+ fbe_struct_offset, fbe_struct_size);");
  WriteLineIndent("unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() "
                  "+ fbe_struct_offset + 4, (uint32_t)fbe_type());");
  WriteLine();
  WriteLineIndent("_buffer.shift(fbe_struct_offset);");
  WriteLineIndent("return fbe_struct_offset;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model set_end() method
  WriteLineIndent("void " + model_name + "::set_end(size_t fbe_begin)");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("_buffer.unshift(fbe_begin);");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model set() method
  WriteLineIndent("void " + model_name + "::set(const " + struct_name +
                  "& fbe_value, std::pmr::memory_resource* resource) noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("size_t fbe_begin = set_begin();");
  WriteLineIndent("if (fbe_begin == 0)");
  Indent(1);
  WriteLineIndent("return;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("set_fields(fbe_value, resource);");
  WriteLineIndent("set_end(fbe_begin);");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model set_fields() method
  WriteLineIndent("void " + model_name +
                  "::set_fields([[maybe_unused]] const " + struct_name +
                  "& fbe_value, std::pmr::memory_resource* resource) noexcept");
  WriteLineIndent("{");
  Indent(1);
  if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty())) {
    if (s->base && !s->base->empty())
      WriteLineIndent("parent.set_fields(fbe_value, resource);");
    if (s->body)
      for (const auto &field : s->body->fields)
        WriteLineIndent(*field->name + ".set(fbe_value." + *field->name +
                        ", resource);");
  }
  Indent(-1);
  WriteLineIndent("}");
}

void GeneratorCpp::GenerateStructModel_Header(
    const std::shared_ptr<Package> &p, const std::shared_ptr<StructType> &s) {
  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

  std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;

  // Generate struct model begin
  WriteLine();
  WriteLineIndent("// Fast Binary Encoding " + *s->name + " model");
  WriteLineIndent("class " + *s->name + "Model : public FBE::Model");
  WriteLineIndent("{");
  WriteLineIndent("public:");
  Indent(1);

  // Generate struct model constructor
  WriteLineIndent(*s->name + "Model() : model(this->buffer(), 4) {}");
  WriteLineIndent(*s->name +
                  "Model(const std::shared_ptr<FBEBuffer>& buffer) : "
                  "FBE::Model(buffer), model(this->buffer(), 4) {}");

  // Generate struct model FBE methods
  WriteLine();
  WriteLineIndent("// Get the model size");
  WriteLineIndent("size_t fbe_size() const noexcept { return model.fbe_size() "
                  "+ model.fbe_extra(); }");
  WriteLineIndent("// Get the model type");
  WriteLineIndent(
      "static constexpr size_t fbe_type() noexcept { return FieldModel<" +
      struct_name + ">::fbe_type(); }");

  // Generate struct model verify() method
  WriteLine();
  WriteLineIndent("// Check if the struct value is valid");
  WriteLineIndent("bool verify();");

  // Generate struct model create_begin(), create_end() methods
  WriteLine();
  WriteLineIndent("// Create a new model (begin phase)");
  WriteLineIndent("size_t create_begin();");
  WriteLineIndent("// Create a new model (end phase)");
  WriteLineIndent("size_t create_end(size_t fbe_begin);");

  // Generate struct model serialize(), deserialize() methods
  WriteLine();
  WriteLineIndent("// Serialize the struct value");
  WriteLineIndent("size_t serialize(const " + struct_name +
                  "& value, std::pmr::memory_resource* resource);");
  WriteLineIndent("// Deserialize the struct value");
  WriteLineIndent(
      "size_t deserialize(" + struct_name +
      "& value, std::pmr::memory_resource* resource) const noexcept;");

  // Generate struct model next() method
  WriteLine();
  WriteLineIndent("// Move to the next struct value");
  WriteLineIndent("void next(size_t prev) noexcept { model.fbe_shift(prev); }");

  // Generate struct model accessor
  Indent(-1);
  WriteLine();
  WriteLineIndent("public:");
  Indent(1);
  WriteLineIndent("FieldModel<" + struct_name + "> model;");

  // Generate struct model end
  Indent(-1);
  WriteLineIndent("};");

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));

  // Generate model_of
  WriteLine();
  WriteLine("template<>");
  WriteLine("struct model_of<" + struct_name + "> {");
  WriteLineIndent("using type = " + ConvertNamespace(*p->name) +
                  "::" + *s->name + "Model;");
  WriteLine("};");
  WriteLine();
}

void GeneratorCpp::GenerateStructModel_Source(
    const std::shared_ptr<Package> &p, const std::shared_ptr<StructType> &s) {
  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

  std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
  std::string model_name = *s->name + "Model";

  // Generate struct model verify() method
  WriteLine();
  WriteLineIndent("bool " + model_name + "::verify()");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("if ((this->buffer().offset() + model.fbe_offset() - 4) > "
                  "this->buffer().size())");
  Indent(1);
  WriteLineIndent("return false;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() "
      "+ this->buffer().offset() + model.fbe_offset() - 4);");
  WriteLineIndent("if (fbe_full_size < model.fbe_size())");
  Indent(1);
  WriteLineIndent("return false;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("return model.verify();");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct model create_begin() method
  WriteLineIndent("size_t " + model_name + "::create_begin()");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent(
      "size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());");
  WriteLineIndent("return fbe_begin;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct model create_end() method
  WriteLineIndent("size_t " + model_name + "::create_end(size_t fbe_begin)");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("size_t fbe_end = this->buffer().size();");
  WriteLineIndent("uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);");
  WriteLineIndent(
      "unaligned_store<uint32_t>(this->buffer().data() + "
      "this->buffer().offset() + model.fbe_offset() - 4, fbe_full_size);");
  WriteLineIndent("return fbe_full_size;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct model serialize() method
  WriteLineIndent("size_t " + model_name + "::serialize(const " + struct_name +
                  "& value, std::pmr::memory_resource* resource)");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("size_t fbe_begin = create_begin();");
  WriteLineIndent("model.set(value, resource);");
  WriteLineIndent("size_t fbe_full_size = create_end(fbe_begin);");
  WriteLineIndent("return fbe_full_size;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct model deserialize() method
  WriteLineIndent(
      "size_t " + model_name + "::deserialize(" + struct_name +
      "& value, std::pmr::memory_resource* resource) const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("if ((this->buffer().offset() + model.fbe_offset() - 4) > "
                  "this->buffer().size())");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() "
      "+ this->buffer().offset() + model.fbe_offset() - 4);");
  WriteLineIndent(
      "assert((fbe_full_size >= model.fbe_size()) && \"Model is broken!\");");
  WriteLineIndent("if (fbe_full_size < model.fbe_size())");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("model.get(value, resource);");
  WriteLineIndent("return fbe_full_size;");
  Indent(-1);
  WriteLineIndent("}");

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));
}

void GeneratorCpp::GenerateStructFinalModel_Header(
    const std::shared_ptr<Package> &p, const std::shared_ptr<StructType> &s) {
  std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;

  // Generate struct final model begin
  WriteLine();
  WriteLineIndent("// Fast Binary Encoding " + struct_name + " final model");
  WriteLineIndent("template <>");
  WriteLineIndent("class FinalModel<" + struct_name + ">");
  WriteLineIndent("{");
  WriteLineIndent("public:");
  Indent(1);

  // Generate struct final model constructor
  WriteLineIndent("FinalModel(FBEBuffer& buffer, size_t offset) noexcept;");

  // Generate struct final model FBE methods
  WriteLine();
  WriteLineIndent("// Get the allocation size");
  WriteLineIndent("size_t fbe_allocation_size(const " + struct_name +
                  "& fbe_value) const noexcept;");
  WriteLineIndent("// Get the final offset");
  WriteLineIndent("size_t fbe_offset() const noexcept { return _offset; }");
  WriteLineIndent("// Set the final offset");
  WriteLineIndent("size_t fbe_offset(size_t offset) const noexcept { return "
                  "_offset = offset; }");
  WriteLineIndent("// Get the final type");
  if (s->base && !s->base->empty() && (s->type == 0))
    WriteLineIndent(
        "static constexpr size_t fbe_type() noexcept { return FinalModel<" +
        ConvertTypeName(*p->name, *s->base, false) + ">::fbe_type(); }");
  else
    WriteLineIndent("static constexpr size_t fbe_type() noexcept { return " +
                    std::to_string(s->type) + "; }");
  WriteLine();
  WriteLineIndent("// Shift the current final offset");
  WriteLineIndent("void fbe_shift(size_t size) noexcept { _offset += size; }");
  WriteLineIndent("// Unshift the current final offset");
  WriteLineIndent(
      "void fbe_unshift(size_t size) noexcept { _offset -= size; }");

  // Generate struct final model verify(), verify_fields() methods
  WriteLine();
  WriteLineIndent("// Check if the struct value is valid");
  WriteLineIndent("size_t verify() const noexcept;");
  WriteLineIndent("// Check if the struct fields are valid");
  WriteLineIndent("size_t verify_fields() const noexcept;");

  // Generate struct final model get(), get_fields() methods
  WriteLine();
  WriteLineIndent("// Get the struct value");
  WriteLineIndent("size_t get(" + struct_name + "& fbe_value) const noexcept;");
  WriteLineIndent("// Get the struct fields values");
  WriteLineIndent("size_t get_fields(" + struct_name +
                  "& fbe_value) const noexcept;");
  if (Arena()) {
    WriteLineIndent("// Get the struct value with memory resource");
    WriteLineIndent(
        "size_t get(" + struct_name +
        "& fbe_value, std::pmr::memory_resource* resource) const noexcept;");
    WriteLineIndent("// Get the struct fields values with memory resource");
    WriteLineIndent(
        "size_t get_fields(" + struct_name +
        "& fbe_value, std::pmr::memory_resource* resource) const noexcept;");
  }

  // Generate struct final model set(), set_fields() method
  WriteLine();
  WriteLineIndent("// Set the struct value");
  WriteLineIndent("size_t set(const " + struct_name + "& fbe_value) noexcept;");
  WriteLineIndent("// Set the struct fields values");
  WriteLineIndent("size_t set_fields(const " + struct_name +
                  "& fbe_value) noexcept;");

  // Generate struct final model buffer & offset
  Indent(-1);
  WriteLine();
  WriteLineIndent("private:");
  Indent(1);
  WriteLineIndent("FBEBuffer& _buffer;");
  WriteLineIndent("mutable size_t _offset;");

  // Generate struct final model accessors
  Indent(-1);
  WriteLine();
  WriteLineIndent("public:");
  Indent(1);
  if (s->base && !s->base->empty())
    WriteLineIndent("FinalModel<" + ConvertTypeName(*p->name, *s->base, false) +
                    "> parent;");
  if (s->body) {
    for (const auto &field : s->body->fields) {
      if (field->array)
        WriteLineIndent(
            "FinalModelArray<" +
            ConvertTypeName(*p->name, *field->type, field->optional) + ", " +
            std::to_string(field->N) + "> " + *field->name + ";");
      else if (field->vector || field->list || field->set)
        WriteLineIndent(
            "FinalModelVector<" +
            ConvertTypeName(*p->name, *field->type, field->optional) + "> " +
            *field->name + ";");
      else if (field->map || field->hash)
        WriteLineIndent(
            "FinalModelMap<" + ConvertTypeName(*p->name, *field->key, false) +
            ", " + ConvertTypeName(*p->name, *field->type, field->optional) +
            "> " + *field->name + ";");
      else
        WriteLineIndent(
            "FinalModel<" +
            ConvertTypeName(*p->name, *field->type, field->optional) + "> " +
            *field->name + ";");
    }
  }

  // Generate struct final model end
  Indent(-1);
  WriteLineIndent("};");
}

void GeneratorCpp::GenerateStructFinalModel_Source(
    const std::shared_ptr<Package> &p, const std::shared_ptr<StructType> &s) {
  std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
  std::string model_name = "FinalModel<" + struct_name + ">";

  // Generate struct final model constructor
  WriteLine();
  WriteLineIndent(model_name + "::FinalModel(FBEBuffer& buffer, size_t offset) "
                               "noexcept : _buffer(buffer), _offset(offset)");
  Indent(1);
  if (s->base && !s->base->empty())
    WriteLineIndent(", parent(buffer, 0)");
  if (s->body)
    for (const auto &field : s->body->fields)
      WriteLineIndent(", " + *field->name + "(buffer, 0)");
  Indent(-1);
  WriteLineIndent("{}");
  WriteLine();

  // Generate struct final model FBE methods
  WriteLineIndent("size_t " + model_name + "::fbe_allocation_size(const " +
                  struct_name + "& fbe_value) const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("size_t fbe_result = 0");
  Indent(1);
  if (s->base && !s->base->empty())
    WriteLineIndent("+ parent.fbe_allocation_size(fbe_value)");
  if (s->body)
    for (const auto &field : s->body->fields)
      WriteLineIndent("+ " + *field->name + ".fbe_allocation_size(fbe_value." +
                      *field->name + ")");
  WriteLineIndent(";");
  Indent(-1);
  WriteLineIndent("return fbe_result;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct final model verify() method
  WriteLineIndent("size_t " + model_name + "::verify() const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("_buffer.shift(fbe_offset());");
  WriteLineIndent("size_t fbe_result = verify_fields();");
  WriteLineIndent("_buffer.unshift(fbe_offset());");
  WriteLineIndent("return fbe_result;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct final model verify_fields() method
  WriteLineIndent("size_t " + model_name + "::verify_fields() const noexcept");
  WriteLineIndent("{");
  Indent(1);
  if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty())) {
    WriteLineIndent("size_t fbe_current_offset = 0;");
    WriteLineIndent("[[maybe_unused]] size_t fbe_field_size;");
    if (s->base && !s->base->empty()) {
      WriteLine();
      WriteLineIndent("parent.fbe_offset(fbe_current_offset);");
      WriteLineIndent("fbe_field_size = parent.verify_fields();");
      WriteLineIndent(
          "if (fbe_field_size == std::numeric_limits<std::size_t>::max())");
      Indent(1);
      WriteLineIndent("return std::numeric_limits<std::size_t>::max();");
      Indent(-1);
      WriteLineIndent("fbe_current_offset += fbe_field_size;");
    }
    if (s->body) {
      // Batch verify consecutive fixed-size fields (primitives, enums, flags,
      // uuid)
      for (size_t i = 0; i < s->body->fields.size();) {
        const auto &field = s->body->fields[i];

        // Check if this is a batchable fixed-size field (including uuid for
        // verify)
        if (IsFixedSizeType(p, *field->type, field->optional) &&
            !IsContainerType(*field)) {
          // Find all consecutive fixed-size fields
          size_t batch_start = i;
          size_t batch_size = 0;
          while (i < s->body->fields.size()) {
            const auto &f = s->body->fields[i];
            if (!IsFixedSizeType(p, *f->type, f->optional) ||
                IsContainerType(*f))
              break;
            size_t field_size = GetFixedTypeSize(p, *f->type);
            if (*f->type == "uuid")
              field_size = 16; // uuid is 16 bytes
            batch_size += field_size;
            i++;
          }

          size_t batch_count = i - batch_start;
          if (batch_count > 1) {
            // Generate batched verify for multiple fixed-size fields
            WriteLine();
            WriteLineIndent("// Batch verify " + std::to_string(batch_count) +
                            " fixed-size fields (" +
                            std::to_string(batch_size) + " bytes)");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent("if ((_buffer.offset() + fbe_current_offset + " +
                            std::to_string(batch_size) + ") > _buffer.size())");
            Indent(1);
            WriteLineIndent("return std::numeric_limits<std::size_t>::max();");
            Indent(-1);
            WriteLineIndent(
                "fbe_current_offset += " + std::to_string(batch_size) + ";");
            Indent(-1);
            WriteLineIndent("}");
          } else {
            // Single fixed-size field - inline verify
            const auto &f = s->body->fields[batch_start];
            const std::string &fbe_type = *f->type;
            size_t field_size =
                (fbe_type == "uuid") ? 16 : GetFixedTypeSize(p, fbe_type);
            WriteLine();
            WriteLineIndent("// Inline verify of " + fbe_type + " field " +
                            *f->name + " (" + std::to_string(field_size) +
                            " bytes)");
            WriteLineIndent("if ((_buffer.offset() + fbe_current_offset + " +
                            std::to_string(field_size) + ") > _buffer.size())");
            Indent(1);
            WriteLineIndent("return std::numeric_limits<std::size_t>::max();");
            Indent(-1);
            WriteLineIndent(
                "fbe_current_offset += " + std::to_string(field_size) + ";");
          }
        } else {
          // Non-fixed-size field - use original code
          WriteLine();
          WriteLineIndent(*field->name + ".fbe_offset(fbe_current_offset);");
          WriteLineIndent("fbe_field_size = " + *field->name + ".verify();");
          WriteLineIndent(
              "if (fbe_field_size == std::numeric_limits<std::size_t>::max())");
          Indent(1);
          WriteLineIndent("return std::numeric_limits<std::size_t>::max();");
          Indent(-1);
          WriteLineIndent("fbe_current_offset += fbe_field_size;");
          i++;
        }
      }
    }
    WriteLine();
    WriteLineIndent("return fbe_current_offset;");
  } else
    WriteLineIndent("return 0;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct final model get() method
  WriteLineIndent("size_t " + model_name + "::get(" + struct_name +
                  "& fbe_value) const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("_buffer.shift(fbe_offset());");
  WriteLineIndent("size_t fbe_result = get_fields(fbe_value);");
  WriteLineIndent("_buffer.unshift(fbe_offset());");
  WriteLineIndent("return fbe_result;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct final model get_fields() method
  WriteLineIndent("size_t " + model_name + "::get_fields([[maybe_unused]] " +
                  struct_name + "& fbe_value) const noexcept");
  WriteLineIndent("{");
  Indent(1);
  if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty())) {
    // Check if we need dynamic offset tracking (for base class or
    // non-fixed-size fields)
    bool has_base = s->base && !s->base->empty();
    bool has_non_fixed = has_base;
    if (!has_non_fixed && s->body) {
      for (const auto &field : s->body->fields) {
        if (!IsFixedSizeType(p, *field->type, field->optional) ||
            IsContainerType(*field)) {
          has_non_fixed = true;
          break;
        }
      }
    }

    if (has_non_fixed) {
      // Original logic with offset tracking for mixed fixed/non-fixed fields
      WriteLineIndent("size_t fbe_current_offset = 0;");
      WriteLineIndent("size_t fbe_current_size = 0;");
      WriteLineIndent("[[maybe_unused]] size_t fbe_field_size;");
      if (has_base) {
        WriteLine();
        WriteLineIndent("parent.fbe_offset(fbe_current_offset);");
        WriteLineIndent("fbe_field_size = parent.get_fields(fbe_value);");
        WriteLineIndent("fbe_current_offset += fbe_field_size;");
        WriteLineIndent("fbe_current_size += fbe_field_size;");
      }
      if (s->body) {
        // Process fields, batching consecutive fixed-size fields
        size_t i = 0;
        while (i < s->body->fields.size()) {
          const auto &field = s->body->fields[i];
          if (IsFixedSizeType(p, *field->type, field->optional) &&
              !IsContainerType(*field)) {
            // Find consecutive fixed-size fields (including uuid)
            size_t batch_start = i;
            size_t batch_size = 0;
            std::vector<
                std::tuple<std::string, std::string, size_t, std::string>>
                batch_fields; // name, cpp_type, offset, fbe_type
            while (i < s->body->fields.size()) {
              const auto &f = s->body->fields[i];
              if (!IsFixedSizeType(p, *f->type, f->optional) ||
                  IsContainerType(*f))
                break;
              size_t field_size =
                  (*f->type == "uuid") ? 16 : GetFixedTypeSize(p, *f->type);
              batch_fields.push_back({*f->name,
                                      GetFixedTypeCppName(p, *f->type),
                                      batch_size, *f->type});
              batch_size += field_size;
              i++;
            }

            if (batch_fields.size() >= 2) {
              // Generate batched read for 2+ consecutive fixed-size fields
              WriteLine();
              WriteLineIndent("// Batch read " +
                              std::to_string(batch_fields.size()) +
                              " fixed-size fields (" +
                              std::to_string(batch_size) + " bytes)");
              WriteLineIndent("{");
              Indent(1);
              WriteLineIndent("size_t fbe_batch_offset = _buffer.offset() + "
                              "fbe_current_offset;");
              WriteLineIndent("if ((fbe_batch_offset + " +
                              std::to_string(batch_size) +
                              ") > _buffer.size())");
              Indent(1);
              WriteLineIndent("return 0;");
              Indent(-1);
              WriteLineIndent("const uint8_t* fbe_batch_ptr = _buffer.data() + "
                              "fbe_batch_offset;");
              for (const auto &bf : batch_fields) {
                const std::string &fname = std::get<0>(bf);
                const std::string &cpp_type = std::get<1>(bf);
                size_t offset = std::get<2>(bf);
                const std::string &fbe_type = std::get<3>(bf);

                // Handle uuid special case - use memcpy
                if (fbe_type == "uuid") {
                  WriteLineIndent("std::memcpy(fbe_value." + fname +
                                  ".data().data(), fbe_batch_ptr + " +
                                  std::to_string(offset) + ", 16);");
                } else {
                  std::string cast_prefix = "";
                  std::string cast_suffix = "";
                  // Handle bool special case - need to cast from uint8_t
                  if (fbe_type == "bool") {
                    cast_prefix = "static_cast<bool>(";
                    cast_suffix = ")";
                  }
                  // Handle enum/flags - need to cast from underlying type
                  else if (!IsPrimitiveType(fbe_type, false)) {
                    // This is an enum or flags type
                    cast_prefix =
                        "static_cast<decltype(fbe_value." + fname + ")>(";
                    cast_suffix = ")";
                  }
                  WriteLineIndent(
                      "fbe_value." + fname + " = " + cast_prefix +
                      "unaligned_load<" + cpp_type + ">(fbe_batch_ptr + " +
                      std::to_string(offset) + ")" + cast_suffix + ";");
                }
              }
              WriteLineIndent(
                  "fbe_current_offset += " + std::to_string(batch_size) + ";");
              WriteLineIndent(
                  "fbe_current_size += " + std::to_string(batch_size) + ";");
              Indent(-1);
              WriteLineIndent("}");
            } else {
              // Single fixed-size field - inline read
              const auto &f = s->body->fields[batch_start];
              const std::string &fbe_type = *f->type;
              size_t field_size =
                  (fbe_type == "uuid") ? 16 : GetFixedTypeSize(p, fbe_type);
              WriteLine();
              WriteLineIndent("// Inline read of " + fbe_type + " field " +
                              *f->name + " (" + std::to_string(field_size) +
                              " bytes)");
              WriteLineIndent("{");
              Indent(1);
              WriteLineIndent("size_t fbe_field_offset = _buffer.offset() + "
                              "fbe_current_offset;");
              WriteLineIndent("if ((fbe_field_offset + " +
                              std::to_string(field_size) +
                              ") > _buffer.size())");
              Indent(1);
              WriteLineIndent("return 0;");
              Indent(-1);
              if (fbe_type == "uuid") {
                WriteLineIndent(
                    "std::memcpy(fbe_value." + *f->name +
                    ".data().data(), _buffer.data() + fbe_field_offset, 16);");
              } else {
                std::string cpp_type = GetFixedTypeCppName(p, fbe_type);
                std::string cast_prefix = "";
                std::string cast_suffix = "";
                if (fbe_type == "bool") {
                  cast_prefix = "static_cast<bool>(";
                  cast_suffix = ")";
                } else if (!IsPrimitiveType(fbe_type, false)) {
                  cast_prefix =
                      "static_cast<decltype(fbe_value." + *f->name + ")>(";
                  cast_suffix = ")";
                }
                WriteLineIndent("fbe_value." + *f->name + " = " + cast_prefix +
                                "unaligned_load<" + cpp_type +
                                ">(_buffer.data() + fbe_field_offset)" +
                                cast_suffix + ";");
              }
              WriteLineIndent(
                  "fbe_current_offset += " + std::to_string(field_size) + ";");
              WriteLineIndent(
                  "fbe_current_size += " + std::to_string(field_size) + ";");
              Indent(-1);
              WriteLineIndent("}");
            }
          } else {
            // Non-fixed-size field - use original code
            WriteLine();
            WriteLineIndent(*field->name + ".fbe_offset(fbe_current_offset);");
            WriteLineIndent("fbe_field_size = " + *field->name +
                            ".get(fbe_value." + *field->name + ");");
            WriteLineIndent("fbe_current_offset += fbe_field_size;");
            WriteLineIndent("fbe_current_size += fbe_field_size;");
            i++;
          }
        }
      }
      WriteLine();
      WriteLineIndent("return fbe_current_size;");
    } else if (s->body && !s->body->fields.empty()) {
      // All fields are fixed-size - generate fully optimized code with
      // compile-time offsets
      size_t total_size = 0;
      std::vector<std::tuple<std::string, std::string, size_t, std::string>>
          all_fields; // name, cpp_type, offset, fbe_type
      for (const auto &field : s->body->fields) {
        size_t field_size =
            (*field->type == "uuid") ? 16 : GetFixedTypeSize(p, *field->type);
        all_fields.push_back({*field->name,
                              GetFixedTypeCppName(p, *field->type), total_size,
                              *field->type});
        total_size += field_size;
      }

      WriteLineIndent("// All fields are fixed-size - optimized batch read (" +
                      std::to_string(total_size) + " bytes)");
      WriteLineIndent("size_t fbe_base_offset = _buffer.offset();");
      WriteLineIndent("if ((fbe_base_offset + " + std::to_string(total_size) +
                      ") > _buffer.size())");
      Indent(1);
      WriteLineIndent("return 0;");
      Indent(-1);
      WriteLineIndent(
          "const uint8_t* fbe_data = _buffer.data() + fbe_base_offset;");
      for (const auto &f : all_fields) {
        const std::string &fname = std::get<0>(f);
        const std::string &cpp_type = std::get<1>(f);
        size_t offset = std::get<2>(f);
        const std::string &fbe_type = std::get<3>(f);

        // Handle uuid special case - use memcpy
        if (fbe_type == "uuid") {
          WriteLineIndent("std::memcpy(fbe_value." + fname +
                          ".data().data(), fbe_data + " +
                          std::to_string(offset) + ", 16);");
        } else {
          std::string cast_prefix = "";
          std::string cast_suffix = "";
          if (fbe_type == "bool") {
            cast_prefix = "static_cast<bool>(";
            cast_suffix = ")";
          } else if (!IsPrimitiveType(fbe_type, false)) {
            // This is an enum or flags type
            cast_prefix = "static_cast<decltype(fbe_value." + fname + ")>(";
            cast_suffix = ")";
          }
          WriteLineIndent("fbe_value." + fname + " = " + cast_prefix +
                          "unaligned_load<" + cpp_type + ">(fbe_data + " +
                          std::to_string(offset) + ")" + cast_suffix + ";");
        }
      }
      WriteLineIndent("return " + std::to_string(total_size) + ";");
    } else {
      WriteLineIndent("return 0;");
    }
  } else
    WriteLineIndent("return 0;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct final model get() with memory resource (Arena mode only)
  if (Arena()) {
    WriteLineIndent("size_t " + model_name + "::get(" + struct_name +
                    "& fbe_value, [[maybe_unused]] std::pmr::memory_resource* "
                    "resource) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("_buffer.shift(fbe_offset());");
    WriteLineIndent("size_t fbe_result = get_fields(fbe_value, resource);");
    WriteLineIndent("_buffer.unshift(fbe_offset());");
    WriteLineIndent("return fbe_result;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate struct final model get_fields() with memory resource (Arena mode
    // only)
    WriteLineIndent("size_t " + model_name + "::get_fields([[maybe_unused]] " +
                    struct_name +
                    "& fbe_value, [[maybe_unused]] std::pmr::memory_resource* "
                    "resource) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    if ((s->base && !s->base->empty()) ||
        (s->body && !s->body->fields.empty())) {
      // Check if we need dynamic offset tracking (for base class or
      // non-fixed-size fields)
      bool has_base = s->base && !s->base->empty();
      bool has_non_fixed = has_base;
      if (!has_non_fixed && s->body) {
        for (const auto &field : s->body->fields) {
          if (!IsFixedSizeType(p, *field->type, field->optional) ||
              IsContainerType(*field)) {
            has_non_fixed = true;
            break;
          }
        }
      }

      if (has_non_fixed) {
        // Logic with offset tracking for mixed fixed/non-fixed fields
        WriteLineIndent("size_t fbe_current_offset = 0;");
        WriteLineIndent("size_t fbe_current_size = 0;");
        WriteLineIndent("[[maybe_unused]] size_t fbe_field_size;");
        if (has_base) {
          WriteLine();
          WriteLineIndent("parent.fbe_offset(fbe_current_offset);");
          WriteLineIndent(
              "fbe_field_size = parent.get_fields(fbe_value, resource);");
          WriteLineIndent("fbe_current_offset += fbe_field_size;");
          WriteLineIndent("fbe_current_size += fbe_field_size;");
        }
        if (s->body) {
          // Process fields, batching consecutive fixed-size fields
          size_t i = 0;
          while (i < s->body->fields.size()) {
            const auto &field = s->body->fields[i];
            if (IsFixedSizeType(p, *field->type, field->optional) &&
                !IsContainerType(*field)) {
              // Find consecutive fixed-size fields
              size_t batch_start = i;
              size_t batch_size = 0;
              std::vector<
                  std::tuple<std::string, std::string, size_t, std::string>>
                  batch_fields;
              while (i < s->body->fields.size()) {
                const auto &f = s->body->fields[i];
                if (!IsFixedSizeType(p, *f->type, f->optional) ||
                    IsContainerType(*f))
                  break;
                size_t field_size =
                    (*f->type == "uuid") ? 16 : GetFixedTypeSize(p, *f->type);
                batch_fields.push_back({*f->name,
                                        GetFixedTypeCppName(p, *f->type),
                                        batch_size, *f->type});
                batch_size += field_size;
                i++;
              }

              if (batch_fields.size() >= 2) {
                // Generate batched read for 2+ consecutive fixed-size fields
                WriteLine();
                WriteLineIndent("// Batch read " +
                                std::to_string(batch_fields.size()) +
                                " fixed-size fields (" +
                                std::to_string(batch_size) + " bytes)");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("size_t fbe_batch_offset = _buffer.offset() + "
                                "fbe_current_offset;");
                WriteLineIndent("if ((fbe_batch_offset + " +
                                std::to_string(batch_size) +
                                ") > _buffer.size())");
                Indent(1);
                WriteLineIndent("return 0;");
                Indent(-1);
                WriteLineIndent("const uint8_t* fbe_batch_ptr = _buffer.data() "
                                "+ fbe_batch_offset;");
                for (const auto &bf : batch_fields) {
                  const std::string &fname = std::get<0>(bf);
                  const std::string &cpp_type = std::get<1>(bf);
                  size_t offset = std::get<2>(bf);
                  const std::string &fbe_type = std::get<3>(bf);

                  if (fbe_type == "uuid") {
                    WriteLineIndent("std::memcpy(fbe_value." + fname +
                                    ".data().data(), fbe_batch_ptr + " +
                                    std::to_string(offset) + ", 16);");
                  } else {
                    std::string cast_prefix = "";
                    std::string cast_suffix = "";
                    if (fbe_type == "bool") {
                      cast_prefix = "static_cast<bool>(";
                      cast_suffix = ")";
                    } else if (!IsPrimitiveType(fbe_type, false)) {
                      cast_prefix =
                          "static_cast<decltype(fbe_value." + fname + ")>(";
                      cast_suffix = ")";
                    }
                    WriteLineIndent(
                        "fbe_value." + fname + " = " + cast_prefix +
                        "unaligned_load<" + cpp_type + ">(fbe_batch_ptr + " +
                        std::to_string(offset) + ")" + cast_suffix + ";");
                  }
                }
                WriteLineIndent("fbe_current_offset += " +
                                std::to_string(batch_size) + ";");
                WriteLineIndent(
                    "fbe_current_size += " + std::to_string(batch_size) + ";");
                Indent(-1);
                WriteLineIndent("}");
              } else {
                // Single fixed-size field - inline read
                const auto &f = s->body->fields[batch_start];
                const std::string &fbe_type = *f->type;
                size_t field_size =
                    (fbe_type == "uuid") ? 16 : GetFixedTypeSize(p, fbe_type);
                WriteLine();
                WriteLineIndent("// Inline read of " + fbe_type + " field " +
                                *f->name + " (" + std::to_string(field_size) +
                                " bytes)");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("size_t fbe_field_offset = _buffer.offset() + "
                                "fbe_current_offset;");
                WriteLineIndent("if ((fbe_field_offset + " +
                                std::to_string(field_size) +
                                ") > _buffer.size())");
                Indent(1);
                WriteLineIndent("return 0;");
                Indent(-1);
                if (fbe_type == "uuid") {
                  WriteLineIndent("std::memcpy(fbe_value." + *f->name +
                                  ".data().data(), _buffer.data() + "
                                  "fbe_field_offset, 16);");
                } else {
                  std::string cpp_type = GetFixedTypeCppName(p, fbe_type);
                  std::string cast_prefix = "";
                  std::string cast_suffix = "";
                  if (fbe_type == "bool") {
                    cast_prefix = "static_cast<bool>(";
                    cast_suffix = ")";
                  } else if (!IsPrimitiveType(fbe_type, false)) {
                    cast_prefix =
                        "static_cast<decltype(fbe_value." + *f->name + ")>(";
                    cast_suffix = ")";
                  }
                  WriteLineIndent("fbe_value." + *f->name + " = " +
                                  cast_prefix + "unaligned_load<" + cpp_type +
                                  ">(_buffer.data() + fbe_field_offset)" +
                                  cast_suffix + ";");
                }
                WriteLineIndent("fbe_current_offset += " +
                                std::to_string(field_size) + ";");
                WriteLineIndent(
                    "fbe_current_size += " + std::to_string(field_size) + ";");
                Indent(-1);
                WriteLineIndent("}");
              }
            } else {
              // Non-fixed-size field - pass resource parameter
              WriteLine();
              WriteLineIndent(*field->name +
                              ".fbe_offset(fbe_current_offset);");
              WriteLineIndent("fbe_field_size = " + *field->name +
                              ".get(fbe_value." + *field->name +
                              ", resource);");
              WriteLineIndent("fbe_current_offset += fbe_field_size;");
              WriteLineIndent("fbe_current_size += fbe_field_size;");
              i++;
            }
          }
        }
        WriteLine();
        WriteLineIndent("return fbe_current_size;");
      } else if (s->body && !s->body->fields.empty()) {
        // All fields are fixed-size - generate fully optimized code with
        // compile-time offsets
        size_t total_size = 0;
        std::vector<std::tuple<std::string, std::string, size_t, std::string>>
            all_fields;
        for (const auto &field : s->body->fields) {
          size_t field_size =
              (*field->type == "uuid") ? 16 : GetFixedTypeSize(p, *field->type);
          all_fields.push_back({*field->name,
                                GetFixedTypeCppName(p, *field->type),
                                total_size, *field->type});
          total_size += field_size;
        }

        WriteLineIndent(
            "// All fields are fixed-size - optimized batch read (" +
            std::to_string(total_size) + " bytes)");
        WriteLineIndent("size_t fbe_base_offset = _buffer.offset();");
        WriteLineIndent("if ((fbe_base_offset + " + std::to_string(total_size) +
                        ") > _buffer.size())");
        Indent(1);
        WriteLineIndent("return 0;");
        Indent(-1);
        WriteLineIndent(
            "const uint8_t* fbe_data = _buffer.data() + fbe_base_offset;");
        for (const auto &f : all_fields) {
          const std::string &fname = std::get<0>(f);
          const std::string &cpp_type = std::get<1>(f);
          size_t offset = std::get<2>(f);
          const std::string &fbe_type = std::get<3>(f);

          if (fbe_type == "uuid") {
            WriteLineIndent("std::memcpy(fbe_value." + fname +
                            ".data().data(), fbe_data + " +
                            std::to_string(offset) + ", 16);");
          } else {
            std::string cast_prefix = "";
            std::string cast_suffix = "";
            if (fbe_type == "bool") {
              cast_prefix = "static_cast<bool>(";
              cast_suffix = ")";
            } else if (!IsPrimitiveType(fbe_type, false)) {
              cast_prefix = "static_cast<decltype(fbe_value." + fname + ")>(";
              cast_suffix = ")";
            }
            WriteLineIndent("fbe_value." + fname + " = " + cast_prefix +
                            "unaligned_load<" + cpp_type + ">(fbe_data + " +
                            std::to_string(offset) + ")" + cast_suffix + ";");
          }
        }
        WriteLineIndent("return " + std::to_string(total_size) + ";");
      } else {
        WriteLineIndent("return 0;");
      }
    } else
      WriteLineIndent("return 0;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
  }

  // Generate struct final model set() method
  WriteLineIndent("size_t " + model_name + "::set(const " + struct_name +
                  "& fbe_value) noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("_buffer.shift(fbe_offset());");
  WriteLineIndent("size_t fbe_result = set_fields(fbe_value);");
  WriteLineIndent("_buffer.unshift(fbe_offset());");
  WriteLineIndent("return fbe_result;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct final model set_fields() method
  WriteLineIndent("size_t " + model_name +
                  "::set_fields([[maybe_unused]] const " + struct_name +
                  "& fbe_value) noexcept");
  WriteLineIndent("{");
  Indent(1);
  if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty())) {
    // Check if we need dynamic offset tracking (for base class or
    // non-fixed-size fields)
    bool has_base = s->base && !s->base->empty();
    bool has_non_fixed = has_base;
    if (!has_non_fixed && s->body) {
      for (const auto &field : s->body->fields) {
        if (!IsFixedSizeType(p, *field->type, field->optional) ||
            IsContainerType(*field)) {
          has_non_fixed = true;
          break;
        }
      }
    }

    if (has_non_fixed) {
      // Original logic with offset tracking for mixed fixed/non-fixed fields
      WriteLineIndent("size_t fbe_current_offset = 0;");
      WriteLineIndent("size_t fbe_current_size = 0;");
      WriteLineIndent("[[maybe_unused]] size_t fbe_field_size;");
      if (has_base) {
        WriteLine();
        WriteLineIndent("parent.fbe_offset(fbe_current_offset);");
        WriteLineIndent("fbe_field_size = parent.set_fields(fbe_value);");
        WriteLineIndent("fbe_current_offset += fbe_field_size;");
        WriteLineIndent("fbe_current_size += fbe_field_size;");
      }
      if (s->body) {
        // Process fields, batching consecutive fixed-size fields
        size_t i = 0;
        while (i < s->body->fields.size()) {
          const auto &field = s->body->fields[i];
          if (IsFixedSizeType(p, *field->type, field->optional) &&
              !IsContainerType(*field)) {
            // Find consecutive fixed-size fields (including uuid)
            size_t batch_start = i;
            size_t batch_size = 0;
            std::vector<
                std::tuple<std::string, std::string, size_t, std::string>>
                batch_fields; // name, cpp_type, offset, fbe_type
            while (i < s->body->fields.size()) {
              const auto &f = s->body->fields[i];
              if (!IsFixedSizeType(p, *f->type, f->optional) ||
                  IsContainerType(*f))
                break;
              size_t field_size =
                  (*f->type == "uuid") ? 16 : GetFixedTypeSize(p, *f->type);
              batch_fields.push_back({*f->name,
                                      GetFixedTypeCppName(p, *f->type),
                                      batch_size, *f->type});
              batch_size += field_size;
              i++;
            }

            if (batch_fields.size() >= 2) {
              // Generate batched write for 2+ consecutive fixed-size fields
              WriteLine();
              WriteLineIndent("// Batch write " +
                              std::to_string(batch_fields.size()) +
                              " fixed-size fields (" +
                              std::to_string(batch_size) + " bytes)");
              WriteLineIndent("{");
              Indent(1);
              WriteLineIndent("size_t fbe_batch_offset = _buffer.offset() + "
                              "fbe_current_offset;");
              WriteLineIndent("assert(((fbe_batch_offset + " +
                              std::to_string(batch_size) +
                              ") <= _buffer.size()) && \"Model is broken!\");");
              WriteLineIndent("if ((fbe_batch_offset + " +
                              std::to_string(batch_size) +
                              ") > _buffer.size())");
              Indent(1);
              WriteLineIndent("return 0;");
              Indent(-1);
              WriteLineIndent("uint8_t* fbe_batch_ptr = _buffer.data() + "
                              "fbe_batch_offset;");
              for (const auto &bf : batch_fields) {
                const std::string &fname = std::get<0>(bf);
                const std::string &cpp_type = std::get<1>(bf);
                size_t offset = std::get<2>(bf);
                const std::string &fbe_type = std::get<3>(bf);

                // Handle uuid special case - use memcpy
                if (fbe_type == "uuid") {
                  WriteLineIndent("std::memcpy(fbe_batch_ptr + " +
                                  std::to_string(offset) + ", fbe_value." +
                                  fname + ".data().data(), 16);");
                } else {
                  std::string value_expr = "fbe_value." + fname;
                  // For bool, cast to uint8_t before storing
                  if (fbe_type == "bool") {
                    value_expr = "static_cast<uint8_t>(" + value_expr + ")";
                  }
                  // For enum/flags, cast to underlying type before storing
                  else if (!IsPrimitiveType(fbe_type, false)) {
                    value_expr =
                        "static_cast<" + cpp_type + ">(" + value_expr + ")";
                  }
                  WriteLineIndent(
                      "unaligned_store<" + cpp_type + ">(fbe_batch_ptr + " +
                      std::to_string(offset) + ", " + value_expr + ");");
                }
              }
              WriteLineIndent(
                  "fbe_current_offset += " + std::to_string(batch_size) + ";");
              WriteLineIndent(
                  "fbe_current_size += " + std::to_string(batch_size) + ";");
              Indent(-1);
              WriteLineIndent("}");
            } else {
              // Single fixed-size field - inline write
              const auto &f = s->body->fields[batch_start];
              const std::string &fbe_type = *f->type;
              size_t field_size =
                  (fbe_type == "uuid") ? 16 : GetFixedTypeSize(p, fbe_type);
              WriteLine();
              WriteLineIndent("// Inline write of " + fbe_type + " field " +
                              *f->name + " (" + std::to_string(field_size) +
                              " bytes)");
              WriteLineIndent("{");
              Indent(1);
              WriteLineIndent("size_t fbe_field_offset = _buffer.offset() + "
                              "fbe_current_offset;");
              WriteLineIndent("assert(((fbe_field_offset + " +
                              std::to_string(field_size) +
                              ") <= _buffer.size()) && \"Model is broken!\");");
              WriteLineIndent("if ((fbe_field_offset + " +
                              std::to_string(field_size) +
                              ") > _buffer.size())");
              Indent(1);
              WriteLineIndent("return 0;");
              Indent(-1);
              if (fbe_type == "uuid") {
                WriteLineIndent("std::memcpy(_buffer.data() + "
                                "fbe_field_offset, fbe_value." +
                                *f->name + ".data().data(), 16);");
              } else {
                std::string cpp_type = GetFixedTypeCppName(p, fbe_type);
                std::string value_expr = "fbe_value." + *f->name;
                if (fbe_type == "bool") {
                  value_expr = "static_cast<uint8_t>(" + value_expr + ")";
                } else if (!IsPrimitiveType(fbe_type, false)) {
                  value_expr =
                      "static_cast<" + cpp_type + ">(" + value_expr + ")";
                }
                WriteLineIndent("unaligned_store<" + cpp_type +
                                ">(_buffer.data() + fbe_field_offset, " +
                                value_expr + ");");
              }
              WriteLineIndent(
                  "fbe_current_offset += " + std::to_string(field_size) + ";");
              WriteLineIndent(
                  "fbe_current_size += " + std::to_string(field_size) + ";");
              Indent(-1);
              WriteLineIndent("}");
            }
          } else {
            // Non-fixed-size field - use original code
            WriteLine();
            WriteLineIndent(*field->name + ".fbe_offset(fbe_current_offset);");
            WriteLineIndent("fbe_field_size = " + *field->name +
                            ".set(fbe_value." + *field->name + ");");
            WriteLineIndent("fbe_current_offset += fbe_field_size;");
            WriteLineIndent("fbe_current_size += fbe_field_size;");
            i++;
          }
        }
      }
      WriteLine();
      WriteLineIndent("return fbe_current_size;");
    } else if (s->body && !s->body->fields.empty()) {
      // All fields are fixed-size - generate fully optimized code with
      // compile-time offsets
      size_t total_size = 0;
      std::vector<std::tuple<std::string, std::string, size_t, std::string>>
          all_fields; // name, cpp_type, offset, fbe_type
      for (const auto &field : s->body->fields) {
        size_t field_size =
            (*field->type == "uuid") ? 16 : GetFixedTypeSize(p, *field->type);
        all_fields.push_back({*field->name,
                              GetFixedTypeCppName(p, *field->type), total_size,
                              *field->type});
        total_size += field_size;
      }

      WriteLineIndent("// All fields are fixed-size - optimized batch write (" +
                      std::to_string(total_size) + " bytes)");
      WriteLineIndent("size_t fbe_base_offset = _buffer.offset();");
      WriteLineIndent("assert(((fbe_base_offset + " +
                      std::to_string(total_size) +
                      ") <= _buffer.size()) && \"Model is broken!\");");
      WriteLineIndent("if ((fbe_base_offset + " + std::to_string(total_size) +
                      ") > _buffer.size())");
      Indent(1);
      WriteLineIndent("return 0;");
      Indent(-1);
      WriteLineIndent("uint8_t* fbe_data = _buffer.data() + fbe_base_offset;");
      for (const auto &f : all_fields) {
        const std::string &fname = std::get<0>(f);
        const std::string &cpp_type = std::get<1>(f);
        size_t offset = std::get<2>(f);
        const std::string &fbe_type = std::get<3>(f);

        // Handle uuid special case - use memcpy
        if (fbe_type == "uuid") {
          WriteLineIndent("std::memcpy(fbe_data + " + std::to_string(offset) +
                          ", fbe_value." + fname + ".data().data(), 16);");
        } else {
          std::string value_expr = "fbe_value." + fname;
          if (fbe_type == "bool") {
            value_expr = "static_cast<uint8_t>(" + value_expr + ")";
          } else if (!IsPrimitiveType(fbe_type, false)) {
            // This is an enum or flags type
            value_expr = "static_cast<" + cpp_type + ">(" + value_expr + ")";
          }
          WriteLineIndent("unaligned_store<" + cpp_type + ">(fbe_data + " +
                          std::to_string(offset) + ", " + value_expr + ");");
        }
      }
      WriteLineIndent("return " + std::to_string(total_size) + ";");
    } else {
      WriteLineIndent("return 0;");
    }
  } else
    WriteLineIndent("return 0;");
  Indent(-1);
  WriteLineIndent("}");
}

void GeneratorCpp::GenerateStructModelFinal_Header(
    const std::shared_ptr<Package> &p, const std::shared_ptr<StructType> &s) {
  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

  std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;

  // Generate struct model final begin
  WriteLine();
  WriteLineIndent("// Fast Binary Encoding " + *s->name + " final model");
  WriteLineIndent("class " + *s->name + "FinalModel : public FBE::Model");
  WriteLineIndent("{");
  WriteLineIndent("public:");
  Indent(1);

  // Generate struct model final constructor
  WriteLineIndent(*s->name + "FinalModel() : _model(this->buffer(), 8) {}");
  WriteLineIndent(*s->name +
                  "FinalModel(const std::shared_ptr<FBEBuffer>& buffer) : "
                  "FBE::Model(buffer), _model(this->buffer(), 8) {}");

  // Generate struct model final FBE methods
  WriteLine();
  WriteLineIndent("// Get the model type");
  WriteLineIndent(
      "static constexpr size_t fbe_type() noexcept { return FinalModel<" +
      struct_name + ">::fbe_type(); }");

  // Generate struct model final verify() method
  WriteLine();
  WriteLineIndent("// Check if the struct value is valid");
  WriteLineIndent("bool verify();");

  // Generate struct model final serialize(), deserialize() methods
  WriteLine();
  WriteLineIndent("// Serialize the struct value");
  WriteLineIndent("size_t serialize(const " + struct_name + "& value);");
  WriteLineIndent("// Deserialize the struct value");
  WriteLineIndent("size_t deserialize(" + struct_name +
                  "& value) const noexcept;");
  if (Arena()) {
    WriteLineIndent("// Deserialize the struct value with memory resource");
    WriteLineIndent(
        "size_t deserialize(" + struct_name +
        "& value, std::pmr::memory_resource* resource) const noexcept;");
  }

  // Generate struct model final next() method
  WriteLine();
  WriteLineIndent("// Move to the next struct value");
  WriteLineIndent(
      "void next(size_t prev) noexcept { _model.fbe_shift(prev); }");

  // Generate struct model final accessor
  Indent(-1);
  WriteLine();
  WriteLineIndent("private:");
  Indent(1);
  WriteLineIndent("FinalModel<" + struct_name + "> _model;");

  // Generate struct model final end
  Indent(-1);
  WriteLineIndent("};");

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));
}

void GeneratorCpp::GenerateStructModelFinal_Source(
    const std::shared_ptr<Package> &p, const std::shared_ptr<StructType> &s) {
  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

  std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
  std::string model_name = *s->name + "FinalModel";

  // Generate struct model final verify() method
  WriteLine();
  WriteLineIndent("bool " + model_name + "::verify()");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("if ((this->buffer().offset() + _model.fbe_offset()) > "
                  "this->buffer().size())");
  Indent(1);
  WriteLineIndent("return false;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() "
      "+ this->buffer().offset() + _model.fbe_offset() - 8);");
  WriteLineIndent(
      "size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() "
      "+ this->buffer().offset() + _model.fbe_offset() - 4);");
  WriteLineIndent(
      "if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))");
  Indent(1);
  WriteLineIndent("return false;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("return ((8 + _model.verify()) == fbe_struct_size);");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct model final serialize() method
  WriteLineIndent("size_t " + model_name + "::serialize(const " + struct_name +
                  "& value)");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("size_t fbe_initial_size = this->buffer().size();");
  WriteLine();
  WriteLineIndent("uint32_t fbe_struct_type = (uint32_t)fbe_type();");
  WriteLineIndent("uint32_t fbe_struct_size = (uint32_t)(8 + "
                  "_model.fbe_allocation_size(value));");
  WriteLineIndent("uint32_t fbe_struct_offset = "
                  "(uint32_t)(this->buffer().allocate(fbe_struct_size) - "
                  "this->buffer().offset());");
  WriteLineIndent(
      "assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) "
      "<= this->buffer().size()) && \"Model is broken!\");");
  WriteLineIndent("if ((this->buffer().offset() + fbe_struct_offset + "
                  "fbe_struct_size) > this->buffer().size())");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("fbe_struct_size = (uint32_t)(8 + _model.set(value));");
  WriteLineIndent("this->buffer().resize(fbe_initial_size + fbe_struct_size);");
  WriteLine();
  WriteLineIndent(
      "*((uint32_t*)(this->buffer().data() + this->buffer().offset() + "
      "_model.fbe_offset() - 8)) = fbe_struct_size;");
  WriteLineIndent(
      "*((uint32_t*)(this->buffer().data() + this->buffer().offset() + "
      "_model.fbe_offset() - 4)) = fbe_struct_type;");
  WriteLine();
  WriteLineIndent("return fbe_struct_size;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct model final deserialize() method
  WriteLineIndent("size_t " + model_name + "::deserialize(" + struct_name +
                  "& value) const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("assert(((this->buffer().offset() + _model.fbe_offset()) <= "
                  "this->buffer().size()) && \"Model is broken!\");");
  WriteLineIndent("if ((this->buffer().offset() + _model.fbe_offset()) > "
                  "this->buffer().size())");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() "
      "+ this->buffer().offset() + _model.fbe_offset() - 8);");
  WriteLineIndent(
      "size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() "
      "+ this->buffer().offset() + _model.fbe_offset() - 4);");
  WriteLineIndent("assert(((fbe_struct_size > 0) && (fbe_struct_type == "
                  "fbe_type())) && \"Model is broken!\");");
  WriteLineIndent(
      "if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))");
  Indent(1);
  WriteLineIndent("return 8;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("return 8 + _model.get(value);");
  Indent(-1);
  WriteLineIndent("}");

  // Generate struct model final deserialize() with memory resource (Arena mode
  // only)
  if (Arena()) {
    WriteLine();
    WriteLineIndent(
        "size_t " + model_name + "::deserialize(" + struct_name +
        "& value, std::pmr::memory_resource* resource) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("assert(((this->buffer().offset() + _model.fbe_offset()) "
                    "<= this->buffer().size()) && \"Model is broken!\");");
    WriteLineIndent("if ((this->buffer().offset() + _model.fbe_offset()) > "
                    "this->buffer().size())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("size_t fbe_struct_size = "
                    "unaligned_load<uint32_t>(this->buffer().data() + "
                    "this->buffer().offset() + _model.fbe_offset() - 8);");
    WriteLineIndent("size_t fbe_struct_type = "
                    "unaligned_load<uint32_t>(this->buffer().data() + "
                    "this->buffer().offset() + _model.fbe_offset() - 4);");
    WriteLineIndent("assert(((fbe_struct_size > 0) && (fbe_struct_type == "
                    "fbe_type())) && \"Model is broken!\");");
    WriteLineIndent(
        "if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))");
    Indent(1);
    WriteLineIndent("return 8;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("return 8 + _model.get(value, resource);");
    Indent(-1);
    WriteLineIndent("}");
  }

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));
}

void GeneratorCpp::GenerateProtocolVersion(const std::shared_ptr<Package> &p) {
  // Generate protocol version struct
  WriteLine();
  WriteLineIndent("// Fast Binary Encoding " + *p->name + " protocol version");
  WriteLineIndent("struct ProtocolVersion");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("// Protocol major version");
  WriteLineIndent(
      "static const int major = " + std::to_string(p->version->major) + ";");
  WriteLineIndent("// Protocol minor version");
  WriteLineIndent(
      "static const int minor = " + std::to_string(p->version->minor) + ";");
  Indent(-1);
  WriteLineIndent("};");
}

void GeneratorCpp::GenerateSender_Header(const std::shared_ptr<Package> &p,
                                         bool final) {
  std::string sender = (final ? "FinalSender" : "Sender");
  std::string model = (final ? "FinalModel" : "Model");

  // Generate sender begin
  WriteLine();
  if (final)
    WriteLineIndent("// Fast Binary Encoding " + *p->name + " final sender");
  else
    WriteLineIndent("// Fast Binary Encoding " + *p->name + " sender");
  WriteLineIndent("class " + sender + " : public virtual FBE::Sender");
  if (p->import) {
    Indent(1);
    for (const auto &import : p->import->imports)
      WriteLineIndent(", public virtual " + *import + "::" + sender);
    Indent(-1);
  }
  WriteLineIndent("{");
  WriteLineIndent("public:");
  Indent(1);

  // Generate sender constructors
  WriteLineIndent(sender + "()");
  bool first = true;
  if (p->body) {
    Indent(1);
    for (const auto &s : p->body->structs) {
      if (s->message) {
        WriteLineIndent((first ? ": " : ", ") + *s->name + "" +
                        "Model(this->_buffer)");
        first = false;
      }
    }
    Indent(-1);
  }
  WriteLineIndent("{" + std::string(final ? " this->final(true); " : "") + "}");
  WriteLineIndent(sender + "(const " + sender + "&) = delete;");
  WriteLineIndent(sender + "(" + sender + "&&) noexcept = delete;");
  WriteLineIndent("virtual ~" + sender + "() = default;");

  // Generate sender operators
  WriteLine();
  WriteLineIndent(sender + "& operator=(const " + sender + "&) = delete;");
  WriteLineIndent(sender + "& operator=(" + sender + "&&) noexcept = delete;");

  // Generate imported senders accessors
  if (p->import) {
    WriteLine();
    WriteLineIndent("// Imported senders");
    for (const auto &import : p->import->imports)
      WriteLineIndent(*import + "::" + sender + "& " + *import +
                      "_sender() noexcept { return *this; }");
  }

  // Generate send() methods
  if (p->body) {
    first = true;
    for (const auto &s : p->body->structs) {
      if (s->message) {
        std::string struct_name =
            "::" + ConvertNamespace(*p->name) + "::" + *s->name;
        if (first)
          WriteLine();
        WriteLineIndent("size_t send(const " + struct_name + "& value);");
        first = false;
      }
    }
  }

  // Generate sender models accessors
  if (p->body) {
    Indent(-1);
    WriteLine();
    WriteLineIndent("public:");
    Indent(1);
    WriteLineIndent("// Sender models accessors");
    for (const auto &s : p->body->structs)
      if (s->message)
        WriteLineIndent("FBE::" + ConvertNamespace(*p->name) + "::" + *s->name +
                        model + " " + *s->name + "Model;");
  }

  // Generate sender end
  Indent(-1);
  WriteLineIndent("};");
}

void GeneratorCpp::GenerateSender_Source(const std::shared_ptr<Package> &p,
                                         bool final) {
  std::string sender = (final ? "FinalSender" : "Sender");

  // Generate send() methods
  if (p->body) {
    for (const auto &s : p->body->structs) {
      if (s->message) {
        std::string struct_name =
            "::" + ConvertNamespace(*p->name) + "::" + *s->name;
        WriteLine();
        WriteLineIndent("size_t " + sender + "::send(const " + struct_name +
                        "& value)");
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent("// Serialize the value into the FBE stream");
        if (not final) {
          WriteLineIndent("size_t serialized = " + *s->name +
                          "Model.serialize(value, nullptr);");
        } else {
          WriteLineIndent("size_t serialized = " + *s->name +
                          "Model.serialize(value);");
        }
        WriteLineIndent("assert((serialized > 0) && \"" +
                        ConvertNamespace(*p->name) + "::" + *s->name +
                        " serialization failed!\");");
        WriteLineIndent("assert(" + *s->name + "Model.verify() && \"" +
                        ConvertNamespace(*p->name) + "::" + *s->name +
                        " validation failed!\");");
        WriteLine();
        WriteLineIndent("// Log the value");
        WriteLineIndent("if (this->_logging)");
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent("std::string message = value.to_string();");
        WriteLineIndent("this->onSendLog(message);");
        Indent(-1);
        WriteLineIndent("}");
        WriteLine();
        WriteLineIndent("// Send the serialized value");
        WriteLineIndent("return this->send_serialized(serialized);");
        Indent(-1);
        WriteLineIndent("}");
      }
    }
  }
}

void GeneratorCpp::GenerateReceiver_Header(const std::shared_ptr<Package> &p,
                                           bool final) {
  std::string receiver = (final ? "FinalReceiver" : "Receiver");
  std::string model = (final ? "FinalModel" : "Model");

  // Generate receiver begin
  WriteLine();
  if (final)
    WriteLineIndent("// Fast Binary Encoding " + *p->name + " final receiver");
  else
    WriteLineIndent("// Fast Binary Encoding " + *p->name + " receiver");
  WriteLineIndent("class " + receiver + " : public virtual FBE::Receiver");
  if (p->import) {
    Indent(1);
    for (const auto &import : p->import->imports)
      WriteLineIndent(", public virtual " + *import + "::" + receiver);
    Indent(-1);
  }
  WriteLineIndent("{");
  WriteLineIndent("public:");
  Indent(1);

  // Generate receiver constructors
  WriteLineIndent(receiver + "() {" +
                  std::string(final ? " this->final(true); " : "") + "}");
  WriteLineIndent(receiver + "(const " + receiver + "&) = delete;");
  WriteLineIndent(receiver + "(" + receiver + "&&) = delete;");
  WriteLineIndent("virtual ~" + receiver + "() = default;");

  // Generate receiver operators
  WriteLine();
  WriteLineIndent(receiver + "& operator=(const " + receiver + "&) = delete;");
  WriteLineIndent(receiver + "& operator=(" + receiver + "&&) = delete;");

  // Generate receiver handlers
  if (p->body) {
    WriteLine();
    Indent(-1);
    WriteLineIndent("protected:");
    Indent(1);
    WriteLineIndent("// Receive handlers");
    for (const auto &s : p->body->structs) {
      if (s->message) {
        std::string struct_name =
            "::" + ConvertNamespace(*p->name) + "::" + *s->name;
        WriteLineIndent("virtual void onReceive(const " + struct_name +
                        "& value) {}");
      }
    }
  }

  // Generate receiver message handler
  WriteLine();
  WriteLineIndent("// Receive message handler");
  WriteLineIndent(
      "bool onReceive(size_t type, const void* data, size_t size) override;");

  // Generate receiver models accessors
  if (p->body) {
    Indent(-1);
    WriteLine();
    WriteLineIndent("private:");
    Indent(1);
    WriteLineIndent("// Receiver values accessors");
    for (const auto &s : p->body->structs) {
      if (s->message) {
        std::string struct_name =
            "::" + ConvertNamespace(*p->name) + "::" + *s->name;
        WriteLineIndent(struct_name + " " + *s->name + "Value;");
      }
    }
    WriteLine();
    WriteLineIndent("// Receiver models accessors");
    for (const auto &s : p->body->structs)
      if (s->message)
        WriteLineIndent("FBE::" + ConvertNamespace(*p->name) + "::" + *s->name +
                        model + " " + *s->name + "Model;");
  }

  // Generate receiver end
  Indent(-1);
  WriteLineIndent("};");
}

void GeneratorCpp::GenerateReceiver_Source(const std::shared_ptr<Package> &p,
                                           bool final) {
  std::string receiver = (final ? "FinalReceiver" : "Receiver");
  std::string model = (final ? "FinalModel" : "Model");

  // Generate receiver message handler
  WriteLine();
  WriteLineIndent("bool " + receiver +
                  "::onReceive(size_t type, const void* data, size_t size)");
  WriteLineIndent("{");
  Indent(1);
  if (p->body) {
    WriteLineIndent("switch (type)");
    WriteLineIndent("{");
    Indent(1);
    for (const auto &s : p->body->structs) {
      if (s->message) {
        std::string struct_name =
            "::" + ConvertNamespace(*p->name) + "::" + *s->name;
        WriteLineIndent("case FBE::" + ConvertNamespace(*p->name) +
                        "::" + *s->name + model + "::fbe_type():");
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent("// Deserialize the value from the FBE stream");
        WriteLineIndent(*s->name + "Model.attach(data, size);");
        WriteLineIndent("assert(" + *s->name + "Model.verify() && \"" +
                        ConvertNamespace(*p->name) + "::" + *s->name +
                        " validation failed!\");");
        if (not final) {
          WriteLineIndent("[[maybe_unused]] size_t deserialized = " + *s->name +
                          "Model.deserialize(" + *s->name + "Value, nullptr);");
        } else {
          WriteLineIndent("[[maybe_unused]] size_t deserialized = " + *s->name +
                          "Model.deserialize(" + *s->name + "Value);");
        }
        WriteLineIndent("assert((deserialized > 0) && \"" +
                        ConvertNamespace(*p->name) + "::" + *s->name +
                        " deserialization failed!\");");
        WriteLine();
        WriteLineIndent("// Log the value");
        WriteLineIndent("if (this->_logging)");
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent("std::string message = " + *s->name +
                        "Value.to_string();");
        WriteLineIndent("this->onReceiveLog(message);");
        Indent(-1);
        WriteLineIndent("}");
        WriteLine();
        WriteLineIndent("// Call receive handler with deserialized value");
        WriteLineIndent("onReceive(" + *s->name + "Value);");
        WriteLineIndent("return true;");
        Indent(-1);
        WriteLineIndent("}");
      }
    }
    WriteLineIndent("default: break;");
    Indent(-1);
    WriteLineIndent("}");
  }
  if (p->import) {
    WriteLine();
    for (const auto &import : p->import->imports) {
      WriteLineIndent("if (" + *import + "::" + receiver +
                      "::onReceive(type, data, size))");
      Indent(1);
      WriteLineIndent("return true;");
      Indent(-1);
    }
  }
  WriteLine();
  WriteLineIndent("return false;");
  Indent(-1);
  WriteLineIndent("}");
}

void GeneratorCpp::GenerateProxy_Header(const std::shared_ptr<Package> &p,
                                        bool final) {
  std::string proxy = (final ? "FinalProxy" : "Proxy");
  std::string model = (final ? "FinalModel" : "Model");

  // Generate proxy begin
  WriteLine();
  if (final)
    WriteLineIndent("// Fast Binary Encoding " + *p->name + " final proxy");
  else
    WriteLineIndent("// Fast Binary Encoding " + *p->name + " proxy");
  WriteLineIndent("class " + proxy + " : public virtual FBE::Receiver");
  if (p->import) {
    Indent(1);
    for (const auto &import : p->import->imports)
      WriteLineIndent(", public virtual " + *import + "::" + proxy);
    Indent(-1);
  }
  WriteLineIndent("{");
  WriteLineIndent("public:");
  Indent(1);

  // Generate proxy constructors
  WriteLineIndent(proxy + "() {" +
                  std::string(final ? " this->final(true); " : "") + "}");
  WriteLineIndent(proxy + "(const " + proxy + "&) = delete;");
  WriteLineIndent(proxy + "(" + proxy + "&&) = delete;");
  WriteLineIndent("virtual ~" + proxy + "() = default;");

  // Generate proxy operators
  WriteLine();
  WriteLineIndent(proxy + "& operator=(const " + proxy + "&) = delete;");
  WriteLineIndent(proxy + "& operator=(" + proxy + "&&) = delete;");

  // Generate proxy handlers
  if (p->body) {
    WriteLine();
    Indent(-1);
    WriteLineIndent("protected:");
    Indent(1);
    WriteLineIndent("// Proxy handlers");
    for (const auto &s : p->body->structs) {
      if (s->message) {
        std::string struct_model =
            "FBE::" + ConvertNamespace(*p->name) + "::" + *s->name + model;
        WriteLineIndent(
            "virtual void onProxy(" + struct_model +
            "& model, size_t type, const void* data, size_t size) {}");
      }
    }
  }

  // Generate proxy message handler
  WriteLine();
  WriteLineIndent("// Receive message handler");
  WriteLineIndent(
      "bool onReceive(size_t type, const void* data, size_t size) override;");

  // Generate proxy models accessors
  if (p->body) {
    Indent(-1);
    WriteLine();
    WriteLineIndent("private:");
    Indent(1);
    WriteLineIndent("// Proxy models accessors");
    for (const auto &s : p->body->structs)
      if (s->message)
        WriteLineIndent("FBE::" + ConvertNamespace(*p->name) + "::" + *s->name +
                        model + " " + *s->name + "Model;");
  }

  // Generate proxy end
  Indent(-1);
  WriteLineIndent("};");
}

void GeneratorCpp::GenerateProxy_Source(const std::shared_ptr<Package> &p,
                                        bool final) {
  std::string proxy = (final ? "FinalProxy" : "Proxy");
  std::string model = (final ? "FinalModel" : "Model");

  // Generate proxy message handler
  WriteLine();
  WriteLineIndent("bool " + proxy +
                  "::onReceive(size_t type, const void* data, size_t size)");
  WriteLineIndent("{");
  Indent(1);
  if (p->body) {
    WriteLineIndent("switch (type)");
    WriteLineIndent("{");
    Indent(1);
    for (const auto &s : p->body->structs) {
      if (s->message) {
        std::string struct_name =
            "::" + ConvertNamespace(*p->name) + "::" + *s->name;
        WriteLineIndent("case FBE::" + ConvertNamespace(*p->name) +
                        "::" + *s->name + model + "::fbe_type():");
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent("// Attach the FBE stream to the proxy model");
        WriteLineIndent(*s->name + "Model.attach(data, size);");
        WriteLineIndent("assert(" + *s->name + "Model.verify() && \"" +
                        ConvertNamespace(*p->name) + "::" + *s->name +
                        " validation failed!\");");
        WriteLine();
        WriteLineIndent("size_t fbe_begin = " + *s->name +
                        "Model.model.get_begin();");
        WriteLineIndent("if (fbe_begin == 0)");
        Indent(1);
        WriteLineIndent("return false;");
        Indent(-1);
        WriteLineIndent("// Call proxy handler");
        WriteLineIndent("onProxy(" + *s->name + "Model, type, data, size);");
        WriteLineIndent(*s->name + "Model.model.get_end(fbe_begin);");
        WriteLineIndent("return true;");
        Indent(-1);
        WriteLineIndent("}");
      }
    }
    WriteLineIndent("default: break;");
    Indent(-1);
    WriteLineIndent("}");
  }
  if (p->import) {
    WriteLine();
    for (const auto &import : p->import->imports) {
      WriteLineIndent("if (" + *import + "::" + proxy +
                      "::onReceive(type, data, size))");
      Indent(1);
      WriteLineIndent("return true;");
      Indent(-1);
    }
  }
  WriteLine();
  WriteLineIndent("return false;");
  Indent(-1);
  WriteLineIndent("}");
}

void GeneratorCpp::GenerateClient_Header(const std::shared_ptr<Package> &p,
                                         bool final) {
  std::string client = (final ? "FinalClient" : "Client");
  std::string sender = (final ? "FinalSender" : "Sender");
  std::string receiver = (final ? "FinalReceiver" : "Receiver");

  // Generate client begin
  WriteLine();
  if (final)
    WriteLineIndent("// Fast Binary Encoding " + *p->name + " final client");
  else
    WriteLineIndent("// Fast Binary Encoding " + *p->name + " client");
  WriteLineIndent("class " + client + " : public virtual " + sender +
                  ", protected virtual " + receiver);
  if (p->import) {
    Indent(1);
    for (const auto &import : p->import->imports)
      WriteLineIndent(", public virtual " + *import + "::" + client);
    Indent(-1);
  }
  WriteLineIndent("{");
  WriteLineIndent("public:");
  if (p->import) {
    Indent(1);
    for (const auto &import : p->import->imports)
      WriteLineIndent("typedef " + *import + "::" + client + " " + *import +
                      client + ";");
    Indent(-1);
    WriteLine();
  }
  Indent(1);

  // Generate client constructors
  WriteLineIndent(client + "() = default;");
  WriteLineIndent(client + "(const " + client + "&) = delete;");
  WriteLineIndent(client + "(" + client + "&&) = delete;");
  WriteLineIndent("virtual ~" + client + "() = default;");

  // Generate client operators
  WriteLine();
  WriteLineIndent(client + "& operator=(const " + client + "&) = delete;");
  WriteLineIndent(client + "& operator=(" + client + "&&) = delete;");

  // Generate imported clients accessors
  if (p->import) {
    WriteLine();
    WriteLineIndent("// Imported clients");
    for (const auto &import : p->import->imports)
      WriteLineIndent(*import + "::" + client + "& " + *import +
                      "_client() noexcept { return *this; }");
  }

  // Generate client reset method
  WriteLine();
  WriteLineIndent("// Reset client buffers");
  WriteLineIndent("void reset() { std::scoped_lock locker(this->_lock); "
                  "reset_requests(); }");

  // Generate watchdog method
  WriteLine();
  WriteLineIndent("// Watchdog for timeouts");
  WriteLineIndent("void watchdog(uint64_t utc) { std::scoped_lock "
                  "locker(this->_lock); watchdog_requests(utc); }");

  // Collect responses & rejects collections
  std::set<std::string> responses;
  std::map<std::string, bool> rejects;
  if (p->body) {
    for (const auto &s : p->body->structs) {
      if (s->message && s->request) {
        std::string response_name =
            (s->response)
                ? ConvertTypeName(*p->name, *s->response->response, false)
                : "";

        if (!response_name.empty()) {
          // Update responses and rejects cache
          responses.insert(*s->response->response);
          if (s->rejects)
            for (const auto &reject : s->rejects->rejects)
              rejects[*reject.reject] = reject.global;
        }
      }
    }
  }

  // Generate request() methods
  if (p->body) {
    WriteLine();
    for (const auto &s : p->body->structs) {
      if (s->message && s->request) {
        std::string request_name =
            "::" + ConvertNamespace(*p->name) + "::" + *s->name;
        std::string response_name =
            (s->response)
                ? ConvertTypeName(*p->name, *s->response->response, false)
                : "";
        std::string response_field =
            (s->response) ? *s->response->response : "";
        replace_all(response_field, ".", "");

        if (response_name.empty())
          WriteLineIndent("std::future<void> request(const " + request_name +
                          "& value, size_t timeout = 0);");
        else
          WriteLineIndent("std::future<" + response_name + "> request(const " +
                          request_name + "& value, size_t timeout = 0);");
      }
    }
  }

  // Generate client protected fields
  Indent(-1);
  WriteLine();
  WriteLineIndent("protected:");
  Indent(1);
  if (!p->import) {
    WriteLineIndent("std::mutex _lock;");
    WriteLineIndent("uint64_t _timestamp{0};");
    WriteLine();
  }

  // Generate response handlers
  for (const auto &response : responses) {
    std::string response_name = ConvertTypeName(*p->name, response, false);
    WriteLineIndent("virtual bool onReceiveResponse(const " + response_name +
                    "& response);");
  }
  if (!responses.empty())
    WriteLine();

  // Generate remaining response handlers
  if (p->body) {
    bool found = false;
    std::set<std::string> cache;
    for (const auto &s : p->body->structs) {
      if (s->message) {
        std::string struct_response_name =
            ConvertTypeName(*p->name, *s->name, false);
        std::string struct_response_field = *s->name;

        if ((responses.find(*s->name) == responses.end()) &&
            (cache.find(struct_response_name) == cache.end())) {
          WriteLineIndent("virtual bool onReceiveResponse(const " +
                          struct_response_name +
                          "& response) { return false; }");
          cache.insert(struct_response_name);
          found = true;
        }
      }
    }
    if (found)
      WriteLine();
  }

  // Generate reject handlers
  for (const auto &reject : rejects) {
    std::string reject_name = ConvertTypeName(*p->name, reject.first, false);
    WriteLineIndent("virtual bool onReceiveReject(const " + reject_name +
                    "& reject);");
  }
  if (!rejects.empty())
    WriteLine();

  // Generate remaining reject handlers
  if (p->body) {
    bool found = false;
    std::set<std::string> cache;
    for (const auto &s : p->body->structs) {
      if (s->message) {
        std::string struct_reject_name =
            ConvertTypeName(*p->name, *s->name, false);
        if ((rejects.find(*s->name) == rejects.end()) &&
            (cache.find(struct_reject_name) == cache.end())) {
          WriteLineIndent("virtual bool onReceiveReject(const " +
                          struct_reject_name + "& reject) { return false; }");
          cache.insert(struct_reject_name);
          found = true;
        }
      }
    }
    if (found)
      WriteLine();
  }

  // Generate notify handlers
  if (p->body) {
    bool found = false;
    std::set<std::string> cache;
    for (const auto &s : p->body->structs) {
      if (s->message) {
        std::string struct_notify_name =
            ConvertTypeName(*p->name, *s->name, false);
        std::string struct_notify_field = *s->name;
        if (cache.find(struct_notify_name) == cache.end()) {
          WriteLineIndent("virtual void onReceiveNotify(const " +
                          struct_notify_name + "& notify) {}");
          cache.insert(struct_notify_name);
          found = true;
        }
      }
    }
    if (found)
      WriteLine();
  }

  // Generate receive handlers
  if (p->body) {
    bool found = false;
    std::set<std::string> cache;
    for (const auto &s : p->body->structs) {
      if (s->message) {
        std::string struct_response_name =
            ConvertTypeName(*p->name, *s->name, false);
        std::string struct_response_field = *s->name;

        if (cache.find(struct_response_name) == cache.end()) {
          WriteLineIndent(
              "virtual void onReceive(const " + struct_response_name +
              "& value) override { if (!onReceiveResponse(value) && "
              "!onReceiveReject(value)) onReceiveNotify(value); }");
          cache.insert(struct_response_name);
          found = true;
        }
      }
    }
    if (found)
      WriteLine();
  }

  // Generate reset requests method
  WriteLineIndent("// Reset client requests");
  WriteLineIndent("virtual void reset_requests();");

  // Generate watchdog requests method
  WriteLine();
  WriteLineIndent("// Watchdog client requests for timeouts");
  WriteLineIndent("virtual void watchdog_requests(uint64_t utc);");

  // Generate client private fields
  if (!responses.empty()) {
    Indent(-1);
    WriteLine();
    WriteLineIndent("private:");
    Indent(1);
    for (const auto &response : responses) {
      std::string response_name = ConvertTypeName(*p->name, response, false);
      std::string response_field = response;
      replace_all(response_field, ".", "");

      WriteLineIndent("std::unordered_map<FBE::uuid_t, std::tuple<uint64_t, "
                      "uint64_t, std::promise<" +
                      response_name + ">>> _requests_by_id_" + response_field +
                      ";");
      WriteLineIndent(
          "std::map<uint64_t, FBE::uuid_t> _requests_by_timestamp_" +
          response_field + ";");
    }
  }

  // Generate client end
  Indent(-1);
  WriteLineIndent("};");
}

void GeneratorCpp::GenerateClient_Source(const std::shared_ptr<Package> &p,
                                         bool final) {
  std::string client = (final ? "FinalClient" : "Client");
  std::string sender = (final ? "FinalSender" : "Sender");

  // Collect responses & rejects collections
  std::set<std::string> responses;
  std::map<std::string, bool> rejects;
  if (p->body) {
    for (const auto &s : p->body->structs) {
      if (s->message && s->request) {
        std::string response_name =
            (s->response)
                ? ConvertTypeName(*p->name, *s->response->response, false)
                : "";

        if (!response_name.empty()) {
          // Update responses and rejects cache
          responses.insert(*s->response->response);
          if (s->rejects)
            for (const auto &reject : s->rejects->rejects)
              rejects[*reject.reject] = reject.global;
        }
      }
    }
  }

  // Generate request() methods
  if (p->body) {
    for (const auto &s : p->body->structs) {
      if (s->message && s->request) {
        std::string request_name =
            "::" + ConvertNamespace(*p->name) + "::" + *s->name;
        std::string response_name =
            (s->response)
                ? ConvertTypeName(*p->name, *s->response->response, false)
                : "";
        std::string response_field =
            (s->response) ? *s->response->response : "";
        replace_all(response_field, ".", "");

        WriteLine();
        if (response_name.empty()) {
          WriteLineIndent("std::future<void> " + client + "::request(const " +
                          request_name + "& value, size_t timeout)");
          WriteLineIndent("{");
          Indent(1);
          WriteLineIndent("std::promise<void> promise;");
          WriteLineIndent("std::future<void> future = promise.get_future();");
          WriteLine();
          WriteLineIndent("// Send the request message");
          WriteLineIndent("size_t serialized = Sender::send(value);");
          WriteLineIndent("if (serialized > 0)");
          Indent(1);
          WriteLineIndent("promise.set_value();");
          Indent(-1);
          WriteLineIndent("else");
          Indent(1);
          WriteLineIndent("promise.set_exception(std::make_exception_ptr(std::"
                          "runtime_error(\"Send request failed!\")));");
          Indent(-1);
          WriteLine();
          WriteLineIndent("return future;");
          Indent(-1);
          WriteLineIndent("}");
        } else {
          WriteLineIndent("std::future<" + response_name + "> " + client +
                          "::request(const " + request_name +
                          "& value, size_t timeout)");
          WriteLineIndent("{");
          Indent(1);
          WriteLineIndent("std::scoped_lock locker(this->_lock);");
          WriteLine();
          WriteLineIndent("std::promise<" + response_name + "> promise;");
          WriteLineIndent("std::future<" + response_name +
                          "> future = promise.get_future();");
          WriteLine();
          WriteLineIndent("uint64_t current = utc();");
          WriteLine();
          WriteLineIndent("// Send the request message");
          WriteLineIndent("size_t serialized = Sender::send(value);");
          WriteLineIndent("if (serialized > 0)");
          WriteLineIndent("{");
          Indent(1);
          WriteLineIndent("// Calculate the unique timestamp");
          WriteLineIndent("this->_timestamp = (current <= this->_timestamp) ? "
                          "this->_timestamp + 1 : current;");
          WriteLine();
          WriteLineIndent("// Register the request");
          WriteLineIndent("_requests_by_id_" + response_field +
                          ".insert(std::make_pair(value.id, "
                          "std::make_tuple(this->_timestamp, timeout * "
                          "1000000, std::move(promise))));");
          WriteLineIndent("if (timeout > 0)");
          Indent(1);
          WriteLineIndent(
              "_requests_by_timestamp_" + response_field +
              ".insert(std::make_pair(this->_timestamp, value.id));");
          Indent(-1);
          Indent(-1);
          WriteLineIndent("}");
          WriteLineIndent("else");
          Indent(1);
          WriteLineIndent("promise.set_exception(std::make_exception_ptr(std::"
                          "runtime_error(\"Send request failed!\")));");
          Indent(-1);
          WriteLine();
          WriteLineIndent("return future;");
          Indent(-1);
          WriteLineIndent("}");
        }
      }
    }
  }

  // Generate response handlers
  for (const auto &response : responses) {
    std::string response_name = ConvertTypeName(*p->name, response, false);
    std::string response_field = response;

    WriteLine();
    WriteLineIndent("bool " + client + "::onReceiveResponse(const " +
                    response_name + "& response)");
    WriteLineIndent("{");
    Indent(1);
    if (p->body) {
      std::set<std::string> cache;
      WriteLineIndent("std::scoped_lock locker(this->_lock);");
      WriteLine();
      for (const auto &s : p->body->structs) {
        if (s->message && s->response) {
          std::string struct_response_name =
              ConvertTypeName(*p->name, *s->response->response, false);
          std::string struct_response_field = *s->response->response;
          replace_all(struct_response_field, ".", "");

          if ((struct_response_name == response_name) &&
              (cache.find(struct_response_name) == cache.end())) {
            WriteLineIndent("auto it_" + struct_response_field +
                            " = _requests_by_id_" + struct_response_field +
                            ".find(response.id);");
            WriteLineIndent("if (it_" + struct_response_field +
                            " != _requests_by_id_" + struct_response_field +
                            ".end())");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent("auto timestamp = std::get<0>(it_" +
                            struct_response_field + "->second);");
            WriteLineIndent("[[maybe_unused]] auto timespan = std::get<1>(it_" +
                            struct_response_field + "->second);");
            WriteLineIndent("auto& promise = std::get<2>(it_" +
                            struct_response_field + "->second);");
            WriteLineIndent("promise.set_value(response);");
            WriteLineIndent("_requests_by_id_" + struct_response_field +
                            ".erase(response.id);");
            WriteLineIndent("_requests_by_timestamp_" + struct_response_field +
                            ".erase(timestamp);");
            WriteLineIndent("return true;");
            cache.insert(struct_response_name);
            Indent(-1);
            WriteLineIndent("}");
            WriteLine();
          }
        }
      }
    }
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLineIndent("}");
  }

  // Generate reject handlers
  for (const auto &reject : rejects) {
    std::string reject_name = ConvertTypeName(*p->name, reject.first, false);
    std::string reject_field = reject.first;
    bool global = reject.second;
    bool imported = replace_all(reject_field, ".", "");

    WriteLine();
    WriteLineIndent("bool " + client + "::onReceiveReject(const " +
                    reject_name + "& reject)");
    WriteLineIndent("{");
    Indent(1);
    if (global) {
      if (p->import) {
        for (const auto &import : p->import->imports) {
          WriteLineIndent("if (" + *import + client +
                          "::onReceiveReject(reject))");
          Indent(1);
          WriteLineIndent("return true;");
          Indent(-1);
        }
        WriteLine();
      }
    } else if (imported) {
      std::string ns = "";
      std::string t = reject.first;
      std::string type = reject.first;

      size_t pos = type.find_last_of('.');
      if (pos != std::string::npos) {
        ns.assign(type, 0, pos);
        t.assign(type, pos + 1, type.size() - pos);
      }

      WriteLineIndent("if (" + ns + client + "::onReceiveReject(reject))");
      Indent(1);
      WriteLineIndent("return true;");
      Indent(-1);
      WriteLine();
    }
    if (p->body) {
      std::set<std::string> cache;
      WriteLineIndent("std::scoped_lock locker(this->_lock);");
      WriteLine();
      for (const auto &s : p->body->structs) {
        if (s->message && s->response && s->rejects) {
          for (const auto &r : s->rejects->rejects) {
            std::string struct_response_name =
                ConvertTypeName(*p->name, *s->response->response, false);
            std::string struct_response_field = *s->response->response;
            replace_all(struct_response_field, ".", "");

            std::string struct_reject_name =
                ConvertTypeName(*p->name, *r.reject, false);
            std::string struct_reject_field = *r.reject;
            replace_all(struct_reject_field, ".", "");

            if ((struct_reject_name == reject_name) &&
                (cache.find(struct_response_field) == cache.end())) {
              WriteLineIndent("auto it_" + struct_response_field +
                              " = _requests_by_id_" + struct_response_field +
                              ".find(reject.id);");
              WriteLineIndent("if (it_" + struct_response_field +
                              " != _requests_by_id_" + struct_response_field +
                              ".end())");
              WriteLineIndent("{");
              Indent(1);
              WriteLineIndent("auto timestamp = std::get<0>(it_" +
                              struct_response_field + "->second);");
              WriteLineIndent(
                  "[[maybe_unused]] auto timespan = std::get<1>(it_" +
                  struct_response_field + "->second);");
              WriteLineIndent("auto& promise = std::get<2>(it_" +
                              struct_response_field + "->second);");
              WriteLineIndent("promise.set_exception(std::make_exception_ptr("
                              "std::runtime_error(reject.to_string())));");
              WriteLineIndent("_requests_by_id_" + struct_response_field +
                              ".erase(reject.id);");
              WriteLineIndent("_requests_by_timestamp_" +
                              struct_response_field + ".erase(timestamp);");
              WriteLineIndent("return true;");
              cache.insert(struct_response_field);
              Indent(-1);
              WriteLineIndent("}");
              WriteLine();
            }
          }
        }
      }
    }
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLineIndent("}");
  }

  // Generate reset requests method
  WriteLine();
  WriteLineIndent("void " + client + "::reset_requests()");
  WriteLineIndent("{");
  Indent(1);
  if (p->import) {
    for (const auto &import : p->import->imports)
      WriteLineIndent(*import + "::" + client + "::reset_requests();");
  } else {
    WriteLineIndent("Sender::reset();");
    WriteLineIndent("Receiver::reset();");
  }
  for (const auto &response : responses) {
    std::string response_name = ConvertTypeName(*p->name, response, false);
    std::string response_field = response;
    replace_all(response_field, ".", "");

    WriteLine();
    WriteLineIndent("for (auto& request : _requests_by_id_" + response_field +
                    ")");
    Indent(1);
    WriteLineIndent("std::get<2>(request.second).set_exception(std::make_"
                    "exception_ptr(std::runtime_error(\"Reset client!\")));");
    Indent(-1);
    WriteLineIndent("_requests_by_id_" + response_field + ".clear();");
    WriteLineIndent("_requests_by_timestamp_" + response_field + ".clear();");
  }
  Indent(-1);
  WriteLineIndent("}");

  // Generate watchdog requests method
  WriteLine();
  WriteLineIndent("void " + client + "::watchdog_requests(uint64_t utc)");
  WriteLineIndent("{");
  Indent(1);
  if (p->import) {
    for (const auto &import : p->import->imports)
      WriteLineIndent(*import + "::" + client + "::watchdog_requests(utc);");
    WriteLine();
  }
  for (const auto &response : responses) {
    std::string response_name = ConvertTypeName(*p->name, response, false);
    std::string response_field = response;
    replace_all(response_field, ".", "");

    WriteLineIndent("auto it_request_by_timestamp_" + response_field +
                    " = _requests_by_timestamp_" + response_field +
                    ".begin();");
    WriteLineIndent("while (it_request_by_timestamp_" + response_field +
                    " != _requests_by_timestamp_" + response_field + ".end())");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("auto& it_request_by_id_" + response_field +
                    " = _requests_by_id_" + response_field +
                    "[it_request_by_timestamp_" + response_field +
                    "->second];");
    WriteLineIndent("auto id = it_request_by_timestamp_" + response_field +
                    "->second;");
    WriteLineIndent("auto timestamp = std::get<0>(it_request_by_id_" +
                    response_field + ");");
    WriteLineIndent("auto timespan = std::get<1>(it_request_by_id_" +
                    response_field + ");");
    WriteLineIndent("if ((timestamp + timespan) <= utc)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("auto& promise = std::get<2>(it_request_by_id_" +
                    response_field + ");");
    WriteLineIndent("promise.set_exception(std::make_exception_ptr(std::"
                    "runtime_error(\"Timeout!\")));");
    WriteLineIndent("_requests_by_id_" + response_field + ".erase(id);");
    WriteLineIndent("_requests_by_timestamp_" + response_field +
                    ".erase(timestamp);");
    WriteLineIndent("it_request_by_timestamp_" + response_field +
                    " = _requests_by_timestamp_" + response_field +
                    ".begin();");
    WriteLineIndent("continue;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLineIndent("else");
    Indent(1);
    WriteLineIndent("break;");
    Indent(-1);
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
  }
  Indent(-1);
  WriteLineIndent("}");
}

void GeneratorCpp::GenerateFBEPtr_Header(const fs::path &path) {
  // Create package path
  create_dir(path);

  // Generate the common file
  fs::path common = path / "fbe_ptr.h";
  WriteBegin();

  // Generate common header
  GenerateHeader("FBE");

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");

  std::string code = R"CODE(
struct Base
{
    virtual ~Base() = default;
};
)CODE";

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate common footer
  GenerateFooter();

  // Store the common file
  WriteEnd();
  Store(common);
}

void GeneratorCpp::GenerateFBEBaseFieldModel_Header() {
  std::string code = GeneratorCPPFixture::GenerateFBEBaseFieldModel_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelStructOptional_Header() {
  std::string code =
      GeneratorCPPFixture::GenerateFBEFieldModelStructOptional_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelStructOptional_Inline() {
  std::string code =
      GeneratorCPPFixture::GenerateFBEFieldModelStructOptional_Inline();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelCustomArray_Header() {
  std::string code =
      GeneratorCPPFixture::GenerateFBEFieldModelCustomArray_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelCustomArray_Inline() {
  std::string code =
      GeneratorCPPFixture::GenerateFBEFieldModelCustomArray_Inline();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelCustomVector_Header() {
  std::string code =
      GeneratorCPPFixture::GenerateFBEFieldModelCustomVector_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelCustomVector_Inline() {
  std::string code =
      GeneratorCPPFixture::GenerateFBEFieldModelCustomVector_Inline();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelCustomMap_Header() {
  std::string code =
      GeneratorCPPFixture::GenerateFBEFieldModelCustomMap_Header();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBEFieldModelCustomMap_Inline() {
  std::string code =
      GeneratorCPPFixture::GenerateFBEFieldModelCustomMap_Inline();

  // Prepare code template
  code = std::regex_replace(code, std::regex("\n"), EndLine());

  Write(code);
}

void GeneratorCpp::GenerateFBECustomModels_Header(const fs::path &path) {
  // Create package path
  create_dir(path);

  // Generate the field models file
  fs::path common = path / "fbe_custom_models.h";
  WriteBegin();

  // Generate field models header
  GenerateHeader("FBE");

  // Generate imports
  GenerateImports("fbe_models.h");
  GenerateImports("fbe_ptr.h");

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");

  // Generate field models
  GenerateFBEBaseFieldModel_Header();
  GenerateFBEFieldModelCustomArray_Header();
  GenerateFBEFieldModelCustomVector_Header();
  GenerateFBEFieldModelCustomMap_Header();
  GenerateFBEFieldModelStructOptional_Header();

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate inline import
  GenerateImports("fbe_custom_models.inl");

  // Generate field models footer
  GenerateFooter();

  // Store the field models file
  WriteEnd();
  Store(common);
}

void GeneratorCpp::GenerateFBECustomModels_Inline(const fs::path &path) {
  // Create package path
  create_dir(path);

  // Generate the field models file
  fs::path common = path / "fbe_custom_models.inl";
  WriteBegin();

  // Generate field models inline
  GenerateInline("FBE");

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");

  // Generate field models
  GenerateFBEFieldModelCustomArray_Inline();
  GenerateFBEFieldModelCustomVector_Inline();
  GenerateFBEFieldModelCustomMap_Inline();
  GenerateFBEFieldModelStructOptional_Inline();

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate field models footer
  GenerateFooter();

  // Store the field models file
  WriteEnd();
  Store(common);
}

void GeneratorCpp::GeneratePtrPackage_Header(
    const std::shared_ptr<Package> &p) {
  fs::path output = _output;

  // Create package path
  create_dir(output);

  // Generate the output file
  output /= ConvertFileName(*p->name, FileType::Struct, true, true);
  WriteBegin();

  // Generate package header
  GenerateHeader(fs::path(_input).filename().string());

  // Generate imports
  GenerateImports(p);
  GenerateImports("fbe_ptr.h");

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

  // Generate namespace body
  if (p->body) {
    // Generate child enums
    for (const auto &e : p->body->enums)
      GenerateEnum(p, e);

    // Generate child flags
    for (const auto &f : p->body->flags)
      GenerateFlags(p, f);

    if (!p->body->variants.empty()) {
      // forward declarations
      GeneratorStructForwardDeclaration(p->body->structs);
      for (const auto &v : p->body->variants) {
        GenerateVariantAlias(p, v);
      }
    }

    // Generate child structs
    for (const auto &s : p->body->structs)
      GeneratePtrStruct_Header(p, s);
  }

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));

  // Generate package footer
  GenerateFooter();

  // Store the output file
  WriteEnd();
  Store(output);
}

void GeneratorCpp::GeneratePtrPackage_Source(
    const std::shared_ptr<Package> &p) {
  fs::path output = _output;

  // Create package path
  create_dir(output);

  // Generate the output file
  output /= ConvertFileName(*p->name, FileType::Struct, false, true);
  WriteBegin();

  // Generate package source
  GenerateSource(fs::path(_input).filename().string());

  // Generate imports
  GenerateImports(ConvertFileName(*p->name, FileType::Struct, true, true));

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

  // Generate namespace body
  if (p->body) {
    // Generate child enums
    for (const auto &e : p->body->enums) {
      // Generate enum output stream
      GenerateEnumOutputStream(e);

      // Generate enum logging stream
      if (Logging())
        GenerateEnumLoggingStream(e);
    }

    // Generate child flags
    for (const auto &f : p->body->flags) {
      // Generate flags output stream
      GenerateFlagsOutputStream(f);

      // Generate flags logging stream
      if (Logging())
        GenerateFlagsLoggingStream(f);
    }

    if (!p->body->variants.empty()) {
      for (const auto &v : p->body->variants) {
        GenerateVariantIsEqualFunc(p, v);
        GenerateVariantOutputStream(p, v);
      }
    }

    // Generate child structs
    for (const auto &s : p->body->structs) {
      GeneratePtrStruct_Source(p, s);

      // Generate struct output stream
      GenerateStructOutputStream(p, s);

      // Generate struct logging stream
      if (Logging())
        GenerateStructLoggingStream(p, s);
    }
  }

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));

  // Generate package footer
  GenerateFooter();

  // Store the output file
  WriteEnd();
  Store(output);
}

void GeneratorCpp::GeneratePtrPackageModels_Header(
    const std::shared_ptr<Package> &p) {
  fs::path output = _output;

  // Create package path
  create_dir(output);

  // Generate the output file
  output /= ConvertFileName(*p->name, FileType::Model, true, true);
  WriteBegin();

  // Generate package models header
  GenerateHeader(fs::path(_input).filename().string());

  // Generate imports
  GenerateImports("fbe_custom_models.h");
  GenerateImportsModels(p, false, true);

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");

  // Generate namespace body
  if (p->body) {
    // Generate child enums
    for (const auto &e : p->body->enums) {
      // Generate enum field model
      GenerateEnumFieldModel(p, e);
    }

    // Generate child flags
    for (const auto &f : p->body->flags) {
      // Generate flags field model
      GenerateFlagsFieldModel(p, f);
    }

    // Generate variant
    for (const auto &v : p->body->variants) {
      GenerateVariantFieldModel_Header(p, v);
    }

    // Generate child ptr structs
    for (const auto &s : p->body->structs) {
      // Generate struct ptr field models
      GenerateStructFieldPtrModel_Header(p, s);
    }

    // Generate child structs
    for (const auto &s : p->body->structs) {
      GeneratePtrStructFieldModel_Header(p, s);
      GeneratePtrStructModel_Header(p, s);
    }
  }

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate package footer
  GenerateFooter();

  // Store the output file
  WriteEnd();
  Store(output);
}

void GeneratorCpp::GeneratePtrPackageModels_Source(
    const std::shared_ptr<Package> &p) {
  fs::path output = _output;

  // Create package path
  create_dir(output);

  // Generate the output file
  output /= ConvertFileName(*p->name, FileType::Model, false, true);
  WriteBegin();

  // Generate package models source
  GenerateSource(fs::path(_input).filename().string());

  // Generate imports
  GenerateImports(ConvertFileName(*p->name, FileType::Model, true, true));

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace FBE {");

  // Generate namespace body
  if (p->body) {
    // Generate variant
    for (const auto &v : p->body->variants) {
      GenerateVariantFieldModel_Source(p, v);
    }

    // Generate child structs
    for (const auto &s : p->body->structs) {
      // Generate struct field models
      GenerateStructFieldPtrModel_Source(p, s);
      GeneratePtrStructFieldModel_Source(p, s);
      GeneratePtrStructModel_Source(p, s);
    }
  }

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace FBE");

  // Generate package footer
  GenerateFooter();

  // Store the output file
  WriteEnd();
  Store(output);
}

void GeneratorCpp::GeneratePtrStruct_Header(
    const std::shared_ptr<Package> &p, const std::shared_ptr<StructType> &s) {
  // Generate struct response forward declaration
  if (s->response) {
    std::string response = *s->response->response;
    bool imported = replace_all(response, ".", "");
    if (!imported) {
      WriteLine();
      WriteLineIndent("struct " + response + ";");
    }
  }

  // Generate struct forward declaration if has ptr field;
  if (s->body) {
    std::set<std::string> unique_type_set;
    for (const auto &field : s->body->fields) {
      if (field->ptr) {
        if (!IsCurrentPackageType(*field->type) || IsKnownType(*field->type) ||
            *field->type == *s->name) {
          continue;
        }
        if (unique_type_set.find(*field->type) != unique_type_set.end()) {
          continue;
        } else {
          if (IsVariantType(p, *field->type))
            continue;
          WriteLine();
          WriteLineIndent("struct " + *field->type + ";");
          unique_type_set.insert(*field->type);
        }
      }
    }
  }

  // Generate struct begin
  WriteLine();
  WriteIndent("struct " +
              std::string(s->attributes->deprecated ? "[[deprecated]] " : "") +
              *s->name);
  if (s->base && !s->base->empty()) {
    Write(" : public " + ConvertPtrTypeName(*p->name, *s->base));
  } else {
    Write(" : FBE::Base");
  }
  WriteLine();
  WriteLineIndent("{");
  Indent(1);

  // Generate struct response type definition
  if (s->response) {
    std::string response = *s->response->response;
    replace_all(response, ".", "::");
    WriteLineIndent("typedef " + response + " Response;");
    if (s->body && !s->body->fields.empty())
      WriteLine();
  }

  // Generate struct body
  if (Arena()) {
    for (auto &tag : ArenaTags()) {
      WriteLineIndent(tag + ";");
    }
    WriteLine();
  }

  // Generate data member
  if (s->body) {
    for (const auto &field : s->body->fields) {
      WriteIndent();
      if (field->attributes && field->attributes->deprecated)
        Write("[[deprecated]] ");
      WriteLine(ConvertPtrTypeName(*p->name, *field, false) + " " +
                *field->name + ";");
    }
    if (!s->body->fields.empty())
      WriteLine();
  }

  // Generate struct FBE type property
  if (s->base && !s->base->empty() && (s->type == 0))
    WriteLineIndent("size_t fbe_type() const noexcept { return " +
                    ConvertPtrTypeName(*p->name, *s->base) + "::fbe_type(); }");
  else
    WriteLineIndent("size_t fbe_type() const noexcept { return " +
                    std::to_string(s->type) + "; }");

  // Generate struct default constructor
  bool first = true;
  WriteLine();
  WriteLineIndent(*s->name + "();");

  // Generate cstr with Arena
  if (Arena()) {
    WriteLineIndent("explicit " + *s->name + "(allocator_type alloc);");
  }

  // Generate struct initialization constructor
  if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty())) {
    first = true;
    size_t args = 0;
    if (s->base && !s->base->empty())
      ++args;
    if (s->body && !s->body->fields.empty())
      args += s->body->fields.size();
    WriteIndent(((args <= 1) ? "explicit " : "") + *s->name + "(");
    if (s->base && !s->base->empty()) {
      Write("const " + ConvertPtrTypeName(*p->name, *s->base) + "& base");
      first = false;
    }
    if (s->body) {
      for (const auto &field : s->body->fields) {
        Write(std::string(first ? "" : ", ") +
              ConvertPtrTypeNameAsArgument(*p->name, *field) + " arg_" +
              *field->name);
        first = false;
      }
    }
    WriteLine(");");
  }

  // copy constructor
  WriteLineIndent(*s->name + "(const " + *s->name + "& other) = default;");
  // move constructor
  WriteLineIndent(*s->name + "(" + *s->name + "&& other) noexcept;");
  // destructor
  WriteLineIndent("~" + *s->name + "() override;");
  WriteLine();
  // copy assignment operator
  WriteLineIndent(*s->name + "& operator=(const " + *s->name +
                  "& other) = default;");
  // move assignment operator
  WriteLineIndent(*s->name + "& operator=(" + *s->name + "&& other) noexcept;");

  // Generate struct compare operators
  WriteLine();
  WriteLineIndent("bool operator==(const " + *s->name +
                  "& other) const noexcept;");
  WriteLineIndent("bool operator!=(const " + *s->name +
                  "& other) const noexcept { return !operator==(other); }");
  WriteLineIndent("bool operator<(const " + *s->name +
                  "& other) const noexcept;");
  WriteLineIndent("bool operator<=(const " + *s->name +
                  "& other) const noexcept { return operator<(other) || "
                  "operator==(other); }");
  WriteLineIndent("bool operator>(const " + *s->name +
                  "& other) const noexcept { return !operator<=(other); }");
  WriteLineIndent("bool operator>=(const " + *s->name +
                  "& other) const noexcept { return !operator<(other); }");

  // Generate struct string convert
  WriteLine();
  WriteLineIndent("std::string to_string() const;");

  // Generate struct output stream operator
  WriteLine();
  WriteLineIndent(
      "friend std::ostream& operator<<(std::ostream& stream, const " +
      *s->name + "& value);");

  // Generate struct output stream operator
  if (Logging()) {
    WriteLine();
    WriteLineIndent("#if defined(LOGGING_PROTOCOL)");
    WriteLineIndent("friend CppLogging::Record& operator<<(CppLogging::Record& "
                    "record, const " +
                    *s->name + "& value);");
    WriteLineIndent("#endif");
  }

  // Generate struct swap methods
  WriteLine();
  WriteLineIndent("void swap(" + *s->name + "& other) noexcept;");
  WriteLineIndent("friend void swap(" + *s->name + "& value1, " + *s->name +
                  "& value2) noexcept { value1.swap(value2); }");

  // Generate struct end
  Indent(-1);
  WriteLineIndent("};");

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));

  // Generate struct hash
  GenerateStructHash(p, s);

  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");
}

void GeneratorCpp::GeneratePtrStruct_Source(
    const std::shared_ptr<Package> &p, const std::shared_ptr<StructType> &s) {
  WriteLine();

  // Generate struct default constructor
  bool first = true;
  WriteLineIndent(*s->name + "::" + *s->name + "()");
  Indent(1);
  if (s->base && !s->base->empty()) {
    WriteLineIndent(": " + ConvertPtrTypeName(*p->name, *s->base) + "()");
    first = false;
  }
  if (s->body) {
    for (const auto &field : s->body->fields) {
      WriteIndent();
      Write(std::string(first ? ": " : ", ") + *field->name + "(");
      if (field->ptr && !IsContainerType(*field)) {
        Write("nullptr");
      } else if (field->value ||
                 IsPrimitiveType(*field->type, field->optional)) {
        Write(ConvertDefault(*p->name, *field));
      }
      Write(")");
      WriteLine();
      first = false;
    }
  }
  Indent(-1);
  WriteLineIndent("{}");

  // Generate struct constructor with arena
  if (Arena()) {
    first = true;
    WriteLine();
    WriteLineIndent(*s->name + "::" + *s->name +
                    "([[maybe_unused]] allocator_type alloc)");
    Indent(1);
    if (s->base && !s->base->empty()) {
      WriteLineIndent(": " + ConvertPtrTypeName(*p->name, *s->base) + "()");
      first = false;
    }
    if (s->body) {
      auto enums = p->body->enums;
      auto flags = p->body->flags;
      for (const auto &field : s->body->fields) {
        WriteIndent();
        Write(std::string(first ? ": " : ", ") + *field->name + "(");
        // priority: container > optional > imported type > ptr >
        // bytes/string/primitive type/custom type > variant
        if (IsContainerType(*field)) {
          Write(field->array ? "" : "alloc");
        } else if (field->optional) {
          Write("std::nullopt");
        } else if (field->ptr) {
          Write("nullptr");
        } else if (!IsCurrentPackageType(*field->type)) {
          Write(std::string("assign_member<") +
                ConvertTypeName(*p->name, *field) + ">(alloc)");
        } else if (*field->type == "bytes" || *field->type == "string") {
          Write("alloc");
        } else if (field->value ||
                   IsPrimitiveType(*field->type, field->optional)) {
          Write(ConvertDefault(*p->name, *field));
          // only struct(no optional or enum) should be initialized with arena
        } else if (*field->type != "uuid" && *field->type != "decimal" &&
                   !IsVariantType(p, *field->type) &&
                   std::find_if(
                       enums.begin(), enums.end(),
                       [t = *field->type](const std::shared_ptr<EnumType> &e)
                           -> bool { return *e->name == t; }) == enums.end() &&
                   std::find_if(
                       flags.begin(), flags.end(),
                       [t = *field->type](const std::shared_ptr<FlagsType> &e)
                           -> bool { return *e->name == t; }) == flags.end()) {
          Write("alloc");
        }
        Write(")");
        WriteLine();
        first = false;
      }
    }
    Indent(-1);
    WriteLineIndent("{}");
  }

  std::vector<std::string> unique_ptr_members;
  std::vector<std::shared_ptr<StructField>> collection_of_container_ptrs;
  std::vector<std::shared_ptr<StructField>> collection_of_optional_fields;
  // Generate struct initialization constructor
  if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty())) {
    first = true;
    WriteLine();
    WriteIndent(*s->name + "::" + *s->name + "(");
    if (s->base && !s->base->empty()) {
      Write("const " + ConvertPtrTypeName(*p->name, *s->base) + "& base");
      first = false;
    }
    if (s->body) {
      for (const auto &field : s->body->fields) {
        Write(std::string(first ? "" : ", ") +
              ConvertPtrTypeNameAsArgument(*p->name, *field) + " arg_" +
              *field->name);
        first = false;
      }
    }
    WriteLine(")");
    Indent(1);
    first = true;
    if (s->base && !s->base->empty()) {
      WriteLineIndent(": " + ConvertPtrTypeName(*p->name, *s->base) + "(base)");
      first = false;
    }
    if (s->body) {
      for (const auto &field : s->body->fields) {
        // body
        if (field->ptr) {
          if (IsContainerType(*field)) {
            collection_of_container_ptrs.push_back(field);
            WriteLineIndent(std::string(first ? ": " : ", ") + *field->name +
                            "()");
          } else {
            unique_ptr_members.push_back(*field->name);
            WriteLineIndent(std::string(first ? ": " : ", ") + *field->name +
                            "(arg_" + *field->name + ".release())");
          }
        } else if (IsKnownType(*field->type)) {
          WriteLineIndent(std::string(first ? ": " : ", ") + *field->name +
                          "(arg_" + *field->name + ")");
        } else if (field->optional) {
          collection_of_optional_fields.push_back(field);
          WriteLineIndent(std::string(first ? ": " : ", ") + *field->name +
                          "()");
        } else {
          WriteLineIndent(std::string(first ? ": " : ", ") + *field->name +
                          "(std::move(arg_" + *field->name + "))");
        }
        first = false;
      }
    }
    Indent(-1);
    if (collection_of_container_ptrs.empty() &&
        collection_of_optional_fields.empty()) {
      WriteLineIndent("{}");
    } else {
      WriteLineIndent("{");
      Indent(1);
      for (const auto &field : collection_of_container_ptrs) {
        if (field->map || field->hash) {
          WriteLineIndent("for (auto& it: arg_" + *field->name + ")");
          Indent(1);
          WriteLineIndent(*field->name +
                          ".emplace(it.first, it.second.release());");
          Indent(-1);
        } else if (field->vector) {
          WriteLineIndent(*field->name + ".reserve(arg_" + *field->name +
                          ".size());");
          WriteLineIndent("for (auto& it : arg_" + *field->name + ")");
          Indent(1);
          WriteLineIndent(*field->name + ".emplace_back(it.release());");
          Indent(-1);
        } else if (field->list) {
          WriteLineIndent("for (auto& it : arg_" + *field->name + ")");
          Indent(1);
          WriteLineIndent(*field->name + ".emplace_back(it.release());");
          Indent(-1);
        } else if (field->array) {
          WriteLineIndent("for (uint32_t i = 0 ; i < " +
                          std::to_string(field->N) + "; ++i)");
          Indent(1);
          WriteLineIndent(*field->name + "[i] = arg_" + *field->name +
                          "[i].release();");
          Indent(-1);
        }
      }
      for (const auto &field : collection_of_optional_fields) {
        WriteLineIndent("if (arg_" + *field->name + ".has_value()) {");
        Indent(1);
        WriteLineIndent(*field->name + ".emplace(std::move(arg_" +
                        *field->name + ".value()));");
        WriteLineIndent("arg_" + *field->name + ".reset();");
        Indent(-1);
        WriteLineIndent("}");
      }
      Indent(-1);
      WriteLineIndent("}");
    }
  }

  // Generate struct move constructor
  collection_of_optional_fields.clear();

  WriteLine();
  WriteLineIndent(*s->name + "::" + *s->name + "([[maybe_unused]] " + *s->name +
                  "&& other) noexcept");
  Indent(1);
  // generate the base move
  first = true;
  if (s->base && !s->base->empty()) {
    WriteLineIndent(": " + ConvertPtrTypeName(*p->name, *s->base) +
                    "(std::move(other))");
    first = false;
  }
  // generate the field move
  if (s->body) {
    for (const auto &field : s->body->fields) {
      if (IsContainerType(*field)) {
        WriteLineIndent(std::string(first ? ": " : ", ") + *field->name +
                        "(std::move(other." + *field->name + "))");
      } else if (field->ptr) {
        WriteLineIndent(std::string(first ? ": " : ", ") + *field->name +
                        "(std::exchange(other." + *field->name + ", nullptr))");
      } else if (field->optional) {
        collection_of_optional_fields.push_back(field);
        WriteLineIndent(std::string(first ? ": " : ", ") + *field->name + "()");
      } else if (IsPrimitiveType(*field->type, field->optional)) {
        WriteLineIndent(std::string(first ? ": " : ", ") + *field->name +
                        "(std::exchange(other." + *field->name + ", " +
                        ConvertDefault(*p->name, *field) + "))");
      } else {
        WriteLineIndent(std::string(first ? ": " : ", ") + *field->name +
                        "(std::move(other." + *field->name + "))");
      }
      first = false;
    }
  }
  Indent(-1);
  if (collection_of_optional_fields.empty()) {
    WriteLineIndent("{}");
  } else {
    WriteLineIndent("{");
    Indent(1);
    for (const auto &field : collection_of_optional_fields) {
      WriteLineIndent("if (other." + *field->name + ".has_value()) {");
      Indent(1);
      if (IsPrimitiveType(*field->type, false)) {
        WriteLineIndent(*field->name + ".emplace(other." + *field->name +
                        ".value());");
      } else {
        WriteLineIndent(*field->name + ".emplace(std::move(other." +
                        *field->name + ".value()));");
      }
      WriteLineIndent("other." + *field->name + ".reset();");
      Indent(-1);
      WriteLineIndent("}");
    }
    Indent(-1);
    WriteLineIndent("}");
  }

  WriteLine();
  WriteLineIndent(*s->name + "::~" + *s->name + "()");
  WriteLine("{");
  // destructor
  if (!unique_ptr_members.empty() || !collection_of_container_ptrs.empty()) {

    Indent(1);
    for (const auto &field : unique_ptr_members) {
      WriteLineIndent("if (" + field + ") delete " + field + ";");
    }
    for (const auto &field : collection_of_container_ptrs) {
      if (field->map || field->hash) {
        WriteLineIndent("for (auto& it: " + *field->name + ")");
        Indent(1);
        WriteLineIndent("delete it.second;");
        Indent(-1);
      } else if (field->vector || field->list) {
        WriteLineIndent("for (auto* it : " + *field->name + ")");
        Indent(1);
        WriteLineIndent("delete it;");
        Indent(-1);
      } else if (field->array) {
        WriteLineIndent("for (uint32_t i = 0 ; i < " +
                        std::to_string(field->N) + "; ++i)");
        Indent(1);
        WriteLineIndent(std::string("delete ") + *field->name + "[i];");
        Indent(-1);
      }
    }
    Indent(-1);
  }
  WriteLine("}");

  // Generate struct compare operators
  WriteLine();
  WriteLineIndent("bool " + *s->name + "::operator==([[maybe_unused]] const " +
                  *s->name + "& other) const noexcept");
  WriteLineIndent("{");
  Indent(1);
  if (s->base && !s->base->empty()) {
    WriteLineIndent("if (" + ConvertPtrTypeName(*p->name, *s->base) +
                    "::operator!=(other))");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
  }
  if (s->body) {
    // disable `key` attribute feature
    // priority: container > ptr = variant > other
    for (const auto &field : s->body->fields) {
      auto field_name = *field->name;
      auto other_field_name = "other." + field_name;
      if (IsContainerType(*field)) {
        // container type can be ptrstruct, or variant.
        WriteLineIndent("// compare container " + field_name);
        if (!field->ptr && !IsVariantType(p, *field->type)) {
          // If the element is a variant type which may be a ptr, it can lead to
          // false-positive equality. It's hard to figure out the details of
          // variants because of the lack of context.
          WriteLineIndent("if (" + field_name + " != " + other_field_name +
                          ")");
          Indent(1);
          WriteLineIndent("return false;");
          Indent(-1);
          continue;
        }
        // first compare size
        WriteLineIndent("if (" + field_name + ".size() != " + other_field_name +
                        ".size())");
        Indent(1);
        WriteLineIndent("return false;");
        Indent(-1);
        if (field->vector || field->array) {
          // each element in lhs compares equal with element in rhs at the same
          // position
          WriteLineIndent("for (size_t i = 0; i < " + field_name +
                          ".size(); i++)");
          WriteLineIndent("{");
          Indent(1);
          if (field->ptr) {
            WriteLineIndent("if (*" + field_name + "[i] != *" +
                            other_field_name + "[i])");
          } else {
            WriteLineIndent("if (!is_equal(" + field_name + "[i], " +
                            other_field_name + "[i]))");
          }
          Indent(1);
          WriteLineIndent("return false;");
          Indent(-1);
          Indent(-1);
          WriteLineIndent("}");
        } else if (field->list) {
          WriteLineIndent("// compare list");
          WriteLineIndent("for (auto l_iter = " + field_name +
                          ".begin(), r_iter = " + other_field_name +
                          ".begin(); r_iter != " + other_field_name +
                          ".end(); l_iter++, r_iter++) {");
          Indent(1);
          if (field->ptr) {
            WriteLineIndent("if (**l_iter != **r_iter)");
          } else {
            WriteLineIndent("if (!is_equal(*l_iter, *r_iter))");
          }
          Indent(1);
          WriteLineIndent("return false;");
          Indent(-1);
          Indent(-1);
          WriteLineIndent("}");
        } else if (field->map || field->hash) {
          // each element in lhs compares equal with element in rhs at the same
          // position
          WriteLineIndent("for (auto & [k, v]: " + field_name + ")");
          WriteLineIndent("{");
          Indent(1);
          WriteLineIndent("if (auto pos = " + other_field_name +
                          ".find(k); pos == " + other_field_name + ".end())");
          Indent(1);
          WriteLineIndent("return false;");
          Indent(-1);
          if (field->ptr) {
            WriteLineIndent("if (auto other_v = " + other_field_name +
                            ".at(k); *other_v != *v)");
          } else {
            WriteLineIndent("if (auto other_v = " + other_field_name +
                            ".at(k); !is_equal(other_v, v))");
          }
          Indent(1);
          WriteLineIndent("return false;");
          Indent(-1);
          Indent(-1);
          WriteLineIndent("}");
        } else {
          static_assert(true, "unreached condition");
        }
      } else if (field->ptr) {
        WriteLineIndent("// compare ptr " + field_name);
        std::string condition1 = "(" + field_name + "  == nullptr && " +
                                 other_field_name + "  != nullptr)";
        std::string condition2 = "(" + field_name + "  != nullptr && " +
                                 other_field_name + "  == nullptr)";
        std::string condition3 = "(" + field_name + "  != nullptr && " +
                                 other_field_name + "  != nullptr && *" +
                                 field_name + " != *" + other_field_name + ")";
        WriteLineIndent("if (" + condition1 + " || " + condition2 + " || " +
                        condition3 + ")");
        Indent(1);
        WriteLineIndent("return false;");
        Indent(-1);
      } else if (IsVariantType(p, *field->type)) {
        WriteLineIndent("// compare variant " + field_name);
        if (field->optional) {
          std::string condition1 = "(" + field_name + ".has_value() && !" +
                                   other_field_name + ".has_value())";
          std::string condition2 = "(!" + field_name + ".has_value() && " +
                                   other_field_name + ".has_value())";
          std::string condition3 =
              "(" + field_name + ".has_value() && " + other_field_name +
              ".has_value() && !is_equal(" + field_name + ".value(), " +
              other_field_name + ".value()))";
          WriteLineIndent("if (" + condition1 + " || " + condition2 + " || " +
                          condition3 + ")");
        } else {
          WriteLineIndent("if (!is_equal(" + field_name + ", " +
                          other_field_name + "))");
        }
        Indent(1);
        WriteLineIndent("return false;");
        Indent(-1);
      } else {
        // optional, struct, variant(imported), enum, flags and other primitive
        // types
        WriteLineIndent("if (" + field_name + " != " + other_field_name + ")");
        Indent(1);
        WriteLineIndent("return false;");
        Indent(-1);
      }
    }
  }
  WriteLineIndent("return true;");

  Indent(-1);
  WriteLineIndent("}");

  WriteLine();
  WriteLineIndent("bool " + *s->name + "::operator<([[maybe_unused]] const " +
                  *s->name + "& other) const noexcept");
  WriteLineIndent("{");
  Indent(1);
  if (s->base && !s->base->empty()) {
    WriteLineIndent("if (" + ConvertPtrTypeName(*p->name, *s->base) +
                    "::operator<(other))");
    Indent(1);
    WriteLineIndent("return true;");
    Indent(-1);
    WriteLineIndent("if (other." + ConvertPtrTypeName(*p->name, *s->base) +
                    "::operator<(*this))");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
  }
  if (s->body) {
    for (const auto &field : s->body->fields) {
      if (field->keys) {
        WriteLineIndent("if (" + *field->name + " < other." + *field->name +
                        ")");
        Indent(1);
        WriteLineIndent("return true;");
        Indent(-1);
        WriteLineIndent("if (other." + *field->name + " < " + *field->name +
                        ")");
        Indent(1);
        WriteLineIndent("return false;");
        Indent(-1);
      }
    }
  }
  WriteLineIndent("return false;");
  Indent(-1);
  WriteLineIndent("}");

  // Generate struct move assignment operator
  WriteLine();
  WriteLineIndent(*s->name + "& " + *s->name + "::operator=(" + *s->name +
                  "&& other) noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("if (this != &other)");
  WriteLineIndent("{");
  Indent(1);
  // generate the base move
  if (s->base && !s->base->empty()) {
    WriteLineIndent("Base::operator = (std::move(other))");
  }
  // generate the field move
  if (s->body) {
    for (const auto &field : s->body->fields) {
      if (IsContainerType(*field)) {
        WriteLineIndent(*field->name + " = std::move(other." + *field->name +
                        ");");
      } else if (field->ptr) {
        WriteLineIndent(*field->name + " = std::exchange(other." +
                        *field->name + ", nullptr);");
      } else if (field->optional) {
        WriteLineIndent("if (other." + *field->name + ".has_value()) {");
        Indent(1);
        if (IsPrimitiveType(*field->type, false)) {
          WriteLineIndent(*field->name + ".emplace(other." + *field->name +
                          ".value());");
        } else {
          WriteLineIndent(*field->name + ".emplace(std::move(other." +
                          *field->name + ".value()));");
        }
        WriteLineIndent("other." + *field->name + ".reset();");
        Indent(-1);
        WriteLineIndent("}");
      } else if (IsPrimitiveType(*field->type, field->optional)) {
        WriteLineIndent(*field->name + " = std::exchange(other." +
                        *field->name + ", " + ConvertDefault(*p->name, *field) +
                        ");");

      } else {
        WriteLineIndent(*field->name + " = std::move(other." + *field->name +
                        ");");
      }
      first = false;
    }
  }
  Indent(-1);
  WriteLineIndent("}");
  WriteLineIndent("return *this;");
  Indent(-1);
  WriteLineIndent("}");

  // Generate struct string method
  WriteLine();
  WriteLineIndent("std::string " + *s->name + "::to_string() const");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("std::stringstream ss; ss << *this; return ss.str();");
  Indent(-1);
  WriteLineIndent("}");

  // Generate struct swap method
  WriteLine();
  WriteLineIndent("void " + *s->name + "::swap([[maybe_unused]] " + *s->name +
                  "& other) noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("using std::swap;");
  if (s->base && !s->base->empty())
    WriteLineIndent(ConvertPtrTypeName(*p->name, *s->base) + "::swap(other);");
  if (s->body)
    for (const auto &field : s->body->fields)
      WriteLineIndent("swap(" + *field->name + ", other." + *field->name +
                      ");");
  Indent(-1);
  WriteLineIndent("}");
}

void GeneratorCpp::GenerateVariantIsEqualFunc(
    const std::shared_ptr<Package> &p, const std::shared_ptr<VariantType> &v) {
  WriteLine();
  WriteLineIndent("auto is_equal(const " + *v->name + "& lhs" + ", const " +
                  *v->name + "& rhs) -> bool {");
  Indent(1);
  WriteLineIndent("if (lhs.index() != rhs.index())");
  Indent(1);
  WriteLineIndent("return false;");
  Indent(-1);
  WriteLineIndent("switch (lhs.index()) {");
  Indent(1);
  WriteLineIndent("case 0 : {");
  Indent(1);
  WriteLineIndent("return true;");
  Indent(-1);
  WriteLineIndent("}");
  for (size_t index = 0; index < v->body->values.size(); index++) {
    WriteLineIndent("case " + std::to_string(index + 1) + ": {");
    Indent(1);
    auto v_value = v->body->values[index];
    auto is_v_value_variant = IsVariantType(p, *v_value->type);
    auto get_lhs_code = "std::get<" + std::to_string(index + 1) + ">(lhs)";
    auto get_rhs_code = "std::get<" + std::to_string(index + 1) + ">(rhs)";
    if (v_value->vector) {
      WriteLineIndent("auto& lhs_value = " + get_lhs_code + ";");
      WriteLineIndent("auto& rhs_value = " + get_rhs_code + ";");
      WriteLineIndent("if (lhs_value.size() != rhs_value.size())");
      Indent(1);
      WriteLineIndent("return false;");
      Indent(-1);
      WriteLineIndent("for (size_t i = 0; i < lhs_value.size(); i++)");
      WriteLineIndent("{");
      Indent(1);
      if (v_value->ptr) {
        WriteLineIndent("if (*lhs_value[i] != *rhs_value[i])");
      } else if (is_v_value_variant) {
        WriteLineIndent("if (!is_equal(lhs_value[i], rhs_value[i]))");
      } else {
        WriteLineIndent("if (lhs_value[i] != rhs_value[i])");
      }
      Indent(1);
      WriteLineIndent("return false;");
      Indent(-1);
      Indent(-1);
      WriteLineIndent("}");
      WriteLineIndent("return true;");
    } else if (v_value->map || v_value->hash) {
      WriteLineIndent("auto& lhs_value = " + get_lhs_code + ";");
      WriteLineIndent("auto& rhs_value = " + get_rhs_code + ";");
      WriteLineIndent("if (lhs_value.size() != rhs_value.size())");
      Indent(1);
      WriteLineIndent("return false;");
      Indent(-1);
      // each element in lhs compares equal with element in rhs at the same
      // position
      WriteLineIndent("for (auto & [k, v]: lhs_value)");
      WriteLineIndent("{");
      Indent(1);
      WriteLineIndent("auto pos = rhs_value.find(k);");
      WriteLineIndent("if (pos == rhs_value.end())");
      Indent(1);
      WriteLineIndent("return false;");
      Indent(-1);
      if (v_value->ptr) {
        WriteLineIndent("if (*pos->second != *v)");
      } else if (is_v_value_variant) {
        WriteLineIndent("if (!is_equal(pos->second, v))");
      } else {
        WriteLineIndent("if (pos->second != v)");
      }
      Indent(1);
      WriteLineIndent("return false;");
      Indent(-1);
      Indent(-1);
      WriteLineIndent("}");
      WriteLineIndent("return true;");
    } else if (v_value->list) {
      WriteLineIndent("for (auto l_iter = " + get_lhs_code +
                      ".begin(), r_iter = " + get_rhs_code +
                      ".begin(); r_iter != " + get_rhs_code +
                      ".end(); l_iter++, r_iter++) {");
      Indent(1);
      if (v_value->ptr) {
        WriteLineIndent("if (**l_iter != **r_iter)");
      } else if (is_v_value_variant) {
        WriteLineIndent("if (!is_equal(*l_iter, *r_iter))");
      } else {
        WriteLineIndent("if (*l_iter != *r_iter)");
      }
      Indent(1);
      WriteLineIndent("return false;");
      Indent(-1);
      Indent(-1);
      WriteLineIndent("}");
      WriteLineIndent("return true;");
    } else if (v_value->ptr) {
      WriteLineIndent("return *" + get_lhs_code + " == *" + get_rhs_code + ";");
    } else if (is_v_value_variant) {
      WriteLineIndent("return is_equal(" + get_lhs_code + ", " + get_rhs_code +
                      ");");
    } else {
      WriteLineIndent("return " + get_lhs_code + " == " + get_rhs_code + ";");
    }
    Indent(-1);
    WriteLineIndent("}");
  }
  WriteLineIndent("default: ");
  Indent(1);
  WriteLineIndent("return true;");
  Indent(-1);
  Indent(-1);
  WriteLineIndent("}");
  Indent(-1);
  WriteLineIndent("}");
}

void GeneratorCpp::GenerateVariantFieldModel_Header(
    const std::shared_ptr<Package> &p, const std::shared_ptr<VariantType> &v) {
  std::string variant_name =
      "::" + ConvertNamespace(*p->name) + "::" + *v->name;
  std::string class_name = "FieldModel<" + variant_name + ">";

  // Generate variant field model begin
  WriteLine();
  WriteLineIndent("template <>");
  WriteLineIndent("class " + class_name);
  WriteLineIndent("{");
  WriteLineIndent("public:");
  Indent(1);

  // Generate variant field model constructor
  WriteLineIndent("FieldModel(FBEBuffer& buffer, size_t offset) noexcept;");

  // Generate variant field model FBE methods
  WriteLine();
  WriteLineIndent("// Get the field offset");
  WriteLineIndent("size_t fbe_offset() const noexcept { return _offset; }");
  WriteLineIndent("// Get the field size");
  WriteLineIndent("size_t fbe_size() const noexcept { return 4; }");
  WriteLineIndent("// Get the field body size");
  WriteLineIndent("size_t fbe_body() const noexcept;");
  WriteLineIndent("// Get the field extra size");
  WriteLineIndent("size_t fbe_extra() const noexcept;");
  WriteLine();
  WriteLineIndent("// Shift the current field offset");
  WriteLineIndent("void fbe_shift(size_t size) noexcept { _offset += size; }");
  WriteLineIndent("// Unshift the current field offset");
  WriteLineIndent(
      "void fbe_unshift(size_t size) noexcept { _offset -= size; }");

  // Generate variant field model verify(), verify_fields() methods
  WriteLine();
  WriteLineIndent("// Check if the variant value is valid");
  WriteLineIndent("bool verify() const noexcept;");

  // Generate variant field model get(), get_fields() methods
  WriteLine();
  WriteLineIndent("// Get the variant value");
  WriteLineIndent(
      "void get(" + variant_name +
      "& fbe_value, std::pmr::memory_resource* resource) const noexcept;");

  WriteLine();
  WriteLineIndent("// Set the variant value (begin phase)");
  WriteLineIndent("size_t set_begin(size_t variant_type_fbe_size, size_t "
                  "variant_type_index);");
  WriteLineIndent("// Set the variant value (end phase)");
  WriteLineIndent("void set_end(size_t fbe_begin);");

  // Generate variant field model set(), set_fields() methods
  WriteLine();
  WriteLineIndent("// Set the variant value");
  WriteLineIndent(
      "void set(const " + variant_name +
      "& fbe_value, std::pmr::memory_resource* resource) noexcept;");

  // Generate variant field model buffer & offset
  Indent(-1);
  WriteLine();
  WriteLineIndent("private:");
  Indent(1);
  WriteLineIndent("FBEBuffer& _buffer;");
  WriteLineIndent("size_t _offset;");
  Indent(-1);
  WriteLineIndent("};");
}

void GeneratorCpp::GenerateVariantFieldModel_Source(
    const std::shared_ptr<Package> &p, const std::shared_ptr<VariantType> &v) {
  std::string variant_name =
      "::" + ConvertNamespace(*p->name) + "::" + *v->name;
  std::string class_name = "FieldModel<" + variant_name + ">";

  // Generate variant field model begin
  WriteLine();
  WriteLineIndent(class_name + "::FieldModel(FBEBuffer& buffer, size_t offset) "
                               "noexcept : _buffer(buffer), _offset(offset)");
  WriteLineIndent("{}");
  WriteLine();

  WriteLineIndent("size_t " + class_name + "::fbe_body() const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("// variant type's fbe_size not included");
  WriteLineIndent("size_t fbe_result = 4;");
  WriteLineIndent("return fbe_result;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  WriteLineIndent("size_t " + class_name + "::fbe_extra() const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent(
      "if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + "
      "_buffer.offset() + fbe_offset());");
  WriteLineIndent("if ((fbe_struct_offset == 0) || ((_buffer.offset() + "
                  "fbe_struct_offset + 4) > _buffer.size()))");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("_buffer.shift(fbe_struct_offset);");
  WriteLine();
  WriteLineIndent("size_t fbe_result = fbe_body();");
  Indent(1);
  // TODO(liuqi): calculate contained type's fbe_extra()
  Indent(-1);
  WriteLine();
  WriteLineIndent("_buffer.unshift(fbe_struct_offset);");
  WriteLine();
  WriteLineIndent("return fbe_result;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate variant field model verify(), verify_fields() methods
  WriteLineIndent("bool " + class_name + "::verify() const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent(
      "if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
  Indent(1);
  WriteLineIndent("return true;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_variant_offset = unaligned_load<uint32_t>(_buffer.data() + "
      "_buffer.offset() + fbe_offset());");
  WriteLineIndent("if ((fbe_variant_offset == 0) || ((_buffer.offset() + "
                  "fbe_variant_offset + 4) > _buffer.size()))");
  Indent(1);
  WriteLineIndent("return false;");
  Indent(-1);
  WriteLine();
  // type
  WriteLineIndent(
      "uint32_t fbe_variant_type = unaligned_load<uint32_t>(_buffer.data() + "
      "_buffer.offset() + fbe_variant_offset);");
  WriteLineIndent("if (fbe_variant_type > " +
                  std::to_string(v->body->values.size()) + ")");
  Indent(1);
  WriteLineIndent("return false;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("_buffer.shift(fbe_variant_offset);");
  WriteLineIndent("switch(fbe_variant_type) {");
  Indent(1);
  // for the std::monostate
  WriteLineIndent("case 0: {");
  Indent(1);
  WriteLineIndent("FieldModel<std::monostate> fbe_model(_buffer, 4);");
  WriteLineIndent("if (!fbe_model.verify())");
  Indent(1);
  WriteLineIndent("return false;");
  Indent(-1);
  WriteLineIndent("break;");
  Indent(-1);
  WriteLineIndent("}");
  for (auto index = 0; index < v->body->values.size(); index++) {
    WriteLineIndent("case " + std::to_string(index + 1) + ": {");
    Indent(1);
    auto &value = v->body->values[index];
    WriteLineIndent(ConvertPtrVariantFieldModelType(p, value) +
                    " fbe_model(_buffer, 4);");
    WriteLineIndent("if (!fbe_model.verify())");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLineIndent("break;");
    Indent(-1);
    WriteLineIndent("}");
  }
  WriteLineIndent("default:");
  Indent(1);
  WriteLineIndent("return false;");
  Indent(-1);
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();
  WriteLineIndent("_buffer.unshift(fbe_variant_offset);");
  WriteLineIndent("return true;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model get() method
  WriteLineIndent(
      "void " + class_name + "::get(" + variant_name +
      "& fbe_value, std::pmr::memory_resource* resource) const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent(
      "if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
  Indent(1);
  WriteLineIndent("return;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_variant_offset = unaligned_load<uint32_t>(_buffer.data() + "
      "_buffer.offset() + fbe_offset());");
  WriteLineIndent(
      "assert(((fbe_variant_offset > 0) && ((_buffer.offset() + "
      "fbe_variant_offset + 4) <= _buffer.size())) && \"Model is broken!\");");
  WriteLineIndent("if ((fbe_variant_offset == 0) || ((_buffer.offset() + "
                  "fbe_variant_offset + 4) > _buffer.size()))");
  Indent(1);
  WriteLineIndent("return;");
  Indent(-1);
  WriteLineIndent(
      "uint32_t variant_type_index = unaligned_load<uint32_t>(_buffer.data() + "
      "_buffer.offset() + fbe_variant_offset);");
  WriteLineIndent(
      "assert(variant_type_index <= " + std::to_string(v->body->values.size()) +
      " && \"Model is broken!\");");
  WriteLine();
  WriteLineIndent("_buffer.shift(fbe_variant_offset);");
  WriteLine();
  WriteLineIndent("switch(variant_type_index) {");
  Indent(1);
  WriteLineIndent("case 0: {");
  Indent(1);
  WriteLineIndent("FieldModel<std::monostate> fbe_model(_buffer, 4);");
  WriteLineIndent("fbe_value.emplace<std::monostate>();");
  WriteLineIndent("break;");
  Indent(-1);
  WriteLineIndent("}");
  for (auto index = 0; index < v->body->values.size(); index++) {
    WriteLineIndent("case " + std::to_string(index + 1) + ": {");
    Indent(1);
    auto &value = v->body->values[index];
    WriteLineIndent(ConvertPtrVariantFieldModelType(p, value) +
                    " fbe_model(_buffer, 4);");
    auto variant_type = ConvertVariantTypeName(*p->name, *value);
    // if (Arena() && IsPMRType(p, variant_type)) {
    //   WriteLineIndent("fbe_value.emplace<" + variant_type + ">(resource);");
    // } else {
    //   WriteLineIndent("fbe_value.emplace<" + variant_type + ">();");
    // }
    WriteLineIndent("variant_emplace_value<" + variant_name + ", " +
                    variant_type + ">(fbe_value, resource);");
    // initialize variant
    WriteLineIndent("auto& value = std::get<" + std::to_string(index + 1) +
                    ">(fbe_value);");
    // if (IsPMRType(p, variant_type)) {
    //     WriteLineIndent(std::string("fbe_model.get(") +
    //     ((!IsContainerType(*value) && value->ptr) ? "&" : "") + "value,
    //     resource);");
    // } else {
    //     WriteLineIndent(std::string("fbe_model.get(") +
    //     ((!IsContainerType(*value) && value->ptr) ? "&" : "") + "value,
    //     nullptr);");

    // }
    WriteLineIndent(std::string("variant_get_value(fbe_model, ") +
                    ((!IsContainerType(*value) && value->ptr) ? "&" : "") +
                    "value, resource);");
    WriteLineIndent("break;");
    Indent(-1);
    WriteLineIndent("}");
  }
  WriteLineIndent("default:");
  Indent(1);
  WriteLineIndent("break;");
  Indent(-1);
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();
  WriteLineIndent("_buffer.unshift(fbe_variant_offset);");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate variant field model set_begin() method
  // We don't know the type of the variant in advance. So we need to pass
  // variant_type_fbe_size to set_begin to alloc.
  WriteLineIndent(
      "size_t " + class_name +
      "::set_begin(size_t variant_type_fbe_size, size_t variant_type_index)");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= "
                  "_buffer.size()) && \"Model is broken!\");");
  WriteLineIndent(
      "if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("uint32_t fbe_variant_size = (uint32_t)(fbe_body() + "
                  "variant_type_fbe_size);");
  WriteLineIndent(
      "uint32_t fbe_variant_offset = "
      "(uint32_t)(_buffer.allocate(fbe_variant_size) - _buffer.offset());");
  WriteLineIndent("assert(((fbe_variant_offset > 0) && ((_buffer.offset() + "
                  "fbe_variant_offset + fbe_variant_size) <= _buffer.size())) "
                  "&& \"Model is broken!\");");
  WriteLineIndent("if ((fbe_variant_offset == 0) || ((_buffer.offset() + "
                  "fbe_variant_offset + fbe_variant_size) > _buffer.size()))");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() "
                  "+ fbe_offset(), fbe_variant_offset);");
  WriteLineIndent("unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() "
                  "+ fbe_variant_offset, variant_type_index);");
  WriteLine();
  WriteLineIndent("_buffer.shift(fbe_variant_offset);");
  WriteLineIndent("return fbe_variant_offset;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate variant field model set_end() method
  WriteLineIndent("void " + class_name + "::set_end(size_t fbe_begin)");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("_buffer.unshift(fbe_begin);");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate variant field model set() method
  WriteLineIndent("// Set the variant value");
  WriteLineIndent("void " + class_name + "::set(const " + variant_name +
                  "& fbe_value, std::pmr::memory_resource* resource) noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= "
                  "_buffer.size()) && \"Model is broken!\");");
  WriteLineIndent(
      "if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
  Indent(1);
  WriteLineIndent("return;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("std::visit(");
  Indent(1);
  WriteLineIndent("overloaded");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("[this, fbe_variant_index = fbe_value.index(), "
                  "resource](std::monostate v) {");
  Indent(1);
  WriteLineIndent("FieldModel<std::monostate> fbe_model(_buffer, 4);");
  WriteLineIndent(
      "size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);");
  WriteLineIndent("if (fbe_begin == 0)");
  Indent(1);
  WriteLineIndent("return;");
  Indent(-1);
  WriteLineIndent("fbe_model.set(v, resource);");
  WriteLineIndent("set_end(fbe_begin);");
  Indent(-1);
  WriteLineIndent("}");

  for (auto index = 0; index < v->body->values.size(); index++) {
    WriteIndent(", ");
    auto &value = v->body->values[index];
    Write("[this, fbe_variant_index = fbe_value.index(), resource](");
    Write(ConvertVariantTypeNameAsArgument(*p->name, *value));
    WriteLine(" v) {");
    Indent(1);
    WriteLineIndent(ConvertPtrVariantFieldModelType(p, value) +
                    " fbe_model(_buffer, 4);");
    WriteLineIndent("size_t fbe_begin = set_begin(fbe_model.fbe_size(), "
                    "fbe_variant_index);");
    WriteLineIndent("if (fbe_begin == 0)");
    Indent(1);
    WriteLineIndent("return;");
    Indent(-1);
    WriteLineIndent("fbe_model.set(v, resource);");
    WriteLineIndent("set_end(fbe_begin);");
    Indent(-1);
    WriteLineIndent("}");
  }
  Indent(-1);
  WriteLineIndent("},");
  WriteLineIndent("fbe_value");
  Indent(-1);
  WriteLineIndent(");");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();
}

void GeneratorCpp::GenerateVariantFinalModel_Header(
    const std::shared_ptr<Package> &p, const std::shared_ptr<VariantType> &v) {
  std::string variant_name =
      "::" + ConvertNamespace(*p->name) + "::" + *v->name;
  std::string class_name = "FinalModel<" + variant_name + ">";

  // Generate variant final model begin
  WriteLine();
  WriteLineIndent("// Fast Binary Encoding " + variant_name + " final model");
  WriteLineIndent("template <>");
  WriteLineIndent("class " + class_name);
  WriteLineIndent("{");
  WriteLineIndent("public:");
  Indent(1);

  // Generate variant final model constructor
  WriteLineIndent("FinalModel(FBEBuffer& buffer, size_t offset) noexcept : "
                  "_buffer(buffer), _offset(offset) {}");

  // Generate variant final model FBE methods
  WriteLine();
  WriteLineIndent("// Get the allocation size");
  WriteLineIndent("size_t fbe_allocation_size(const " + variant_name +
                  "& fbe_value) const noexcept;");
  WriteLineIndent("// Get the final offset");
  WriteLineIndent("size_t fbe_offset() const noexcept { return _offset; }");
  WriteLineIndent("// Set the final offset");
  WriteLineIndent("size_t fbe_offset(size_t offset) const noexcept { return "
                  "_offset = offset; }");
  WriteLine();
  WriteLineIndent("// Shift the current final offset");
  WriteLineIndent("void fbe_shift(size_t size) noexcept { _offset += size; }");
  WriteLineIndent("// Unshift the current final offset");
  WriteLineIndent(
      "void fbe_unshift(size_t size) noexcept { _offset -= size; }");

  // Generate variant final model verify() method
  WriteLine();
  WriteLineIndent("// Check if the variant value is valid");
  WriteLineIndent("size_t verify() const noexcept;");

  // Generate variant final model get() methods
  WriteLine();
  WriteLineIndent("// Get the variant value");
  WriteLineIndent("size_t get(" + variant_name +
                  "& fbe_value) const noexcept;");
  if (Arena()) {
    WriteLineIndent("// Get the variant value with memory resource");
    WriteLineIndent(
        "size_t get(" + variant_name +
        "& fbe_value, std::pmr::memory_resource* resource) const noexcept;");
  }

  // Generate variant final model set() method
  WriteLine();
  WriteLineIndent("// Set the variant value");
  WriteLineIndent("size_t set(const " + variant_name +
                  "& fbe_value) noexcept;");

  // Generate variant final model buffer & offset
  Indent(-1);
  WriteLine();
  WriteLineIndent("private:");
  Indent(1);
  WriteLineIndent("FBEBuffer& _buffer;");
  WriteLineIndent("mutable size_t _offset;");
  Indent(-1);
  WriteLineIndent("};");
}

void GeneratorCpp::GenerateVariantFinalModel_Source(
    const std::shared_ptr<Package> &p, const std::shared_ptr<VariantType> &v) {
  std::string variant_name =
      "::" + ConvertNamespace(*p->name) + "::" + *v->name;
  std::string class_name = "FinalModel<" + variant_name + ">";

  // Generate variant final model fbe_allocation_size() method
  WriteLine();
  WriteLineIndent("size_t " + class_name + "::fbe_allocation_size(const " +
                  variant_name + "& fbe_value) const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("size_t fbe_result = 4; // variant type index size");
  WriteLineIndent("std::visit(");
  Indent(1);
  WriteLineIndent("overloaded");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("[](std::monostate) { },");
  for (size_t index = 0; index < v->body->values.size(); index++) {
    auto &value = v->body->values[index];
    std::string final_model_type =
        ConvertVariantFinalModelType(*p->name, *value);
    WriteIndent("[this, &fbe_result](");
    Write(ConvertVariantTypeNameAsArgument(*p->name, *value));
    WriteLine(" v) {");
    Indent(1);
    WriteLineIndent(final_model_type + " fbe_model(_buffer, 0);");
    WriteLineIndent("fbe_result += fbe_model.fbe_allocation_size(v);");
    Indent(-1);
    WriteLineIndent("},");
  }
  Indent(-1);
  WriteLineIndent("},");
  WriteLineIndent("fbe_value");
  Indent(-1);
  WriteLineIndent(");");
  WriteLineIndent("return fbe_result;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate variant final model verify() method
  WriteLineIndent("size_t " + class_name + "::verify() const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("size_t fbe_full_offset = _buffer.offset() + fbe_offset();");
  WriteLineIndent("if ((fbe_full_offset + 4) > _buffer.size())");
  Indent(1);
  WriteLineIndent("return std::numeric_limits<std::size_t>::max();");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_variant_type = unaligned_load<uint32_t>(_buffer.data() + "
      "fbe_full_offset);");
  WriteLineIndent("if (fbe_variant_type > " +
                  std::to_string(v->body->values.size()) + ")");
  Indent(1);
  WriteLineIndent("return std::numeric_limits<std::size_t>::max();");
  Indent(-1);
  WriteLine();
  WriteLineIndent("_buffer.shift(fbe_offset() + 4);");
  WriteLineIndent("size_t fbe_result = 4;");
  WriteLineIndent("switch (fbe_variant_type) {");
  Indent(1);
  WriteLineIndent("case 0: // std::monostate");
  Indent(1);
  WriteLineIndent("break;");
  Indent(-1);
  for (size_t index = 0; index < v->body->values.size(); index++) {
    auto &value = v->body->values[index];
    std::string final_model_type =
        ConvertVariantFinalModelType(*p->name, *value);
    WriteLineIndent("case " + std::to_string(index + 1) + ": {");
    Indent(1);
    WriteLineIndent(final_model_type + " fbe_model(_buffer, 0);");
    WriteLineIndent("size_t fbe_field_size = fbe_model.verify();");
    WriteLineIndent(
        "if (fbe_field_size == std::numeric_limits<std::size_t>::max()) {");
    Indent(1);
    WriteLineIndent("_buffer.unshift(fbe_offset() + 4);");
    WriteLineIndent("return std::numeric_limits<std::size_t>::max();");
    Indent(-1);
    WriteLineIndent("}");
    WriteLineIndent("fbe_result += fbe_field_size;");
    WriteLineIndent("break;");
    Indent(-1);
    WriteLineIndent("}");
  }
  WriteLineIndent("default:");
  Indent(1);
  WriteLineIndent("_buffer.unshift(fbe_offset() + 4);");
  WriteLineIndent("return std::numeric_limits<std::size_t>::max();");
  Indent(-1);
  Indent(-1);
  WriteLineIndent("}");
  WriteLineIndent("_buffer.unshift(fbe_offset() + 4);");
  WriteLineIndent("return fbe_result;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate variant final model get() method (without resource)
  WriteLineIndent("size_t " + class_name + "::get(" + variant_name +
                  "& fbe_value) const noexcept");
  WriteLineIndent("{");
  Indent(1);
  if (Arena())
    WriteLineIndent("return get(fbe_value, nullptr);");
  else {
    WriteLineIndent(
        "size_t fbe_full_offset = _buffer.offset() + fbe_offset();");
    WriteLineIndent("assert(((fbe_full_offset + 4) <= _buffer.size()) && "
                    "\"Model is broken!\");");
    WriteLineIndent("if ((fbe_full_offset + 4) > _buffer.size())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent(
        "uint32_t fbe_variant_type = unaligned_load<uint32_t>(_buffer.data() + "
        "fbe_full_offset);");
    WriteLineIndent(
        "assert(fbe_variant_type <= " + std::to_string(v->body->values.size()) +
        " && \"Model is broken!\");");
    WriteLine();
    WriteLineIndent("_buffer.shift(fbe_offset() + 4);");
    WriteLineIndent("size_t fbe_result = 4;");
    WriteLineIndent("switch (fbe_variant_type) {");
    Indent(1);
    WriteLineIndent("case 0:");
    Indent(1);
    WriteLineIndent("fbe_value.emplace<std::monostate>();");
    WriteLineIndent("break;");
    Indent(-1);
    for (size_t index = 0; index < v->body->values.size(); index++) {
      auto &value = v->body->values[index];
      std::string variant_type = ConvertVariantTypeName(*p->name, *value);
      std::string final_model_type =
          ConvertVariantFinalModelType(*p->name, *value);
      WriteLineIndent("case " + std::to_string(index + 1) + ": {");
      Indent(1);
      WriteLineIndent(final_model_type + " fbe_model(_buffer, 0);");
      WriteLineIndent("fbe_value.emplace<" + variant_type + ">();");
      WriteLineIndent("auto& value = std::get<" + std::to_string(index + 1) +
                      ">(fbe_value);");
      WriteLineIndent("fbe_result += fbe_model.get(value);");
      WriteLineIndent("break;");
      Indent(-1);
      WriteLineIndent("}");
    }
    WriteLineIndent("default:");
    Indent(1);
    WriteLineIndent("break;");
    Indent(-1);
    Indent(-1);
    WriteLineIndent("}");
    WriteLineIndent("_buffer.unshift(fbe_offset() + 4);");
    WriteLineIndent("return fbe_result;");
  }
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate variant final model get() method with resource (only for Arena
  // mode)
  if (Arena()) {
    WriteLineIndent(
        "size_t " + class_name + "::get(" + variant_name +
        "& fbe_value, std::pmr::memory_resource* resource) const noexcept");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent(
        "size_t fbe_full_offset = _buffer.offset() + fbe_offset();");
    WriteLineIndent("assert(((fbe_full_offset + 4) <= _buffer.size()) && "
                    "\"Model is broken!\");");
    WriteLineIndent("if ((fbe_full_offset + 4) > _buffer.size())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent(
        "uint32_t fbe_variant_type = unaligned_load<uint32_t>(_buffer.data() + "
        "fbe_full_offset);");
    WriteLineIndent(
        "assert(fbe_variant_type <= " + std::to_string(v->body->values.size()) +
        " && \"Model is broken!\");");
    WriteLine();
    WriteLineIndent("_buffer.shift(fbe_offset() + 4);");
    WriteLineIndent("size_t fbe_result = 4;");
    WriteLineIndent("switch (fbe_variant_type) {");
    Indent(1);
    WriteLineIndent("case 0:");
    Indent(1);
    WriteLineIndent("fbe_value.emplace<std::monostate>();");
    WriteLineIndent("break;");
    Indent(-1);
    for (size_t index = 0; index < v->body->values.size(); index++) {
      auto &value = v->body->values[index];
      std::string variant_type = ConvertVariantTypeName(*p->name, *value);
      std::string final_model_type =
          ConvertVariantFinalModelType(*p->name, *value);
      WriteLineIndent("case " + std::to_string(index + 1) + ": {");
      Indent(1);
      WriteLineIndent(final_model_type + " fbe_model(_buffer, 0);");
      WriteLineIndent("final_variant_emplace_value<" + variant_name + ", " +
                      variant_type + ">(fbe_value, resource);");
      WriteLineIndent("auto& value = std::get<" + std::to_string(index + 1) +
                      ">(fbe_value);");
      WriteLineIndent("fbe_result += fbe_model.get(value, resource);");
      WriteLineIndent("break;");
      Indent(-1);
      WriteLineIndent("}");
    }
    WriteLineIndent("default:");
    Indent(1);
    WriteLineIndent("break;");
    Indent(-1);
    Indent(-1);
    WriteLineIndent("}");
    WriteLineIndent("_buffer.unshift(fbe_offset() + 4);");
    WriteLineIndent("return fbe_result;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
  }

  // Generate variant final model set() method
  WriteLineIndent("size_t " + class_name + "::set(const " + variant_name +
                  "& fbe_value) noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("size_t fbe_full_offset = _buffer.offset() + fbe_offset();");
  WriteLineIndent("assert(((fbe_full_offset + 4) <= _buffer.size()) && \"Model "
                  "is broken!\");");
  WriteLineIndent("if ((fbe_full_offset + 4) > _buffer.size())");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("size_t fbe_result = 4;");
  WriteLineIndent(
      "uint32_t fbe_variant_type = static_cast<uint32_t>(fbe_value.index());");
  WriteLineIndent("unaligned_store<uint32_t>(_buffer.data() + fbe_full_offset, "
                  "fbe_variant_type);");
  WriteLine();
  WriteLineIndent("_buffer.shift(fbe_offset() + 4);");
  WriteLineIndent("std::visit(");
  Indent(1);
  WriteLineIndent("overloaded");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("[](std::monostate) { },");
  for (size_t index = 0; index < v->body->values.size(); index++) {
    auto &value = v->body->values[index];
    std::string final_model_type =
        ConvertVariantFinalModelType(*p->name, *value);
    WriteIndent("[this, &fbe_result](");
    Write(ConvertVariantTypeNameAsArgument(*p->name, *value));
    WriteLine(" v) {");
    Indent(1);
    WriteLineIndent(final_model_type + " fbe_model(_buffer, 0);");
    WriteLineIndent("fbe_result += fbe_model.set(v);");
    Indent(-1);
    WriteLineIndent("},");
  }
  Indent(-1);
  WriteLineIndent("},");
  WriteLineIndent("fbe_value");
  Indent(-1);
  WriteLineIndent(");");
  WriteLineIndent("_buffer.unshift(fbe_offset() + 4);");
  WriteLineIndent("return fbe_result;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();
}

void GeneratorCpp::GenerateStructFieldPtrModel_Header(
    const std::shared_ptr<Package> &p, const std::shared_ptr<StructType> &s) {
  std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
  std::string class_name = std::string("FieldModel") + (Arena() ? "PMR" : "") +
                           "Ptr_" + *p->name + "_" + *s->name;

  // Generate struct field ptr model begin
  WriteLine();
  WriteLineIndent("class " + class_name);
  WriteLineIndent("{");
  WriteLineIndent("public:");
  Indent(1);

  // Generate struct field ptr model constructor
  WriteLineIndent(class_name + "(FBEBuffer& buffer, size_t offset) noexcept;");
  WriteLineIndent("~" + class_name + "();");

  // Generate struct field ptr model FBE methods
  WriteLine();
  WriteLineIndent("// Get the field offset");
  WriteLineIndent("size_t fbe_offset() const noexcept { return _offset; }");
  WriteLineIndent("// Get the field size");
  WriteLineIndent("size_t fbe_size() const noexcept { return 5; }");
  WriteLineIndent("// Get the field extra size");
  WriteLineIndent("size_t fbe_extra() const noexcept;");
  WriteLineIndent("// Get the field type");
  WriteLineIndent("static constexpr size_t fbe_type() noexcept { return " +
                  std::to_string(s->type) + "; }");
  WriteLine();
  WriteLineIndent("// Shift the current field offset");
  WriteLineIndent("void fbe_shift(size_t size) noexcept { _offset += size; }");
  WriteLineIndent("// Unshift the current field offset");
  WriteLineIndent(
      "void fbe_unshift(size_t size) noexcept { _offset -= size; }");

  // Generate struct field model verify(), verify_fields() methods
  WriteLine();
  WriteLineIndent("// Check if the struct value is valid");
  WriteLineIndent("bool verify() const noexcept;");
  WriteLineIndent("// Check if the struct ptr is nullptr");
  WriteLineIndent("bool has_value() const noexcept;");

  // Generate struct field model get_begin(), get_end() methods
  WriteLine();
  WriteLineIndent("// Get the struct value (begin phase)");
  WriteLineIndent("size_t get_begin() const noexcept;");
  WriteLineIndent("// Get the struct value (end phase)");
  WriteLineIndent("void get_end(size_t fbe_begin) const noexcept;");

  // Generate struct field model get(), get_fields() methods
  WriteLine();
  WriteLineIndent("// Get the struct value");
  WriteLineIndent(
      "void get(" + struct_name +
      "** fbe_value, std::pmr::memory_resource* resource) noexcept;");
  WriteLineIndent("// Get the struct fields values");
  WriteLineIndent("void get_fields(" + struct_name +
                  "& fbe_value, size_t fbe_struct_size, "
                  "std::pmr::memory_resource* resource) noexcept;");

  // Generate struct field model set_begin(), set_end() methods
  WriteLine();
  WriteLineIndent("// Set the struct value (begin phase)");
  WriteLineIndent("size_t set_begin(bool has_value);");
  WriteLineIndent("// Set the struct value (end phase)");
  WriteLineIndent("void set_end(size_t fbe_begin);");

  // Generate struct field model set(), set_fields() methods
  WriteLine();
  WriteLineIndent("// Set the struct value");
  WriteLineIndent(
      "void set(const " + struct_name +
      "* fbe_value, std::pmr::memory_resource* resource) noexcept;");
  WriteLineIndent("// Set the struct fields values");
  WriteLineIndent(
      "void set_fields(const " + struct_name +
      "* fbe_value, std::pmr::memory_resource* resource) noexcept;");

  // Generate struct field model buffer & offset
  Indent(-1);
  WriteLine();
  WriteLineIndent("private:");
  Indent(1);
  WriteLineIndent("FBEBuffer& _buffer;");
  WriteLineIndent("size_t _offset;");

  // Generate struct field model accessors
  Indent(-1);
  WriteLine();
  WriteLineIndent("public:");
  Indent(1);
  WriteLineIndent("BaseFieldModel* ptr{nullptr};");

  // Generate struct field model end
  Indent(-1);
  WriteLineIndent("};");
}

void GeneratorCpp::GeneratePtrStructFieldModel_Header(
    const std::shared_ptr<Package> &p, const std::shared_ptr<StructType> &s) {
  std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
  std::string class_name = std::string("FieldModel") +
                           (Arena() ? "PMR_" : "_") + *p->name + "_" + *s->name;

  // Generate struct field model begin
  WriteLine();
  WriteLineIndent("// Fast Binary Encoding " + struct_name + " field model");
  WriteLineIndent("class " + class_name + " : public BaseFieldModel");
  WriteLineIndent("{");
  WriteLineIndent("public:");
  Indent(1);

  // Generate struct field model constructor
  WriteLineIndent(class_name + "(FBEBuffer& buffer, size_t offset) noexcept;");

  // Generate struct field model FBE methods
  WriteLine();
  WriteLineIndent("// Get the field offset");
  WriteLineIndent(
      "size_t fbe_offset() const noexcept override { return _offset; }");
  WriteLineIndent("// Get the field size");
  WriteLineIndent("size_t fbe_size() const noexcept override { return 4; }");
  WriteLineIndent("// Get the field body size");
  WriteLineIndent("size_t fbe_body() const noexcept;");
  WriteLineIndent("// Get the field extra size");
  WriteLineIndent("size_t fbe_extra() const noexcept override;");
  WriteLineIndent("// Get the field type");
  if (s->base && !s->base->empty() && (s->type == 0))
    WriteLineIndent(
        "static constexpr size_t fbe_type() noexcept { return FieldModel<" +
        ConvertPtrTypeName(*p->name, *s->base) + ">::fbe_type(); }");
  else
    WriteLineIndent("static constexpr size_t fbe_type() noexcept { return " +
                    std::to_string(s->type) + "; }");
  WriteLine();
  WriteLineIndent("// Shift the current field offset");
  WriteLineIndent(
      "void fbe_shift(size_t size) noexcept override { _offset += size; }");
  WriteLineIndent("// Unshift the current field offset");
  WriteLineIndent(
      "void fbe_unshift(size_t size) noexcept override { _offset -= size; }");

  // Generate struct field model verify(), verify_fields() methods
  WriteLine();
  WriteLineIndent("// Check if the struct value is valid");
  WriteLineIndent(
      "bool verify(bool fbe_verify_type = true) const noexcept override;");
  WriteLineIndent("// Check if the struct fields are valid");
  WriteLineIndent(
      "bool verify_fields(size_t fbe_struct_size) const noexcept override;");

  // Generate struct field model get_begin(), get_end() methods
  WriteLine();
  WriteLineIndent("// Get the struct value (begin phase)");
  WriteLineIndent("size_t get_begin() const noexcept override;");
  WriteLineIndent("// Get the struct value (end phase)");
  WriteLineIndent("void get_end(size_t fbe_begin) const noexcept override;");

  // Generate struct field model get(), get_fields() methods
  WriteLine();
  WriteLineIndent("// Get the struct value");
  WriteLineIndent("void get(::FBE::Base& fbe_value, std::pmr::memory_resource* "
                  "resource) noexcept override;");
  WriteLineIndent("// Get the struct fields values");
  WriteLineIndent(
      "void get_fields(::FBE::Base& fbe_value, size_t fbe_struct_size, "
      "std::pmr::memory_resource* resource) noexcept override;");

  // Generate struct field model set_begin(), set_end() methods
  WriteLine();
  WriteLineIndent("// Set the struct value (begin phase)");
  WriteLineIndent("size_t set_begin() override;");
  WriteLineIndent("// Set the struct value (end phase)");
  WriteLineIndent("void set_end(size_t fbe_begin) override;");

  // Generate struct field model set(), set_fields() methods
  WriteLine();
  WriteLineIndent("// Set the struct value");
  WriteLineIndent("void set(const ::FBE::Base& fbe_value, "
                  "std::pmr::memory_resource* resource) noexcept override;");
  WriteLineIndent("// Set the struct fields values");
  WriteLineIndent("void set_fields(const ::FBE::Base& fbe_value, "
                  "std::pmr::memory_resource* resource) noexcept override;");

  // Generate struct field model buffer & offset
  Indent(-1);
  WriteLine();
  WriteLineIndent("private:");
  Indent(1);
  WriteLineIndent("FBEBuffer& _buffer;");
  WriteLineIndent("size_t _offset;");

  // Generate struct field model accessors
  Indent(-1);
  WriteLine();
  WriteLineIndent("public:");
  Indent(1);
  if (s->base && !s->base->empty())
    // TODO: check if this is correct
    WriteLineIndent("FieldModel<" + ConvertPtrTypeName(*p->name, *s->base) +
                    "> parent;");
  if (s->body) {
    for (const auto &field : s->body->fields) {
      WriteLineIndent(ConvertPtrFieldModelType(p, field) + " " + *field->name +
                      ";");
    }
  }

  // Generate struct field model end
  Indent(-1);
  WriteLineIndent("};");
}

void GeneratorCpp::GeneratePtrStructFieldModel_Source(
    const std::shared_ptr<Package> &p, const std::shared_ptr<StructType> &s) {
  std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
  std::string class_name = std::string("FieldModel") +
                           (Arena() ? "PMR_" : "_") + *p->name + "_" + *s->name;

  // Generate struct field model constructor
  WriteLine();
  WriteLineIndent(class_name + "::" + class_name +
                  "(FBEBuffer& buffer, size_t offset) noexcept : "
                  "_buffer(buffer), _offset(offset)");
  Indent(1);
  std::string prev_offset("4");
  std::string prev_size("4");
  if (s->base && !s->base->empty()) {
    WriteLineIndent(", parent(buffer, " + prev_offset + " + " + prev_size +
                    ")");
    prev_offset = "parent.fbe_offset()";
    prev_size = "parent.fbe_body() - 4 - 4";
  }
  if (s->body) {
    for (const auto &field : s->body->fields) {
      WriteLineIndent(", " + *field->name + "(buffer, " + prev_offset + " + " +
                      prev_size + ")");
      prev_offset = *field->name + ".fbe_offset()";
      prev_size = *field->name + ".fbe_size()";
    }
  }
  Indent(-1);
  WriteLineIndent("{}");
  WriteLine();

  // Generate struct field model FBE methods
  WriteLineIndent("size_t " + class_name + "::fbe_body() const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("size_t fbe_result = 4 + 4");
  Indent(1);
  if (s->base && !s->base->empty())
    WriteLineIndent("+ parent.fbe_body() - 4 - 4");
  if (s->body)
    for (const auto &field : s->body->fields)
      WriteLineIndent("+ " + *field->name + ".fbe_size()");
  WriteLineIndent(";");
  Indent(-1);
  WriteLineIndent("return fbe_result;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();
  WriteLineIndent("size_t " + class_name + "::fbe_extra() const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent(
      "if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + "
      "_buffer.offset() + fbe_offset());");
  WriteLineIndent("if ((fbe_struct_offset == 0) || ((_buffer.offset() + "
                  "fbe_struct_offset + 4) > _buffer.size()))");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("_buffer.shift(fbe_struct_offset);");
  WriteLine();
  WriteLineIndent("size_t fbe_result = fbe_body()");
  Indent(1);
  if (s->base && !s->base->empty())
    WriteLineIndent("+ parent.fbe_extra()");
  if (s->body)
    for (const auto &field : s->body->fields)
      WriteLineIndent("+ " + *field->name + ".fbe_extra()");
  WriteLineIndent(";");
  Indent(-1);
  WriteLine();
  WriteLineIndent("_buffer.unshift(fbe_struct_offset);");
  WriteLine();
  WriteLineIndent("return fbe_result;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model verify() method
  WriteLineIndent("bool " + class_name +
                  "::verify(bool fbe_verify_type) const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent(
      "if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
  Indent(1);
  WriteLineIndent("return true;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + "
      "_buffer.offset() + fbe_offset());");
  WriteLineIndent("if ((fbe_struct_offset == 0) || ((_buffer.offset() + "
                  "fbe_struct_offset + 4 + 4) > _buffer.size()))");
  Indent(1);
  WriteLineIndent("return false;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + "
      "_buffer.offset() + fbe_struct_offset);");
  WriteLineIndent("if (fbe_struct_size < (4 + 4))");
  Indent(1);
  WriteLineIndent("return false;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + "
      "_buffer.offset() + fbe_struct_offset + 4);");
  WriteLineIndent("if (fbe_verify_type && (fbe_struct_type != fbe_type()))");
  Indent(1);
  WriteLineIndent("return false;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("_buffer.shift(fbe_struct_offset);");
  WriteLineIndent("bool fbe_result = verify_fields(fbe_struct_size);");
  WriteLineIndent("_buffer.unshift(fbe_struct_offset);");
  WriteLineIndent("return fbe_result;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model verify_fields() method
  WriteLineIndent("bool " + class_name +
                  "::verify_fields([[maybe_unused]] size_t fbe_struct_size) "
                  "const noexcept");
  WriteLineIndent("{");
  Indent(1);
  if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty())) {
    WriteLineIndent("size_t fbe_current_size = 4 + 4;");
    if (s->base && !s->base->empty()) {
      WriteLine();
      WriteLineIndent("if ((fbe_current_size + parent.fbe_body() - 4 - 4) > "
                      "fbe_struct_size)");
      Indent(1);
      WriteLineIndent("return true;");
      Indent(-1);
      WriteLineIndent("if (!parent.verify_fields(fbe_struct_size))");
      Indent(1);
      WriteLineIndent("return false;");
      Indent(-1);
      WriteLineIndent("fbe_current_size += parent.fbe_body() - 4 - 4;");
    }
    if (s->body) {
      for (const auto &field : s->body->fields) {
        WriteLine();
        WriteLineIndent("if ((fbe_current_size + " + *field->name +
                        ".fbe_size()) > fbe_struct_size)");
        Indent(1);
        WriteLineIndent("return true;");
        Indent(-1);
        WriteLineIndent("if (!" + *field->name + ".verify())");
        Indent(1);
        WriteLineIndent("return false;");
        Indent(-1);
        WriteLineIndent("fbe_current_size += " + *field->name + ".fbe_size();");
      }
    }
    WriteLine();
  }
  WriteLineIndent("return true;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model get_begin() method
  WriteLineIndent("size_t " + class_name + "::get_begin() const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent(
      "if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + "
      "_buffer.offset() + fbe_offset());");
  WriteLineIndent("assert(((fbe_struct_offset > 0) && ((_buffer.offset() + "
                  "fbe_struct_offset + 4 + 4) <= _buffer.size())) && \"Model "
                  "is broken!\");");
  WriteLineIndent("if ((fbe_struct_offset == 0) || ((_buffer.offset() + "
                  "fbe_struct_offset + 4 + 4) > _buffer.size()))");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + "
      "_buffer.offset() + fbe_struct_offset);");
  WriteLineIndent(
      "assert((fbe_struct_size >= (4 + 4)) && \"Model is broken!\");");
  WriteLineIndent("if (fbe_struct_size < (4 + 4))");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("_buffer.shift(fbe_struct_offset);");
  WriteLineIndent("return fbe_struct_offset;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model get_end() method
  WriteLineIndent("void " + class_name +
                  "::get_end(size_t fbe_begin) const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("_buffer.unshift(fbe_begin);");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model get() method
  WriteLineIndent("void " + class_name +
                  "::get(::FBE::Base& fbe_value, std::pmr::memory_resource* "
                  "resource) noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("size_t fbe_begin = get_begin();");
  WriteLineIndent("if (fbe_begin == 0)");
  Indent(1);
  WriteLineIndent("return;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + "
      "_buffer.offset());");
  WriteLineIndent("get_fields(fbe_value, fbe_struct_size, resource);");
  WriteLineIndent("get_end(fbe_begin);");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model get_fields() method
  WriteLineIndent("void " + class_name +
                  "::get_fields([[maybe_unused]] ::FBE::Base& base_fbe_value, "
                  "[[maybe_unused]] size_t fbe_struct_size, "
                  "std::pmr::memory_resource* resource) noexcept");
  WriteLineIndent("{");
  Indent(1);
  if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty())) {
    WriteLineIndent(struct_name + "& fbe_value = static_cast<" + struct_name +
                    "&>(base_fbe_value);");
    WriteLineIndent("size_t fbe_current_size = 4 + 4;");
    if (s->base && !s->base->empty()) {
      WriteLine();
      WriteLineIndent("if ((fbe_current_size + parent.fbe_body() - 4 - 4) <= "
                      "fbe_struct_size)");
      Indent(1);
      if (Arena()) {
        WriteLineIndent(
            "parent.get_fields(fbe_value, fbe_struct_size, resource);");
      } else {
        WriteLineIndent("parent.get_fields(fbe_value, fbe_struct_size);");
      }
      Indent(-1);
      WriteLineIndent("fbe_current_size += parent.fbe_body() - 4 - 4;");
    }
    if (s->body) {
      for (const auto &field : s->body->fields) {
        WriteLine();
        WriteLineIndent("if ((fbe_current_size + " + *field->name +
                        ".fbe_size()) <= fbe_struct_size)");
        Indent(1);
        if (!field->ptr || IsContainerType(*field)) {
          WriteLineIndent("{");
          Indent(1);
          if (Arena()) {
            WriteLineIndent(*field->name + ".get(fbe_value." + *field->name +
                            ", resource);");
          } else {
            WriteLineIndent(*field->name + ".get(fbe_value." + *field->name +
                            ", nullptr);");
          }
          Indent(-1);
          WriteLineIndent("}");
        } else {
          WriteLineIndent("{");
          Indent(1);
          if (Arena()) {
            WriteLineIndent(*field->name + ".get(&fbe_value." + *field->name +
                            ", resource);");
          } else {
            WriteLineIndent(*field->name + ".get(&fbe_value." + *field->name +
                            ", nullptr);");
          }
          Indent(-1);
          WriteLineIndent("}");
        }
        Indent(-1);
        WriteLineIndent("else");
        Indent(1);
        if (field->array) {
          // Do nothing here...
        } else if (field->vector || field->list || field->set || field->map ||
                   field->hash ||
                   ((*field->type == "bytes") && !field->optional))
          WriteLineIndent("fbe_value." + *field->name + ".clear();");
        else
          WriteLineIndent("fbe_value." + *field->name + " = " +
                          ConvertDefault(*p->name, *field) + ";");
        Indent(-1);
        WriteLineIndent("fbe_current_size += " + *field->name + ".fbe_size();");
      }
    }
  }
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model set_begin() method
  WriteLineIndent("size_t " + class_name + "::set_begin()");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= "
                  "_buffer.size()) && \"Model is broken!\");");
  WriteLineIndent(
      "if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("uint32_t fbe_struct_size = (uint32_t)fbe_body();");
  WriteLineIndent(
      "uint32_t fbe_struct_offset = "
      "(uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());");
  WriteLineIndent("assert(((fbe_struct_offset > 0) && ((_buffer.offset() + "
                  "fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "
                  "\"Model is broken!\");");
  WriteLineIndent("if ((fbe_struct_offset == 0) || ((_buffer.offset() + "
                  "fbe_struct_offset + fbe_struct_size) > _buffer.size()))");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() "
                  "+ fbe_offset(), fbe_struct_offset);");
  WriteLineIndent("unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() "
                  "+ fbe_struct_offset, fbe_struct_size);");
  WriteLineIndent("unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() "
                  "+ fbe_struct_offset + 4, fbe_type());");
  WriteLine();
  WriteLineIndent("_buffer.shift(fbe_struct_offset);");
  WriteLineIndent("return fbe_struct_offset;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model set_end() method
  WriteLineIndent("void " + class_name + "::set_end(size_t fbe_begin)");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("_buffer.unshift(fbe_begin);");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model set() method
  WriteLineIndent("void " + class_name +
                  "::set(const ::FBE::Base& fbe_value, "
                  "std::pmr::memory_resource* resource) noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("size_t fbe_begin = set_begin();");
  WriteLineIndent("if (fbe_begin == 0)");
  Indent(1);
  WriteLineIndent("return;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("set_fields(fbe_value, resource);");
  WriteLineIndent("set_end(fbe_begin);");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model set_fields() method
  WriteLineIndent(
      "void " + class_name +
      "::set_fields([[maybe_unused]] const ::FBE::Base& base_fbe_value, "
      "std::pmr::memory_resource* resource) noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("[[maybe_unused]] const " + struct_name +
                  "& fbe_value = static_cast<const " + struct_name +
                  "&>(base_fbe_value);");
  if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty())) {
    if (s->base && !s->base->empty())
      WriteLineIndent("parent.set_fields(fbe_value, resource);");
    if (s->body)
      for (const auto &field : s->body->fields) {
        if (IsStructType(p, *field->type) && !field->ptr &&
            !IsContainerType(*field) && !field->optional)
          WriteLineIndent(*field->name + ".set(static_cast<const ::" +
                          ConvertNamespace(*p->name) + "::" + *field->type +
                          "&>(" + "fbe_value." + *field->name +
                          "), resource);");
        else
          WriteLineIndent(*field->name + ".set(fbe_value." + *field->name +
                          ", resource);");
      }
  }
  Indent(-1);
  WriteLineIndent("}");
}

void GeneratorCpp::GenerateStructFieldPtrModel_Source(
    const std::shared_ptr<Package> &p, const std::shared_ptr<StructType> &s) {
  std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
  std::string class_name = std::string("FieldModel") + (Arena() ? "PMR" : "") +
                           "Ptr_" + *p->name + "_" + *s->name;

  // Generate struct field model constructor
  WriteLine();
  WriteLineIndent(class_name + "::" + class_name +
                  "(FBEBuffer& buffer, size_t offset) noexcept : "
                  "_buffer(buffer), _offset(offset)");
  WriteLineIndent("{}");
  WriteLine();

  WriteLineIndent(class_name + "::~" + class_name + "()");
  WriteLineIndent("{");
  if (not Arena()) {
    Indent(1);
    WriteLineIndent("if (ptr) delete ptr;");
    Indent(-1);
  }
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field ptr model FBE methods
  WriteLineIndent("size_t " + class_name + "::fbe_extra() const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("if (!ptr) return 0;");
  WriteLine();
  WriteLineIndent(
      "if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + "
      "_buffer.offset() + fbe_offset() + 1);");
  WriteLineIndent("if ((fbe_ptr_offset == 0) || ((_buffer.offset() + "
                  "fbe_ptr_offset + 4) > _buffer.size()))");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("_buffer.shift(fbe_ptr_offset);");
  WriteLineIndent("size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();");
  WriteLineIndent("_buffer.unshift(fbe_ptr_offset);");
  WriteLine();
  WriteLineIndent("return fbe_result;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model verify() method
  WriteLineIndent("bool " + class_name + "::verify() const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("if (!ptr) return true;");
  WriteLine();
  WriteLineIndent(
      "if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
  Indent(1);
  WriteLineIndent("return true;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() "
                  "+ _buffer.offset() + fbe_offset()));");
  WriteLineIndent("if (fbe_has_value == 0)");
  Indent(1);
  WriteLineIndent("return true;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() "
      "+ _buffer.offset() + fbe_offset() + 1);");

  WriteLineIndent("if (fbe_optional_offset == 0)");
  Indent(1);
  WriteLineIndent("return false;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("_buffer.shift(fbe_optional_offset);");
  WriteLineIndent("bool fbe_result = ptr->verify();");
  WriteLineIndent("_buffer.unshift(fbe_optional_offset);");
  WriteLineIndent("return fbe_result;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model has_value() method
  WriteLineIndent("bool " + class_name + "::has_value() const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent(
      "if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
  Indent(1);
  WriteLineIndent("return false;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() "
                  "+ _buffer.offset() + fbe_offset()));");
  WriteLineIndent("return (fbe_has_value != 0);");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model get_begin() method
  WriteLineIndent("size_t " + class_name + "::get_begin() const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("if (!has_value())");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + "
      "_buffer.offset() + fbe_offset() + 1);");
  WriteLineIndent("assert((fbe_ptr_offset > 0) && \"Model is broken!\");");
  WriteLineIndent("if (fbe_ptr_offset == 0)");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("_buffer.shift(fbe_ptr_offset);");
  WriteLineIndent("return fbe_ptr_offset;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model get_end() method
  WriteLineIndent("void " + class_name +
                  "::get_end(size_t fbe_begin) const noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("_buffer.unshift(fbe_begin);");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model get() method
  WriteLineIndent(
      "void " + class_name + "::get(" + struct_name +
      "** fbe_value, std::pmr::memory_resource* resource) noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("size_t fbe_begin = get_begin();");
  WriteLineIndent("if (fbe_begin == 0)");
  Indent(1);
  WriteLineIndent("return;");
  Indent(-1);
  WriteLine();
  if (not Arena()) {
    WriteLineIndent("if (ptr) delete ptr;");
    WriteLineIndent(std::string("ptr = new FieldModel") + "_" + *p->name + "_" +
                    *s->name + "(_buffer, 0);");
  } else {
    WriteLineIndent(
        "std::pmr::polymorphic_allocator<char> allocator{resource};");
    WriteLineIndent(
        std::string("auto* buffer = allocator.allocate(sizeof(FieldModelPMR_") +
        *p->name + "_" + *s->name + "));");
    WriteLineIndent("ptr = new (buffer) FieldModelPMR_" + *p->name + "_" +
                    *s->name + "(_buffer, 0);");
    // WriteLineIndent(std::string("ptr = new FieldModel") + (Arena() ? "PMR_" :
    // "_") + *p->name + "_" + *s->name + "(_buffer, 0);");
  }
  WriteLine();
  if (not Arena()) {
    WriteLineIndent(struct_name + " *tempModel = new " + struct_name + "();");
  } else {
    WriteLineIndent(std::string("auto * buffer2 = allocator.allocate(sizeof(") +
                    struct_name + "));");
    WriteLineIndent(struct_name + " *tempModel = new (buffer2) " + struct_name +
                    "(allocator);");
  }
  WriteLineIndent("ptr->get(*tempModel, resource);");
  WriteLineIndent("*fbe_value = tempModel;");
  WriteLine();
  WriteLineIndent("get_end(fbe_begin);");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model set_begin() method
  WriteLineIndent("size_t " + class_name + "::set_begin(bool has_value)");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= "
                  "_buffer.size()) && \"Model is broken!\");");
  WriteLineIndent(
      "if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("uint8_t fbe_has_value = has_value ? 1 : 0;");
  WriteLineIndent("*((uint8_t *)(_buffer.data() + _buffer.offset() + "
                  "fbe_offset())) = fbe_has_value;");
  WriteLineIndent("if (fbe_has_value == 0)");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("uint32_t fbe_ptr_size = 4;");
  WriteLineIndent(
      "uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - "
      "_buffer.offset());");
  WriteLineIndent(
      "assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + "
      "fbe_ptr_size) <= _buffer.size())) && \"Model is broken!\");");
  WriteLineIndent("if ((fbe_ptr_offset == 0) || ((_buffer.offset() + "
                  "fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() "
                  "+ fbe_offset() + 1, fbe_ptr_offset);");

  WriteLine();
  WriteLineIndent("_buffer.shift(fbe_ptr_offset);");
  WriteLineIndent("return fbe_ptr_offset;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model set_end() method
  WriteLineIndent("void " + class_name + "::set_end(size_t fbe_begin)");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("_buffer.unshift(fbe_begin);");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct field model set() method
  WriteLineIndent("void " + class_name + "::set(const " + struct_name +
                  "* fbe_value, std::pmr::memory_resource* resource) noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("size_t fbe_begin = set_begin(fbe_value != nullptr);");
  WriteLineIndent("if (fbe_begin == 0)");
  Indent(1);
  WriteLineIndent("return;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("if (fbe_value != nullptr) {");
  Indent(1);
  if (not Arena()) {
    WriteLineIndent(std::string("BaseFieldModel* temp = new FieldModel") +
                    (Arena() ? "PMR_" : "_") + *p->name + "_" + *s->name +
                    "(_buffer, 0);");
    WriteLineIndent("if (ptr) delete ptr;");
    WriteLineIndent("ptr = temp;");
  } else {
    WriteLineIndent(std::string(
        "std::pmr::polymorphic_allocator<char> allocator{resource};"));
    WriteLineIndent(
        std::string("auto* buffer = allocator.allocate(sizeof(FieldModelPMR_") +
        *p->name + "_" + *s->name + "));");
    WriteLineIndent("ptr = new (buffer) FieldModelPMR_" + *p->name + "_" +
                    *s->name + "(_buffer, 0);");
  }
  WriteLineIndent("variant_set_value(ptr, *fbe_value, resource);");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();
  WriteLineIndent("set_end(fbe_begin);");
  Indent(-1);
  WriteLineIndent("}");
}

void GeneratorCpp::GeneratePtrStructModel_Header(
    const std::shared_ptr<Package> &p, const std::shared_ptr<StructType> &s) {
  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

  std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
  std::string class_name = std::string("FieldModel") +
                           (Arena() ? "PMR_" : "_") + *p->name + "_" + *s->name;

  // Generate struct model begin
  WriteLine();
  WriteLineIndent("// Fast Binary Encoding " + *s->name + " model");
  WriteLineIndent("class " + *s->name + "Model : public FBE::Model");
  WriteLineIndent("{");
  WriteLineIndent("public:");
  Indent(1);

  // Generate struct model constructor
  WriteLineIndent(*s->name + "Model() : model(this->buffer(), 4) {}");
  WriteLineIndent(*s->name +
                  "Model(const std::shared_ptr<FBEBuffer>& buffer) : "
                  "FBE::Model(buffer), model(this->buffer(), 4) {}");

  // Generate struct model FBE methods
  WriteLine();
  WriteLineIndent("// Get the model size");
  WriteLineIndent("size_t fbe_size() const noexcept { return model.fbe_size() "
                  "+ model.fbe_extra(); }");
  WriteLineIndent("// Get the model type");
  WriteLineIndent("static constexpr size_t fbe_type() noexcept { return " +
                  class_name + "::fbe_type(); }");

  // Generate struct model verify() method
  WriteLine();
  WriteLineIndent("// Check if the struct value is valid");
  WriteLineIndent("bool verify();");

  // Generate struct model create_begin(), create_end() methods
  WriteLine();
  WriteLineIndent("// Create a new model (begin phase)");
  WriteLineIndent("size_t create_begin();");
  WriteLineIndent("// Create a new model (end phase)");
  WriteLineIndent("size_t create_end(size_t fbe_begin);");

  // Generate struct model serialize(), deserialize() methods
  WriteLine();
  WriteLineIndent("// Serialize the struct value");
  WriteLineIndent("size_t serialize(const " + struct_name +
                  "& value, std::pmr::memory_resource* resource);");
  WriteLineIndent("// Deserialize the struct value");
  WriteLineIndent("size_t deserialize(" + struct_name +
                  "& value, std::pmr::memory_resource* resource) noexcept;");

  // Generate struct model next() method
  WriteLine();
  WriteLineIndent("// Move to the next struct value");
  WriteLineIndent("void next(size_t prev) noexcept { model.fbe_shift(prev); }");

  // Generate struct model accessor
  Indent(-1);
  WriteLine();
  WriteLineIndent("public:");
  Indent(1);
  WriteLineIndent(class_name + " model;");

  // Generate struct model end
  Indent(-1);
  WriteLineIndent("};");

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));

  // Generate model_of
  WriteLine();
  WriteLine("template<>");
  WriteLine("struct model_of<" + struct_name + "> {");
  WriteLineIndent("using type = " + ConvertNamespace(*p->name) +
                  "::" + *s->name + "Model;");
  WriteLine("};");
  WriteLine();
}

void GeneratorCpp::GeneratePtrStructModel_Source(
    const std::shared_ptr<Package> &p, const std::shared_ptr<StructType> &s) {
  // Generate namespace begin
  WriteLine();
  WriteLineIndent("namespace " + ConvertNamespace(*p->name) + " {");

  std::string struct_name = "::" + ConvertNamespace(*p->name) + "::" + *s->name;
  std::string model_name = *s->name + "Model";

  // Generate struct model verify() method
  WriteLine();
  WriteLineIndent("bool " + model_name + "::verify()");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("if ((this->buffer().offset() + model.fbe_offset() - 4) > "
                  "this->buffer().size())");
  Indent(1);
  WriteLineIndent("return false;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() "
      "+ this->buffer().offset() + model.fbe_offset() - 4);");
  WriteLineIndent("if (fbe_full_size < model.fbe_size())");
  Indent(1);
  WriteLineIndent("return false;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("return model.verify();");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct model create_begin() method
  WriteLineIndent("size_t " + model_name + "::create_begin()");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent(
      "size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());");
  WriteLineIndent("return fbe_begin;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct model create_end() method
  WriteLineIndent("size_t " + model_name + "::create_end(size_t fbe_begin)");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("size_t fbe_end = this->buffer().size();");
  WriteLineIndent("uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);");
  WriteLineIndent(
      "*((uint32_t*)(this->buffer().data() + this->buffer().offset() + "
      "model.fbe_offset() - 4)) = fbe_full_size;");
  WriteLineIndent("return fbe_full_size;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct model serialize() method
  WriteLineIndent("size_t " + model_name + "::serialize(const " + struct_name +
                  "& value, std::pmr::memory_resource* resource)");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("size_t fbe_begin = create_begin();");
  WriteLineIndent("model.set(value, resource);");
  WriteLineIndent("size_t fbe_full_size = create_end(fbe_begin);");
  WriteLineIndent("return fbe_full_size;");
  Indent(-1);
  WriteLineIndent("}");
  WriteLine();

  // Generate struct model deserialize() method
  WriteLineIndent("size_t " + model_name + "::deserialize(" + struct_name +
                  "& value, std::pmr::memory_resource* resource) noexcept");
  WriteLineIndent("{");
  Indent(1);
  WriteLineIndent("if ((this->buffer().offset() + model.fbe_offset() - 4) > "
                  "this->buffer().size())");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent(
      "uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() "
      "+ this->buffer().offset() + model.fbe_offset() - 4);");
  WriteLineIndent(
      "assert((fbe_full_size >= model.fbe_size()) && \"Model is broken!\");");
  WriteLineIndent("if (fbe_full_size < model.fbe_size())");
  Indent(1);
  WriteLineIndent("return 0;");
  Indent(-1);
  WriteLine();
  WriteLineIndent("model.get(value, resource);");
  WriteLineIndent("return fbe_full_size;");
  Indent(-1);
  WriteLineIndent("}");

  // Generate namespace end
  WriteLine();
  WriteLineIndent("} // namespace " + ConvertNamespace(*p->name));
}

bool GeneratorCpp::IsKnownType(const std::string &type) {
  return ((type == "bool") || (type == "byte") || (type == "bytes") ||
          (type == "char") || (type == "wchar") || (type == "int8") ||
          (type == "uint8") || (type == "int16") || (type == "uint16") ||
          (type == "int32") || (type == "uint32") || (type == "int64") ||
          (type == "uint64") || (type == "int128") || (type == "uint128") ||
          (type == "float") || (type == "double") || (type == "decimal") ||
          (type == "string") || (type == "timestamp") || (type == "uuid"));
}

bool GeneratorCpp::IsPrimitiveType(const std::string &type,
                                   bool optional) const {
  if (optional)
    return false;

  return ((type == "bool") || (type == "byte") || (type == "char") ||
          (type == "wchar") || (type == "int8") || (type == "uint8") ||
          (type == "int16") || (type == "uint16") || (type == "int32") ||
          (type == "uint32") || (type == "int64") || (type == "uint64") ||
          (type == "int128") || (type == "uint128") || (type == "float") ||
          (type == "double") || (type == "timestamp"));
}

size_t GeneratorCpp::GetPrimitiveTypeSize(const std::string &type) const {
  if (type == "bool")
    return 1;
  if (type == "byte")
    return 1;
  if (type == "char")
    return 1;
  if (type == "wchar")
    return 4;
  if (type == "int8")
    return 1;
  if (type == "uint8")
    return 1;
  if (type == "int16")
    return 2;
  if (type == "uint16")
    return 2;
  if (type == "int32")
    return 4;
  if (type == "uint32")
    return 4;
  if (type == "int64")
    return 8;
  if (type == "uint64")
    return 8;
  if (type == "int128")
    return 16;
  if (type == "uint128")
    return 16;
  if (type == "float")
    return 4;
  if (type == "double")
    return 8;
  if (type == "timestamp")
    return 8;
  return 0;
}

std::string
GeneratorCpp::GetPrimitiveTypeCppName(const std::string &type) const {
  if (type == "bool")
    return "uint8_t"; // bool stored as uint8_t in buffer
  if (type == "byte")
    return "uint8_t";
  if (type == "char")
    return "uint8_t";
  if (type == "wchar")
    return "uint32_t";
  if (type == "int8")
    return "int8_t";
  if (type == "uint8")
    return "uint8_t";
  if (type == "int16")
    return "int16_t";
  if (type == "uint16")
    return "uint16_t";
  if (type == "int32")
    return "int32_t";
  if (type == "uint32")
    return "uint32_t";
  if (type == "int64")
    return "int64_t";
  if (type == "uint64")
    return "uint64_t";
  if (type == "int128")
    return "__int128_t";
  if (type == "uint128")
    return "__uint128_t";
  if (type == "float")
    return "float";
  if (type == "double")
    return "double";
  if (type == "timestamp")
    return "uint64_t";
  return "";
}

bool GeneratorCpp::IsFixedSizeType(const std::shared_ptr<Package> &p,
                                   const std::string &type,
                                   bool optional) const {
  if (optional)
    return false;

  // Check if it's a primitive type
  if (IsPrimitiveType(type, false))
    return true;

  // Check if it's uuid (16 bytes fixed)
  if (type == "uuid")
    return true;

  // Check if it's an enum type in this package
  if (p && p->body) {
    for (const auto &e : p->body->enums) {
      if (*e->name == type)
        return true;
    }
    // Check if it's a flags type in this package
    for (const auto &f : p->body->flags) {
      if (*f->name == type)
        return true;
    }
  }

  return false;
}

size_t GeneratorCpp::GetFixedTypeSize(const std::shared_ptr<Package> &p,
                                      const std::string &type) const {
  // Check primitive types first
  size_t primitive_size = GetPrimitiveTypeSize(type);
  if (primitive_size > 0)
    return primitive_size;

  // UUID is 16 bytes
  if (type == "uuid")
    return 16;

  // Check enums
  if (p && p->body) {
    for (const auto &e : p->body->enums) {
      if (*e->name == type) {
        std::string base_type =
            (e->base && !e->base->empty()) ? *e->base : "int32";
        return GetPrimitiveTypeSize(base_type);
      }
    }
    // Check flags
    for (const auto &f : p->body->flags) {
      if (*f->name == type) {
        std::string base_type =
            (f->base && !f->base->empty()) ? *f->base : "int32";
        return GetPrimitiveTypeSize(base_type);
      }
    }
  }

  return 0;
}

std::string GeneratorCpp::GetFixedTypeCppName(const std::shared_ptr<Package> &p,
                                              const std::string &type) const {
  // Check primitive types first
  std::string primitive_cpp = GetPrimitiveTypeCppName(type);
  if (!primitive_cpp.empty())
    return primitive_cpp;

  // UUID uses memcpy, not unaligned_load, so we handle it specially
  if (type == "uuid")
    return "uuid_t";

  // Check enums
  if (p && p->body) {
    for (const auto &e : p->body->enums) {
      if (*e->name == type) {
        std::string base_type =
            (e->base && !e->base->empty()) ? *e->base : "int32";
        return GetPrimitiveTypeCppName(base_type);
      }
    }
    // Check flags
    for (const auto &f : p->body->flags) {
      if (*f->name == type) {
        std::string base_type =
            (f->base && !f->base->empty()) ? *f->base : "int32";
        return GetPrimitiveTypeCppName(base_type);
      }
    }
  }

  return "";
}

std::string GeneratorCpp::ConvertEnumType(const std::string &type) {
  if (type == "byte")
    return "uint8_t";
  else if (type == "char")
    return "uint8_t";
  else if (type == "wchar")
    return "uint32_t";
  else if (type == "int8")
    return "int8_t";
  else if (type == "uint8")
    return "uint8_t";
  else if (type == "int16")
    return "int16_t";
  else if (type == "uint16")
    return "uint16_t";
  else if (type == "int32")
    return "int32_t";
  else if (type == "uint32")
    return "uint32_t";
  else if (type == "int64")
    return "int64_t";
  else if (type == "uint64")
    return "uint64_t";
  else if (type == "int128")
    return "__int128_t";
  else if (type == "uint128")
    return "__uint128_t";

  yyerror("Unsupported enum base type - " + type);
  return "";
}

std::string GeneratorCpp::ConvertTypeName(const std::string &package,
                                          const std::string &type,
                                          bool optional) {
  if (optional)
    return "std::optional<" + ConvertTypeName(package, type, false) + ">";

  if (type == "bool")
    return "bool";
  else if (type == "byte")
    return "uint8_t";
  else if (type == "bytes")
    return Arena() ? "FBE::pmr_buffer_t" : "FBE::buffer_t";
  else if (type == "char")
    return "char";
  else if (type == "wchar")
    return "wchar_t";
  else if (type == "int8")
    return "int8_t";
  else if (type == "uint8")
    return "uint8_t";
  else if (type == "int16")
    return "int16_t";
  else if (type == "uint16")
    return "uint16_t";
  else if (type == "int32")
    return "int32_t";
  else if (type == "uint32")
    return "uint32_t";
  else if (type == "int64")
    return "int64_t";
  else if (type == "uint64")
    return "uint64_t";
  else if (type == "int128")
    return "__int128_t";
  else if (type == "uint128")
    return "__uint128_t";
  else if (type == "float")
    return "float";
  else if (type == "double")
    return "double";
  else if (type == "decimal")
    return "FBE::decimal_t";
  else if (type == "string")
    return Arena() ? "ArenaString" : "FBEString";
  else if (type == "timestamp")
    return "uint64_t";
  else if (type == "uuid")
    return "FBE::uuid_t";

  // split by .
  auto items = split(type, ".", true);
  if (items.size() == 1)
    return "::" + ConvertNamespace(package) + "::" + type;
  std::string result = "::" + ConvertNamespace(items[0]);
  for (size_t i = 1; i < items.size(); ++i) {
    result += "::" + items[i];
  }
  return result;
}

std::string GeneratorCpp::ConvertTypeName(const std::string &package,
                                          const StructField &field) {
  std::string prefix = "std";
  if (Arena()) {
    prefix = "std::pmr";
  }
  if (field.array)
    return "std::array<" +
           ConvertTypeName(package, *field.type, field.optional) + ", " +
           std::to_string(field.N) + ">";
  else if (field.vector)
    return (Arena() ? "std::pmr::vector<" : "FastVec<") +
           ConvertTypeName(package, *field.type, field.optional) + ">";
  else if (field.list)
    return prefix + "::list<" +
           ConvertTypeName(package, *field.type, field.optional) + ">";
  else if (field.set)
    return (Arena() ? "FBE::pmr::set<" : "FBE::set<") +
           ConvertTypeName(package, *field.key, false) + ">";
  else if (field.map)
    return (Arena() ? "FBE::pmr::map<" : "FBE::map<") +
           ConvertTypeName(package, *field.key, false) + ", " +
           ConvertTypeName(package, *field.type, field.optional) + ">";
  else if (field.hash)
    return prefix + "::unordered_map<" +
           ConvertTypeName(package, *field.key, false) + ", " +
           ConvertTypeName(package, *field.type, field.optional) + ">";

  return ConvertTypeName(package, *field.type, field.optional);
}

std::string GeneratorCpp::ConvertTypeNameAsArgument(const std::string &package,
                                                    const StructField &field) {
  if (field.optional || field.array || field.vector || field.list ||
      field.set || field.map || field.hash)
    return "const " + ConvertTypeName(package, field) + "&";

  if (IsPrimitiveType(*field.type, false))
    return ConvertTypeName(package, field);

  return "const " + ConvertTypeName(package, field) + "&";
}

std::string GeneratorCpp::ConvertConstant(const std::string &type,
                                          const std::string &value,
                                          bool optional) {
  if (value == "true")
    return "true";
  else if (value == "false")
    return "false";
  else if (value == "null")
    return optional ? "std::nullopt" : "std::nullptr";
  else if (value == "min") {
    if ((type == "byte") || (type == "uint8") || (type == "uint16") ||
        (type == "uint32") || (type == "uint64"))
      return ConvertConstantPrefix(type) + "0" + ConvertConstantSuffix(type);
    else if (type == "int8")
      return ConvertConstantPrefix(type) + "-128" + ConvertConstantSuffix(type);
    else if (type == "int16")
      return ConvertConstantPrefix(type) + "-32768" +
             ConvertConstantSuffix(type);
    else if (type == "int32")
      return ConvertConstantPrefix(type) + "-2147483648ll" +
             ConvertConstantSuffix(type);
    else if (type == "int64")
      return ConvertConstantPrefix(type) + "-9223372036854775808ll" +
             ConvertConstantSuffix(type);

    yyerror("Unsupported type " + type + " for 'min' constant");
    return "";
  } else if (value == "max") {
    if (type == "byte")
      return ConvertConstantPrefix(type) + "255" + ConvertConstantSuffix(type);
    else if (type == "int8")
      return ConvertConstantPrefix(type) + "127" + ConvertConstantSuffix(type);
    else if (type == "uint8")
      return ConvertConstantPrefix(type) + "255" + ConvertConstantSuffix(type);
    else if (type == "int16")
      return ConvertConstantPrefix(type) + "32767" +
             ConvertConstantSuffix(type);
    else if (type == "uint16")
      return ConvertConstantPrefix(type) + "65535" +
             ConvertConstantSuffix(type);
    else if (type == "int32")
      return ConvertConstantPrefix(type) + "2147483647" +
             ConvertConstantSuffix(type);
    else if (type == "uint32")
      return ConvertConstantPrefix(type) + "4294967295" +
             ConvertConstantSuffix(type);
    else if (type == "int64")
      return ConvertConstantPrefix(type) + "9223372036854775807" +
             ConvertConstantSuffix(type);
    else if (type == "uint64")
      return ConvertConstantPrefix(type) + "18446744073709551615" +
             ConvertConstantSuffix(type);

    yyerror("Unsupported type " + type + " for 'max' constant");
    return "";
  } else if (value == "epoch")
    return "FBE::epoch()";
  else if (value == "utc")
    return "FBE::utc()";
  else if (value == "uuid0")
    return "FBE::uuid_t::nil()";
  else if (value == "uuid1")
    return "FBE::uuid_t::sequential()";
  else if (value == "uuid4")
    return "FBE::uuid_t::random()";

  if (IsKnownType(type))
    return ConvertConstantPrefix(type) + value + ConvertConstantSuffix(type);

  // TODO(liuqi): check using ConvertNamespace
  bool first = true;
  std::string result;
  auto items = split(value, '|', true);
  for (auto &item : items) {
    bool pkg = (count_char(item, '.') > 1);
    replace_all(item, ".", "::");
    result += (!first ? " | " : "");
    result += (pkg ? "::" : "") + item;
    first = false;
  }

  return result;
}

std::string GeneratorCpp::ConvertConstantPrefix(const std::string &type) {
  if (type == "bool")
    return "(bool)";
  else if (type == "byte")
    return "(uint8_t)";
  else if (type == "char")
    return "(char)";
  else if (type == "wchar")
    return "(wchar_t)";
  else if (type == "int8")
    return "(int8_t)";
  else if (type == "uint8")
    return "(uint8_t)";
  else if (type == "int16")
    return "(int16_t)";
  else if (type == "uint16")
    return "(uint16_t)";
  else if (type == "int32")
    return "(int32_t)";
  else if (type == "uint32")
    return "(uint32_t)";
  else if (type == "int64")
    return "(int64_t)";
  else if (type == "uint64")
    return "(uint64_t)";
  else if (type == "int128")
    return "(__int128_t)";
  else if (type == "uint128")
    return "(__uint128_t)";
  else if (type == "float")
    return "(float)";
  else if (type == "double")
    return "(double)";
  else if (type == "decimal")
    return "FBE::decimal_t(";
  else if (type == "timestamp")
    return "(uint64_t)";
  else if (type == "uuid")
    return "FBE::uuid_t(";

  return "";
}

std::string GeneratorCpp::ConvertConstantSuffix(const std::string &type) {
  if ((type == "byte") || (type == "uint8") || (type == "uint16"))
    return "u";
  else if ((type == "int32") || (type == "int64"))
    return "ll";
  else if ((type == "uint32") || (type == "uint64") || (type == "timestamp"))
    return "ull";
  else if (type == "float")
    return "f";
  else if ((type == "decimal") || (type == "uuid"))
    return ")";

  return "";
}

std::string GeneratorCpp::ConvertDefault(const std::string &package,
                                         const std::string &type) {
  if (type == "bool")
    return "false";
  else if (type == "bytes")
    return "";
  else if (type == "char")
    return "'\\0'";
  else if (type == "wchar")
    return "L'\\0'";
  else if ((type == "byte") || (type == "int8") || (type == "uint8") ||
           (type == "int16") || (type == "uint16") || (type == "int32") ||
           (type == "uint32") || (type == "int64") || (type == "uint64") ||
           (type == "int128") || (type == "uint128") || (type == "timestamp"))
    return ConvertConstantPrefix(type) + "0" + ConvertConstantSuffix(type);
  else if (type == "float")
    return "0.0f";
  else if (type == "double")
    return "0.0";
  else if (type == "decimal")
    return "FBE::decimal_t()";
  else if (type == "string")
    return "\"\"";
  else if (type == "uuid")
    return "FBE::uuid_t::nil()";

  auto items = split(type, ".", true);
  if (items.size() == 1)
    return "::" + ConvertNamespace(package) + "::" + type + "()";
  std::string result = "::" + ConvertNamespace(items[0]);
  for (size_t i = 1; i < items.size(); ++i) {
    result += "::" + items[i];
  }
  return result + "()";
}

std::string GeneratorCpp::ConvertDefault(const std::string &package,
                                         const StructField &field) {
  if (field.ptr)
    return "nullptr";
  if (field.value)
    return ConvertConstant(*field.type, *field.value, field.optional);

  if (field.array || field.vector || field.list || field.set || field.map ||
      field.hash || field.ptr)
    return "";
  else if (field.optional)
    return "std::nullopt";

  return ConvertDefault(package, *field.type);
}

std::string GeneratorCpp::ConvertOutputStreamType(const std::string &type,
                                                  const std::string &name,
                                                  bool ptr, bool optional) {
  std::string wrapped_name = name;
  if (ptr) {
    return "\"ptr of other struct: \" << (" + name +
           " == nullptr ? \"nullptr\" : \"true\"" + ")";
  }
  if (type == "bool")
    return "(" + std::string(optional ? "*" : "") + wrapped_name +
           " ? \"true\" : \"false\"" + ")";
  else if ((type == "byte") || (type == "int8") || (type == "uint8"))
    return "(int)" + std::string(optional ? "*" : "") + wrapped_name;
  else if (type == "bytes")
    return "\"bytes[\" << " + name + std::string(optional ? "->" : ".") +
           "size() << \"]\"";
  else if (type == "char")
    return "\"'\" << " + std::string(optional ? "*" : "") + name + " << \"'\"";
  else if (type == "wchar")
    return "\"'\" << (char)" + std::string(optional ? "*" : "") + name +
           " << \"'\"";
  else if ((type == "string") || (type == "uuid"))
    return "\"\\\"\" << " + std::string(optional ? "*" : "") + wrapped_name +
           " << \"\\\"\"";
  else if ((type == "int128") || (type == "uint128"))
    return "\"(" + std::string(optional ? "optional " : "") +
           std::string(type) + ") operator<< unimplemented\"";
  return std::string(optional ? "*" : "") + wrapped_name;
}

std::string GeneratorCpp::ConvertOutputStreamValue(const std::string &type,
                                                   const std::string &name,
                                                   bool ptr, bool optional,
                                                   bool separate) {
  std::string comma = separate ? "<< std::string(first ? \"\" : \",\") " : "";

  if (optional)
    return "if (" + name + ") stream " + comma + "<< " +
           ConvertOutputStreamType(type, name, ptr, true) + "; else stream " +
           comma + "<< \"null\";";
  else
    return "stream " + comma + "<< " +
           ConvertOutputStreamType(type, name, ptr, false) + ";";
}

std::string GeneratorCpp::ConvertLoggingStreamType(const std::string &type,
                                                   const std::string &name,
                                                   bool optional) {
  if (type == "bool")
    return "StoreList(" + std::string(optional ? "*" : "") + name +
           " ? \"true\" : \"false\"" + ")";
  else if ((type == "byte") || (type == "int8") || (type == "uint8"))
    return "StoreList((int)" + std::string(optional ? "*" : "") + name + ")";
  else if (type == "bytes")
    return "StoreList(\"bytes[\").StoreList(" + name +
           std::string(optional ? "->" : ".") + "size()).StoreList(\"]\")";
  else if ((type == "char") || (type == "wchar"))
    return "StoreList(\"'\").StoreList(" + std::string(optional ? "*" : "") +
           name + ").StoreList(\"'\")";
  else if ((type == "string") || (type == "uuid"))
    return "StoreList(\"\\\"\").StoreList(" + std::string(optional ? "*" : "") +
           name + ").StoreList(\"\\\"\")";
  else
    return "StoreList(" + std::string(optional ? "*" : "") + name + ")";
}

std::string GeneratorCpp::ConvertLoggingStreamValue(const std::string &type,
                                                    const std::string &name,
                                                    bool optional,
                                                    bool separate) {
  std::string comma = separate ? "StoreList(first ? \"\" : \",\")." : "";

  if (optional)
    return "if (" + name + ") record." + comma +
           ConvertLoggingStreamType(type, name, true) + "; else record." +
           comma + "StoreList(\"null\");";
  else
    return "record." + comma + ConvertLoggingStreamType(type, name, false) +
           ";";
}

bool GeneratorCpp::IsContainerType(const StructField &field) {
  return (field.array || field.vector || field.list || field.set || field.map ||
          field.hash);
}

bool GeneratorCpp::IsContainerType(const VariantValue &variant) {
  return (variant.vector || variant.list || variant.map || variant.hash);
}

bool GeneratorCpp::IsStructType(const std::shared_ptr<Package> &p,
                                const std::string &field_type) {
  std::string field_type_without_namespace = field_type;
  // extract the last token after ::
  auto pos = field_type_without_namespace.rfind("::");
  if (pos != std::string::npos) {
    field_type_without_namespace = field_type_without_namespace.substr(pos + 2);
  }

  for (const auto &s : p->body->structs) {
    if (*s->name == field_type_without_namespace) {
      return true;
    }
  }
  return false;
}

bool GeneratorCpp::IsPMRType(const std::shared_ptr<Package> &p,
                             const std::string &field_type) {
  return IsStructType(p, field_type) || field_type.starts_with("FBE::pmr") ||
         field_type.starts_with("pmr") || field_type.starts_with("Arena");
}

std::string GeneratorCpp::ConvertPtrTypeName(const std::string &package,
                                             const std::string &type) {
  return ConvertTypeName(package, type, false);
}

// because of the y file. optional and typeptr will not be true in the same, and
// the ptr will never pointer to primitive type.
std::string GeneratorCpp::ConvertPtrTypeName(const std::string &package,
                                             const std::string &type,
                                             bool optional, bool typeptr,
                                             bool as_argument) {
  // TODO: conflict with pointer, we need to check. Or omit?
  if (optional)
    return "std::optional<" + ConvertPtrTypeName(package, type) + ">";

  auto ret = ConvertPtrTypeName(package, type);
  if (typeptr) {
    if (as_argument)
      return "std::unique_ptr<" + ret + ">";
    else
      return ret + "*";
  }
  return ret;
}

std::string GeneratorCpp::ConvertPtrTypeName(const std::string &package,
                                             const StructField &field,
                                             bool as_argument) {
  std::string prefix = "std";
  if (Arena()) {
    prefix = "std::pmr";
  }
  bool typeptr = field.ptr;
  if (field.array)
    return "std::array<" +
           ConvertPtrTypeName(package, *field.type, field.optional, typeptr,
                              as_argument) +
           ", " + std::to_string(field.N) + ">";
  else if (field.optional)
    return "std::optional<" + ConvertPtrTypeName(package, *field.type) + ">";
  else if (field.vector)
    return (Arena() ? "std::pmr::vector<" : "FastVec<") +
           ConvertPtrTypeName(package, *field.type, field.optional, typeptr,
                              as_argument) +
           ">";
  else if (field.list)
    return prefix + "::list<" +
           ConvertPtrTypeName(package, *field.type, field.optional, typeptr,
                              as_argument) +
           ">";
  else if (field.set)
    return (Arena() ? "FBE::pmr::set<" : "FBE::set<") +
           ConvertPtrTypeName(package, *field.key, false, typeptr,
                              as_argument) +
           ">";
  else if (field.map)
    return (Arena() ? "FBE::pmr::map<" : "FBE::map<") +
           ConvertPtrTypeName(package, *field.key, false, false, as_argument) +
           ", " +
           ConvertPtrTypeName(package, *field.type, field.optional, typeptr,
                              as_argument) +
           ">";
  else if (field.hash)
    return prefix + "::unordered_map<" +
           ConvertPtrTypeName(package, *field.key, false, false, as_argument) +
           ", " +
           ConvertPtrTypeName(package, *field.type, field.optional, typeptr,
                              as_argument) +
           ">";
  auto s = ConvertPtrTypeName(package, *field.type, field.optional, typeptr,
                              as_argument);
  return s;
}

std::string GeneratorCpp::ConvertVariantTypeName(const std::string &package,
                                                 const VariantValue &variant) {
  std::string prefix = "std";
  if (Arena()) {
    prefix = "std::pmr";
  }
  if (variant.vector)
    return (Arena() ? "std::pmr::vector<" : "FastVec<") +
           ConvertPtrTypeName(package, *variant.type, false, variant.ptr,
                              false) +
           ">";
  else if (variant.list)
    return prefix + "::list<" +
           ConvertPtrTypeName(package, *variant.type, false, variant.ptr,
                              false) +
           ">";
  else if (variant.map)
    return (Arena() ? "FBE::pmr::map<" : "FBE::map<") +
           ConvertPtrTypeName(package, *variant.key, false, false, false) +
           ", " +
           ConvertPtrTypeName(package, *variant.type, false, variant.ptr,
                              false) +
           ">";
  else if (variant.hash)
    return prefix + "::unordered_map<" +
           ConvertPtrTypeName(package, *variant.key, false, false, false) +
           ", " +
           ConvertPtrTypeName(package, *variant.type, false, variant.ptr,
                              false) +
           ">";
  return ConvertPtrTypeName(package, *variant.type, false, variant.ptr, false);
}

std::string
GeneratorCpp::ConvertVariantTypeNameAsArgument(const std::string &package,
                                               const VariantValue &variant) {
  if (variant.ptr) {
    return "const " + ConvertVariantTypeName(package, variant);
  }
  if (IsContainerType(variant))
    return "const " + ConvertVariantTypeName(package, variant) + "&";
  if (IsPrimitiveType(*variant.type, false)) {
    return ConvertVariantTypeName(package, variant);
  }
  return "const " + ConvertVariantTypeName(package, variant) + "&";
}

std::string
GeneratorCpp::ConvertVariantFinalModelType(const std::string &package,
                                           const VariantValue &variant) {
  std::string element_type =
      ConvertPtrTypeName(package, *variant.type, false, variant.ptr, false);

  if (variant.vector || variant.list)
    return "FinalModelVector<" + element_type + ">";
  else if (variant.map || variant.hash) {
    std::string key_type =
        ConvertPtrTypeName(package, *variant.key, false, false, false);
    return "FinalModelMap<" + key_type + ", " + element_type + ">";
  }
  return "FinalModel<" + ConvertVariantTypeName(package, variant) + ">";
}

// two cases:
// 1. struct should be rvalue references, because we disable copy cstr
// 2. for container of ptrs, use unique_ptr instead.
std::string
GeneratorCpp::ConvertPtrTypeNameAsArgument(const std::string &package,
                                           const StructField &field) {
  if (field.ptr || IsPrimitiveType(*field.type, false))
    return ConvertPtrTypeName(package, field, true);
  if (IsKnownType(*field.type))
    return "const " + ConvertPtrTypeName(package, field, true) + "&";

  return ConvertPtrTypeName(package, field, true);
}

// Generates fieldmodel for data members in a struct field.
// only used for ptr-based FBE
std::string GeneratorCpp::ConvertPtrFieldModelType(
    const std::shared_ptr<Package> &p,
    const std::shared_ptr<StructField> &field) {
  std::string field_model_type;
  if (IsStructType(p, *field->type) ||
      (ImportPtr() && !IsCurrentPackageType(*field->type))) {
    std::string model_name =
        std::string("FieldModel") + (Arena() ? "PMR" : "") +
        (field->ptr ? "Ptr" : "") + "_" +
        (IsCurrentPackageType(*field->type) ? (*p->name + "_") : "") +
        *field->type;
    replace_all(model_name, ".", "_");
    if (IsContainerType(*field)) {
      field_model_type = "FieldModel";
      if (field->array) {
        field_model_type += "CustomArray<" + model_name + ", " +
                            ConvertPtrTypeName(*p->name, *field->type) + ", " +
                            std::to_string(field->N) + ">";
      } else if (field->vector || field->list || field->set) {
        field_model_type += "CustomVector<" + model_name + ", " +
                            ConvertPtrTypeName(*p->name, *field->type) + ">";
      } else if (field->map || field->hash) {
        // TODO:
        // specificationkeyStructFieldptrvaluekeypointer
        std::string kType;
        // 1. struct type
        // 2. import-ptr struct type
        if (IsStructType(p, *field->key) ||
            (!IsCurrentPackageType(*field->key) && ImportPtr())) {
          kType = std::string("FieldModel") + "_" +
                  (IsCurrentPackageType(*field->type) ? (*p->name + "_") : "") +
                  *field->type;
          replace_all(kType, ".", "_");

        } else {
          kType = std::string("FieldModel<") +
                  ConvertPtrTypeName(*p->name, *field->key) + ">";
        }
        auto kStruct = ConvertPtrTypeName(*p->name, *field->key);
        auto vStruct = ConvertPtrTypeName(*p->name, *field->type);
        field_model_type += "CustomMap<" + kType + ", " + model_name + ", " +
                            kStruct + ", " + vStruct + ">";
      }
    } else if (field->optional) {
      field_model_type = "FieldModelStructOptional<" + model_name + ", " +
                         ConvertPtrTypeName(*p->name, *field->type) + ">";
    } else
      field_model_type = model_name;
  } else if (field->array)
    field_model_type = "FieldModelArray<" +
                       ConvertPtrTypeName(*p->name, *field->type,
                                          field->optional, field->ptr, false) +
                       ", " + std::to_string(field->N) + ">";
  else if (field->vector || field->list || field->set)
    field_model_type = "FieldModelVector<" +
                       ConvertPtrTypeName(*p->name, *field->type,
                                          field->optional, field->ptr, false) +
                       ">";
  else if (field->map || field->hash)
    field_model_type = "FieldModelMap<" +
                       ConvertPtrTypeName(*p->name, *field->key) + ", " +
                       ConvertPtrTypeName(*p->name, *field->type,
                                          field->optional, field->ptr, false) +
                       ">";
  else
    field_model_type = "FieldModel<" +
                       ConvertPtrTypeName(*p->name, *field->type,
                                          field->optional, field->ptr, false) +
                       ">";
  return field_model_type;
}

std::string GeneratorCpp::ConvertPtrVariantFieldModelType(
    const std::shared_ptr<Package> &p,
    const std::shared_ptr<VariantValue> &variant) {
  std::string variant_field_model_type;
  if (Ptr()) {
    if (IsStructType(p, *variant->type) && !IsKnownType(*variant->type)) {
      std::string model_name =
          std::string("FieldModel") + (Arena() ? "PMR" : "") +
          (variant->ptr ? "Ptr" : "") + "_" + *p->name + "_" + *variant->type;
      if (IsContainerType(*variant)) {
        variant_field_model_type = "FieldModel";
        if (variant->vector || variant->list)
          variant_field_model_type +=
              "CustomVector<" + model_name + ", " +
              ConvertPtrTypeName(*p->name, *variant->type) + ">";
        else if (variant->map || variant->hash) {
          std::string kType = "FieldModel";
          if (IsKnownType(*variant->key)) {
            kType += "<" + ConvertPtrTypeName(*p->name, *variant->key) + ">";
          } else {
            kType += "_" + *p->name + "_" + *variant->type;
          }
          auto kStruct = ConvertPtrTypeName(*p->name, *variant->key);
          auto vStruct = ConvertPtrTypeName(*p->name, *variant->type);
          variant_field_model_type += "CustomMap<" + kType + ", " + model_name +
                                      ", " + kStruct + ", " + vStruct + ">";
        }
      } else {
        variant_field_model_type += model_name;
      }
    } else if (variant->vector || variant->list)
      variant_field_model_type =
          "FieldModelVector<" +
          ConvertPtrTypeName(*p->name, *variant->type, false, variant->ptr,
                             false) +
          ">";
    else if (variant->map || variant->hash)
      variant_field_model_type =
          "FieldModelMap<" + ConvertPtrTypeName(*p->name, *variant->key) +
          ", " +
          ConvertPtrTypeName(*p->name, *variant->type, false, variant->ptr,
                             false) +
          ">";
    else
      variant_field_model_type =
          "FieldModel<" +
          ConvertPtrTypeName(*p->name, *variant->type, false, variant->ptr,
                             false) +
          ">";
  } else if (variant->vector || variant->list) // template based
    variant_field_model_type =
        "FieldModelVector<" + ConvertTypeName(*p->name, *variant->type, false) +
        ">";
  else if (variant->map || variant->hash)
    variant_field_model_type =
        "FieldModelMap<" + ConvertTypeName(*p->name, *variant->key, false) +
        ", " + ConvertTypeName(*p->name, *variant->type, false) + ">";
  else
    variant_field_model_type =
        "FieldModel<" + ConvertTypeName(*p->name, *variant->type, false) + ">";
  return variant_field_model_type;
}

bool GeneratorCpp::IsCurrentPackageType(const std::string &field_type,
                                        const std::string &delimiter) {
  auto found_delimiter = field_type.find(delimiter);
  return found_delimiter == std::string::npos;
}

std::string GeneratorCpp::ConvertNamespace(const std::string &package) {
  return package + (Arena() ? "_pmr" : ""); // we prefer _pmr over ::pmr to
                                            // avoid conflicting with STL pmr
}

std::string GeneratorCpp::ConvertFileName(const std::string &package,
                                          FileType file_type, bool is_header,
                                          bool is_ptr, bool is_final) {
  std::string filename =
      package + (is_ptr ? "_ptr" : "") + (is_final ? "_final" : "");
  // Arena support for both regular and final modes
  if (Arena()) {
    filename += "_pmr";
  }
  switch (file_type) {
  case FileType::Struct:
    break;
  case FileType::Model:
    filename += "_models";
    break;
  // case FileType::JSON:
  //     filename += "_json";
  //     break;
  // case FileType::PROTOCOL:
  //     filename += "_protocol";
  //     break;
  default:
    break;
  }
  return filename + (is_header ? ".h" : ".cpp");
}

} // namespace FBE
