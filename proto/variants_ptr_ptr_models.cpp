//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: variants_ptr.fbe
// FBE version: 1.11.0.0
//------------------------------------------------------------------------------

#include "variants_ptr_ptr_models.h"

namespace FBE {

FieldModel<::variants_ptr::Expr>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

size_t FieldModel<::variants_ptr::Expr>::fbe_body() const noexcept
{
    // variant type's fbe_size not included
    size_t fbe_result = 4;
    return fbe_result;
}

size_t FieldModel<::variants_ptr::Expr>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body();

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::variants_ptr::Expr>::verify() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_variant_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_variant_offset == 0) || ((_buffer.offset() + fbe_variant_offset + 4) > _buffer.size()))
        return false;

    uint32_t fbe_variant_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_variant_offset);
    if (fbe_variant_type > 4)
        return false;

    _buffer.shift(fbe_variant_offset);
    switch(fbe_variant_type) {
        case 0: {
            FieldModel<std::monostate> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 1: {
            FieldModel<bool> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 2: {
            FieldModel<FBEString> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 3: {
            FieldModel<int32_t> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 4: {
            FieldModelVector<uint8_t> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        default:
            return false;
    }

    _buffer.unshift(fbe_variant_offset);
    return true;
}

void FieldModel<::variants_ptr::Expr>::get(::variants_ptr::Expr& fbe_value, pmr::memory_resource* resource) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    uint32_t fbe_variant_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_variant_offset > 0) && ((_buffer.offset() + fbe_variant_offset + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_variant_offset == 0) || ((_buffer.offset() + fbe_variant_offset + 4) > _buffer.size()))
        return;
    uint32_t variant_type_index = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_variant_offset);
    assert(variant_type_index <= 4 && "Model is broken!");

    _buffer.shift(fbe_variant_offset);

    switch(variant_type_index) {
        case 0: {
            FieldModel<std::monostate> fbe_model(_buffer, 4);
            fbe_value.emplace<std::monostate>();
            break;
        }
        case 1: {
            FieldModel<bool> fbe_model(_buffer, 4);
            variant_emplace_value<::variants_ptr::Expr, bool>(fbe_value, resource);
            auto& value = std::get<1>(fbe_value);
            variant_get_value(fbe_model, value, resource);
            break;
        }
        case 2: {
            FieldModel<FBEString> fbe_model(_buffer, 4);
            variant_emplace_value<::variants_ptr::Expr, FBEString>(fbe_value, resource);
            auto& value = std::get<2>(fbe_value);
            variant_get_value(fbe_model, value, resource);
            break;
        }
        case 3: {
            FieldModel<int32_t> fbe_model(_buffer, 4);
            variant_emplace_value<::variants_ptr::Expr, int32_t>(fbe_value, resource);
            auto& value = std::get<3>(fbe_value);
            variant_get_value(fbe_model, value, resource);
            break;
        }
        case 4: {
            FieldModelVector<uint8_t> fbe_model(_buffer, 4);
            variant_emplace_value<::variants_ptr::Expr, FastVec<uint8_t>>(fbe_value, resource);
            auto& value = std::get<4>(fbe_value);
            variant_get_value(fbe_model, value, resource);
            break;
        }
        default:
            break;
    }

    _buffer.unshift(fbe_variant_offset);
}

size_t FieldModel<::variants_ptr::Expr>::set_begin(size_t variant_type_fbe_size, size_t variant_type_index)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_variant_size = (uint32_t)(fbe_body() + variant_type_fbe_size);
    uint32_t fbe_variant_offset = (uint32_t)(_buffer.allocate(fbe_variant_size) - _buffer.offset());
    assert(((fbe_variant_offset > 0) && ((_buffer.offset() + fbe_variant_offset + fbe_variant_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_variant_offset == 0) || ((_buffer.offset() + fbe_variant_offset + fbe_variant_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_variant_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_variant_offset, variant_type_index);

    _buffer.shift(fbe_variant_offset);
    return fbe_variant_offset;
}

void FieldModel<::variants_ptr::Expr>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

// Set the variant value
void FieldModel<::variants_ptr::Expr>::set(const ::variants_ptr::Expr& fbe_value, pmr::memory_resource* resource) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    std::visit(
        overloaded
        {
            [this, fbe_variant_index = fbe_value.index(), resource](std::monostate v) {
                FieldModel<std::monostate> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index(), resource](bool v) {
                FieldModel<bool> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index(), resource](const FBEString& v) {
                FieldModel<FBEString> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index(), resource](int32_t v) {
                FieldModel<int32_t> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index(), resource](const FastVec<uint8_t>& v) {
                FieldModelVector<uint8_t> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
        },
        fbe_value
    );
}


FieldModel<::variants_ptr::V>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

size_t FieldModel<::variants_ptr::V>::fbe_body() const noexcept
{
    // variant type's fbe_size not included
    size_t fbe_result = 4;
    return fbe_result;
}

size_t FieldModel<::variants_ptr::V>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body();

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::variants_ptr::V>::verify() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_variant_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_variant_offset == 0) || ((_buffer.offset() + fbe_variant_offset + 4) > _buffer.size()))
        return false;

    uint32_t fbe_variant_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_variant_offset);
    if (fbe_variant_type > 14)
        return false;

    _buffer.shift(fbe_variant_offset);
    switch(fbe_variant_type) {
        case 0: {
            FieldModel<std::monostate> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 1: {
            FieldModel<int32_t> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 2: {
            FieldModel<FBEString> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 3: {
            FieldModel<double> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 4: {
            FieldModel_variants_ptr_Simple fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 5: {
            FieldModelPtr_variants_ptr_Simple fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 6: {
            FieldModelCustomVector<FieldModel_variants_ptr_Simple, ::variants_ptr::Simple> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 7: {
            FieldModelVector<int32_t> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 8: {
            FieldModelCustomMap<FieldModel<int32_t>, FieldModel_variants_ptr_Simple, int32_t, ::variants_ptr::Simple> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 9: {
            FieldModelVector<FBE::buffer_t> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 10: {
            FieldModelVector<FBEString> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 11: {
            FieldModelMap<int32_t, FBE::buffer_t> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 12: {
            FieldModelMap<FBEString, FBE::buffer_t> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 13: {
            FieldModelCustomVector<FieldModelPtr_variants_ptr_Simple, ::variants_ptr::Simple> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 14: {
            FieldModel<::variants_ptr::Expr> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        default:
            return false;
    }

    _buffer.unshift(fbe_variant_offset);
    return true;
}

void FieldModel<::variants_ptr::V>::get(::variants_ptr::V& fbe_value, pmr::memory_resource* resource) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    uint32_t fbe_variant_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_variant_offset > 0) && ((_buffer.offset() + fbe_variant_offset + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_variant_offset == 0) || ((_buffer.offset() + fbe_variant_offset + 4) > _buffer.size()))
        return;
    uint32_t variant_type_index = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_variant_offset);
    assert(variant_type_index <= 14 && "Model is broken!");

    _buffer.shift(fbe_variant_offset);

    switch(variant_type_index) {
        case 0: {
            FieldModel<std::monostate> fbe_model(_buffer, 4);
            fbe_value.emplace<std::monostate>();
            break;
        }
        case 1: {
            FieldModel<int32_t> fbe_model(_buffer, 4);
            variant_emplace_value<::variants_ptr::V, int32_t>(fbe_value, resource);
            auto& value = std::get<1>(fbe_value);
            variant_get_value(fbe_model, value, resource);
            break;
        }
        case 2: {
            FieldModel<FBEString> fbe_model(_buffer, 4);
            variant_emplace_value<::variants_ptr::V, FBEString>(fbe_value, resource);
            auto& value = std::get<2>(fbe_value);
            variant_get_value(fbe_model, value, resource);
            break;
        }
        case 3: {
            FieldModel<double> fbe_model(_buffer, 4);
            variant_emplace_value<::variants_ptr::V, double>(fbe_value, resource);
            auto& value = std::get<3>(fbe_value);
            variant_get_value(fbe_model, value, resource);
            break;
        }
        case 4: {
            FieldModel_variants_ptr_Simple fbe_model(_buffer, 4);
            variant_emplace_value<::variants_ptr::V, ::variants_ptr::Simple>(fbe_value, resource);
            auto& value = std::get<4>(fbe_value);
            variant_get_value(fbe_model, value, resource);
            break;
        }
        case 5: {
            FieldModelPtr_variants_ptr_Simple fbe_model(_buffer, 4);
            variant_emplace_value<::variants_ptr::V, ::variants_ptr::Simple*>(fbe_value, resource);
            auto& value = std::get<5>(fbe_value);
            variant_get_value(fbe_model, &value, resource);
            break;
        }
        case 6: {
            FieldModelCustomVector<FieldModel_variants_ptr_Simple, ::variants_ptr::Simple> fbe_model(_buffer, 4);
            variant_emplace_value<::variants_ptr::V, FastVec<::variants_ptr::Simple>>(fbe_value, resource);
            auto& value = std::get<6>(fbe_value);
            variant_get_value(fbe_model, value, resource);
            break;
        }
        case 7: {
            FieldModelVector<int32_t> fbe_model(_buffer, 4);
            variant_emplace_value<::variants_ptr::V, FastVec<int32_t>>(fbe_value, resource);
            auto& value = std::get<7>(fbe_value);
            variant_get_value(fbe_model, value, resource);
            break;
        }
        case 8: {
            FieldModelCustomMap<FieldModel<int32_t>, FieldModel_variants_ptr_Simple, int32_t, ::variants_ptr::Simple> fbe_model(_buffer, 4);
            variant_emplace_value<::variants_ptr::V, std::unordered_map<int32_t, ::variants_ptr::Simple>>(fbe_value, resource);
            auto& value = std::get<8>(fbe_value);
            variant_get_value(fbe_model, value, resource);
            break;
        }
        case 9: {
            FieldModelVector<FBE::buffer_t> fbe_model(_buffer, 4);
            variant_emplace_value<::variants_ptr::V, FastVec<FBE::buffer_t>>(fbe_value, resource);
            auto& value = std::get<9>(fbe_value);
            variant_get_value(fbe_model, value, resource);
            break;
        }
        case 10: {
            FieldModelVector<FBEString> fbe_model(_buffer, 4);
            variant_emplace_value<::variants_ptr::V, FastVec<FBEString>>(fbe_value, resource);
            auto& value = std::get<10>(fbe_value);
            variant_get_value(fbe_model, value, resource);
            break;
        }
        case 11: {
            FieldModelMap<int32_t, FBE::buffer_t> fbe_model(_buffer, 4);
            variant_emplace_value<::variants_ptr::V, std::unordered_map<int32_t, FBE::buffer_t>>(fbe_value, resource);
            auto& value = std::get<11>(fbe_value);
            variant_get_value(fbe_model, value, resource);
            break;
        }
        case 12: {
            FieldModelMap<FBEString, FBE::buffer_t> fbe_model(_buffer, 4);
            variant_emplace_value<::variants_ptr::V, std::unordered_map<FBEString, FBE::buffer_t>>(fbe_value, resource);
            auto& value = std::get<12>(fbe_value);
            variant_get_value(fbe_model, value, resource);
            break;
        }
        case 13: {
            FieldModelCustomVector<FieldModelPtr_variants_ptr_Simple, ::variants_ptr::Simple> fbe_model(_buffer, 4);
            variant_emplace_value<::variants_ptr::V, FastVec<::variants_ptr::Simple*>>(fbe_value, resource);
            auto& value = std::get<13>(fbe_value);
            variant_get_value(fbe_model, value, resource);
            break;
        }
        case 14: {
            FieldModel<::variants_ptr::Expr> fbe_model(_buffer, 4);
            variant_emplace_value<::variants_ptr::V, ::variants_ptr::Expr>(fbe_value, resource);
            auto& value = std::get<14>(fbe_value);
            variant_get_value(fbe_model, value, resource);
            break;
        }
        default:
            break;
    }

    _buffer.unshift(fbe_variant_offset);
}

size_t FieldModel<::variants_ptr::V>::set_begin(size_t variant_type_fbe_size, size_t variant_type_index)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_variant_size = (uint32_t)(fbe_body() + variant_type_fbe_size);
    uint32_t fbe_variant_offset = (uint32_t)(_buffer.allocate(fbe_variant_size) - _buffer.offset());
    assert(((fbe_variant_offset > 0) && ((_buffer.offset() + fbe_variant_offset + fbe_variant_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_variant_offset == 0) || ((_buffer.offset() + fbe_variant_offset + fbe_variant_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_variant_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_variant_offset, variant_type_index);

    _buffer.shift(fbe_variant_offset);
    return fbe_variant_offset;
}

void FieldModel<::variants_ptr::V>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

// Set the variant value
void FieldModel<::variants_ptr::V>::set(const ::variants_ptr::V& fbe_value, pmr::memory_resource* resource) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    std::visit(
        overloaded
        {
            [this, fbe_variant_index = fbe_value.index(), resource](std::monostate v) {
                FieldModel<std::monostate> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index(), resource](int32_t v) {
                FieldModel<int32_t> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index(), resource](const FBEString& v) {
                FieldModel<FBEString> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index(), resource](double v) {
                FieldModel<double> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index(), resource](const ::variants_ptr::Simple& v) {
                FieldModel_variants_ptr_Simple fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index(), resource](const ::variants_ptr::Simple* v) {
                FieldModelPtr_variants_ptr_Simple fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index(), resource](const FastVec<::variants_ptr::Simple>& v) {
                FieldModelCustomVector<FieldModel_variants_ptr_Simple, ::variants_ptr::Simple> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index(), resource](const FastVec<int32_t>& v) {
                FieldModelVector<int32_t> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index(), resource](const std::unordered_map<int32_t, ::variants_ptr::Simple>& v) {
                FieldModelCustomMap<FieldModel<int32_t>, FieldModel_variants_ptr_Simple, int32_t, ::variants_ptr::Simple> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index(), resource](const FastVec<FBE::buffer_t>& v) {
                FieldModelVector<FBE::buffer_t> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index(), resource](const FastVec<FBEString>& v) {
                FieldModelVector<FBEString> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index(), resource](const std::unordered_map<int32_t, FBE::buffer_t>& v) {
                FieldModelMap<int32_t, FBE::buffer_t> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index(), resource](const std::unordered_map<FBEString, FBE::buffer_t>& v) {
                FieldModelMap<FBEString, FBE::buffer_t> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index(), resource](const FastVec<::variants_ptr::Simple*> v) {
                FieldModelCustomVector<FieldModelPtr_variants_ptr_Simple, ::variants_ptr::Simple> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index(), resource](const ::variants_ptr::Expr& v) {
                FieldModel<::variants_ptr::Expr> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
        },
        fbe_value
    );
}


FieldModel<::variants_ptr::Scalar1>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

size_t FieldModel<::variants_ptr::Scalar1>::fbe_body() const noexcept
{
    // variant type's fbe_size not included
    size_t fbe_result = 4;
    return fbe_result;
}

size_t FieldModel<::variants_ptr::Scalar1>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body();

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::variants_ptr::Scalar1>::verify() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_variant_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_variant_offset == 0) || ((_buffer.offset() + fbe_variant_offset + 4) > _buffer.size()))
        return false;

    uint32_t fbe_variant_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_variant_offset);
    if (fbe_variant_type > 4)
        return false;

    _buffer.shift(fbe_variant_offset);
    switch(fbe_variant_type) {
        case 0: {
            FieldModel<std::monostate> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 1: {
            FieldModel<bool> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 2: {
            FieldModel<int32_t> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 3: {
            FieldModel<int64_t> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        case 4: {
            FieldModel<FBEString> fbe_model(_buffer, 4);
            if (!fbe_model.verify())
                return false;
            break;
        }
        default:
            return false;
    }

    _buffer.unshift(fbe_variant_offset);
    return true;
}

void FieldModel<::variants_ptr::Scalar1>::get(::variants_ptr::Scalar1& fbe_value, pmr::memory_resource* resource) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    uint32_t fbe_variant_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_variant_offset > 0) && ((_buffer.offset() + fbe_variant_offset + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_variant_offset == 0) || ((_buffer.offset() + fbe_variant_offset + 4) > _buffer.size()))
        return;
    uint32_t variant_type_index = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_variant_offset);
    assert(variant_type_index <= 4 && "Model is broken!");

    _buffer.shift(fbe_variant_offset);

    switch(variant_type_index) {
        case 0: {
            FieldModel<std::monostate> fbe_model(_buffer, 4);
            fbe_value.emplace<std::monostate>();
            break;
        }
        case 1: {
            FieldModel<bool> fbe_model(_buffer, 4);
            variant_emplace_value<::variants_ptr::Scalar1, bool>(fbe_value, resource);
            auto& value = std::get<1>(fbe_value);
            variant_get_value(fbe_model, value, resource);
            break;
        }
        case 2: {
            FieldModel<int32_t> fbe_model(_buffer, 4);
            variant_emplace_value<::variants_ptr::Scalar1, int32_t>(fbe_value, resource);
            auto& value = std::get<2>(fbe_value);
            variant_get_value(fbe_model, value, resource);
            break;
        }
        case 3: {
            FieldModel<int64_t> fbe_model(_buffer, 4);
            variant_emplace_value<::variants_ptr::Scalar1, int64_t>(fbe_value, resource);
            auto& value = std::get<3>(fbe_value);
            variant_get_value(fbe_model, value, resource);
            break;
        }
        case 4: {
            FieldModel<FBEString> fbe_model(_buffer, 4);
            variant_emplace_value<::variants_ptr::Scalar1, FBEString>(fbe_value, resource);
            auto& value = std::get<4>(fbe_value);
            variant_get_value(fbe_model, value, resource);
            break;
        }
        default:
            break;
    }

    _buffer.unshift(fbe_variant_offset);
}

size_t FieldModel<::variants_ptr::Scalar1>::set_begin(size_t variant_type_fbe_size, size_t variant_type_index)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_variant_size = (uint32_t)(fbe_body() + variant_type_fbe_size);
    uint32_t fbe_variant_offset = (uint32_t)(_buffer.allocate(fbe_variant_size) - _buffer.offset());
    assert(((fbe_variant_offset > 0) && ((_buffer.offset() + fbe_variant_offset + fbe_variant_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_variant_offset == 0) || ((_buffer.offset() + fbe_variant_offset + fbe_variant_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_variant_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_variant_offset, variant_type_index);

    _buffer.shift(fbe_variant_offset);
    return fbe_variant_offset;
}

void FieldModel<::variants_ptr::Scalar1>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

// Set the variant value
void FieldModel<::variants_ptr::Scalar1>::set(const ::variants_ptr::Scalar1& fbe_value, pmr::memory_resource* resource) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    std::visit(
        overloaded
        {
            [this, fbe_variant_index = fbe_value.index(), resource](std::monostate v) {
                FieldModel<std::monostate> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index(), resource](bool v) {
                FieldModel<bool> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index(), resource](int32_t v) {
                FieldModel<int32_t> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index(), resource](int64_t v) {
                FieldModel<int64_t> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
            , [this, fbe_variant_index = fbe_value.index(), resource](const FBEString& v) {
                FieldModel<FBEString> fbe_model(_buffer, 4);
                size_t fbe_begin = set_begin(fbe_model.fbe_size(), fbe_variant_index);
                if (fbe_begin == 0)
                    return;
                fbe_model.set(v, resource);
                set_end(fbe_begin);
            }
        },
        fbe_value
    );
}


FieldModelPtr_variants_ptr_Simple::FieldModelPtr_variants_ptr_Simple(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_variants_ptr_Simple::~FieldModelPtr_variants_ptr_Simple()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_variants_ptr_Simple::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_variants_ptr_Simple::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_variants_ptr_Simple::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_variants_ptr_Simple::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_variants_ptr_Simple::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_variants_ptr_Simple::get(::variants_ptr::Simple** fbe_value, pmr::memory_resource* resource) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    if (ptr) delete ptr;
    ptr = new FieldModel_variants_ptr_Simple(_buffer, 0);

    ::variants_ptr::Simple *tempModel = new ::variants_ptr::Simple();
    ptr->get(*tempModel, resource);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_variants_ptr_Simple::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_variants_ptr_Simple::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_variants_ptr_Simple::set(const ::variants_ptr::Simple* fbe_value, pmr::memory_resource* resource) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_variants_ptr_Simple(_buffer, 0);
        if (ptr) delete ptr;
        ptr = temp;
        variant_set_value(ptr, *fbe_value, resource);
    }

    set_end(fbe_begin);
}

FieldModel_variants_ptr_Simple::FieldModel_variants_ptr_Simple(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , name(buffer, 4 + 4)
{}

size_t FieldModel_variants_ptr_Simple::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + name.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_variants_ptr_Simple::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + name.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_variants_ptr_Simple::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_variants_ptr_Simple::verify_fields([[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
        return true;
    if (!name.verify())
        return false;
    fbe_current_size += name.fbe_size();

    return true;
}

size_t FieldModel_variants_ptr_Simple::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_variants_ptr_Simple::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_variants_ptr_Simple::get(::FBE::Base& fbe_value, pmr::memory_resource* resource) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size, resource);
    get_end(fbe_begin);
}

void FieldModel_variants_ptr_Simple::get_fields([[maybe_unused]] ::FBE::Base& base_fbe_value, [[maybe_unused]] size_t fbe_struct_size, pmr::memory_resource* resource) noexcept
{
    ::variants_ptr::Simple& fbe_value = static_cast<::variants_ptr::Simple&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
        {
            name.get(fbe_value.name, nullptr);
        }
    else
        fbe_value.name = "";
    fbe_current_size += name.fbe_size();
}

size_t FieldModel_variants_ptr_Simple::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_variants_ptr_Simple::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_variants_ptr_Simple::set(const ::FBE::Base& fbe_value, pmr::memory_resource* resource) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value, resource);
    set_end(fbe_begin);
}

void FieldModel_variants_ptr_Simple::set_fields([[maybe_unused]] const ::FBE::Base& base_fbe_value, pmr::memory_resource* resource) noexcept
{
    [[maybe_unused]] const ::variants_ptr::Simple& fbe_value = static_cast<const ::variants_ptr::Simple&>(base_fbe_value);
    name.set(fbe_value.name, resource);
}

namespace variants_ptr {

bool SimpleModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t SimpleModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t SimpleModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t SimpleModel::serialize(const ::variants_ptr::Simple& value, pmr::memory_resource* resource)
{
    size_t fbe_begin = create_begin();
    model.set(value, resource);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t SimpleModel::deserialize(::variants_ptr::Simple& value, pmr::memory_resource* resource) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value, resource);
    return fbe_full_size;
}

} // namespace variants_ptr

FieldModelPtr_variants_ptr_ExprContainer::FieldModelPtr_variants_ptr_ExprContainer(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_variants_ptr_ExprContainer::~FieldModelPtr_variants_ptr_ExprContainer()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_variants_ptr_ExprContainer::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_variants_ptr_ExprContainer::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_variants_ptr_ExprContainer::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_variants_ptr_ExprContainer::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_variants_ptr_ExprContainer::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_variants_ptr_ExprContainer::get(::variants_ptr::ExprContainer** fbe_value, pmr::memory_resource* resource) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    if (ptr) delete ptr;
    ptr = new FieldModel_variants_ptr_ExprContainer(_buffer, 0);

    ::variants_ptr::ExprContainer *tempModel = new ::variants_ptr::ExprContainer();
    ptr->get(*tempModel, resource);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_variants_ptr_ExprContainer::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_variants_ptr_ExprContainer::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_variants_ptr_ExprContainer::set(const ::variants_ptr::ExprContainer* fbe_value, pmr::memory_resource* resource) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_variants_ptr_ExprContainer(_buffer, 0);
        if (ptr) delete ptr;
        ptr = temp;
        variant_set_value(ptr, *fbe_value, resource);
    }

    set_end(fbe_begin);
}

FieldModel_variants_ptr_ExprContainer::FieldModel_variants_ptr_ExprContainer(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , e(buffer, 4 + 4)
    , eo(buffer, e.fbe_offset() + e.fbe_size())
    , so(buffer, eo.fbe_offset() + eo.fbe_size())
{}

size_t FieldModel_variants_ptr_ExprContainer::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + e.fbe_size()
        + eo.fbe_size()
        + so.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_variants_ptr_ExprContainer::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + e.fbe_extra()
        + eo.fbe_extra()
        + so.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_variants_ptr_ExprContainer::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_variants_ptr_ExprContainer::verify_fields([[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + e.fbe_size()) > fbe_struct_size)
        return true;
    if (!e.verify())
        return false;
    fbe_current_size += e.fbe_size();

    if ((fbe_current_size + eo.fbe_size()) > fbe_struct_size)
        return true;
    if (!eo.verify())
        return false;
    fbe_current_size += eo.fbe_size();

    if ((fbe_current_size + so.fbe_size()) > fbe_struct_size)
        return true;
    if (!so.verify())
        return false;
    fbe_current_size += so.fbe_size();

    return true;
}

size_t FieldModel_variants_ptr_ExprContainer::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_variants_ptr_ExprContainer::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_variants_ptr_ExprContainer::get(::FBE::Base& fbe_value, pmr::memory_resource* resource) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size, resource);
    get_end(fbe_begin);
}

void FieldModel_variants_ptr_ExprContainer::get_fields([[maybe_unused]] ::FBE::Base& base_fbe_value, [[maybe_unused]] size_t fbe_struct_size, pmr::memory_resource* resource) noexcept
{
    ::variants_ptr::ExprContainer& fbe_value = static_cast<::variants_ptr::ExprContainer&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + e.fbe_size()) <= fbe_struct_size)
        {
            e.get(fbe_value.e, nullptr);
        }
    else
        fbe_value.e = ::variants_ptr::Expr();
    fbe_current_size += e.fbe_size();

    if ((fbe_current_size + eo.fbe_size()) <= fbe_struct_size)
        {
            eo.get(fbe_value.eo, nullptr);
        }
    else
        fbe_value.eo = std::nullopt;
    fbe_current_size += eo.fbe_size();

    if ((fbe_current_size + so.fbe_size()) <= fbe_struct_size)
        {
            so.get(fbe_value.so, nullptr);
        }
    else
        fbe_value.so = std::nullopt;
    fbe_current_size += so.fbe_size();
}

size_t FieldModel_variants_ptr_ExprContainer::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_variants_ptr_ExprContainer::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_variants_ptr_ExprContainer::set(const ::FBE::Base& fbe_value, pmr::memory_resource* resource) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value, resource);
    set_end(fbe_begin);
}

void FieldModel_variants_ptr_ExprContainer::set_fields([[maybe_unused]] const ::FBE::Base& base_fbe_value, pmr::memory_resource* resource) noexcept
{
    [[maybe_unused]] const ::variants_ptr::ExprContainer& fbe_value = static_cast<const ::variants_ptr::ExprContainer&>(base_fbe_value);
    e.set(fbe_value.e, resource);
    eo.set(fbe_value.eo, resource);
    so.set(fbe_value.so, resource);
}

namespace variants_ptr {

bool ExprContainerModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ExprContainerModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ExprContainerModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ExprContainerModel::serialize(const ::variants_ptr::ExprContainer& value, pmr::memory_resource* resource)
{
    size_t fbe_begin = create_begin();
    model.set(value, resource);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ExprContainerModel::deserialize(::variants_ptr::ExprContainer& value, pmr::memory_resource* resource) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value, resource);
    return fbe_full_size;
}

} // namespace variants_ptr

FieldModelPtr_variants_ptr_Value::FieldModelPtr_variants_ptr_Value(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_variants_ptr_Value::~FieldModelPtr_variants_ptr_Value()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_variants_ptr_Value::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_variants_ptr_Value::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_variants_ptr_Value::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_variants_ptr_Value::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_variants_ptr_Value::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_variants_ptr_Value::get(::variants_ptr::Value** fbe_value, pmr::memory_resource* resource) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    if (ptr) delete ptr;
    ptr = new FieldModel_variants_ptr_Value(_buffer, 0);

    ::variants_ptr::Value *tempModel = new ::variants_ptr::Value();
    ptr->get(*tempModel, resource);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_variants_ptr_Value::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_variants_ptr_Value::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_variants_ptr_Value::set(const ::variants_ptr::Value* fbe_value, pmr::memory_resource* resource) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_variants_ptr_Value(_buffer, 0);
        if (ptr) delete ptr;
        ptr = temp;
        variant_set_value(ptr, *fbe_value, resource);
    }

    set_end(fbe_begin);
}

FieldModel_variants_ptr_Value::FieldModel_variants_ptr_Value(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , v(buffer, 4 + 4)
    , vo(buffer, v.fbe_offset() + v.fbe_size())
    , vo2(buffer, vo.fbe_offset() + vo.fbe_size())
{}

size_t FieldModel_variants_ptr_Value::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + v.fbe_size()
        + vo.fbe_size()
        + vo2.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_variants_ptr_Value::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + v.fbe_extra()
        + vo.fbe_extra()
        + vo2.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_variants_ptr_Value::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_variants_ptr_Value::verify_fields([[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + v.fbe_size()) > fbe_struct_size)
        return true;
    if (!v.verify())
        return false;
    fbe_current_size += v.fbe_size();

    if ((fbe_current_size + vo.fbe_size()) > fbe_struct_size)
        return true;
    if (!vo.verify())
        return false;
    fbe_current_size += vo.fbe_size();

    if ((fbe_current_size + vo2.fbe_size()) > fbe_struct_size)
        return true;
    if (!vo2.verify())
        return false;
    fbe_current_size += vo2.fbe_size();

    return true;
}

size_t FieldModel_variants_ptr_Value::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_variants_ptr_Value::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_variants_ptr_Value::get(::FBE::Base& fbe_value, pmr::memory_resource* resource) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size, resource);
    get_end(fbe_begin);
}

void FieldModel_variants_ptr_Value::get_fields([[maybe_unused]] ::FBE::Base& base_fbe_value, [[maybe_unused]] size_t fbe_struct_size, pmr::memory_resource* resource) noexcept
{
    ::variants_ptr::Value& fbe_value = static_cast<::variants_ptr::Value&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + v.fbe_size()) <= fbe_struct_size)
        {
            v.get(fbe_value.v, nullptr);
        }
    else
        fbe_value.v = ::variants_ptr::V();
    fbe_current_size += v.fbe_size();

    if ((fbe_current_size + vo.fbe_size()) <= fbe_struct_size)
        {
            vo.get(fbe_value.vo, nullptr);
        }
    else
        fbe_value.vo = std::nullopt;
    fbe_current_size += vo.fbe_size();

    if ((fbe_current_size + vo2.fbe_size()) <= fbe_struct_size)
        {
            vo2.get(fbe_value.vo2, nullptr);
        }
    else
        fbe_value.vo2 = std::nullopt;
    fbe_current_size += vo2.fbe_size();
}

size_t FieldModel_variants_ptr_Value::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_variants_ptr_Value::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_variants_ptr_Value::set(const ::FBE::Base& fbe_value, pmr::memory_resource* resource) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value, resource);
    set_end(fbe_begin);
}

void FieldModel_variants_ptr_Value::set_fields([[maybe_unused]] const ::FBE::Base& base_fbe_value, pmr::memory_resource* resource) noexcept
{
    [[maybe_unused]] const ::variants_ptr::Value& fbe_value = static_cast<const ::variants_ptr::Value&>(base_fbe_value);
    v.set(fbe_value.v, resource);
    vo.set(fbe_value.vo, resource);
    vo2.set(fbe_value.vo2, resource);
}

namespace variants_ptr {

bool ValueModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ValueModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ValueModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ValueModel::serialize(const ::variants_ptr::Value& value, pmr::memory_resource* resource)
{
    size_t fbe_begin = create_begin();
    model.set(value, resource);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ValueModel::deserialize(::variants_ptr::Value& value, pmr::memory_resource* resource) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value, resource);
    return fbe_full_size;
}

} // namespace variants_ptr

FieldModelPtr_variants_ptr_ValueContainer::FieldModelPtr_variants_ptr_ValueContainer(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_variants_ptr_ValueContainer::~FieldModelPtr_variants_ptr_ValueContainer()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_variants_ptr_ValueContainer::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_variants_ptr_ValueContainer::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_variants_ptr_ValueContainer::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_variants_ptr_ValueContainer::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_variants_ptr_ValueContainer::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_variants_ptr_ValueContainer::get(::variants_ptr::ValueContainer** fbe_value, pmr::memory_resource* resource) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    if (ptr) delete ptr;
    ptr = new FieldModel_variants_ptr_ValueContainer(_buffer, 0);

    ::variants_ptr::ValueContainer *tempModel = new ::variants_ptr::ValueContainer();
    ptr->get(*tempModel, resource);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_variants_ptr_ValueContainer::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_variants_ptr_ValueContainer::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_variants_ptr_ValueContainer::set(const ::variants_ptr::ValueContainer* fbe_value, pmr::memory_resource* resource) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_variants_ptr_ValueContainer(_buffer, 0);
        if (ptr) delete ptr;
        ptr = temp;
        variant_set_value(ptr, *fbe_value, resource);
    }

    set_end(fbe_begin);
}

FieldModel_variants_ptr_ValueContainer::FieldModel_variants_ptr_ValueContainer(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , vv(buffer, 4 + 4)
    , vm(buffer, vv.fbe_offset() + vv.fbe_size())
{}

size_t FieldModel_variants_ptr_ValueContainer::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + vv.fbe_size()
        + vm.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_variants_ptr_ValueContainer::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + vv.fbe_extra()
        + vm.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_variants_ptr_ValueContainer::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_variants_ptr_ValueContainer::verify_fields([[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + vv.fbe_size()) > fbe_struct_size)
        return true;
    if (!vv.verify())
        return false;
    fbe_current_size += vv.fbe_size();

    if ((fbe_current_size + vm.fbe_size()) > fbe_struct_size)
        return true;
    if (!vm.verify())
        return false;
    fbe_current_size += vm.fbe_size();

    return true;
}

size_t FieldModel_variants_ptr_ValueContainer::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_variants_ptr_ValueContainer::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_variants_ptr_ValueContainer::get(::FBE::Base& fbe_value, pmr::memory_resource* resource) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size, resource);
    get_end(fbe_begin);
}

void FieldModel_variants_ptr_ValueContainer::get_fields([[maybe_unused]] ::FBE::Base& base_fbe_value, [[maybe_unused]] size_t fbe_struct_size, pmr::memory_resource* resource) noexcept
{
    ::variants_ptr::ValueContainer& fbe_value = static_cast<::variants_ptr::ValueContainer&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + vv.fbe_size()) <= fbe_struct_size)
        {
            vv.get(fbe_value.vv, nullptr);
        }
    else
        fbe_value.vv.clear();
    fbe_current_size += vv.fbe_size();

    if ((fbe_current_size + vm.fbe_size()) <= fbe_struct_size)
        {
            vm.get(fbe_value.vm, nullptr);
        }
    else
        fbe_value.vm.clear();
    fbe_current_size += vm.fbe_size();
}

size_t FieldModel_variants_ptr_ValueContainer::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_variants_ptr_ValueContainer::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_variants_ptr_ValueContainer::set(const ::FBE::Base& fbe_value, pmr::memory_resource* resource) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value, resource);
    set_end(fbe_begin);
}

void FieldModel_variants_ptr_ValueContainer::set_fields([[maybe_unused]] const ::FBE::Base& base_fbe_value, pmr::memory_resource* resource) noexcept
{
    [[maybe_unused]] const ::variants_ptr::ValueContainer& fbe_value = static_cast<const ::variants_ptr::ValueContainer&>(base_fbe_value);
    vv.set(fbe_value.vv, resource);
    vm.set(fbe_value.vm, resource);
}

namespace variants_ptr {

bool ValueContainerModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t ValueContainerModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t ValueContainerModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t ValueContainerModel::serialize(const ::variants_ptr::ValueContainer& value, pmr::memory_resource* resource)
{
    size_t fbe_begin = create_begin();
    model.set(value, resource);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t ValueContainerModel::deserialize(::variants_ptr::ValueContainer& value, pmr::memory_resource* resource) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value, resource);
    return fbe_full_size;
}

} // namespace variants_ptr

FieldModelPtr_variants_ptr_Scalar1Container::FieldModelPtr_variants_ptr_Scalar1Container(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

FieldModelPtr_variants_ptr_Scalar1Container::~FieldModelPtr_variants_ptr_Scalar1Container()
{
    if (ptr) delete ptr;
}

size_t FieldModelPtr_variants_ptr_Scalar1Container::fbe_extra() const noexcept
{
    if (!ptr) return 0;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_ptr_offset);
    size_t fbe_result = ptr->fbe_size() + ptr->fbe_extra();
    _buffer.unshift(fbe_ptr_offset);

    return fbe_result;
}

bool FieldModelPtr_variants_ptr_Scalar1Container::verify() const noexcept
{
    if (!ptr) return true;

    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = ptr->verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

bool FieldModelPtr_variants_ptr_Scalar1Container::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

size_t FieldModelPtr_variants_ptr_Scalar1Container::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_ptr_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_ptr_offset > 0) && "Model is broken!");
    if (fbe_ptr_offset == 0)
        return 0;

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_variants_ptr_Scalar1Container::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_variants_ptr_Scalar1Container::get(::variants_ptr::Scalar1Container** fbe_value, pmr::memory_resource* resource) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    if (ptr) delete ptr;
    ptr = new FieldModel_variants_ptr_Scalar1Container(_buffer, 0);

    ::variants_ptr::Scalar1Container *tempModel = new ::variants_ptr::Scalar1Container();
    ptr->get(*tempModel, resource);
    *fbe_value = tempModel;

    get_end(fbe_begin);
}

size_t FieldModelPtr_variants_ptr_Scalar1Container::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t *)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_ptr_size = 4;
    uint32_t fbe_ptr_offset = (uint32_t)(_buffer.allocate(fbe_ptr_size) - _buffer.offset());
    assert(((fbe_ptr_offset > 0) && ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_ptr_offset == 0) || ((_buffer.offset() + fbe_ptr_offset + fbe_ptr_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_ptr_offset);

    _buffer.shift(fbe_ptr_offset);
    return fbe_ptr_offset;
}

void FieldModelPtr_variants_ptr_Scalar1Container::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModelPtr_variants_ptr_Scalar1Container::set(const ::variants_ptr::Scalar1Container* fbe_value, pmr::memory_resource* resource) noexcept
{
    size_t fbe_begin = set_begin(fbe_value != nullptr);
    if (fbe_begin == 0)
        return;

    if (fbe_value != nullptr) {
        BaseFieldModel* temp = new FieldModel_variants_ptr_Scalar1Container(_buffer, 0);
        if (ptr) delete ptr;
        ptr = temp;
        variant_set_value(ptr, *fbe_value, resource);
    }

    set_end(fbe_begin);
}

FieldModel_variants_ptr_Scalar1Container::FieldModel_variants_ptr_Scalar1Container(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , s(buffer, 4 + 4)
{}

size_t FieldModel_variants_ptr_Scalar1Container::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + s.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel_variants_ptr_Scalar1Container::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + s.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel_variants_ptr_Scalar1Container::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel_variants_ptr_Scalar1Container::verify_fields([[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + s.fbe_size()) > fbe_struct_size)
        return true;
    if (!s.verify())
        return false;
    fbe_current_size += s.fbe_size();

    return true;
}

size_t FieldModel_variants_ptr_Scalar1Container::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_variants_ptr_Scalar1Container::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_variants_ptr_Scalar1Container::get(::FBE::Base& fbe_value, pmr::memory_resource* resource) noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size, resource);
    get_end(fbe_begin);
}

void FieldModel_variants_ptr_Scalar1Container::get_fields([[maybe_unused]] ::FBE::Base& base_fbe_value, [[maybe_unused]] size_t fbe_struct_size, pmr::memory_resource* resource) noexcept
{
    ::variants_ptr::Scalar1Container& fbe_value = static_cast<::variants_ptr::Scalar1Container&>(base_fbe_value);
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + s.fbe_size()) <= fbe_struct_size)
        {
            s.get(fbe_value.s, nullptr);
        }
    else
        fbe_value.s.clear();
    fbe_current_size += s.fbe_size();
}

size_t FieldModel_variants_ptr_Scalar1Container::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel_variants_ptr_Scalar1Container::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel_variants_ptr_Scalar1Container::set(const ::FBE::Base& fbe_value, pmr::memory_resource* resource) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value, resource);
    set_end(fbe_begin);
}

void FieldModel_variants_ptr_Scalar1Container::set_fields([[maybe_unused]] const ::FBE::Base& base_fbe_value, pmr::memory_resource* resource) noexcept
{
    [[maybe_unused]] const ::variants_ptr::Scalar1Container& fbe_value = static_cast<const ::variants_ptr::Scalar1Container&>(base_fbe_value);
    s.set(fbe_value.s, resource);
}

namespace variants_ptr {

bool Scalar1ContainerModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t Scalar1ContainerModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t Scalar1ContainerModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t Scalar1ContainerModel::serialize(const ::variants_ptr::Scalar1Container& value, pmr::memory_resource* resource)
{
    size_t fbe_begin = create_begin();
    model.set(value, resource);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t Scalar1ContainerModel::deserialize(::variants_ptr::Scalar1Container& value, pmr::memory_resource* resource) noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value, resource);
    return fbe_full_size;
}

} // namespace variants_ptr

} // namespace FBE
