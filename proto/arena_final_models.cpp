//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: arena.fbe
// FBE version: 1.11.0.0
//------------------------------------------------------------------------------

#include "arena_final_models.h"

namespace FBE {

FinalModel<::arena::Item>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , optr(buffer, 0)
    , alias(buffer, 0)
    , expressions(buffer, 0)
    , aliases_int(buffer, 0)
{}

size_t FinalModel<::arena::Item>::fbe_allocation_size(const ::arena::Item& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + optr.fbe_allocation_size(fbe_value.optr)
        + alias.fbe_allocation_size(fbe_value.alias)
        + expressions.fbe_allocation_size(fbe_value.expressions)
        + aliases_int.fbe_allocation_size(fbe_value.aliases_int)
        ;
    return fbe_result;
}

size_t FinalModel<::arena::Item>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::arena::Item>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    optr.fbe_offset(fbe_current_offset);
    fbe_field_size = optr.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    alias.fbe_offset(fbe_current_offset);
    fbe_field_size = alias.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    expressions.fbe_offset(fbe_current_offset);
    fbe_field_size = expressions.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    aliases_int.fbe_offset(fbe_current_offset);
    fbe_field_size = aliases_int.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    return fbe_current_offset;
}

size_t FinalModel<::arena::Item>::get(::arena::Item& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::arena::Item>::get_fields([[maybe_unused]] ::arena::Item& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    optr.fbe_offset(fbe_current_offset);
    fbe_field_size = optr.get(fbe_value.optr);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    alias.fbe_offset(fbe_current_offset);
    fbe_field_size = alias.get(fbe_value.alias);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    expressions.fbe_offset(fbe_current_offset);
    fbe_field_size = expressions.get(fbe_value.expressions);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    aliases_int.fbe_offset(fbe_current_offset);
    fbe_field_size = aliases_int.get(fbe_value.aliases_int);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::arena::Item>::set(const ::arena::Item& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::arena::Item>::set_fields([[maybe_unused]] const ::arena::Item& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    optr.fbe_offset(fbe_current_offset);
    fbe_field_size = optr.set(fbe_value.optr);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    alias.fbe_offset(fbe_current_offset);
    fbe_field_size = alias.set(fbe_value.alias);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    expressions.fbe_offset(fbe_current_offset);
    fbe_field_size = expressions.set(fbe_value.expressions);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    aliases_int.fbe_offset(fbe_current_offset);
    fbe_field_size = aliases_int.set(fbe_value.aliases_int);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

namespace arena {

bool ItemFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t ItemFinalModel::serialize(const ::arena::Item& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t ItemFinalModel::deserialize(::arena::Item& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

} // namespace arena

FinalModel<::arena::Item2>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , bytes_v(buffer, 0)
{}

size_t FinalModel<::arena::Item2>::fbe_allocation_size(const ::arena::Item2& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + bytes_v.fbe_allocation_size(fbe_value.bytes_v)
        ;
    return fbe_result;
}

size_t FinalModel<::arena::Item2>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::arena::Item2>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    bytes_v.fbe_offset(fbe_current_offset);
    fbe_field_size = bytes_v.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    return fbe_current_offset;
}

size_t FinalModel<::arena::Item2>::get(::arena::Item2& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::arena::Item2>::get_fields([[maybe_unused]] ::arena::Item2& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    bytes_v.fbe_offset(fbe_current_offset);
    fbe_field_size = bytes_v.get(fbe_value.bytes_v);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::arena::Item2>::set(const ::arena::Item2& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::arena::Item2>::set_fields([[maybe_unused]] const ::arena::Item2& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    bytes_v.fbe_offset(fbe_current_offset);
    fbe_field_size = bytes_v.set(fbe_value.bytes_v);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

namespace arena {

bool Item2FinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t Item2FinalModel::serialize(const ::arena::Item2& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t Item2FinalModel::deserialize(::arena::Item2& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

} // namespace arena

} // namespace FBE
