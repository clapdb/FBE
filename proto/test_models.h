//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: test.fbe
// FBE version: 1.10.0.0
//------------------------------------------------------------------------------

#pragma once

#ifdef isset
#undef isset
#endif

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "fbe_models.h"

#include "test.h"

#include "proto_models.h"

namespace FBE {

// Fast Binary Encoding ::test::EnumSimple field model
template <>
class FieldModel<::test::EnumSimple> : public FieldModelBase<::test::EnumSimple, int32_t>
{
public:
    using FieldModelBase<::test::EnumSimple, int32_t>::FieldModelBase;
};

// Fast Binary Encoding ::test::EnumTyped field model
template <>
class FieldModel<::test::EnumTyped> : public FieldModelBase<::test::EnumTyped, uint8_t>
{
public:
    using FieldModelBase<::test::EnumTyped, uint8_t>::FieldModelBase;
};

// Fast Binary Encoding ::test::EnumEmpty field model
template <>
class FieldModel<::test::EnumEmpty> : public FieldModelBase<::test::EnumEmpty, int32_t>
{
public:
    using FieldModelBase<::test::EnumEmpty, int32_t>::FieldModelBase;
};

// Fast Binary Encoding ::test::FlagsSimple field model
template <>
class FieldModel<::test::FlagsSimple> : public FieldModelBase<::test::FlagsSimple, int32_t>
{
public:
    using FieldModelBase<::test::FlagsSimple, int32_t>::FieldModelBase;
};

// Fast Binary Encoding ::test::FlagsTyped field model
template <>
class FieldModel<::test::FlagsTyped> : public FieldModelBase<::test::FlagsTyped, uint64_t>
{
public:
    using FieldModelBase<::test::FlagsTyped, uint64_t>::FieldModelBase;
};

// Fast Binary Encoding ::test::FlagsEmpty field model
template <>
class FieldModel<::test::FlagsEmpty> : public FieldModelBase<::test::FlagsEmpty, int32_t>
{
public:
    using FieldModelBase<::test::FlagsEmpty, int32_t>::FieldModelBase;
};

// Fast Binary Encoding ::test::StructSimple field model
template <>
class FieldModel<::test::StructSimple>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 110; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::test::StructSimple& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::test::StructSimple& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::test::StructSimple& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::test::StructSimple& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<int32_t> id;
    FieldModel<bool> f1;
    FieldModel<bool> f2;
    FieldModel<uint8_t> f3;
    FieldModel<uint8_t> f4;
    FieldModel<char> f5;
    FieldModel<char> f6;
    FieldModel<wchar_t> f7;
    FieldModel<wchar_t> f8;
    FieldModel<int8_t> f9;
    FieldModel<int8_t> f10;
    FieldModel<uint8_t> f11;
    FieldModel<uint8_t> f12;
    FieldModel<int16_t> f13;
    FieldModel<int16_t> f14;
    FieldModel<uint16_t> f15;
    FieldModel<uint16_t> f16;
    FieldModel<int32_t> f17;
    FieldModel<int32_t> f18;
    FieldModel<uint32_t> f19;
    FieldModel<uint32_t> f20;
    FieldModel<int64_t> f21;
    FieldModel<int64_t> f22;
    FieldModel<uint64_t> f23;
    FieldModel<uint64_t> f24;
    FieldModel<float> f25;
    FieldModel<float> f26;
    FieldModel<double> f27;
    FieldModel<double> f28;
    FieldModel<FBE::decimal_t> f29;
    FieldModel<FBE::decimal_t> f30;
    FieldModel<stdb::memory::string> f31;
    FieldModel<stdb::memory::string> f32;
    FieldModel<uint64_t> f33;
    FieldModel<uint64_t> f34;
    FieldModel<uint64_t> f35;
    FieldModel<FBE::uuid_t> f36;
    FieldModel<FBE::uuid_t> f37;
    FieldModel<FBE::uuid_t> f38;
    FieldModel<::proto::OrderSide> f39;
    FieldModel<::proto::OrderType> f40;
    FieldModel<::proto::Order> f41;
    FieldModel<::proto::Balance> f42;
    FieldModel<::proto::State> f43;
    FieldModel<::proto::Account> f44;
};

namespace test {

// Fast Binary Encoding StructSimple model
class StructSimpleModel : public FBE::Model
{
public:
    StructSimpleModel() : model(this->buffer(), 4) {}
    StructSimpleModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::test::StructSimple>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::test::StructSimple& value);
    // Deserialize the struct value
    size_t deserialize(::test::StructSimple& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::test::StructSimple> model;
};

} // namespace test

// Fast Binary Encoding ::test::StructOptional field model
template <>
class FieldModel<::test::StructOptional>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 111; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::test::StructOptional& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::test::StructOptional& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::test::StructOptional& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::test::StructOptional& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<::test::StructSimple> parent;
    FieldModel<std::optional<bool>> f100;
    FieldModel<std::optional<bool>> f101;
    FieldModel<std::optional<bool>> f102;
    FieldModel<std::optional<uint8_t>> f103;
    FieldModel<std::optional<uint8_t>> f104;
    FieldModel<std::optional<uint8_t>> f105;
    FieldModel<std::optional<char>> f106;
    FieldModel<std::optional<char>> f107;
    FieldModel<std::optional<char>> f108;
    FieldModel<std::optional<wchar_t>> f109;
    FieldModel<std::optional<wchar_t>> f110;
    FieldModel<std::optional<wchar_t>> f111;
    FieldModel<std::optional<int8_t>> f112;
    FieldModel<std::optional<int8_t>> f113;
    FieldModel<std::optional<int8_t>> f114;
    FieldModel<std::optional<uint8_t>> f115;
    FieldModel<std::optional<uint8_t>> f116;
    FieldModel<std::optional<uint8_t>> f117;
    FieldModel<std::optional<int16_t>> f118;
    FieldModel<std::optional<int16_t>> f119;
    FieldModel<std::optional<int16_t>> f120;
    FieldModel<std::optional<uint16_t>> f121;
    FieldModel<std::optional<uint16_t>> f122;
    FieldModel<std::optional<uint16_t>> f123;
    FieldModel<std::optional<int32_t>> f124;
    FieldModel<std::optional<int32_t>> f125;
    FieldModel<std::optional<int32_t>> f126;
    FieldModel<std::optional<uint32_t>> f127;
    FieldModel<std::optional<uint32_t>> f128;
    FieldModel<std::optional<uint32_t>> f129;
    FieldModel<std::optional<int64_t>> f130;
    FieldModel<std::optional<int64_t>> f131;
    FieldModel<std::optional<int64_t>> f132;
    FieldModel<std::optional<uint64_t>> f133;
    FieldModel<std::optional<uint64_t>> f134;
    FieldModel<std::optional<uint64_t>> f135;
    FieldModel<std::optional<float>> f136;
    FieldModel<std::optional<float>> f137;
    FieldModel<std::optional<float>> f138;
    FieldModel<std::optional<double>> f139;
    FieldModel<std::optional<double>> f140;
    FieldModel<std::optional<double>> f141;
    FieldModel<std::optional<FBE::decimal_t>> f142;
    FieldModel<std::optional<FBE::decimal_t>> f143;
    FieldModel<std::optional<FBE::decimal_t>> f144;
    FieldModel<std::optional<stdb::memory::string>> f145;
    FieldModel<std::optional<stdb::memory::string>> f146;
    FieldModel<std::optional<stdb::memory::string>> f147;
    FieldModel<std::optional<uint64_t>> f148;
    FieldModel<std::optional<uint64_t>> f149;
    FieldModel<std::optional<uint64_t>> f150;
    FieldModel<std::optional<FBE::uuid_t>> f151;
    FieldModel<std::optional<FBE::uuid_t>> f152;
    FieldModel<std::optional<FBE::uuid_t>> f153;
    FieldModel<std::optional<::proto::OrderSide>> f154;
    FieldModel<std::optional<::proto::OrderSide>> f155;
    FieldModel<std::optional<::proto::OrderType>> f156;
    FieldModel<std::optional<::proto::OrderType>> f157;
    FieldModel<std::optional<::proto::Order>> f158;
    FieldModel<std::optional<::proto::Order>> f159;
    FieldModel<std::optional<::proto::Balance>> f160;
    FieldModel<std::optional<::proto::Balance>> f161;
    FieldModel<std::optional<::proto::State>> f162;
    FieldModel<std::optional<::proto::State>> f163;
    FieldModel<std::optional<::proto::Account>> f164;
    FieldModel<std::optional<::proto::Account>> f165;
};

namespace test {

// Fast Binary Encoding StructOptional model
class StructOptionalModel : public FBE::Model
{
public:
    StructOptionalModel() : model(this->buffer(), 4) {}
    StructOptionalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::test::StructOptional>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::test::StructOptional& value);
    // Deserialize the struct value
    size_t deserialize(::test::StructOptional& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::test::StructOptional> model;
};

} // namespace test

// Fast Binary Encoding ::test::StructNested field model
template <>
class FieldModel<::test::StructNested>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 112; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::test::StructNested& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::test::StructNested& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::test::StructNested& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::test::StructNested& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<::test::StructOptional> parent;
    FieldModel<::test::EnumSimple> f1000;
    FieldModel<std::optional<::test::EnumSimple>> f1001;
    FieldModel<::test::EnumTyped> f1002;
    FieldModel<std::optional<::test::EnumTyped>> f1003;
    FieldModel<::test::FlagsSimple> f1004;
    FieldModel<std::optional<::test::FlagsSimple>> f1005;
    FieldModel<::test::FlagsTyped> f1006;
    FieldModel<std::optional<::test::FlagsTyped>> f1007;
    FieldModel<::test::StructSimple> f1008;
    FieldModel<std::optional<::test::StructSimple>> f1009;
    FieldModel<::test::StructOptional> f1010;
    FieldModel<std::optional<::test::StructOptional>> f1011;
};

namespace test {

// Fast Binary Encoding StructNested model
class StructNestedModel : public FBE::Model
{
public:
    StructNestedModel() : model(this->buffer(), 4) {}
    StructNestedModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::test::StructNested>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::test::StructNested& value);
    // Deserialize the struct value
    size_t deserialize(::test::StructNested& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::test::StructNested> model;
};

} // namespace test

// Fast Binary Encoding ::test::StructBytes field model
template <>
class FieldModel<::test::StructBytes>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 120; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::test::StructBytes& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::test::StructBytes& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::test::StructBytes& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::test::StructBytes& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<FBE::buffer_t> f1;
    FieldModel<std::optional<FBE::buffer_t>> f2;
    FieldModel<std::optional<FBE::buffer_t>> f3;
};

namespace test {

// Fast Binary Encoding StructBytes model
class StructBytesModel : public FBE::Model
{
public:
    StructBytesModel() : model(this->buffer(), 4) {}
    StructBytesModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::test::StructBytes>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::test::StructBytes& value);
    // Deserialize the struct value
    size_t deserialize(::test::StructBytes& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::test::StructBytes> model;
};

} // namespace test

// Fast Binary Encoding ::test::StructArray field model
template <>
class FieldModel<::test::StructArray>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 125; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::test::StructArray& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::test::StructArray& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::test::StructArray& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::test::StructArray& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModelArray<uint8_t, 2> f1;
    FieldModelArray<std::optional<uint8_t>, 2> f2;
    FieldModelArray<FBE::buffer_t, 2> f3;
    FieldModelArray<std::optional<FBE::buffer_t>, 2> f4;
    FieldModelArray<::test::EnumSimple, 2> f5;
    FieldModelArray<std::optional<::test::EnumSimple>, 2> f6;
    FieldModelArray<::test::FlagsSimple, 2> f7;
    FieldModelArray<std::optional<::test::FlagsSimple>, 2> f8;
    FieldModelArray<::test::StructSimple, 2> f9;
    FieldModelArray<std::optional<::test::StructSimple>, 2> f10;
};

namespace test {

// Fast Binary Encoding StructArray model
class StructArrayModel : public FBE::Model
{
public:
    StructArrayModel() : model(this->buffer(), 4) {}
    StructArrayModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::test::StructArray>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::test::StructArray& value);
    // Deserialize the struct value
    size_t deserialize(::test::StructArray& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::test::StructArray> model;
};

} // namespace test

// Fast Binary Encoding ::test::StructVector field model
template <>
class FieldModel<::test::StructVector>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 130; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::test::StructVector& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::test::StructVector& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::test::StructVector& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::test::StructVector& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModelVector<uint8_t> f1;
    FieldModelVector<std::optional<uint8_t>> f2;
    FieldModelVector<FBE::buffer_t> f3;
    FieldModelVector<std::optional<FBE::buffer_t>> f4;
    FieldModelVector<::test::EnumSimple> f5;
    FieldModelVector<std::optional<::test::EnumSimple>> f6;
    FieldModelVector<::test::FlagsSimple> f7;
    FieldModelVector<std::optional<::test::FlagsSimple>> f8;
    FieldModelVector<::test::StructSimple> f9;
    FieldModelVector<std::optional<::test::StructSimple>> f10;
};

namespace test {

// Fast Binary Encoding StructVector model
class StructVectorModel : public FBE::Model
{
public:
    StructVectorModel() : model(this->buffer(), 4) {}
    StructVectorModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::test::StructVector>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::test::StructVector& value);
    // Deserialize the struct value
    size_t deserialize(::test::StructVector& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::test::StructVector> model;
};

} // namespace test

// Fast Binary Encoding ::test::StructList field model
template <>
class FieldModel<::test::StructList>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 131; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::test::StructList& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::test::StructList& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::test::StructList& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::test::StructList& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModelVector<uint8_t> f1;
    FieldModelVector<std::optional<uint8_t>> f2;
    FieldModelVector<FBE::buffer_t> f3;
    FieldModelVector<std::optional<FBE::buffer_t>> f4;
    FieldModelVector<::test::EnumSimple> f5;
    FieldModelVector<std::optional<::test::EnumSimple>> f6;
    FieldModelVector<::test::FlagsSimple> f7;
    FieldModelVector<std::optional<::test::FlagsSimple>> f8;
    FieldModelVector<::test::StructSimple> f9;
    FieldModelVector<std::optional<::test::StructSimple>> f10;
};

namespace test {

// Fast Binary Encoding StructList model
class StructListModel : public FBE::Model
{
public:
    StructListModel() : model(this->buffer(), 4) {}
    StructListModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::test::StructList>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::test::StructList& value);
    // Deserialize the struct value
    size_t deserialize(::test::StructList& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::test::StructList> model;
};

} // namespace test

// Fast Binary Encoding ::test::StructSet field model
template <>
class FieldModel<::test::StructSet>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 132; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::test::StructSet& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::test::StructSet& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::test::StructSet& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::test::StructSet& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModelVector<uint8_t> f1;
    FieldModelVector<::test::EnumSimple> f2;
    FieldModelVector<::test::FlagsSimple> f3;
    FieldModelVector<::test::StructSimple> f4;
};

namespace test {

// Fast Binary Encoding StructSet model
class StructSetModel : public FBE::Model
{
public:
    StructSetModel() : model(this->buffer(), 4) {}
    StructSetModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::test::StructSet>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::test::StructSet& value);
    // Deserialize the struct value
    size_t deserialize(::test::StructSet& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::test::StructSet> model;
};

} // namespace test

// Fast Binary Encoding ::test::StructMap field model
template <>
class FieldModel<::test::StructMap>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 140; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::test::StructMap& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::test::StructMap& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::test::StructMap& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::test::StructMap& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModelMap<int32_t, uint8_t> f1;
    FieldModelMap<int32_t, std::optional<uint8_t>> f2;
    FieldModelMap<int32_t, FBE::buffer_t> f3;
    FieldModelMap<int32_t, std::optional<FBE::buffer_t>> f4;
    FieldModelMap<int32_t, ::test::EnumSimple> f5;
    FieldModelMap<int32_t, std::optional<::test::EnumSimple>> f6;
    FieldModelMap<int32_t, ::test::FlagsSimple> f7;
    FieldModelMap<int32_t, std::optional<::test::FlagsSimple>> f8;
    FieldModelMap<int32_t, ::test::StructSimple> f9;
    FieldModelMap<int32_t, std::optional<::test::StructSimple>> f10;
};

namespace test {

// Fast Binary Encoding StructMap model
class StructMapModel : public FBE::Model
{
public:
    StructMapModel() : model(this->buffer(), 4) {}
    StructMapModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::test::StructMap>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::test::StructMap& value);
    // Deserialize the struct value
    size_t deserialize(::test::StructMap& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::test::StructMap> model;
};

} // namespace test

// Fast Binary Encoding ::test::StructHash field model
template <>
class FieldModel<::test::StructHash>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 141; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::test::StructHash& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::test::StructHash& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::test::StructHash& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::test::StructHash& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModelMap<stdb::memory::string, uint8_t> f1;
    FieldModelMap<stdb::memory::string, std::optional<uint8_t>> f2;
    FieldModelMap<stdb::memory::string, FBE::buffer_t> f3;
    FieldModelMap<stdb::memory::string, std::optional<FBE::buffer_t>> f4;
    FieldModelMap<stdb::memory::string, ::test::EnumSimple> f5;
    FieldModelMap<stdb::memory::string, std::optional<::test::EnumSimple>> f6;
    FieldModelMap<stdb::memory::string, ::test::FlagsSimple> f7;
    FieldModelMap<stdb::memory::string, std::optional<::test::FlagsSimple>> f8;
    FieldModelMap<stdb::memory::string, ::test::StructSimple> f9;
    FieldModelMap<stdb::memory::string, std::optional<::test::StructSimple>> f10;
};

namespace test {

// Fast Binary Encoding StructHash model
class StructHashModel : public FBE::Model
{
public:
    StructHashModel() : model(this->buffer(), 4) {}
    StructHashModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::test::StructHash>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::test::StructHash& value);
    // Deserialize the struct value
    size_t deserialize(::test::StructHash& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::test::StructHash> model;
};

} // namespace test

// Fast Binary Encoding ::test::StructHashEx field model
template <>
class FieldModel<::test::StructHashEx>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 142; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::test::StructHashEx& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::test::StructHashEx& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::test::StructHashEx& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::test::StructHashEx& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
    FieldModelMap<::test::StructSimple, ::test::StructNested> f1;
    FieldModelMap<::test::StructSimple, std::optional<::test::StructNested>> f2;
};

namespace test {

// Fast Binary Encoding StructHashEx model
class StructHashExModel : public FBE::Model
{
public:
    StructHashExModel() : model(this->buffer(), 4) {}
    StructHashExModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::test::StructHashEx>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::test::StructHashEx& value);
    // Deserialize the struct value
    size_t deserialize(::test::StructHashEx& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::test::StructHashEx> model;
};

} // namespace test

// Fast Binary Encoding ::test::StructEmpty field model
template <>
class FieldModel<::test::StructEmpty>
{
public:
    FieldModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept;
    // Get the field extra size
    size_t fbe_extra() const noexcept;
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 143; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept;
    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept;

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept;
    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept;

    // Get the struct value
    void get(::test::StructEmpty& fbe_value) const noexcept;
    // Get the struct fields values
    void get_fields(::test::StructEmpty& fbe_value, size_t fbe_struct_size) const noexcept;

    // Set the struct value (begin phase)
    size_t set_begin();
    // Set the struct value (end phase)
    void set_end(size_t fbe_begin);

    // Set the struct value
    void set(const ::test::StructEmpty& fbe_value) noexcept;
    // Set the struct fields values
    void set_fields(const ::test::StructEmpty& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    size_t _offset;

public:
};

namespace test {

// Fast Binary Encoding StructEmpty model
class StructEmptyModel : public FBE::Model
{
public:
    StructEmptyModel() : model(this->buffer(), 4) {}
    StructEmptyModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<::test::StructEmpty>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Create a new model (begin phase)
    size_t create_begin();
    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin);

    // Serialize the struct value
    size_t serialize(const ::test::StructEmpty& value);
    // Deserialize the struct value
    size_t deserialize(::test::StructEmpty& value) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { model.fbe_shift(prev); }

public:
    FieldModel<::test::StructEmpty> model;
};

} // namespace test

} // namespace FBE
