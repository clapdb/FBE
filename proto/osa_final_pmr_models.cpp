//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: osa.fbe
// FBE version: 1.11.0.0
//------------------------------------------------------------------------------

#include "osa_final_pmr_models.h"

namespace FBE {

FinalModel<::osa_pmr::Extra>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , name(buffer, 0)
    , detail(buffer, 0)
    , sex(buffer, 0)
    , flag(buffer, 0)
{}

size_t FinalModel<::osa_pmr::Extra>::fbe_allocation_size(const ::osa_pmr::Extra& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + name.fbe_allocation_size(fbe_value.name)
        + detail.fbe_allocation_size(fbe_value.detail)
        + sex.fbe_allocation_size(fbe_value.sex)
        + flag.fbe_allocation_size(fbe_value.flag)
        ;
    return fbe_result;
}

size_t FinalModel<::osa_pmr::Extra>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::osa_pmr::Extra>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    name.fbe_offset(fbe_current_offset);
    fbe_field_size = name.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    detail.fbe_offset(fbe_current_offset);
    fbe_field_size = detail.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    // Batch verify 2 fixed-size fields (8 bytes)
    {
        if ((_buffer.offset() + fbe_current_offset + 8) > _buffer.size())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += 8;
    }

    return fbe_current_offset;
}

size_t FinalModel<::osa_pmr::Extra>::get(::osa_pmr::Extra& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::osa_pmr::Extra>::get_fields([[maybe_unused]] ::osa_pmr::Extra& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    name.fbe_offset(fbe_current_offset);
    fbe_field_size = name.get(fbe_value.name);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    detail.fbe_offset(fbe_current_offset);
    fbe_field_size = detail.get(fbe_value.detail);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Batch read 2 fixed-size fields (8 bytes)
    {
        size_t fbe_batch_offset = _buffer.offset() + fbe_current_offset;
        if ((fbe_batch_offset + 8) > _buffer.size())
            return 0;
        const uint8_t* fbe_batch_ptr = _buffer.data() + fbe_batch_offset;
        fbe_value.sex = static_cast<decltype(fbe_value.sex)>(unaligned_load<int32_t>(fbe_batch_ptr + 0));
        fbe_value.flag = static_cast<decltype(fbe_value.flag)>(unaligned_load<int32_t>(fbe_batch_ptr + 4));
        fbe_current_offset += 8;
        fbe_current_size += 8;
    }

    return fbe_current_size;
}

size_t FinalModel<::osa_pmr::Extra>::get(::osa_pmr::Extra& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value, resource);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::osa_pmr::Extra>::get_fields([[maybe_unused]] ::osa_pmr::Extra& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    name.fbe_offset(fbe_current_offset);
    fbe_field_size = name.get(fbe_value.name, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    detail.fbe_offset(fbe_current_offset);
    fbe_field_size = detail.get(fbe_value.detail, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Batch read 2 fixed-size fields (8 bytes)
    {
        size_t fbe_batch_offset = _buffer.offset() + fbe_current_offset;
        if ((fbe_batch_offset + 8) > _buffer.size())
            return 0;
        const uint8_t* fbe_batch_ptr = _buffer.data() + fbe_batch_offset;
        fbe_value.sex = static_cast<decltype(fbe_value.sex)>(unaligned_load<int32_t>(fbe_batch_ptr + 0));
        fbe_value.flag = static_cast<decltype(fbe_value.flag)>(unaligned_load<int32_t>(fbe_batch_ptr + 4));
        fbe_current_offset += 8;
        fbe_current_size += 8;
    }

    return fbe_current_size;
}

size_t FinalModel<::osa_pmr::Extra>::set(const ::osa_pmr::Extra& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::osa_pmr::Extra>::set_fields([[maybe_unused]] const ::osa_pmr::Extra& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    name.fbe_offset(fbe_current_offset);
    fbe_field_size = name.set(fbe_value.name);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    detail.fbe_offset(fbe_current_offset);
    fbe_field_size = detail.set(fbe_value.detail);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Batch write 2 fixed-size fields (8 bytes)
    {
        size_t fbe_batch_offset = _buffer.offset() + fbe_current_offset;
        assert(((fbe_batch_offset + 8) <= _buffer.size()) && "Model is broken!");
        if ((fbe_batch_offset + 8) > _buffer.size())
            return 0;
        uint8_t* fbe_batch_ptr = _buffer.data() + fbe_batch_offset;
        unaligned_store<int32_t>(fbe_batch_ptr + 0, static_cast<int32_t>(fbe_value.sex));
        unaligned_store<int32_t>(fbe_batch_ptr + 4, static_cast<int32_t>(fbe_value.flag));
        fbe_current_offset += 8;
        fbe_current_size += 8;
    }

    return fbe_current_size;
}

namespace osa_pmr {

bool ExtraFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t ExtraFinalModel::serialize(const ::osa_pmr::Extra& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t ExtraFinalModel::deserialize(::osa_pmr::Extra& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

size_t ExtraFinalModel::deserialize(::osa_pmr::Extra& value, std::pmr::memory_resource* resource) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value, resource);
}

} // namespace osa_pmr

FinalModel<::osa_pmr::Simple>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , name(buffer, 0)
    , depth(buffer, 0)
    , sa(buffer, 0)
    , sex(buffer, 0)
{}

size_t FinalModel<::osa_pmr::Simple>::fbe_allocation_size(const ::osa_pmr::Simple& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + name.fbe_allocation_size(fbe_value.name)
        + depth.fbe_allocation_size(fbe_value.depth)
        + sa.fbe_allocation_size(fbe_value.sa)
        + sex.fbe_allocation_size(fbe_value.sex)
        ;
    return fbe_result;
}

size_t FinalModel<::osa_pmr::Simple>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::osa_pmr::Simple>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    name.fbe_offset(fbe_current_offset);
    fbe_field_size = name.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    // Inline verify of int32 field depth (4 bytes)
    if ((_buffer.offset() + fbe_current_offset + 4) > _buffer.size())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += 4;

    sa.fbe_offset(fbe_current_offset);
    fbe_field_size = sa.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    // Inline verify of Sex field sex (4 bytes)
    if ((_buffer.offset() + fbe_current_offset + 4) > _buffer.size())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += 4;

    return fbe_current_offset;
}

size_t FinalModel<::osa_pmr::Simple>::get(::osa_pmr::Simple& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::osa_pmr::Simple>::get_fields([[maybe_unused]] ::osa_pmr::Simple& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    name.fbe_offset(fbe_current_offset);
    fbe_field_size = name.get(fbe_value.name);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Inline read of int32 field depth (4 bytes)
    {
        size_t fbe_field_offset = _buffer.offset() + fbe_current_offset;
        if ((fbe_field_offset + 4) > _buffer.size())
            return 0;
        fbe_value.depth = unaligned_load<int32_t>(_buffer.data() + fbe_field_offset);
        fbe_current_offset += 4;
        fbe_current_size += 4;
    }

    sa.fbe_offset(fbe_current_offset);
    fbe_field_size = sa.get(fbe_value.sa);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Inline read of Sex field sex (4 bytes)
    {
        size_t fbe_field_offset = _buffer.offset() + fbe_current_offset;
        if ((fbe_field_offset + 4) > _buffer.size())
            return 0;
        fbe_value.sex = static_cast<decltype(fbe_value.sex)>(unaligned_load<int32_t>(_buffer.data() + fbe_field_offset));
        fbe_current_offset += 4;
        fbe_current_size += 4;
    }

    return fbe_current_size;
}

size_t FinalModel<::osa_pmr::Simple>::get(::osa_pmr::Simple& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value, resource);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::osa_pmr::Simple>::get_fields([[maybe_unused]] ::osa_pmr::Simple& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    name.fbe_offset(fbe_current_offset);
    fbe_field_size = name.get(fbe_value.name, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Inline read of int32 field depth (4 bytes)
    {
        size_t fbe_field_offset = _buffer.offset() + fbe_current_offset;
        if ((fbe_field_offset + 4) > _buffer.size())
            return 0;
        fbe_value.depth = unaligned_load<int32_t>(_buffer.data() + fbe_field_offset);
        fbe_current_offset += 4;
        fbe_current_size += 4;
    }

    sa.fbe_offset(fbe_current_offset);
    fbe_field_size = sa.get(fbe_value.sa, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Inline read of Sex field sex (4 bytes)
    {
        size_t fbe_field_offset = _buffer.offset() + fbe_current_offset;
        if ((fbe_field_offset + 4) > _buffer.size())
            return 0;
        fbe_value.sex = static_cast<decltype(fbe_value.sex)>(unaligned_load<int32_t>(_buffer.data() + fbe_field_offset));
        fbe_current_offset += 4;
        fbe_current_size += 4;
    }

    return fbe_current_size;
}

size_t FinalModel<::osa_pmr::Simple>::set(const ::osa_pmr::Simple& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::osa_pmr::Simple>::set_fields([[maybe_unused]] const ::osa_pmr::Simple& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    name.fbe_offset(fbe_current_offset);
    fbe_field_size = name.set(fbe_value.name);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Inline write of int32 field depth (4 bytes)
    {
        size_t fbe_field_offset = _buffer.offset() + fbe_current_offset;
        assert(((fbe_field_offset + 4) <= _buffer.size()) && "Model is broken!");
        if ((fbe_field_offset + 4) > _buffer.size())
            return 0;
        unaligned_store<int32_t>(_buffer.data() + fbe_field_offset, fbe_value.depth);
        fbe_current_offset += 4;
        fbe_current_size += 4;
    }

    sa.fbe_offset(fbe_current_offset);
    fbe_field_size = sa.set(fbe_value.sa);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Inline write of Sex field sex (4 bytes)
    {
        size_t fbe_field_offset = _buffer.offset() + fbe_current_offset;
        assert(((fbe_field_offset + 4) <= _buffer.size()) && "Model is broken!");
        if ((fbe_field_offset + 4) > _buffer.size())
            return 0;
        unaligned_store<int32_t>(_buffer.data() + fbe_field_offset, static_cast<int32_t>(fbe_value.sex));
        fbe_current_offset += 4;
        fbe_current_size += 4;
    }

    return fbe_current_size;
}

namespace osa_pmr {

bool SimpleFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t SimpleFinalModel::serialize(const ::osa_pmr::Simple& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t SimpleFinalModel::deserialize(::osa_pmr::Simple& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

size_t SimpleFinalModel::deserialize(::osa_pmr::Simple& value, std::pmr::memory_resource* resource) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value, resource);
}

} // namespace osa_pmr

} // namespace FBE
