//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: test.fbe
// FBE version: 1.11.0.0
//------------------------------------------------------------------------------

#pragma once

#ifdef isset
#undef isset
#endif

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "fbe_final_models.h"

#include "test_pmr.h"

#include "proto_final_pmr_models.h"

namespace FBE {

// Fast Binary Encoding ::test_pmr::EnumSimple final model
template <>
class FinalModel<::test_pmr::EnumSimple> : public FinalModelBase<::test_pmr::EnumSimple, int32_t>
{
public:
    using FinalModelBase<::test_pmr::EnumSimple, int32_t>::FinalModelBase;
};

// Fast Binary Encoding ::test_pmr::EnumTyped final model
template <>
class FinalModel<::test_pmr::EnumTyped> : public FinalModelBase<::test_pmr::EnumTyped, uint8_t>
{
public:
    using FinalModelBase<::test_pmr::EnumTyped, uint8_t>::FinalModelBase;
};

// Fast Binary Encoding ::test_pmr::EnumEmpty final model
template <>
class FinalModel<::test_pmr::EnumEmpty> : public FinalModelBase<::test_pmr::EnumEmpty, int32_t>
{
public:
    using FinalModelBase<::test_pmr::EnumEmpty, int32_t>::FinalModelBase;
};

// Fast Binary Encoding ::test_pmr::FlagsSimple final model
template <>
class FinalModel<::test_pmr::FlagsSimple> : public FinalModelBase<::test_pmr::FlagsSimple, int32_t>
{
public:
    using FinalModelBase<::test_pmr::FlagsSimple, int32_t>::FinalModelBase;
};

// Fast Binary Encoding ::test_pmr::FlagsTyped final model
template <>
class FinalModel<::test_pmr::FlagsTyped> : public FinalModelBase<::test_pmr::FlagsTyped, uint64_t>
{
public:
    using FinalModelBase<::test_pmr::FlagsTyped, uint64_t>::FinalModelBase;
};

// Fast Binary Encoding ::test_pmr::FlagsEmpty final model
template <>
class FinalModel<::test_pmr::FlagsEmpty> : public FinalModelBase<::test_pmr::FlagsEmpty, int32_t>
{
public:
    using FinalModelBase<::test_pmr::FlagsEmpty, int32_t>::FinalModelBase;
};

// Fast Binary Encoding ::test_pmr::StructSimple final model
template <>
class FinalModel<::test_pmr::StructSimple>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::test_pmr::StructSimple& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 110; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::test_pmr::StructSimple& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::test_pmr::StructSimple& fbe_value) const noexcept;
    // Get the struct value with memory resource
    size_t get(::test_pmr::StructSimple& fbe_value, std::pmr::memory_resource* resource) const noexcept;
    // Get the struct fields values with memory resource
    size_t get_fields(::test_pmr::StructSimple& fbe_value, std::pmr::memory_resource* resource) const noexcept;

    // Set the struct value
    size_t set(const ::test_pmr::StructSimple& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::test_pmr::StructSimple& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<int32_t> id;
    FinalModel<bool> f1;
    FinalModel<bool> f2;
    FinalModel<uint8_t> f3;
    FinalModel<uint8_t> f4;
    FinalModel<char> f5;
    FinalModel<char> f6;
    FinalModel<wchar_t> f7;
    FinalModel<wchar_t> f8;
    FinalModel<int8_t> f9;
    FinalModel<int8_t> f10;
    FinalModel<uint8_t> f11;
    FinalModel<uint8_t> f12;
    FinalModel<int16_t> f13;
    FinalModel<int16_t> f14;
    FinalModel<uint16_t> f15;
    FinalModel<uint16_t> f16;
    FinalModel<int32_t> f17;
    FinalModel<int32_t> f18;
    FinalModel<uint32_t> f19;
    FinalModel<uint32_t> f20;
    FinalModel<int64_t> f21;
    FinalModel<int64_t> f22;
    FinalModel<uint64_t> f23;
    FinalModel<uint64_t> f24;
    FinalModel<float> f25;
    FinalModel<float> f26;
    FinalModel<double> f27;
    FinalModel<double> f28;
    FinalModel<FBE::decimal_t> f29;
    FinalModel<FBE::decimal_t> f30;
    FinalModel<ArenaString> f31;
    FinalModel<ArenaString> f32;
    FinalModel<uint64_t> f33;
    FinalModel<uint64_t> f34;
    FinalModel<uint64_t> f35;
    FinalModel<FBE::uuid_t> f36;
    FinalModel<FBE::uuid_t> f37;
    FinalModel<FBE::uuid_t> f38;
    FinalModel<::proto_pmr::OrderSide> f39;
    FinalModel<::proto_pmr::OrderType> f40;
    FinalModel<::proto_pmr::Order> f41;
    FinalModel<::proto_pmr::Balance> f42;
    FinalModel<::proto_pmr::State> f43;
    FinalModel<::proto_pmr::Account> f44;
};

namespace test_pmr {

// Fast Binary Encoding StructSimple final model
class StructSimpleFinalModel : public FBE::Model
{
public:
    StructSimpleFinalModel() : _model(this->buffer(), 8) {}
    StructSimpleFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::test_pmr::StructSimple>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::test_pmr::StructSimple& value);
    // Deserialize the struct value
    size_t deserialize(::test_pmr::StructSimple& value) const noexcept;
    // Deserialize the struct value with memory resource
    size_t deserialize(::test_pmr::StructSimple& value, std::pmr::memory_resource* resource) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::test_pmr::StructSimple> _model;
};

} // namespace test_pmr

// Fast Binary Encoding ::test_pmr::StructOptional final model
template <>
class FinalModel<::test_pmr::StructOptional>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::test_pmr::StructOptional& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 111; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::test_pmr::StructOptional& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::test_pmr::StructOptional& fbe_value) const noexcept;
    // Get the struct value with memory resource
    size_t get(::test_pmr::StructOptional& fbe_value, std::pmr::memory_resource* resource) const noexcept;
    // Get the struct fields values with memory resource
    size_t get_fields(::test_pmr::StructOptional& fbe_value, std::pmr::memory_resource* resource) const noexcept;

    // Set the struct value
    size_t set(const ::test_pmr::StructOptional& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::test_pmr::StructOptional& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<::test_pmr::StructSimple> parent;
    FinalModel<std::optional<bool>> f100;
    FinalModel<std::optional<bool>> f101;
    FinalModel<std::optional<bool>> f102;
    FinalModel<std::optional<uint8_t>> f103;
    FinalModel<std::optional<uint8_t>> f104;
    FinalModel<std::optional<uint8_t>> f105;
    FinalModel<std::optional<char>> f106;
    FinalModel<std::optional<char>> f107;
    FinalModel<std::optional<char>> f108;
    FinalModel<std::optional<wchar_t>> f109;
    FinalModel<std::optional<wchar_t>> f110;
    FinalModel<std::optional<wchar_t>> f111;
    FinalModel<std::optional<int8_t>> f112;
    FinalModel<std::optional<int8_t>> f113;
    FinalModel<std::optional<int8_t>> f114;
    FinalModel<std::optional<uint8_t>> f115;
    FinalModel<std::optional<uint8_t>> f116;
    FinalModel<std::optional<uint8_t>> f117;
    FinalModel<std::optional<int16_t>> f118;
    FinalModel<std::optional<int16_t>> f119;
    FinalModel<std::optional<int16_t>> f120;
    FinalModel<std::optional<uint16_t>> f121;
    FinalModel<std::optional<uint16_t>> f122;
    FinalModel<std::optional<uint16_t>> f123;
    FinalModel<std::optional<int32_t>> f124;
    FinalModel<std::optional<int32_t>> f125;
    FinalModel<std::optional<int32_t>> f126;
    FinalModel<std::optional<uint32_t>> f127;
    FinalModel<std::optional<uint32_t>> f128;
    FinalModel<std::optional<uint32_t>> f129;
    FinalModel<std::optional<int64_t>> f130;
    FinalModel<std::optional<int64_t>> f131;
    FinalModel<std::optional<int64_t>> f132;
    FinalModel<std::optional<uint64_t>> f133;
    FinalModel<std::optional<uint64_t>> f134;
    FinalModel<std::optional<uint64_t>> f135;
    FinalModel<std::optional<float>> f136;
    FinalModel<std::optional<float>> f137;
    FinalModel<std::optional<float>> f138;
    FinalModel<std::optional<double>> f139;
    FinalModel<std::optional<double>> f140;
    FinalModel<std::optional<double>> f141;
    FinalModel<std::optional<FBE::decimal_t>> f142;
    FinalModel<std::optional<FBE::decimal_t>> f143;
    FinalModel<std::optional<FBE::decimal_t>> f144;
    FinalModel<std::optional<ArenaString>> f145;
    FinalModel<std::optional<ArenaString>> f146;
    FinalModel<std::optional<ArenaString>> f147;
    FinalModel<std::optional<uint64_t>> f148;
    FinalModel<std::optional<uint64_t>> f149;
    FinalModel<std::optional<uint64_t>> f150;
    FinalModel<std::optional<FBE::uuid_t>> f151;
    FinalModel<std::optional<FBE::uuid_t>> f152;
    FinalModel<std::optional<FBE::uuid_t>> f153;
    FinalModel<std::optional<::proto_pmr::OrderSide>> f154;
    FinalModel<std::optional<::proto_pmr::OrderSide>> f155;
    FinalModel<std::optional<::proto_pmr::OrderType>> f156;
    FinalModel<std::optional<::proto_pmr::OrderType>> f157;
    FinalModel<std::optional<::proto_pmr::Order>> f158;
    FinalModel<std::optional<::proto_pmr::Order>> f159;
    FinalModel<std::optional<::proto_pmr::Balance>> f160;
    FinalModel<std::optional<::proto_pmr::Balance>> f161;
    FinalModel<std::optional<::proto_pmr::State>> f162;
    FinalModel<std::optional<::proto_pmr::State>> f163;
    FinalModel<std::optional<::proto_pmr::Account>> f164;
    FinalModel<std::optional<::proto_pmr::Account>> f165;
};

namespace test_pmr {

// Fast Binary Encoding StructOptional final model
class StructOptionalFinalModel : public FBE::Model
{
public:
    StructOptionalFinalModel() : _model(this->buffer(), 8) {}
    StructOptionalFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::test_pmr::StructOptional>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::test_pmr::StructOptional& value);
    // Deserialize the struct value
    size_t deserialize(::test_pmr::StructOptional& value) const noexcept;
    // Deserialize the struct value with memory resource
    size_t deserialize(::test_pmr::StructOptional& value, std::pmr::memory_resource* resource) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::test_pmr::StructOptional> _model;
};

} // namespace test_pmr

// Fast Binary Encoding ::test_pmr::StructNested final model
template <>
class FinalModel<::test_pmr::StructNested>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::test_pmr::StructNested& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 112; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::test_pmr::StructNested& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::test_pmr::StructNested& fbe_value) const noexcept;
    // Get the struct value with memory resource
    size_t get(::test_pmr::StructNested& fbe_value, std::pmr::memory_resource* resource) const noexcept;
    // Get the struct fields values with memory resource
    size_t get_fields(::test_pmr::StructNested& fbe_value, std::pmr::memory_resource* resource) const noexcept;

    // Set the struct value
    size_t set(const ::test_pmr::StructNested& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::test_pmr::StructNested& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<::test_pmr::StructOptional> parent;
    FinalModel<::test_pmr::EnumSimple> f1000;
    FinalModel<std::optional<::test_pmr::EnumSimple>> f1001;
    FinalModel<::test_pmr::EnumTyped> f1002;
    FinalModel<std::optional<::test_pmr::EnumTyped>> f1003;
    FinalModel<::test_pmr::FlagsSimple> f1004;
    FinalModel<std::optional<::test_pmr::FlagsSimple>> f1005;
    FinalModel<::test_pmr::FlagsTyped> f1006;
    FinalModel<std::optional<::test_pmr::FlagsTyped>> f1007;
    FinalModel<::test_pmr::StructSimple> f1008;
    FinalModel<std::optional<::test_pmr::StructSimple>> f1009;
    FinalModel<::test_pmr::StructOptional> f1010;
    FinalModel<std::optional<::test_pmr::StructOptional>> f1011;
};

namespace test_pmr {

// Fast Binary Encoding StructNested final model
class StructNestedFinalModel : public FBE::Model
{
public:
    StructNestedFinalModel() : _model(this->buffer(), 8) {}
    StructNestedFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::test_pmr::StructNested>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::test_pmr::StructNested& value);
    // Deserialize the struct value
    size_t deserialize(::test_pmr::StructNested& value) const noexcept;
    // Deserialize the struct value with memory resource
    size_t deserialize(::test_pmr::StructNested& value, std::pmr::memory_resource* resource) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::test_pmr::StructNested> _model;
};

} // namespace test_pmr

// Fast Binary Encoding ::test_pmr::StructBytes final model
template <>
class FinalModel<::test_pmr::StructBytes>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::test_pmr::StructBytes& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 120; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::test_pmr::StructBytes& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::test_pmr::StructBytes& fbe_value) const noexcept;
    // Get the struct value with memory resource
    size_t get(::test_pmr::StructBytes& fbe_value, std::pmr::memory_resource* resource) const noexcept;
    // Get the struct fields values with memory resource
    size_t get_fields(::test_pmr::StructBytes& fbe_value, std::pmr::memory_resource* resource) const noexcept;

    // Set the struct value
    size_t set(const ::test_pmr::StructBytes& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::test_pmr::StructBytes& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<FBE::pmr_buffer_t> f1;
    FinalModel<std::optional<FBE::pmr_buffer_t>> f2;
    FinalModel<std::optional<FBE::pmr_buffer_t>> f3;
};

namespace test_pmr {

// Fast Binary Encoding StructBytes final model
class StructBytesFinalModel : public FBE::Model
{
public:
    StructBytesFinalModel() : _model(this->buffer(), 8) {}
    StructBytesFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::test_pmr::StructBytes>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::test_pmr::StructBytes& value);
    // Deserialize the struct value
    size_t deserialize(::test_pmr::StructBytes& value) const noexcept;
    // Deserialize the struct value with memory resource
    size_t deserialize(::test_pmr::StructBytes& value, std::pmr::memory_resource* resource) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::test_pmr::StructBytes> _model;
};

} // namespace test_pmr

// Fast Binary Encoding ::test_pmr::StructArray final model
template <>
class FinalModel<::test_pmr::StructArray>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::test_pmr::StructArray& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 125; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::test_pmr::StructArray& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::test_pmr::StructArray& fbe_value) const noexcept;
    // Get the struct value with memory resource
    size_t get(::test_pmr::StructArray& fbe_value, std::pmr::memory_resource* resource) const noexcept;
    // Get the struct fields values with memory resource
    size_t get_fields(::test_pmr::StructArray& fbe_value, std::pmr::memory_resource* resource) const noexcept;

    // Set the struct value
    size_t set(const ::test_pmr::StructArray& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::test_pmr::StructArray& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelArray<uint8_t, 2> f1;
    FinalModelArray<std::optional<uint8_t>, 2> f2;
    FinalModelArray<FBE::pmr_buffer_t, 2> f3;
    FinalModelArray<std::optional<FBE::pmr_buffer_t>, 2> f4;
    FinalModelArray<::test_pmr::EnumSimple, 2> f5;
    FinalModelArray<std::optional<::test_pmr::EnumSimple>, 2> f6;
    FinalModelArray<::test_pmr::FlagsSimple, 2> f7;
    FinalModelArray<std::optional<::test_pmr::FlagsSimple>, 2> f8;
    FinalModelArray<::test_pmr::StructSimple, 2> f9;
    FinalModelArray<std::optional<::test_pmr::StructSimple>, 2> f10;
};

namespace test_pmr {

// Fast Binary Encoding StructArray final model
class StructArrayFinalModel : public FBE::Model
{
public:
    StructArrayFinalModel() : _model(this->buffer(), 8) {}
    StructArrayFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::test_pmr::StructArray>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::test_pmr::StructArray& value);
    // Deserialize the struct value
    size_t deserialize(::test_pmr::StructArray& value) const noexcept;
    // Deserialize the struct value with memory resource
    size_t deserialize(::test_pmr::StructArray& value, std::pmr::memory_resource* resource) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::test_pmr::StructArray> _model;
};

} // namespace test_pmr

// Fast Binary Encoding ::test_pmr::StructVector final model
template <>
class FinalModel<::test_pmr::StructVector>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::test_pmr::StructVector& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 130; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::test_pmr::StructVector& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::test_pmr::StructVector& fbe_value) const noexcept;
    // Get the struct value with memory resource
    size_t get(::test_pmr::StructVector& fbe_value, std::pmr::memory_resource* resource) const noexcept;
    // Get the struct fields values with memory resource
    size_t get_fields(::test_pmr::StructVector& fbe_value, std::pmr::memory_resource* resource) const noexcept;

    // Set the struct value
    size_t set(const ::test_pmr::StructVector& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::test_pmr::StructVector& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelVector<uint8_t> f1;
    FinalModelVector<std::optional<uint8_t>> f2;
    FinalModelVector<FBE::pmr_buffer_t> f3;
    FinalModelVector<std::optional<FBE::pmr_buffer_t>> f4;
    FinalModelVector<::test_pmr::EnumSimple> f5;
    FinalModelVector<std::optional<::test_pmr::EnumSimple>> f6;
    FinalModelVector<::test_pmr::FlagsSimple> f7;
    FinalModelVector<std::optional<::test_pmr::FlagsSimple>> f8;
    FinalModelVector<::test_pmr::StructSimple> f9;
    FinalModelVector<std::optional<::test_pmr::StructSimple>> f10;
};

namespace test_pmr {

// Fast Binary Encoding StructVector final model
class StructVectorFinalModel : public FBE::Model
{
public:
    StructVectorFinalModel() : _model(this->buffer(), 8) {}
    StructVectorFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::test_pmr::StructVector>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::test_pmr::StructVector& value);
    // Deserialize the struct value
    size_t deserialize(::test_pmr::StructVector& value) const noexcept;
    // Deserialize the struct value with memory resource
    size_t deserialize(::test_pmr::StructVector& value, std::pmr::memory_resource* resource) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::test_pmr::StructVector> _model;
};

} // namespace test_pmr

// Fast Binary Encoding ::test_pmr::StructList final model
template <>
class FinalModel<::test_pmr::StructList>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::test_pmr::StructList& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 131; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::test_pmr::StructList& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::test_pmr::StructList& fbe_value) const noexcept;
    // Get the struct value with memory resource
    size_t get(::test_pmr::StructList& fbe_value, std::pmr::memory_resource* resource) const noexcept;
    // Get the struct fields values with memory resource
    size_t get_fields(::test_pmr::StructList& fbe_value, std::pmr::memory_resource* resource) const noexcept;

    // Set the struct value
    size_t set(const ::test_pmr::StructList& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::test_pmr::StructList& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelVector<uint8_t> f1;
    FinalModelVector<std::optional<uint8_t>> f2;
    FinalModelVector<FBE::pmr_buffer_t> f3;
    FinalModelVector<std::optional<FBE::pmr_buffer_t>> f4;
    FinalModelVector<::test_pmr::EnumSimple> f5;
    FinalModelVector<std::optional<::test_pmr::EnumSimple>> f6;
    FinalModelVector<::test_pmr::FlagsSimple> f7;
    FinalModelVector<std::optional<::test_pmr::FlagsSimple>> f8;
    FinalModelVector<::test_pmr::StructSimple> f9;
    FinalModelVector<std::optional<::test_pmr::StructSimple>> f10;
};

namespace test_pmr {

// Fast Binary Encoding StructList final model
class StructListFinalModel : public FBE::Model
{
public:
    StructListFinalModel() : _model(this->buffer(), 8) {}
    StructListFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::test_pmr::StructList>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::test_pmr::StructList& value);
    // Deserialize the struct value
    size_t deserialize(::test_pmr::StructList& value) const noexcept;
    // Deserialize the struct value with memory resource
    size_t deserialize(::test_pmr::StructList& value, std::pmr::memory_resource* resource) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::test_pmr::StructList> _model;
};

} // namespace test_pmr

// Fast Binary Encoding ::test_pmr::StructSet final model
template <>
class FinalModel<::test_pmr::StructSet>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::test_pmr::StructSet& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 132; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::test_pmr::StructSet& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::test_pmr::StructSet& fbe_value) const noexcept;
    // Get the struct value with memory resource
    size_t get(::test_pmr::StructSet& fbe_value, std::pmr::memory_resource* resource) const noexcept;
    // Get the struct fields values with memory resource
    size_t get_fields(::test_pmr::StructSet& fbe_value, std::pmr::memory_resource* resource) const noexcept;

    // Set the struct value
    size_t set(const ::test_pmr::StructSet& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::test_pmr::StructSet& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelVector<uint8_t> f1;
    FinalModelVector<::test_pmr::EnumSimple> f2;
    FinalModelVector<::test_pmr::FlagsSimple> f3;
    FinalModelVector<::test_pmr::StructSimple> f4;
};

namespace test_pmr {

// Fast Binary Encoding StructSet final model
class StructSetFinalModel : public FBE::Model
{
public:
    StructSetFinalModel() : _model(this->buffer(), 8) {}
    StructSetFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::test_pmr::StructSet>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::test_pmr::StructSet& value);
    // Deserialize the struct value
    size_t deserialize(::test_pmr::StructSet& value) const noexcept;
    // Deserialize the struct value with memory resource
    size_t deserialize(::test_pmr::StructSet& value, std::pmr::memory_resource* resource) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::test_pmr::StructSet> _model;
};

} // namespace test_pmr

// Fast Binary Encoding ::test_pmr::StructMap final model
template <>
class FinalModel<::test_pmr::StructMap>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::test_pmr::StructMap& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 140; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::test_pmr::StructMap& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::test_pmr::StructMap& fbe_value) const noexcept;
    // Get the struct value with memory resource
    size_t get(::test_pmr::StructMap& fbe_value, std::pmr::memory_resource* resource) const noexcept;
    // Get the struct fields values with memory resource
    size_t get_fields(::test_pmr::StructMap& fbe_value, std::pmr::memory_resource* resource) const noexcept;

    // Set the struct value
    size_t set(const ::test_pmr::StructMap& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::test_pmr::StructMap& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelMap<int32_t, uint8_t> f1;
    FinalModelMap<int32_t, std::optional<uint8_t>> f2;
    FinalModelMap<int32_t, FBE::pmr_buffer_t> f3;
    FinalModelMap<int32_t, std::optional<FBE::pmr_buffer_t>> f4;
    FinalModelMap<int32_t, ::test_pmr::EnumSimple> f5;
    FinalModelMap<int32_t, std::optional<::test_pmr::EnumSimple>> f6;
    FinalModelMap<int32_t, ::test_pmr::FlagsSimple> f7;
    FinalModelMap<int32_t, std::optional<::test_pmr::FlagsSimple>> f8;
    FinalModelMap<int32_t, ::test_pmr::StructSimple> f9;
    FinalModelMap<int32_t, std::optional<::test_pmr::StructSimple>> f10;
};

namespace test_pmr {

// Fast Binary Encoding StructMap final model
class StructMapFinalModel : public FBE::Model
{
public:
    StructMapFinalModel() : _model(this->buffer(), 8) {}
    StructMapFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::test_pmr::StructMap>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::test_pmr::StructMap& value);
    // Deserialize the struct value
    size_t deserialize(::test_pmr::StructMap& value) const noexcept;
    // Deserialize the struct value with memory resource
    size_t deserialize(::test_pmr::StructMap& value, std::pmr::memory_resource* resource) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::test_pmr::StructMap> _model;
};

} // namespace test_pmr

// Fast Binary Encoding ::test_pmr::StructHash final model
template <>
class FinalModel<::test_pmr::StructHash>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::test_pmr::StructHash& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 141; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::test_pmr::StructHash& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::test_pmr::StructHash& fbe_value) const noexcept;
    // Get the struct value with memory resource
    size_t get(::test_pmr::StructHash& fbe_value, std::pmr::memory_resource* resource) const noexcept;
    // Get the struct fields values with memory resource
    size_t get_fields(::test_pmr::StructHash& fbe_value, std::pmr::memory_resource* resource) const noexcept;

    // Set the struct value
    size_t set(const ::test_pmr::StructHash& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::test_pmr::StructHash& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelMap<ArenaString, uint8_t> f1;
    FinalModelMap<ArenaString, std::optional<uint8_t>> f2;
    FinalModelMap<ArenaString, FBE::pmr_buffer_t> f3;
    FinalModelMap<ArenaString, std::optional<FBE::pmr_buffer_t>> f4;
    FinalModelMap<ArenaString, ::test_pmr::EnumSimple> f5;
    FinalModelMap<ArenaString, std::optional<::test_pmr::EnumSimple>> f6;
    FinalModelMap<ArenaString, ::test_pmr::FlagsSimple> f7;
    FinalModelMap<ArenaString, std::optional<::test_pmr::FlagsSimple>> f8;
    FinalModelMap<ArenaString, ::test_pmr::StructSimple> f9;
    FinalModelMap<ArenaString, std::optional<::test_pmr::StructSimple>> f10;
};

namespace test_pmr {

// Fast Binary Encoding StructHash final model
class StructHashFinalModel : public FBE::Model
{
public:
    StructHashFinalModel() : _model(this->buffer(), 8) {}
    StructHashFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::test_pmr::StructHash>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::test_pmr::StructHash& value);
    // Deserialize the struct value
    size_t deserialize(::test_pmr::StructHash& value) const noexcept;
    // Deserialize the struct value with memory resource
    size_t deserialize(::test_pmr::StructHash& value, std::pmr::memory_resource* resource) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::test_pmr::StructHash> _model;
};

} // namespace test_pmr

// Fast Binary Encoding ::test_pmr::StructHashEx final model
template <>
class FinalModel<::test_pmr::StructHashEx>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::test_pmr::StructHashEx& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 142; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::test_pmr::StructHashEx& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::test_pmr::StructHashEx& fbe_value) const noexcept;
    // Get the struct value with memory resource
    size_t get(::test_pmr::StructHashEx& fbe_value, std::pmr::memory_resource* resource) const noexcept;
    // Get the struct fields values with memory resource
    size_t get_fields(::test_pmr::StructHashEx& fbe_value, std::pmr::memory_resource* resource) const noexcept;

    // Set the struct value
    size_t set(const ::test_pmr::StructHashEx& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::test_pmr::StructHashEx& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelMap<::test_pmr::StructSimple, ::test_pmr::StructNested> f1;
    FinalModelMap<::test_pmr::StructSimple, std::optional<::test_pmr::StructNested>> f2;
};

namespace test_pmr {

// Fast Binary Encoding StructHashEx final model
class StructHashExFinalModel : public FBE::Model
{
public:
    StructHashExFinalModel() : _model(this->buffer(), 8) {}
    StructHashExFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::test_pmr::StructHashEx>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::test_pmr::StructHashEx& value);
    // Deserialize the struct value
    size_t deserialize(::test_pmr::StructHashEx& value) const noexcept;
    // Deserialize the struct value with memory resource
    size_t deserialize(::test_pmr::StructHashEx& value, std::pmr::memory_resource* resource) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::test_pmr::StructHashEx> _model;
};

} // namespace test_pmr

// Fast Binary Encoding ::test_pmr::StructEmpty final model
template <>
class FinalModel<::test_pmr::StructEmpty>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::test_pmr::StructEmpty& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 143; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::test_pmr::StructEmpty& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::test_pmr::StructEmpty& fbe_value) const noexcept;
    // Get the struct value with memory resource
    size_t get(::test_pmr::StructEmpty& fbe_value, std::pmr::memory_resource* resource) const noexcept;
    // Get the struct fields values with memory resource
    size_t get_fields(::test_pmr::StructEmpty& fbe_value, std::pmr::memory_resource* resource) const noexcept;

    // Set the struct value
    size_t set(const ::test_pmr::StructEmpty& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::test_pmr::StructEmpty& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
};

namespace test_pmr {

// Fast Binary Encoding StructEmpty final model
class StructEmptyFinalModel : public FBE::Model
{
public:
    StructEmptyFinalModel() : _model(this->buffer(), 8) {}
    StructEmptyFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::test_pmr::StructEmpty>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::test_pmr::StructEmpty& value);
    // Deserialize the struct value
    size_t deserialize(::test_pmr::StructEmpty& value) const noexcept;
    // Deserialize the struct value with memory resource
    size_t deserialize(::test_pmr::StructEmpty& value, std::pmr::memory_resource* resource) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::test_pmr::StructEmpty> _model;
};

} // namespace test_pmr

// Fast Binary Encoding ::test_pmr::StructFieldNamedString final model
template <>
class FinalModel<::test_pmr::StructFieldNamedString>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::test_pmr::StructFieldNamedString& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 144; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::test_pmr::StructFieldNamedString& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::test_pmr::StructFieldNamedString& fbe_value) const noexcept;
    // Get the struct value with memory resource
    size_t get(::test_pmr::StructFieldNamedString& fbe_value, std::pmr::memory_resource* resource) const noexcept;
    // Get the struct fields values with memory resource
    size_t get_fields(::test_pmr::StructFieldNamedString& fbe_value, std::pmr::memory_resource* resource) const noexcept;

    // Set the struct value
    size_t set(const ::test_pmr::StructFieldNamedString& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::test_pmr::StructFieldNamedString& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<::test_pmr::StructEmpty> string;
};

namespace test_pmr {

// Fast Binary Encoding StructFieldNamedString final model
class StructFieldNamedStringFinalModel : public FBE::Model
{
public:
    StructFieldNamedStringFinalModel() : _model(this->buffer(), 8) {}
    StructFieldNamedStringFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::test_pmr::StructFieldNamedString>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::test_pmr::StructFieldNamedString& value);
    // Deserialize the struct value
    size_t deserialize(::test_pmr::StructFieldNamedString& value) const noexcept;
    // Deserialize the struct value with memory resource
    size_t deserialize(::test_pmr::StructFieldNamedString& value, std::pmr::memory_resource* resource) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::test_pmr::StructFieldNamedString> _model;
};

} // namespace test_pmr

// Fast Binary Encoding ::test_pmr::StringFieldNamedString final model
template <>
class FinalModel<::test_pmr::StringFieldNamedString>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::test_pmr::StringFieldNamedString& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 145; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::test_pmr::StringFieldNamedString& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::test_pmr::StringFieldNamedString& fbe_value) const noexcept;
    // Get the struct value with memory resource
    size_t get(::test_pmr::StringFieldNamedString& fbe_value, std::pmr::memory_resource* resource) const noexcept;
    // Get the struct fields values with memory resource
    size_t get_fields(::test_pmr::StringFieldNamedString& fbe_value, std::pmr::memory_resource* resource) const noexcept;

    // Set the struct value
    size_t set(const ::test_pmr::StringFieldNamedString& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::test_pmr::StringFieldNamedString& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<ArenaString> string;
};

namespace test_pmr {

// Fast Binary Encoding StringFieldNamedString final model
class StringFieldNamedStringFinalModel : public FBE::Model
{
public:
    StringFieldNamedStringFinalModel() : _model(this->buffer(), 8) {}
    StringFieldNamedStringFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::test_pmr::StringFieldNamedString>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::test_pmr::StringFieldNamedString& value);
    // Deserialize the struct value
    size_t deserialize(::test_pmr::StringFieldNamedString& value) const noexcept;
    // Deserialize the struct value with memory resource
    size_t deserialize(::test_pmr::StringFieldNamedString& value, std::pmr::memory_resource* resource) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::test_pmr::StringFieldNamedString> _model;
};

} // namespace test_pmr

// Fast Binary Encoding ::test_pmr::OptionalFieldNamedString final model
template <>
class FinalModel<::test_pmr::OptionalFieldNamedString>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::test_pmr::OptionalFieldNamedString& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 146; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::test_pmr::OptionalFieldNamedString& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::test_pmr::OptionalFieldNamedString& fbe_value) const noexcept;
    // Get the struct value with memory resource
    size_t get(::test_pmr::OptionalFieldNamedString& fbe_value, std::pmr::memory_resource* resource) const noexcept;
    // Get the struct fields values with memory resource
    size_t get_fields(::test_pmr::OptionalFieldNamedString& fbe_value, std::pmr::memory_resource* resource) const noexcept;

    // Set the struct value
    size_t set(const ::test_pmr::OptionalFieldNamedString& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::test_pmr::OptionalFieldNamedString& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<std::optional<ArenaString>> string;
};

namespace test_pmr {

// Fast Binary Encoding OptionalFieldNamedString final model
class OptionalFieldNamedStringFinalModel : public FBE::Model
{
public:
    OptionalFieldNamedStringFinalModel() : _model(this->buffer(), 8) {}
    OptionalFieldNamedStringFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::test_pmr::OptionalFieldNamedString>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::test_pmr::OptionalFieldNamedString& value);
    // Deserialize the struct value
    size_t deserialize(::test_pmr::OptionalFieldNamedString& value) const noexcept;
    // Deserialize the struct value with memory resource
    size_t deserialize(::test_pmr::OptionalFieldNamedString& value, std::pmr::memory_resource* resource) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::test_pmr::OptionalFieldNamedString> _model;
};

} // namespace test_pmr

// Fast Binary Encoding ::test_pmr::ArrayFieldNamedString final model
template <>
class FinalModel<::test_pmr::ArrayFieldNamedString>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::test_pmr::ArrayFieldNamedString& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 147; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::test_pmr::ArrayFieldNamedString& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::test_pmr::ArrayFieldNamedString& fbe_value) const noexcept;
    // Get the struct value with memory resource
    size_t get(::test_pmr::ArrayFieldNamedString& fbe_value, std::pmr::memory_resource* resource) const noexcept;
    // Get the struct fields values with memory resource
    size_t get_fields(::test_pmr::ArrayFieldNamedString& fbe_value, std::pmr::memory_resource* resource) const noexcept;

    // Set the struct value
    size_t set(const ::test_pmr::ArrayFieldNamedString& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::test_pmr::ArrayFieldNamedString& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelArray<ArenaString, 4> string;
};

namespace test_pmr {

// Fast Binary Encoding ArrayFieldNamedString final model
class ArrayFieldNamedStringFinalModel : public FBE::Model
{
public:
    ArrayFieldNamedStringFinalModel() : _model(this->buffer(), 8) {}
    ArrayFieldNamedStringFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::test_pmr::ArrayFieldNamedString>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::test_pmr::ArrayFieldNamedString& value);
    // Deserialize the struct value
    size_t deserialize(::test_pmr::ArrayFieldNamedString& value) const noexcept;
    // Deserialize the struct value with memory resource
    size_t deserialize(::test_pmr::ArrayFieldNamedString& value, std::pmr::memory_resource* resource) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::test_pmr::ArrayFieldNamedString> _model;
};

} // namespace test_pmr

// Fast Binary Encoding ::test_pmr::VectorFieldNamedString final model
template <>
class FinalModel<::test_pmr::VectorFieldNamedString>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::test_pmr::VectorFieldNamedString& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 148; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::test_pmr::VectorFieldNamedString& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::test_pmr::VectorFieldNamedString& fbe_value) const noexcept;
    // Get the struct value with memory resource
    size_t get(::test_pmr::VectorFieldNamedString& fbe_value, std::pmr::memory_resource* resource) const noexcept;
    // Get the struct fields values with memory resource
    size_t get_fields(::test_pmr::VectorFieldNamedString& fbe_value, std::pmr::memory_resource* resource) const noexcept;

    // Set the struct value
    size_t set(const ::test_pmr::VectorFieldNamedString& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::test_pmr::VectorFieldNamedString& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelVector<ArenaString> string;
};

namespace test_pmr {

// Fast Binary Encoding VectorFieldNamedString final model
class VectorFieldNamedStringFinalModel : public FBE::Model
{
public:
    VectorFieldNamedStringFinalModel() : _model(this->buffer(), 8) {}
    VectorFieldNamedStringFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::test_pmr::VectorFieldNamedString>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::test_pmr::VectorFieldNamedString& value);
    // Deserialize the struct value
    size_t deserialize(::test_pmr::VectorFieldNamedString& value) const noexcept;
    // Deserialize the struct value with memory resource
    size_t deserialize(::test_pmr::VectorFieldNamedString& value, std::pmr::memory_resource* resource) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::test_pmr::VectorFieldNamedString> _model;
};

} // namespace test_pmr

// Fast Binary Encoding ::test_pmr::BytesFieldNamedString final model
template <>
class FinalModel<::test_pmr::BytesFieldNamedString>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::test_pmr::BytesFieldNamedString& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 149; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::test_pmr::BytesFieldNamedString& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::test_pmr::BytesFieldNamedString& fbe_value) const noexcept;
    // Get the struct value with memory resource
    size_t get(::test_pmr::BytesFieldNamedString& fbe_value, std::pmr::memory_resource* resource) const noexcept;
    // Get the struct fields values with memory resource
    size_t get_fields(::test_pmr::BytesFieldNamedString& fbe_value, std::pmr::memory_resource* resource) const noexcept;

    // Set the struct value
    size_t set(const ::test_pmr::BytesFieldNamedString& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::test_pmr::BytesFieldNamedString& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<FBE::pmr_buffer_t> string;
};

namespace test_pmr {

// Fast Binary Encoding BytesFieldNamedString final model
class BytesFieldNamedStringFinalModel : public FBE::Model
{
public:
    BytesFieldNamedStringFinalModel() : _model(this->buffer(), 8) {}
    BytesFieldNamedStringFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::test_pmr::BytesFieldNamedString>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::test_pmr::BytesFieldNamedString& value);
    // Deserialize the struct value
    size_t deserialize(::test_pmr::BytesFieldNamedString& value) const noexcept;
    // Deserialize the struct value with memory resource
    size_t deserialize(::test_pmr::BytesFieldNamedString& value, std::pmr::memory_resource* resource) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::test_pmr::BytesFieldNamedString> _model;
};

} // namespace test_pmr

} // namespace FBE
