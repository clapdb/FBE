//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: extra.fbe
// FBE version: 1.10.0.0
//------------------------------------------------------------------------------

#pragma once

#ifdef isset
#undef isset
#endif

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "fbe.h"
#include "arena/arena.hpp"

namespace extra_pmr {
using namespace FBE;
using allocator_type = pmr::polymorphic_allocator<char>;
} // namespace extra_pmr

namespace FBE {
using namespace ::extra_pmr;
} // namespace FBE

#include "fbe_ptr.h"

namespace extra_pmr {

struct Extra;

struct Info : FBE::Base
{
    ArenaManagedCreateOnlyTag;

    stdb::memory::arena_string info;
    ::extra_pmr::Extra* extra;
    pmr::vector<::extra_pmr::Extra*> extras;
    pmr::vector<::extra_pmr::Extra*> extras1;

    size_t fbe_type() const noexcept { return 1; }

    Info();
    explicit Info(allocator_type alloc);
    Info(const stdb::memory::arena_string& arg_info, std::unique_ptr<::extra_pmr::Extra> arg_extra, pmr::vector<std::unique_ptr<::extra_pmr::Extra>> arg_extras, pmr::vector<std::unique_ptr<::extra_pmr::Extra>> arg_extras1);
    Info(const Info& other) = default;
    Info(Info&& other) noexcept;
    ~Info() override;

    Info& operator=(const Info& other) = default;
    Info& operator=(Info&& other) noexcept;

    bool operator==(const Info& other) const noexcept;
    bool operator!=(const Info& other) const noexcept { return !operator==(other); }
    bool operator<(const Info& other) const noexcept;
    bool operator<=(const Info& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Info& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Info& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const Info& value);

    void swap(Info& other) noexcept;
    friend void swap(Info& value1, Info& value2) noexcept { value1.swap(value2); }
};

} // namespace extra_pmr

template<>
struct std::hash<extra_pmr::Info>
{
    typedef extra_pmr::Info argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

namespace extra_pmr {

struct Info;

struct Extra : FBE::Base
{
    ArenaManagedCreateOnlyTag;

    int64_t num;
    stdb::memory::arena_string data;
    ::extra_pmr::Info* info;
    ::extra_pmr::Info* info2;
    ::extra_pmr::Info info3;
    pmr::vector<::extra_pmr::Info> infov;
    pmr::vector<::extra_pmr::Info*> infopv;
    pmr::list<::extra_pmr::Info> infol;
    pmr::list<::extra_pmr::Info*> infopl;

    size_t fbe_type() const noexcept { return 2; }

    Extra();
    explicit Extra(allocator_type alloc);
    Extra(int64_t arg_num, const stdb::memory::arena_string& arg_data, std::unique_ptr<::extra_pmr::Info> arg_info, std::unique_ptr<::extra_pmr::Info> arg_info2, ::extra_pmr::Info arg_info3, pmr::vector<::extra_pmr::Info> arg_infov, pmr::vector<std::unique_ptr<::extra_pmr::Info>> arg_infopv, pmr::list<::extra_pmr::Info> arg_infol, pmr::list<std::unique_ptr<::extra_pmr::Info>> arg_infopl);
    Extra(const Extra& other) = default;
    Extra(Extra&& other) noexcept;
    ~Extra() override;

    Extra& operator=(const Extra& other) = default;
    Extra& operator=(Extra&& other) noexcept;

    bool operator==(const Extra& other) const noexcept;
    bool operator!=(const Extra& other) const noexcept { return !operator==(other); }
    bool operator<(const Extra& other) const noexcept;
    bool operator<=(const Extra& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Extra& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Extra& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, const Extra& value);

    void swap(Extra& other) noexcept;
    friend void swap(Extra& value1, Extra& value2) noexcept { value1.swap(value2); }
};

} // namespace extra_pmr

template<>
struct std::hash<extra_pmr::Extra>
{
    typedef extra_pmr::Extra argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

namespace extra_pmr {

} // namespace extra_pmr
