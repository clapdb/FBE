//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: cpp_only.fbe
// FBE version: 1.11.0.0
//------------------------------------------------------------------------------

#include "cpp_only.h"

namespace cpp_only {

Struct128::Struct128()
    : f1((__int128_t)0)
    , f2()
    , f3((__uint128_t)0)
    , f4()
{}

Struct128::Struct128(__int128_t arg_f1, const std::optional<__int128_t>& arg_f2, __uint128_t arg_f3, const std::optional<__uint128_t>& arg_f4)
    : f1(arg_f1)
    , f2(arg_f2)
    , f3(arg_f3)
    , f4(arg_f4)
{}

bool Struct128::operator==([[maybe_unused]] const Struct128& other) const noexcept
{
    return (
        (f1 == other.f1)
        && (f2 == other.f2)
        && (f3 == other.f3)
        && (f4 == other.f4)
        );
}

bool Struct128::operator<([[maybe_unused]] const Struct128& other) const noexcept
{
    return false;
}

std::string Struct128::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void Struct128::swap([[maybe_unused]] Struct128& other) noexcept
{
    using std::swap;
    swap(f1, other.f1);
    swap(f2, other.f2);
    swap(f3, other.f3);
    swap(f4, other.f4);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const Struct128& value)
{
    stream << "Struct128(";
    stream << "f1="; stream << "(int128) operator<< unimplemented";
    stream << ",f2="; if (value.f2) stream << "(optional int128) operator<< unimplemented"; else stream << "null";
    stream << ",f3="; stream << "(uint128) operator<< unimplemented";
    stream << ",f4="; if (value.f4) stream << "(optional uint128) operator<< unimplemented"; else stream << "null";
    stream << ")";
    return stream;
}

} // namespace cpp_only
