//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: extra.fbe
// FBE version: 1.11.0.0
//------------------------------------------------------------------------------

#include "extra_ptr_pmr.h"

namespace extra_pmr {

Info::Info()
    : info()
    , extra(nullptr)
    , extras()
    , extras1()
{}

Info::Info([[maybe_unused]] allocator_type alloc)
    : info(alloc)
    , extra(nullptr)
    , extras(alloc)
    , extras1(alloc)
{}

Info::Info(const stdb::memory::arena_string& arg_info, std::unique_ptr<::extra_pmr::Extra> arg_extra, pmr::vector<std::unique_ptr<::extra_pmr::Extra>> arg_extras, pmr::vector<std::unique_ptr<::extra_pmr::Extra>> arg_extras1)
    : info(arg_info)
    , extra(arg_extra.release())
    , extras()
    , extras1()
{
    extras.reserve(arg_extras.size());
    for (auto& it : arg_extras)
        #if defined(USING_STD_VECTOR)
        extras.emplace_back(it.release());
        #else
        extras.emplace_back(it.release());
        #endif
    extras1.reserve(arg_extras1.size());
    for (auto& it : arg_extras1)
        #if defined(USING_STD_VECTOR)
        extras1.emplace_back(it.release());
        #else
        extras1.emplace_back(it.release());
        #endif
}

Info::Info([[maybe_unused]] Info&& other) noexcept
    : info(std::move(other.info))
    , extra(std::exchange(other.extra, nullptr))
    , extras(std::move(other.extras))
    , extras1(std::move(other.extras1))
{}

Info::~Info()
{
    if (extra) delete extra;
    for (auto* it : extras)
        delete it;
    for (auto* it : extras1)
        delete it;
}

bool Info::operator==([[maybe_unused]] const Info& other) const noexcept
{
    if (info != other.info)
        return false;
    // compare ptr extra
    if ((extra  == nullptr && other.extra  != nullptr) || (extra  != nullptr && other.extra  == nullptr) || (extra  != nullptr && other.extra  != nullptr && *extra != *other.extra))
        return false;
    // compare container extras
    if (extras.size() != other.extras.size())
        return false;
    for (size_t i = 0; i < extras.size(); i++)
    {
        if (*extras[i] != *other.extras[i])
            return false;
    }
    // compare container extras1
    if (extras1.size() != other.extras1.size())
        return false;
    for (size_t i = 0; i < extras1.size(); i++)
    {
        if (*extras1[i] != *other.extras1[i])
            return false;
    }
    return true;
}

bool Info::operator<([[maybe_unused]] const Info& other) const noexcept
{
    return false;
}

Info& Info::operator=(Info&& other) noexcept
{
    if (this != &other)
    {
        info = std::move(other.info);
        extra = std::exchange(other.extra, nullptr);
        extras = std::move(other.extras);
        extras1 = std::move(other.extras1);
    }
    return *this;
}

std::string Info::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void Info::swap([[maybe_unused]] Info& other) noexcept
{
    using std::swap;
    swap(info, other.info);
    swap(extra, other.extra);
    swap(extras, other.extras);
    swap(extras1, other.extras1);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const Info& value)
{
    stream << "Info(";
    stream << "info="; stream << "\"" << value.info << "\"";
    stream << ",extra="; stream << "ptr of other struct: " << (value.extra == nullptr ? "nullptr" : "true");
    {
        bool first = true;
        stream << ",extras=[" << value.extras.size() << "][";
        for (const auto& it : value.extras)
        {
            stream << std::string(first ? "" : ",") << "ptr of other struct: " << (it == nullptr ? "nullptr" : "true");
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",extras1=[" << value.extras1.size() << "][";
        for (const auto& it : value.extras1)
        {
            stream << std::string(first ? "" : ",") << "ptr of other struct: " << (it == nullptr ? "nullptr" : "true");
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

Extra::Extra()
    : num((int64_t)0ll)
    , data()
    , info(nullptr)
    , info2(nullptr)
    , info3()
    , infov()
    , infopv()
    , infol()
    , infopl()
{}

Extra::Extra([[maybe_unused]] allocator_type alloc)
    : num((int64_t)0ll)
    , data(alloc)
    , info(nullptr)
    , info2(nullptr)
    , info3(alloc)
    , infov(alloc)
    , infopv(alloc)
    , infol(alloc)
    , infopl(alloc)
{}

Extra::Extra(int64_t arg_num, const stdb::memory::arena_string& arg_data, std::unique_ptr<::extra_pmr::Info> arg_info, std::unique_ptr<::extra_pmr::Info> arg_info2, ::extra_pmr::Info arg_info3, pmr::vector<::extra_pmr::Info> arg_infov, pmr::vector<std::unique_ptr<::extra_pmr::Info>> arg_infopv, pmr::list<::extra_pmr::Info> arg_infol, pmr::list<std::unique_ptr<::extra_pmr::Info>> arg_infopl)
    : num(arg_num)
    , data(arg_data)
    , info(arg_info.release())
    , info2(arg_info2.release())
    , info3(std::move(arg_info3))
    , infov(std::move(arg_infov))
    , infopv()
    , infol(std::move(arg_infol))
    , infopl()
{
    infopv.reserve(arg_infopv.size());
    for (auto& it : arg_infopv)
        #if defined(USING_STD_VECTOR)
        infopv.emplace_back(it.release());
        #else
        infopv.emplace_back(it.release());
        #endif
    for (auto& it : arg_infopl)
        infopl.emplace_back(it.release());
}

Extra::Extra([[maybe_unused]] Extra&& other) noexcept
    : num(std::exchange(other.num, (int64_t)0ll))
    , data(std::move(other.data))
    , info(std::exchange(other.info, nullptr))
    , info2(std::exchange(other.info2, nullptr))
    , info3(std::move(other.info3))
    , infov(std::move(other.infov))
    , infopv(std::move(other.infopv))
    , infol(std::move(other.infol))
    , infopl(std::move(other.infopl))
{}

Extra::~Extra()
{
    if (info) delete info;
    if (info2) delete info2;
    for (auto* it : infopv)
        delete it;
    for (auto* it : infopl)
        delete it;
}

bool Extra::operator==([[maybe_unused]] const Extra& other) const noexcept
{
    if (num != other.num)
        return false;
    if (data != other.data)
        return false;
    // compare ptr info
    if ((info  == nullptr && other.info  != nullptr) || (info  != nullptr && other.info  == nullptr) || (info  != nullptr && other.info  != nullptr && *info != *other.info))
        return false;
    // compare ptr info2
    if ((info2  == nullptr && other.info2  != nullptr) || (info2  != nullptr && other.info2  == nullptr) || (info2  != nullptr && other.info2  != nullptr && *info2 != *other.info2))
        return false;
    if (info3 != other.info3)
        return false;
    // compare container infov
    if (infov != other.infov)
        return false;
    // compare container infopv
    if (infopv.size() != other.infopv.size())
        return false;
    for (size_t i = 0; i < infopv.size(); i++)
    {
        if (*infopv[i] != *other.infopv[i])
            return false;
    }
    // compare container infol
    if (infol != other.infol)
        return false;
    // compare container infopl
    if (infopl.size() != other.infopl.size())
        return false;
    // compare list
    for (auto l_iter = infopl.begin(), r_iter = other.infopl.begin(); r_iter != other.infopl.end(); l_iter++, r_iter++) {
        if (**l_iter != **r_iter)
            return false;
    }
    return true;
}

bool Extra::operator<([[maybe_unused]] const Extra& other) const noexcept
{
    return false;
}

Extra& Extra::operator=(Extra&& other) noexcept
{
    if (this != &other)
    {
        num = std::exchange(other.num, (int64_t)0ll);
        data = std::move(other.data);
        info = std::exchange(other.info, nullptr);
        info2 = std::exchange(other.info2, nullptr);
        info3 = std::move(other.info3);
        infov = std::move(other.infov);
        infopv = std::move(other.infopv);
        infol = std::move(other.infol);
        infopl = std::move(other.infopl);
    }
    return *this;
}

std::string Extra::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void Extra::swap([[maybe_unused]] Extra& other) noexcept
{
    using std::swap;
    swap(num, other.num);
    swap(data, other.data);
    swap(info, other.info);
    swap(info2, other.info2);
    swap(info3, other.info3);
    swap(infov, other.infov);
    swap(infopv, other.infopv);
    swap(infol, other.infol);
    swap(infopl, other.infopl);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const Extra& value)
{
    stream << "Extra(";
    stream << "num="; stream << value.num;
    stream << ",data="; stream << "\"" << value.data << "\"";
    stream << ",info="; stream << "ptr of other struct: " << (value.info == nullptr ? "nullptr" : "true");
    stream << ",info2="; stream << "ptr of other struct: " << (value.info2 == nullptr ? "nullptr" : "true");
    stream << ",info3="; stream << value.info3;
    {
        bool first = true;
        stream << ",infov=[" << value.infov.size() << "][";
        for (const auto& it : value.infov)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",infopv=[" << value.infopv.size() << "][";
        for (const auto& it : value.infopv)
        {
            stream << std::string(first ? "" : ",") << "ptr of other struct: " << (it == nullptr ? "nullptr" : "true");
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",infol=[" << value.infol.size()<< "]<";
        for (const auto& it : value.infol)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << ">";
    }
    {
        bool first = true;
        stream << ",infopl=[" << value.infopl.size()<< "]<";
        for (const auto& it : value.infopl)
        {
            stream << std::string(first ? "" : ",") << "ptr of other struct: " << (it == nullptr ? "nullptr" : "true");
            first = false;
        }
        stream << ">";
    }
    stream << ")";
    return stream;
}

} // namespace extra_pmr
