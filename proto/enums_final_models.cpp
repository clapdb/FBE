//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: enums.fbe
// FBE version: 1.11.0.0
//------------------------------------------------------------------------------

#include "enums_final_models.h"

namespace FBE {

FinalModel<::enums::Enums>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , byte0(buffer, 0)
    , byte1(buffer, 0)
    , byte2(buffer, 0)
    , byte3(buffer, 0)
    , byte4(buffer, 0)
    , byte5(buffer, 0)
    , char0(buffer, 0)
    , char1(buffer, 0)
    , char2(buffer, 0)
    , char3(buffer, 0)
    , char4(buffer, 0)
    , char5(buffer, 0)
    , wchar0(buffer, 0)
    , wchar1(buffer, 0)
    , wchar2(buffer, 0)
    , wchar3(buffer, 0)
    , wchar4(buffer, 0)
    , wchar5(buffer, 0)
    , int8b0(buffer, 0)
    , int8b1(buffer, 0)
    , int8b2(buffer, 0)
    , int8b3(buffer, 0)
    , int8b4(buffer, 0)
    , int8b5(buffer, 0)
    , uint8b0(buffer, 0)
    , uint8b1(buffer, 0)
    , uint8b2(buffer, 0)
    , uint8b3(buffer, 0)
    , uint8b4(buffer, 0)
    , uint8b5(buffer, 0)
    , int16b0(buffer, 0)
    , int16b1(buffer, 0)
    , int16b2(buffer, 0)
    , int16b3(buffer, 0)
    , int16b4(buffer, 0)
    , int16b5(buffer, 0)
    , uint16b0(buffer, 0)
    , uint16b1(buffer, 0)
    , uint16b2(buffer, 0)
    , uint16b3(buffer, 0)
    , uint16b4(buffer, 0)
    , uint16b5(buffer, 0)
    , int32b0(buffer, 0)
    , int32b1(buffer, 0)
    , int32b2(buffer, 0)
    , int32b3(buffer, 0)
    , int32b4(buffer, 0)
    , int32b5(buffer, 0)
    , uint32b0(buffer, 0)
    , uint32b1(buffer, 0)
    , uint32b2(buffer, 0)
    , uint32b3(buffer, 0)
    , uint32b4(buffer, 0)
    , uint32b5(buffer, 0)
    , int64b0(buffer, 0)
    , int64b1(buffer, 0)
    , int64b2(buffer, 0)
    , int64b3(buffer, 0)
    , int64b4(buffer, 0)
    , int64b5(buffer, 0)
    , uint64b0(buffer, 0)
    , uint64b1(buffer, 0)
    , uint64b2(buffer, 0)
    , uint64b3(buffer, 0)
    , uint64b4(buffer, 0)
    , uint64b5(buffer, 0)
{}

size_t FinalModel<::enums::Enums>::fbe_allocation_size(const ::enums::Enums& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + byte0.fbe_allocation_size(fbe_value.byte0)
        + byte1.fbe_allocation_size(fbe_value.byte1)
        + byte2.fbe_allocation_size(fbe_value.byte2)
        + byte3.fbe_allocation_size(fbe_value.byte3)
        + byte4.fbe_allocation_size(fbe_value.byte4)
        + byte5.fbe_allocation_size(fbe_value.byte5)
        + char0.fbe_allocation_size(fbe_value.char0)
        + char1.fbe_allocation_size(fbe_value.char1)
        + char2.fbe_allocation_size(fbe_value.char2)
        + char3.fbe_allocation_size(fbe_value.char3)
        + char4.fbe_allocation_size(fbe_value.char4)
        + char5.fbe_allocation_size(fbe_value.char5)
        + wchar0.fbe_allocation_size(fbe_value.wchar0)
        + wchar1.fbe_allocation_size(fbe_value.wchar1)
        + wchar2.fbe_allocation_size(fbe_value.wchar2)
        + wchar3.fbe_allocation_size(fbe_value.wchar3)
        + wchar4.fbe_allocation_size(fbe_value.wchar4)
        + wchar5.fbe_allocation_size(fbe_value.wchar5)
        + int8b0.fbe_allocation_size(fbe_value.int8b0)
        + int8b1.fbe_allocation_size(fbe_value.int8b1)
        + int8b2.fbe_allocation_size(fbe_value.int8b2)
        + int8b3.fbe_allocation_size(fbe_value.int8b3)
        + int8b4.fbe_allocation_size(fbe_value.int8b4)
        + int8b5.fbe_allocation_size(fbe_value.int8b5)
        + uint8b0.fbe_allocation_size(fbe_value.uint8b0)
        + uint8b1.fbe_allocation_size(fbe_value.uint8b1)
        + uint8b2.fbe_allocation_size(fbe_value.uint8b2)
        + uint8b3.fbe_allocation_size(fbe_value.uint8b3)
        + uint8b4.fbe_allocation_size(fbe_value.uint8b4)
        + uint8b5.fbe_allocation_size(fbe_value.uint8b5)
        + int16b0.fbe_allocation_size(fbe_value.int16b0)
        + int16b1.fbe_allocation_size(fbe_value.int16b1)
        + int16b2.fbe_allocation_size(fbe_value.int16b2)
        + int16b3.fbe_allocation_size(fbe_value.int16b3)
        + int16b4.fbe_allocation_size(fbe_value.int16b4)
        + int16b5.fbe_allocation_size(fbe_value.int16b5)
        + uint16b0.fbe_allocation_size(fbe_value.uint16b0)
        + uint16b1.fbe_allocation_size(fbe_value.uint16b1)
        + uint16b2.fbe_allocation_size(fbe_value.uint16b2)
        + uint16b3.fbe_allocation_size(fbe_value.uint16b3)
        + uint16b4.fbe_allocation_size(fbe_value.uint16b4)
        + uint16b5.fbe_allocation_size(fbe_value.uint16b5)
        + int32b0.fbe_allocation_size(fbe_value.int32b0)
        + int32b1.fbe_allocation_size(fbe_value.int32b1)
        + int32b2.fbe_allocation_size(fbe_value.int32b2)
        + int32b3.fbe_allocation_size(fbe_value.int32b3)
        + int32b4.fbe_allocation_size(fbe_value.int32b4)
        + int32b5.fbe_allocation_size(fbe_value.int32b5)
        + uint32b0.fbe_allocation_size(fbe_value.uint32b0)
        + uint32b1.fbe_allocation_size(fbe_value.uint32b1)
        + uint32b2.fbe_allocation_size(fbe_value.uint32b2)
        + uint32b3.fbe_allocation_size(fbe_value.uint32b3)
        + uint32b4.fbe_allocation_size(fbe_value.uint32b4)
        + uint32b5.fbe_allocation_size(fbe_value.uint32b5)
        + int64b0.fbe_allocation_size(fbe_value.int64b0)
        + int64b1.fbe_allocation_size(fbe_value.int64b1)
        + int64b2.fbe_allocation_size(fbe_value.int64b2)
        + int64b3.fbe_allocation_size(fbe_value.int64b3)
        + int64b4.fbe_allocation_size(fbe_value.int64b4)
        + int64b5.fbe_allocation_size(fbe_value.int64b5)
        + uint64b0.fbe_allocation_size(fbe_value.uint64b0)
        + uint64b1.fbe_allocation_size(fbe_value.uint64b1)
        + uint64b2.fbe_allocation_size(fbe_value.uint64b2)
        + uint64b3.fbe_allocation_size(fbe_value.uint64b3)
        + uint64b4.fbe_allocation_size(fbe_value.uint64b4)
        + uint64b5.fbe_allocation_size(fbe_value.uint64b5)
        ;
    return fbe_result;
}

size_t FinalModel<::enums::Enums>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::enums::Enums>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    // Batch verify 66 fixed-size fields (216 bytes)
    {
        if ((_buffer.offset() + fbe_current_offset + 216) > _buffer.size())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += 216;
    }

    return fbe_current_offset;
}

size_t FinalModel<::enums::Enums>::get(::enums::Enums& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::enums::Enums>::get_fields([[maybe_unused]] ::enums::Enums& fbe_value) const noexcept
{
    // All fields are fixed-size - optimized batch read (216 bytes)
    size_t fbe_base_offset = _buffer.offset();
    if ((fbe_base_offset + 216) > _buffer.size())
        return 0;
    const uint8_t* fbe_data = _buffer.data() + fbe_base_offset;
    fbe_value.byte0 = static_cast<decltype(fbe_value.byte0)>(unaligned_load<uint8_t>(fbe_data + 0));
    fbe_value.byte1 = static_cast<decltype(fbe_value.byte1)>(unaligned_load<uint8_t>(fbe_data + 1));
    fbe_value.byte2 = static_cast<decltype(fbe_value.byte2)>(unaligned_load<uint8_t>(fbe_data + 2));
    fbe_value.byte3 = static_cast<decltype(fbe_value.byte3)>(unaligned_load<uint8_t>(fbe_data + 3));
    fbe_value.byte4 = static_cast<decltype(fbe_value.byte4)>(unaligned_load<uint8_t>(fbe_data + 4));
    fbe_value.byte5 = static_cast<decltype(fbe_value.byte5)>(unaligned_load<uint8_t>(fbe_data + 5));
    fbe_value.char0 = static_cast<decltype(fbe_value.char0)>(unaligned_load<uint8_t>(fbe_data + 6));
    fbe_value.char1 = static_cast<decltype(fbe_value.char1)>(unaligned_load<uint8_t>(fbe_data + 7));
    fbe_value.char2 = static_cast<decltype(fbe_value.char2)>(unaligned_load<uint8_t>(fbe_data + 8));
    fbe_value.char3 = static_cast<decltype(fbe_value.char3)>(unaligned_load<uint8_t>(fbe_data + 9));
    fbe_value.char4 = static_cast<decltype(fbe_value.char4)>(unaligned_load<uint8_t>(fbe_data + 10));
    fbe_value.char5 = static_cast<decltype(fbe_value.char5)>(unaligned_load<uint8_t>(fbe_data + 11));
    fbe_value.wchar0 = static_cast<decltype(fbe_value.wchar0)>(unaligned_load<uint32_t>(fbe_data + 12));
    fbe_value.wchar1 = static_cast<decltype(fbe_value.wchar1)>(unaligned_load<uint32_t>(fbe_data + 16));
    fbe_value.wchar2 = static_cast<decltype(fbe_value.wchar2)>(unaligned_load<uint32_t>(fbe_data + 20));
    fbe_value.wchar3 = static_cast<decltype(fbe_value.wchar3)>(unaligned_load<uint32_t>(fbe_data + 24));
    fbe_value.wchar4 = static_cast<decltype(fbe_value.wchar4)>(unaligned_load<uint32_t>(fbe_data + 28));
    fbe_value.wchar5 = static_cast<decltype(fbe_value.wchar5)>(unaligned_load<uint32_t>(fbe_data + 32));
    fbe_value.int8b0 = static_cast<decltype(fbe_value.int8b0)>(unaligned_load<int8_t>(fbe_data + 36));
    fbe_value.int8b1 = static_cast<decltype(fbe_value.int8b1)>(unaligned_load<int8_t>(fbe_data + 37));
    fbe_value.int8b2 = static_cast<decltype(fbe_value.int8b2)>(unaligned_load<int8_t>(fbe_data + 38));
    fbe_value.int8b3 = static_cast<decltype(fbe_value.int8b3)>(unaligned_load<int8_t>(fbe_data + 39));
    fbe_value.int8b4 = static_cast<decltype(fbe_value.int8b4)>(unaligned_load<int8_t>(fbe_data + 40));
    fbe_value.int8b5 = static_cast<decltype(fbe_value.int8b5)>(unaligned_load<int8_t>(fbe_data + 41));
    fbe_value.uint8b0 = static_cast<decltype(fbe_value.uint8b0)>(unaligned_load<uint8_t>(fbe_data + 42));
    fbe_value.uint8b1 = static_cast<decltype(fbe_value.uint8b1)>(unaligned_load<uint8_t>(fbe_data + 43));
    fbe_value.uint8b2 = static_cast<decltype(fbe_value.uint8b2)>(unaligned_load<uint8_t>(fbe_data + 44));
    fbe_value.uint8b3 = static_cast<decltype(fbe_value.uint8b3)>(unaligned_load<uint8_t>(fbe_data + 45));
    fbe_value.uint8b4 = static_cast<decltype(fbe_value.uint8b4)>(unaligned_load<uint8_t>(fbe_data + 46));
    fbe_value.uint8b5 = static_cast<decltype(fbe_value.uint8b5)>(unaligned_load<uint8_t>(fbe_data + 47));
    fbe_value.int16b0 = static_cast<decltype(fbe_value.int16b0)>(unaligned_load<int16_t>(fbe_data + 48));
    fbe_value.int16b1 = static_cast<decltype(fbe_value.int16b1)>(unaligned_load<int16_t>(fbe_data + 50));
    fbe_value.int16b2 = static_cast<decltype(fbe_value.int16b2)>(unaligned_load<int16_t>(fbe_data + 52));
    fbe_value.int16b3 = static_cast<decltype(fbe_value.int16b3)>(unaligned_load<int16_t>(fbe_data + 54));
    fbe_value.int16b4 = static_cast<decltype(fbe_value.int16b4)>(unaligned_load<int16_t>(fbe_data + 56));
    fbe_value.int16b5 = static_cast<decltype(fbe_value.int16b5)>(unaligned_load<int16_t>(fbe_data + 58));
    fbe_value.uint16b0 = static_cast<decltype(fbe_value.uint16b0)>(unaligned_load<uint16_t>(fbe_data + 60));
    fbe_value.uint16b1 = static_cast<decltype(fbe_value.uint16b1)>(unaligned_load<uint16_t>(fbe_data + 62));
    fbe_value.uint16b2 = static_cast<decltype(fbe_value.uint16b2)>(unaligned_load<uint16_t>(fbe_data + 64));
    fbe_value.uint16b3 = static_cast<decltype(fbe_value.uint16b3)>(unaligned_load<uint16_t>(fbe_data + 66));
    fbe_value.uint16b4 = static_cast<decltype(fbe_value.uint16b4)>(unaligned_load<uint16_t>(fbe_data + 68));
    fbe_value.uint16b5 = static_cast<decltype(fbe_value.uint16b5)>(unaligned_load<uint16_t>(fbe_data + 70));
    fbe_value.int32b0 = static_cast<decltype(fbe_value.int32b0)>(unaligned_load<int32_t>(fbe_data + 72));
    fbe_value.int32b1 = static_cast<decltype(fbe_value.int32b1)>(unaligned_load<int32_t>(fbe_data + 76));
    fbe_value.int32b2 = static_cast<decltype(fbe_value.int32b2)>(unaligned_load<int32_t>(fbe_data + 80));
    fbe_value.int32b3 = static_cast<decltype(fbe_value.int32b3)>(unaligned_load<int32_t>(fbe_data + 84));
    fbe_value.int32b4 = static_cast<decltype(fbe_value.int32b4)>(unaligned_load<int32_t>(fbe_data + 88));
    fbe_value.int32b5 = static_cast<decltype(fbe_value.int32b5)>(unaligned_load<int32_t>(fbe_data + 92));
    fbe_value.uint32b0 = static_cast<decltype(fbe_value.uint32b0)>(unaligned_load<uint32_t>(fbe_data + 96));
    fbe_value.uint32b1 = static_cast<decltype(fbe_value.uint32b1)>(unaligned_load<uint32_t>(fbe_data + 100));
    fbe_value.uint32b2 = static_cast<decltype(fbe_value.uint32b2)>(unaligned_load<uint32_t>(fbe_data + 104));
    fbe_value.uint32b3 = static_cast<decltype(fbe_value.uint32b3)>(unaligned_load<uint32_t>(fbe_data + 108));
    fbe_value.uint32b4 = static_cast<decltype(fbe_value.uint32b4)>(unaligned_load<uint32_t>(fbe_data + 112));
    fbe_value.uint32b5 = static_cast<decltype(fbe_value.uint32b5)>(unaligned_load<uint32_t>(fbe_data + 116));
    fbe_value.int64b0 = static_cast<decltype(fbe_value.int64b0)>(unaligned_load<int64_t>(fbe_data + 120));
    fbe_value.int64b1 = static_cast<decltype(fbe_value.int64b1)>(unaligned_load<int64_t>(fbe_data + 128));
    fbe_value.int64b2 = static_cast<decltype(fbe_value.int64b2)>(unaligned_load<int64_t>(fbe_data + 136));
    fbe_value.int64b3 = static_cast<decltype(fbe_value.int64b3)>(unaligned_load<int64_t>(fbe_data + 144));
    fbe_value.int64b4 = static_cast<decltype(fbe_value.int64b4)>(unaligned_load<int64_t>(fbe_data + 152));
    fbe_value.int64b5 = static_cast<decltype(fbe_value.int64b5)>(unaligned_load<int64_t>(fbe_data + 160));
    fbe_value.uint64b0 = static_cast<decltype(fbe_value.uint64b0)>(unaligned_load<uint64_t>(fbe_data + 168));
    fbe_value.uint64b1 = static_cast<decltype(fbe_value.uint64b1)>(unaligned_load<uint64_t>(fbe_data + 176));
    fbe_value.uint64b2 = static_cast<decltype(fbe_value.uint64b2)>(unaligned_load<uint64_t>(fbe_data + 184));
    fbe_value.uint64b3 = static_cast<decltype(fbe_value.uint64b3)>(unaligned_load<uint64_t>(fbe_data + 192));
    fbe_value.uint64b4 = static_cast<decltype(fbe_value.uint64b4)>(unaligned_load<uint64_t>(fbe_data + 200));
    fbe_value.uint64b5 = static_cast<decltype(fbe_value.uint64b5)>(unaligned_load<uint64_t>(fbe_data + 208));
    return 216;
}

size_t FinalModel<::enums::Enums>::set(const ::enums::Enums& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::enums::Enums>::set_fields([[maybe_unused]] const ::enums::Enums& fbe_value) noexcept
{
    // All fields are fixed-size - optimized batch write (216 bytes)
    size_t fbe_base_offset = _buffer.offset();
    assert(((fbe_base_offset + 216) <= _buffer.size()) && "Model is broken!");
    if ((fbe_base_offset + 216) > _buffer.size())
        return 0;
    uint8_t* fbe_data = _buffer.data() + fbe_base_offset;
    unaligned_store<uint8_t>(fbe_data + 0, static_cast<uint8_t>(fbe_value.byte0));
    unaligned_store<uint8_t>(fbe_data + 1, static_cast<uint8_t>(fbe_value.byte1));
    unaligned_store<uint8_t>(fbe_data + 2, static_cast<uint8_t>(fbe_value.byte2));
    unaligned_store<uint8_t>(fbe_data + 3, static_cast<uint8_t>(fbe_value.byte3));
    unaligned_store<uint8_t>(fbe_data + 4, static_cast<uint8_t>(fbe_value.byte4));
    unaligned_store<uint8_t>(fbe_data + 5, static_cast<uint8_t>(fbe_value.byte5));
    unaligned_store<uint8_t>(fbe_data + 6, static_cast<uint8_t>(fbe_value.char0));
    unaligned_store<uint8_t>(fbe_data + 7, static_cast<uint8_t>(fbe_value.char1));
    unaligned_store<uint8_t>(fbe_data + 8, static_cast<uint8_t>(fbe_value.char2));
    unaligned_store<uint8_t>(fbe_data + 9, static_cast<uint8_t>(fbe_value.char3));
    unaligned_store<uint8_t>(fbe_data + 10, static_cast<uint8_t>(fbe_value.char4));
    unaligned_store<uint8_t>(fbe_data + 11, static_cast<uint8_t>(fbe_value.char5));
    unaligned_store<uint32_t>(fbe_data + 12, static_cast<uint32_t>(fbe_value.wchar0));
    unaligned_store<uint32_t>(fbe_data + 16, static_cast<uint32_t>(fbe_value.wchar1));
    unaligned_store<uint32_t>(fbe_data + 20, static_cast<uint32_t>(fbe_value.wchar2));
    unaligned_store<uint32_t>(fbe_data + 24, static_cast<uint32_t>(fbe_value.wchar3));
    unaligned_store<uint32_t>(fbe_data + 28, static_cast<uint32_t>(fbe_value.wchar4));
    unaligned_store<uint32_t>(fbe_data + 32, static_cast<uint32_t>(fbe_value.wchar5));
    unaligned_store<int8_t>(fbe_data + 36, static_cast<int8_t>(fbe_value.int8b0));
    unaligned_store<int8_t>(fbe_data + 37, static_cast<int8_t>(fbe_value.int8b1));
    unaligned_store<int8_t>(fbe_data + 38, static_cast<int8_t>(fbe_value.int8b2));
    unaligned_store<int8_t>(fbe_data + 39, static_cast<int8_t>(fbe_value.int8b3));
    unaligned_store<int8_t>(fbe_data + 40, static_cast<int8_t>(fbe_value.int8b4));
    unaligned_store<int8_t>(fbe_data + 41, static_cast<int8_t>(fbe_value.int8b5));
    unaligned_store<uint8_t>(fbe_data + 42, static_cast<uint8_t>(fbe_value.uint8b0));
    unaligned_store<uint8_t>(fbe_data + 43, static_cast<uint8_t>(fbe_value.uint8b1));
    unaligned_store<uint8_t>(fbe_data + 44, static_cast<uint8_t>(fbe_value.uint8b2));
    unaligned_store<uint8_t>(fbe_data + 45, static_cast<uint8_t>(fbe_value.uint8b3));
    unaligned_store<uint8_t>(fbe_data + 46, static_cast<uint8_t>(fbe_value.uint8b4));
    unaligned_store<uint8_t>(fbe_data + 47, static_cast<uint8_t>(fbe_value.uint8b5));
    unaligned_store<int16_t>(fbe_data + 48, static_cast<int16_t>(fbe_value.int16b0));
    unaligned_store<int16_t>(fbe_data + 50, static_cast<int16_t>(fbe_value.int16b1));
    unaligned_store<int16_t>(fbe_data + 52, static_cast<int16_t>(fbe_value.int16b2));
    unaligned_store<int16_t>(fbe_data + 54, static_cast<int16_t>(fbe_value.int16b3));
    unaligned_store<int16_t>(fbe_data + 56, static_cast<int16_t>(fbe_value.int16b4));
    unaligned_store<int16_t>(fbe_data + 58, static_cast<int16_t>(fbe_value.int16b5));
    unaligned_store<uint16_t>(fbe_data + 60, static_cast<uint16_t>(fbe_value.uint16b0));
    unaligned_store<uint16_t>(fbe_data + 62, static_cast<uint16_t>(fbe_value.uint16b1));
    unaligned_store<uint16_t>(fbe_data + 64, static_cast<uint16_t>(fbe_value.uint16b2));
    unaligned_store<uint16_t>(fbe_data + 66, static_cast<uint16_t>(fbe_value.uint16b3));
    unaligned_store<uint16_t>(fbe_data + 68, static_cast<uint16_t>(fbe_value.uint16b4));
    unaligned_store<uint16_t>(fbe_data + 70, static_cast<uint16_t>(fbe_value.uint16b5));
    unaligned_store<int32_t>(fbe_data + 72, static_cast<int32_t>(fbe_value.int32b0));
    unaligned_store<int32_t>(fbe_data + 76, static_cast<int32_t>(fbe_value.int32b1));
    unaligned_store<int32_t>(fbe_data + 80, static_cast<int32_t>(fbe_value.int32b2));
    unaligned_store<int32_t>(fbe_data + 84, static_cast<int32_t>(fbe_value.int32b3));
    unaligned_store<int32_t>(fbe_data + 88, static_cast<int32_t>(fbe_value.int32b4));
    unaligned_store<int32_t>(fbe_data + 92, static_cast<int32_t>(fbe_value.int32b5));
    unaligned_store<uint32_t>(fbe_data + 96, static_cast<uint32_t>(fbe_value.uint32b0));
    unaligned_store<uint32_t>(fbe_data + 100, static_cast<uint32_t>(fbe_value.uint32b1));
    unaligned_store<uint32_t>(fbe_data + 104, static_cast<uint32_t>(fbe_value.uint32b2));
    unaligned_store<uint32_t>(fbe_data + 108, static_cast<uint32_t>(fbe_value.uint32b3));
    unaligned_store<uint32_t>(fbe_data + 112, static_cast<uint32_t>(fbe_value.uint32b4));
    unaligned_store<uint32_t>(fbe_data + 116, static_cast<uint32_t>(fbe_value.uint32b5));
    unaligned_store<int64_t>(fbe_data + 120, static_cast<int64_t>(fbe_value.int64b0));
    unaligned_store<int64_t>(fbe_data + 128, static_cast<int64_t>(fbe_value.int64b1));
    unaligned_store<int64_t>(fbe_data + 136, static_cast<int64_t>(fbe_value.int64b2));
    unaligned_store<int64_t>(fbe_data + 144, static_cast<int64_t>(fbe_value.int64b3));
    unaligned_store<int64_t>(fbe_data + 152, static_cast<int64_t>(fbe_value.int64b4));
    unaligned_store<int64_t>(fbe_data + 160, static_cast<int64_t>(fbe_value.int64b5));
    unaligned_store<uint64_t>(fbe_data + 168, static_cast<uint64_t>(fbe_value.uint64b0));
    unaligned_store<uint64_t>(fbe_data + 176, static_cast<uint64_t>(fbe_value.uint64b1));
    unaligned_store<uint64_t>(fbe_data + 184, static_cast<uint64_t>(fbe_value.uint64b2));
    unaligned_store<uint64_t>(fbe_data + 192, static_cast<uint64_t>(fbe_value.uint64b3));
    unaligned_store<uint64_t>(fbe_data + 200, static_cast<uint64_t>(fbe_value.uint64b4));
    unaligned_store<uint64_t>(fbe_data + 208, static_cast<uint64_t>(fbe_value.uint64b5));
    return 216;
}

namespace enums {

bool EnumsFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t EnumsFinalModel::serialize(const ::enums::Enums& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    unaligned_store<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8, fbe_struct_size);
    unaligned_store<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4, fbe_struct_type);

    return fbe_struct_size;
}

size_t EnumsFinalModel::deserialize(::enums::Enums& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

} // namespace enums

} // namespace FBE
