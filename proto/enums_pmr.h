//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: enums.fbe
// FBE version: 1.11.0.0
//------------------------------------------------------------------------------

#pragma once

#ifdef isset
#undef isset
#endif

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "fbe.h"
#include "arena/arena.hpp"

namespace enums_pmr {
using namespace FBE;
using allocator_type = pmr::polymorphic_allocator<char>;
} // namespace enums_pmr

namespace FBE {
using namespace ::enums_pmr;
} // namespace FBE

namespace enums_pmr {

enum class EnumByte : uint8_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (uint8_t)0u,
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (uint8_t)254u,
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] EnumByte value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, EnumByte value);
#endif

enum class EnumChar : uint8_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (char)'1',
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (char)'3',
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] EnumChar value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, EnumChar value);
#endif

enum class EnumWChar : uint32_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (wchar_t)0x0444,
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (wchar_t)0x0555,
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] EnumWChar value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, EnumWChar value);
#endif

enum class EnumInt8 : int8_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (int8_t)-128,
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (int8_t)126,
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] EnumInt8 value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, EnumInt8 value);
#endif

enum class EnumUInt8 : uint8_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (uint8_t)0u,
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (uint8_t)254u,
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] EnumUInt8 value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, EnumUInt8 value);
#endif

enum class EnumInt16 : int16_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (int16_t)-32768,
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (int16_t)32766,
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] EnumInt16 value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, EnumInt16 value);
#endif

enum class EnumUInt16 : uint16_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (uint16_t)0u,
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (uint16_t)65534u,
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] EnumUInt16 value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, EnumUInt16 value);
#endif

enum class EnumInt32 : int32_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (int32_t)-2147483648ll,
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (int32_t)2147483646ll,
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] EnumInt32 value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, EnumInt32 value);
#endif

enum class EnumUInt32 : uint32_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (uint32_t)0ull,
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (uint32_t)0xFFFFFFFEull,
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] EnumUInt32 value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, EnumUInt32 value);
#endif

enum class EnumInt64 : int64_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (int64_t)-9223372036854775807ll,
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (int64_t)9223372036854775806ll,
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] EnumInt64 value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, EnumInt64 value);
#endif

enum class EnumUInt64 : uint64_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (uint64_t)0ull,
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (uint64_t)0xFFFFFFFFFFFFFFFEull,
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] EnumUInt64 value);

#if defined(LOGGING_PROTOCOL)
CppLogging::Record& operator<<(CppLogging::Record& record, EnumUInt64 value);
#endif

struct Enums
{
    ArenaManagedCreateOnlyTag;

    ::enums_pmr::EnumByte byte0;
    ::enums_pmr::EnumByte byte1;
    ::enums_pmr::EnumByte byte2;
    ::enums_pmr::EnumByte byte3;
    ::enums_pmr::EnumByte byte4;
    ::enums_pmr::EnumByte byte5;
    ::enums_pmr::EnumChar char0;
    ::enums_pmr::EnumChar char1;
    ::enums_pmr::EnumChar char2;
    ::enums_pmr::EnumChar char3;
    ::enums_pmr::EnumChar char4;
    ::enums_pmr::EnumChar char5;
    ::enums_pmr::EnumWChar wchar0;
    ::enums_pmr::EnumWChar wchar1;
    ::enums_pmr::EnumWChar wchar2;
    ::enums_pmr::EnumWChar wchar3;
    ::enums_pmr::EnumWChar wchar4;
    ::enums_pmr::EnumWChar wchar5;
    ::enums_pmr::EnumInt8 int8b0;
    ::enums_pmr::EnumInt8 int8b1;
    ::enums_pmr::EnumInt8 int8b2;
    ::enums_pmr::EnumInt8 int8b3;
    ::enums_pmr::EnumInt8 int8b4;
    ::enums_pmr::EnumInt8 int8b5;
    ::enums_pmr::EnumUInt8 uint8b0;
    ::enums_pmr::EnumUInt8 uint8b1;
    ::enums_pmr::EnumUInt8 uint8b2;
    ::enums_pmr::EnumUInt8 uint8b3;
    ::enums_pmr::EnumUInt8 uint8b4;
    ::enums_pmr::EnumUInt8 uint8b5;
    ::enums_pmr::EnumInt16 int16b0;
    ::enums_pmr::EnumInt16 int16b1;
    ::enums_pmr::EnumInt16 int16b2;
    ::enums_pmr::EnumInt16 int16b3;
    ::enums_pmr::EnumInt16 int16b4;
    ::enums_pmr::EnumInt16 int16b5;
    ::enums_pmr::EnumUInt16 uint16b0;
    ::enums_pmr::EnumUInt16 uint16b1;
    ::enums_pmr::EnumUInt16 uint16b2;
    ::enums_pmr::EnumUInt16 uint16b3;
    ::enums_pmr::EnumUInt16 uint16b4;
    ::enums_pmr::EnumUInt16 uint16b5;
    ::enums_pmr::EnumInt32 int32b0;
    ::enums_pmr::EnumInt32 int32b1;
    ::enums_pmr::EnumInt32 int32b2;
    ::enums_pmr::EnumInt32 int32b3;
    ::enums_pmr::EnumInt32 int32b4;
    ::enums_pmr::EnumInt32 int32b5;
    ::enums_pmr::EnumUInt32 uint32b0;
    ::enums_pmr::EnumUInt32 uint32b1;
    ::enums_pmr::EnumUInt32 uint32b2;
    ::enums_pmr::EnumUInt32 uint32b3;
    ::enums_pmr::EnumUInt32 uint32b4;
    ::enums_pmr::EnumUInt32 uint32b5;
    ::enums_pmr::EnumInt64 int64b0;
    ::enums_pmr::EnumInt64 int64b1;
    ::enums_pmr::EnumInt64 int64b2;
    ::enums_pmr::EnumInt64 int64b3;
    ::enums_pmr::EnumInt64 int64b4;
    ::enums_pmr::EnumInt64 int64b5;
    ::enums_pmr::EnumUInt64 uint64b0;
    ::enums_pmr::EnumUInt64 uint64b1;
    ::enums_pmr::EnumUInt64 uint64b2;
    ::enums_pmr::EnumUInt64 uint64b3;
    ::enums_pmr::EnumUInt64 uint64b4;
    ::enums_pmr::EnumUInt64 uint64b5;

    size_t fbe_type() const noexcept { return 1; }

    Enums();
    explicit Enums(allocator_type alloc);
    Enums(const ::enums_pmr::EnumByte& arg_byte0, const ::enums_pmr::EnumByte& arg_byte1, const ::enums_pmr::EnumByte& arg_byte2, const ::enums_pmr::EnumByte& arg_byte3, const ::enums_pmr::EnumByte& arg_byte4, const ::enums_pmr::EnumByte& arg_byte5, const ::enums_pmr::EnumChar& arg_char0, const ::enums_pmr::EnumChar& arg_char1, const ::enums_pmr::EnumChar& arg_char2, const ::enums_pmr::EnumChar& arg_char3, const ::enums_pmr::EnumChar& arg_char4, const ::enums_pmr::EnumChar& arg_char5, const ::enums_pmr::EnumWChar& arg_wchar0, const ::enums_pmr::EnumWChar& arg_wchar1, const ::enums_pmr::EnumWChar& arg_wchar2, const ::enums_pmr::EnumWChar& arg_wchar3, const ::enums_pmr::EnumWChar& arg_wchar4, const ::enums_pmr::EnumWChar& arg_wchar5, const ::enums_pmr::EnumInt8& arg_int8b0, const ::enums_pmr::EnumInt8& arg_int8b1, const ::enums_pmr::EnumInt8& arg_int8b2, const ::enums_pmr::EnumInt8& arg_int8b3, const ::enums_pmr::EnumInt8& arg_int8b4, const ::enums_pmr::EnumInt8& arg_int8b5, const ::enums_pmr::EnumUInt8& arg_uint8b0, const ::enums_pmr::EnumUInt8& arg_uint8b1, const ::enums_pmr::EnumUInt8& arg_uint8b2, const ::enums_pmr::EnumUInt8& arg_uint8b3, const ::enums_pmr::EnumUInt8& arg_uint8b4, const ::enums_pmr::EnumUInt8& arg_uint8b5, const ::enums_pmr::EnumInt16& arg_int16b0, const ::enums_pmr::EnumInt16& arg_int16b1, const ::enums_pmr::EnumInt16& arg_int16b2, const ::enums_pmr::EnumInt16& arg_int16b3, const ::enums_pmr::EnumInt16& arg_int16b4, const ::enums_pmr::EnumInt16& arg_int16b5, const ::enums_pmr::EnumUInt16& arg_uint16b0, const ::enums_pmr::EnumUInt16& arg_uint16b1, const ::enums_pmr::EnumUInt16& arg_uint16b2, const ::enums_pmr::EnumUInt16& arg_uint16b3, const ::enums_pmr::EnumUInt16& arg_uint16b4, const ::enums_pmr::EnumUInt16& arg_uint16b5, const ::enums_pmr::EnumInt32& arg_int32b0, const ::enums_pmr::EnumInt32& arg_int32b1, const ::enums_pmr::EnumInt32& arg_int32b2, const ::enums_pmr::EnumInt32& arg_int32b3, const ::enums_pmr::EnumInt32& arg_int32b4, const ::enums_pmr::EnumInt32& arg_int32b5, const ::enums_pmr::EnumUInt32& arg_uint32b0, const ::enums_pmr::EnumUInt32& arg_uint32b1, const ::enums_pmr::EnumUInt32& arg_uint32b2, const ::enums_pmr::EnumUInt32& arg_uint32b3, const ::enums_pmr::EnumUInt32& arg_uint32b4, const ::enums_pmr::EnumUInt32& arg_uint32b5, const ::enums_pmr::EnumInt64& arg_int64b0, const ::enums_pmr::EnumInt64& arg_int64b1, const ::enums_pmr::EnumInt64& arg_int64b2, const ::enums_pmr::EnumInt64& arg_int64b3, const ::enums_pmr::EnumInt64& arg_int64b4, const ::enums_pmr::EnumInt64& arg_int64b5, const ::enums_pmr::EnumUInt64& arg_uint64b0, const ::enums_pmr::EnumUInt64& arg_uint64b1, const ::enums_pmr::EnumUInt64& arg_uint64b2, const ::enums_pmr::EnumUInt64& arg_uint64b3, const ::enums_pmr::EnumUInt64& arg_uint64b4, const ::enums_pmr::EnumUInt64& arg_uint64b5);
    Enums(const Enums& other) = default;
    Enums(Enums&& other) = default;
    ~Enums() = default;

    Enums& operator=(const Enums& other) = default;
    Enums& operator=(Enums&& other) = default;

    bool operator==(const Enums& other) const noexcept;
    bool operator!=(const Enums& other) const noexcept { return !operator==(other); }
    bool operator<(const Enums& other) const noexcept;
    bool operator<=(const Enums& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Enums& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Enums& other) const noexcept { return !operator<(other); }

    std::string string() const;

    friend std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const Enums& value);

    void swap(Enums& other) noexcept;
    friend void swap(Enums& value1, Enums& value2) noexcept { value1.swap(value2); }
};

} // namespace enums_pmr

template<>
struct std::hash<enums_pmr::Enums>
{
    typedef enums_pmr::Enums argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

namespace enums_pmr {

} // namespace enums_pmr
