//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: variants_ptr.fbe
// FBE version: 1.11.0.0
//------------------------------------------------------------------------------

#pragma once

#ifdef isset
#undef isset
#endif

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "fbe.h"
#include "arena/arena.hpp"

namespace variants_ptr_pmr {
using namespace FBE;
using allocator_type = std::pmr::polymorphic_allocator<char>;
} // namespace variants_ptr_pmr

namespace FBE {
using namespace ::variants_ptr_pmr;
} // namespace FBE

#include "fbe_ptr.h"

namespace variants_ptr_pmr {
// forward declaration
struct Simple;
struct ExprContainer;
struct Value;
struct ValueContainer;
struct Scalar1Container;

using Expr = std::variant<std::monostate, bool, ArenaString, int32_t, std::pmr::vector<uint8_t>>;
std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const Expr& value);
auto is_equal(const Expr& lhs, const Expr& rhs) -> bool;

using V = std::variant<std::monostate, int32_t, ArenaString, double, ::variants_ptr_pmr::Simple, ::variants_ptr_pmr::Simple*, std::pmr::vector<::variants_ptr_pmr::Simple>, std::pmr::vector<int32_t>, FBE::pmr::HashMap<int32_t, ::variants_ptr_pmr::Simple>, std::pmr::vector<FBE::pmr_buffer_t>, std::pmr::vector<ArenaString>, FBE::pmr::HashMap<int32_t, FBE::pmr_buffer_t>, FBE::pmr::HashMap<ArenaString, FBE::pmr_buffer_t>, std::pmr::vector<::variants_ptr_pmr::Simple*>, ::variants_ptr_pmr::Expr>;
std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const V& value);
auto is_equal(const V& lhs, const V& rhs) -> bool;

using Scalar1 = std::variant<std::monostate, bool, int32_t, int64_t, ArenaString>;
std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const Scalar1& value);
auto is_equal(const Scalar1& lhs, const Scalar1& rhs) -> bool;

struct Simple : FBE::Base
{
    ArenaManagedCreateOnlyTag;

    ArenaString name;

    size_t fbe_type() const noexcept { return 1; }

    Simple();
    explicit Simple(allocator_type alloc);
    explicit Simple(const ArenaString& arg_name);
    Simple(const Simple& other) = default;
    Simple(Simple&& other) noexcept;
    ~Simple() override;

    Simple& operator=(const Simple& other) = default;
    Simple& operator=(Simple&& other) noexcept;

    bool operator==(const Simple& other) const noexcept;
    bool operator!=(const Simple& other) const noexcept { return !operator==(other); }
    bool operator<(const Simple& other) const noexcept;
    bool operator<=(const Simple& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Simple& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Simple& other) const noexcept { return !operator<(other); }

    std::string to_string() const;

    friend std::ostream& operator<<(std::ostream& stream, const Simple& value);

    void swap(Simple& other) noexcept;
    friend void swap(Simple& value1, Simple& value2) noexcept { value1.swap(value2); }
};

} // namespace variants_ptr_pmr

template<>
struct std::hash<variants_ptr_pmr::Simple>
{
    typedef variants_ptr_pmr::Simple argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

namespace variants_ptr_pmr {

struct ExprContainer : FBE::Base
{
    ArenaManagedCreateOnlyTag;

    ::variants_ptr_pmr::Expr e;
    std::optional<::variants_ptr_pmr::Expr> eo;
    std::optional<::variants_ptr_pmr::Simple> so;

    size_t fbe_type() const noexcept { return 2; }

    ExprContainer();
    explicit ExprContainer(allocator_type alloc);
    ExprContainer(::variants_ptr_pmr::Expr arg_e, std::optional<::variants_ptr_pmr::Expr> arg_eo, std::optional<::variants_ptr_pmr::Simple> arg_so);
    ExprContainer(const ExprContainer& other) = default;
    ExprContainer(ExprContainer&& other) noexcept;
    ~ExprContainer() override;

    ExprContainer& operator=(const ExprContainer& other) = default;
    ExprContainer& operator=(ExprContainer&& other) noexcept;

    bool operator==(const ExprContainer& other) const noexcept;
    bool operator!=(const ExprContainer& other) const noexcept { return !operator==(other); }
    bool operator<(const ExprContainer& other) const noexcept;
    bool operator<=(const ExprContainer& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ExprContainer& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ExprContainer& other) const noexcept { return !operator<(other); }

    std::string to_string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ExprContainer& value);

    void swap(ExprContainer& other) noexcept;
    friend void swap(ExprContainer& value1, ExprContainer& value2) noexcept { value1.swap(value2); }
};

} // namespace variants_ptr_pmr

template<>
struct std::hash<variants_ptr_pmr::ExprContainer>
{
    typedef variants_ptr_pmr::ExprContainer argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

namespace variants_ptr_pmr {

struct Value : FBE::Base
{
    ArenaManagedCreateOnlyTag;

    ::variants_ptr_pmr::V v;
    std::optional<::variants_ptr_pmr::V> vo;
    std::optional<::variants_ptr_pmr::V> vo2;

    size_t fbe_type() const noexcept { return 3; }

    Value();
    explicit Value(allocator_type alloc);
    Value(::variants_ptr_pmr::V arg_v, std::optional<::variants_ptr_pmr::V> arg_vo, std::optional<::variants_ptr_pmr::V> arg_vo2);
    Value(const Value& other) = default;
    Value(Value&& other) noexcept;
    ~Value() override;

    Value& operator=(const Value& other) = default;
    Value& operator=(Value&& other) noexcept;

    bool operator==(const Value& other) const noexcept;
    bool operator!=(const Value& other) const noexcept { return !operator==(other); }
    bool operator<(const Value& other) const noexcept;
    bool operator<=(const Value& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Value& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Value& other) const noexcept { return !operator<(other); }

    std::string to_string() const;

    friend std::ostream& operator<<(std::ostream& stream, const Value& value);

    void swap(Value& other) noexcept;
    friend void swap(Value& value1, Value& value2) noexcept { value1.swap(value2); }
};

} // namespace variants_ptr_pmr

template<>
struct std::hash<variants_ptr_pmr::Value>
{
    typedef variants_ptr_pmr::Value argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

namespace variants_ptr_pmr {

struct ValueContainer : FBE::Base
{
    ArenaManagedCreateOnlyTag;

    std::pmr::vector<::variants_ptr_pmr::V> vv;
    FBE::pmr::HashMap<int32_t, ::variants_ptr_pmr::V> vm;

    size_t fbe_type() const noexcept { return 4; }

    ValueContainer();
    explicit ValueContainer(allocator_type alloc);
    ValueContainer(std::pmr::vector<::variants_ptr_pmr::V> arg_vv, FBE::pmr::HashMap<int32_t, ::variants_ptr_pmr::V> arg_vm);
    ValueContainer(const ValueContainer& other) = default;
    ValueContainer(ValueContainer&& other) noexcept;
    ~ValueContainer() override;

    ValueContainer& operator=(const ValueContainer& other) = default;
    ValueContainer& operator=(ValueContainer&& other) noexcept;

    bool operator==(const ValueContainer& other) const noexcept;
    bool operator!=(const ValueContainer& other) const noexcept { return !operator==(other); }
    bool operator<(const ValueContainer& other) const noexcept;
    bool operator<=(const ValueContainer& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const ValueContainer& other) const noexcept { return !operator<=(other); }
    bool operator>=(const ValueContainer& other) const noexcept { return !operator<(other); }

    std::string to_string() const;

    friend std::ostream& operator<<(std::ostream& stream, const ValueContainer& value);

    void swap(ValueContainer& other) noexcept;
    friend void swap(ValueContainer& value1, ValueContainer& value2) noexcept { value1.swap(value2); }
};

} // namespace variants_ptr_pmr

template<>
struct std::hash<variants_ptr_pmr::ValueContainer>
{
    typedef variants_ptr_pmr::ValueContainer argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

namespace variants_ptr_pmr {

struct Scalar1Container : FBE::Base
{
    ArenaManagedCreateOnlyTag;

    FBE::pmr::HashMap<::variants_ptr_pmr::Scalar1, ::variants_ptr_pmr::Expr> s;

    size_t fbe_type() const noexcept { return 5; }

    Scalar1Container();
    explicit Scalar1Container(allocator_type alloc);
    explicit Scalar1Container(FBE::pmr::HashMap<::variants_ptr_pmr::Scalar1, ::variants_ptr_pmr::Expr> arg_s);
    Scalar1Container(const Scalar1Container& other) = default;
    Scalar1Container(Scalar1Container&& other) noexcept;
    ~Scalar1Container() override;

    Scalar1Container& operator=(const Scalar1Container& other) = default;
    Scalar1Container& operator=(Scalar1Container&& other) noexcept;

    bool operator==(const Scalar1Container& other) const noexcept;
    bool operator!=(const Scalar1Container& other) const noexcept { return !operator==(other); }
    bool operator<(const Scalar1Container& other) const noexcept;
    bool operator<=(const Scalar1Container& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Scalar1Container& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Scalar1Container& other) const noexcept { return !operator<(other); }

    std::string to_string() const;

    friend std::ostream& operator<<(std::ostream& stream, const Scalar1Container& value);

    void swap(Scalar1Container& other) noexcept;
    friend void swap(Scalar1Container& value1, Scalar1Container& value2) noexcept { value1.swap(value2); }
};

} // namespace variants_ptr_pmr

template<>
struct std::hash<variants_ptr_pmr::Scalar1Container>
{
    typedef variants_ptr_pmr::Scalar1Container argument_type;
    typedef size_t result_type;

    result_type operator() ([[maybe_unused]] const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

namespace variants_ptr_pmr {

} // namespace variants_ptr_pmr
