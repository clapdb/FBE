//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: ptrpkg.fbe
// FBE version: 1.11.0.0
//------------------------------------------------------------------------------

#include "ptrpkg_ptr_pmr.h"

namespace ptrpkg_pmr {

Line::Line()
    : value()
    , value_ptr(nullptr)
{}

Line::Line([[maybe_unused]] allocator_type alloc)
    : value(assign_member<::variants_ptr_pmr::Value>(alloc))
    , value_ptr(nullptr)
{}

Line::Line(::variants_ptr_pmr::Value arg_value, std::unique_ptr<::variants_ptr_pmr::Value> arg_value_ptr)
    : value(std::move(arg_value))
    , value_ptr(arg_value_ptr.release())
{}

Line::Line([[maybe_unused]] Line&& other) noexcept
    : value(std::move(other.value))
    , value_ptr(std::exchange(other.value_ptr, nullptr))
{}

Line::~Line()
{
    if (value_ptr) delete value_ptr;
}

bool Line::operator==([[maybe_unused]] const Line& other) const noexcept
{
    if (value != other.value)
        return false;
    // compare ptr value_ptr
    if ((value_ptr  == nullptr && other.value_ptr  != nullptr) || (value_ptr  != nullptr && other.value_ptr  == nullptr) || (value_ptr  != nullptr && other.value_ptr  != nullptr && *value_ptr != *other.value_ptr))
        return false;
    return true;
}

bool Line::operator<([[maybe_unused]] const Line& other) const noexcept
{
    return false;
}

Line& Line::operator=(Line&& other) noexcept
{
    if (this != &other)
    {
        value = std::move(other.value);
        value_ptr = std::exchange(other.value_ptr, nullptr);
    }
    return *this;
}

std::string Line::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void Line::swap([[maybe_unused]] Line& other) noexcept
{
    using std::swap;
    swap(value, other.value);
    swap(value_ptr, other.value_ptr);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const Line& value)
{
    stream << "Line(";
    stream << "value="; stream << value.value;
    stream << ",value_ptr="; stream << "ptr of other struct: " << (value.value_ptr == nullptr ? "nullptr" : "true");
    stream << ")";
    return stream;
}

} // namespace ptrpkg_pmr
