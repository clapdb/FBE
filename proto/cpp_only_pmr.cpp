//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: cpp_only.fbe
// FBE version: 1.11.0.0
//------------------------------------------------------------------------------

#include "cpp_only_pmr.h"

namespace cpp_only_pmr {

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const LargeNum& value)
{
    stream << "LargeNum(variant|";
    [[maybe_unused]] bool first = true;
    switch (value.index()) {
        case 0:
            stream << "{empty}";
            break;
        case 1:
            stream<< "{int64}";
            stream << std::get<1>(value);
            break;
        case 2:
            stream<< "{int128}";
            stream << "unimplemented";
            break;
        case 3:
            stream<< "{uint128}";
            stream << "unimplemented";
            break;
        case 4:
            stream << "{int128}=[" << std::get<4>(value).size() << "][";
            for ([[maybe_unused]] const auto& it : std::get<4>(value))
            {
                stream << std::string(first ? "" : ",") << "(int128) operator<< unimplemented";
                first = false;
            }
            stream << "]";
            break;
        case 5:
            stream << "{uint128->int128}=[" << std::get<5>(value).size() << "][";
            for ([[maybe_unused]] const auto& it : std::get<5>(value))
            {
                stream << std::string(first ? "" : ",") << "(uint128) operator<< unimplemented";
                stream << "->";
                stream << "(int128) operator<< unimplemented";
                first = false;
            }
            stream << "]";
            break;
        default:
            static_assert("unreachable branch");
    }
    stream << ")";
    return stream;
}


Struct128::Struct128()
    : f1((__int128_t)0)
    , f2()
    , f3((__uint128_t)0)
    , f4()
    , f5()
    , f6()
    , f7()
{}

Struct128::Struct128([[maybe_unused]] allocator_type alloc)
    : f1((__int128_t)0)
    , f2(std::nullopt)
    , f3((__uint128_t)0)
    , f4(std::nullopt)
    , f5(alloc)
    , f6(alloc)
    , f7()
{}

Struct128::Struct128(__int128_t arg_f1, const std::optional<__int128_t>& arg_f2, __uint128_t arg_f3, const std::optional<__uint128_t>& arg_f4, const pmr::vector<__int128_t>& arg_f5, const pmr::unordered_map<__uint128_t, __int128_t>& arg_f6, const ::cpp_only_pmr::LargeNum& arg_f7)
    : f1(arg_f1)
    , f2(arg_f2)
    , f3(arg_f3)
    , f4(arg_f4)
    , f5(arg_f5)
    , f6(arg_f6)
    , f7(arg_f7)
{}

bool Struct128::operator==([[maybe_unused]] const Struct128& other) const noexcept
{
    return (
        (f1 == other.f1)
        && (f2 == other.f2)
        && (f3 == other.f3)
        && (f4 == other.f4)
        && (f5 == other.f5)
        && (f6 == other.f6)
        && (f7 == other.f7)
        );
}

bool Struct128::operator<([[maybe_unused]] const Struct128& other) const noexcept
{
    return false;
}

std::string Struct128::string() const
{
    std::stringstream ss; ss << *this; return ss.str();
}

void Struct128::swap([[maybe_unused]] Struct128& other) noexcept
{
    using std::swap;
    swap(f1, other.f1);
    swap(f2, other.f2);
    swap(f3, other.f3);
    swap(f4, other.f4);
    swap(f5, other.f5);
    swap(f6, other.f6);
    swap(f7, other.f7);
}

std::ostream& operator<<(std::ostream& stream, [[maybe_unused]] const Struct128& value)
{
    stream << "Struct128(";
    stream << "f1="; stream << "(int128) operator<< unimplemented";
    stream << ",f2="; if (value.f2) stream << "(optional int128) operator<< unimplemented"; else stream << "null";
    stream << ",f3="; stream << "(uint128) operator<< unimplemented";
    stream << ",f4="; if (value.f4) stream << "(optional uint128) operator<< unimplemented"; else stream << "null";
    {
        bool first = true;
        stream << ",f5=[" << value.f5.size() << "][";
        for ([[maybe_unused]] const auto& it : value.f5)
        {
            stream << std::string(first ? "" : ",") << "(int128) operator<< unimplemented";
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",f6=[" << value.f6.size()<< "][{";
        for ([[maybe_unused]] const auto& it : value.f6)
        {
            stream << std::string(first ? "" : ",") << "(uint128) operator<< unimplemented";
            stream << "->";
            stream << "(int128) operator<< unimplemented";
            first = false;
        }
        stream << "}]";
    }
    stream << ",f7="; stream << value.f7;
    stream << ")";
    return stream;
}

} // namespace cpp_only_pmr
