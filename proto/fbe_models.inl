//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: FBE
// FBE version: 1.11.0.0
//------------------------------------------------------------------------------

namespace FBE {

template <typename T, typename TBase>
inline void FieldModelBase<T, TBase>::get(T& value, pmr::memory_resource* resource, T defaults) const noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    if ((fbe_full_offset + fbe_size()) > _buffer.size())
    {
        value = defaults;
        return;
    }

    value = unaligned_load<T>(_buffer.data() + fbe_full_offset);
}

template <typename T, typename TBase>
inline void FieldModelBase<T, TBase>::set(T value, pmr::memory_resource* resource) noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + fbe_size()) > _buffer.size())
        return;

    unaligned_store<TBase>(_buffer.data() + fbe_full_offset, (TBase)value);
}

template <typename T>
inline size_t FieldModel<std::optional<T>>::fbe_extra() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if ((fbe_optional_offset == 0) || ((_buffer.offset() + fbe_optional_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_optional_offset);
    size_t fbe_result = value.fbe_size() + value.fbe_extra();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

template <typename T>
inline bool FieldModel<std::optional<T>>::has_value() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    return (fbe_has_value != 0);
}

template <typename T>
inline bool FieldModel<std::optional<T>>::verify() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint8_t fbe_has_value = *((const uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if (fbe_has_value == 0)
        return true;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    if (fbe_optional_offset == 0)
        return false;

    _buffer.shift(fbe_optional_offset);
    bool fbe_result = value.verify();
    _buffer.unshift(fbe_optional_offset);
    return fbe_result;
}

template <typename T>
inline size_t FieldModel<std::optional<T>>::get_begin() const noexcept
{
    if (!has_value())
        return 0;

    uint32_t fbe_optional_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1);
    assert((fbe_optional_offset > 0) && "Model is broken!");
    if (fbe_optional_offset == 0)
        return 0;

    _buffer.shift(fbe_optional_offset);
    return fbe_optional_offset;
}

template <typename T>
inline void FieldModel<std::optional<T>>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

template <typename T>
inline void FieldModel<std::optional<T>>::get(std::optional<T>& opt, pmr::memory_resource* resource, const std::optional<T>& defaults) const noexcept
{
    opt = defaults;

    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;
    if constexpr(std::is_constructible_v<T, pmr::memory_resource*> and not is_variant_v<T>) {
        T temp = T(resource);

        value.get(temp, resource);
        opt.emplace(std::move(temp));

        get_end(fbe_begin);
    } else {
        T temp{};

        value.get(temp, resource);
        opt.emplace(std::move(temp));

        get_end(fbe_begin);
    }
}

template <typename T>
inline void FieldModel<std::optional<T>>::get(std::optional<T>& opt, pmr::memory_resource* resource) const noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    if constexpr(std::is_constructible_v<T, pmr::memory_resource*> and not is_variant_v<T>) {
        T temp = T(resource);

        value.get(temp, resource);
        opt.emplace(std::move(temp));

        get_end(fbe_begin);
    } else {
        T temp = T();

        value.get(temp, resource);
        opt.emplace(std::move(temp));

        get_end(fbe_begin);
    }
}

template <typename T>
inline size_t FieldModel<std::optional<T>>::set_begin(bool has_value)
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = has_value ? 1 : 0;
    *((uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
    if (fbe_has_value == 0)
        return 0;

    uint32_t fbe_optional_size = (uint32_t)value.fbe_size();
    uint32_t fbe_optional_offset = (uint32_t)(_buffer.allocate(fbe_optional_size) - _buffer.offset());
    assert(((fbe_optional_offset > 0) && ((_buffer.offset() + fbe_optional_offset + fbe_optional_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_optional_offset == 0) || ((_buffer.offset() + fbe_optional_offset + fbe_optional_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset() + 1, fbe_optional_offset);

    _buffer.shift(fbe_optional_offset);
    return fbe_optional_offset;
}

template <typename T>
inline void FieldModel<std::optional<T>>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

template <typename T>
inline void FieldModel<std::optional<T>>::set(const std::optional<T>& opt, pmr::memory_resource* resource)
{
    size_t fbe_begin = set_begin(opt.has_value());
    if (fbe_begin == 0)
        return;

    if (opt)
        value.set(opt.value(), resource);

    set_end(fbe_begin);
}

template <typename T, size_t N>
inline const uint8_t* FieldModelArray<T, N>::data() const noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    return _buffer.data() + _buffer.offset() + fbe_offset();
}

template <typename T, size_t N>
inline uint8_t* FieldModelArray<T, N>::data() noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    return _buffer.data() + _buffer.offset() + fbe_offset();
}

template <typename T, size_t N>
inline FieldModel<T> FieldModelArray<T, N>::operator[](size_t index) const noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    assert((index < N) && "Index is out of bounds!");

    FieldModel<T> fbe_model(_buffer, fbe_offset());
    fbe_model.fbe_shift(index * fbe_model.fbe_size());
    return fbe_model;
}

template <typename T, size_t N>
inline bool FieldModelArray<T, N>::verify() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return false;

    FieldModel<T> fbe_model(_buffer, fbe_offset());
    for (size_t i = N; i-- > 0;)
    {
        if (!fbe_model.verify())
            return false;
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }

    return true;
}

template <typename T, size_t N>
template <size_t S>
inline void FieldModelArray<T, N>::get(T (&values)[S], pmr::memory_resource* resource) const noexcept
{
    auto fbe_model = (*this)[0];
    for (size_t i = 0; (i < S) && (i < N); ++i)
    {
        fbe_model.get(values[i], resource);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T, size_t N>
template <size_t S>
inline void FieldModelArray<T, N>::get(std::array<T, S>& values, pmr::memory_resource* resource) const noexcept
{
    auto fbe_model = (*this)[0];
    for (size_t i = 0; (i < S) && (i < N); ++i)
    {
        fbe_model.get(values[i], resource);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T, size_t N>
inline void FieldModelArray<T, N>::get(FastVec<T>& values, pmr::memory_resource* resource) const noexcept
{
    values.clear();
    values.reserve(N);

    auto fbe_model = (*this)[0];
    for (size_t i = N; i-- > 0;)
    {
        T value = T();
        fbe_model.get(value, resource);
        #if defined(USING_STD_VECTOR)
        values.emplace_back(value);
        #else
        values.template emplace_back<Safety::Unsafe>(value);
        #endif
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T, size_t N>
template <size_t S>
inline void FieldModelArray<T, N>::set(const T (&values)[S], pmr::memory_resource* resource) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    auto fbe_model = (*this)[0];
    for (size_t i = 0; (i < S) && (i < N); ++i)
    {
        fbe_model.set(values[i], resource);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T, size_t N>
template <size_t S>
inline void FieldModelArray<T, N>::set(const std::array<T, S>& values, pmr::memory_resource* resource) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    auto fbe_model = (*this)[0];
    for (size_t i = 0; (i < S) && (i < N); ++i)
    {
        fbe_model.set(values[i], resource);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T, size_t N>
inline void FieldModelArray<T, N>::set(const FastVec<T>& values, pmr::memory_resource* resource) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    auto fbe_model = (*this)[0];
    for (size_t i = 0; (i < values.size()) && (i < N); ++i)
    {
        fbe_model.set(values[i], resource);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T>
inline size_t FieldModelVector<T>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_vector_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_vector_offset == 0) || ((_buffer.offset() + fbe_vector_offset + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_vector_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_vector_offset);

    size_t fbe_result = 4;
    FieldModel<T> fbe_model(_buffer, fbe_vector_offset + 4);
    for (size_t i = fbe_vector_size; i-- > 0;)
    {
        fbe_result += fbe_model.fbe_size() + fbe_model.fbe_extra();
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
    return fbe_result;
}

template <typename T>
inline size_t FieldModelVector<T>::offset() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_vector_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    return fbe_vector_offset;
}

template <typename T>
inline size_t FieldModelVector<T>::size() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_vector_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_vector_offset == 0) || ((_buffer.offset() + fbe_vector_offset + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_vector_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_vector_offset);
    return fbe_vector_size;
}

template <typename T>
inline FieldModel<T> FieldModelVector<T>::operator[](size_t index) const noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");

    uint32_t fbe_vector_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_vector_offset > 0) && ((_buffer.offset() + fbe_vector_offset + 4) <= _buffer.size())) && "Model is broken!");

    [[maybe_unused]] uint32_t fbe_vector_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_vector_offset);
    assert((index < fbe_vector_size) && "Index is out of bounds!");

    FieldModel<T> fbe_model(_buffer, fbe_vector_offset + 4);
    fbe_model.fbe_shift(index * fbe_model.fbe_size());
    return fbe_model;
}

template <typename T>
inline FieldModel<T> FieldModelVector<T>::resize(size_t size)
{
    FieldModel<T> fbe_model(_buffer, fbe_offset());

    uint32_t fbe_vector_size = (uint32_t)(size * fbe_model.fbe_size());
    uint32_t fbe_vector_offset = (uint32_t)(_buffer.allocate(4 + fbe_vector_size) - _buffer.offset());
    assert(((fbe_vector_offset > 0) && ((_buffer.offset() + fbe_vector_offset + 4) <= _buffer.size())) && "Model is broken!");

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_vector_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_vector_offset, size);

    memset((char*)(_buffer.data() + _buffer.offset() + fbe_vector_offset + 4), 0, fbe_vector_size);

    return FieldModel<T>(_buffer, fbe_vector_offset + 4);
}

template <typename T>
inline bool FieldModelVector<T>::verify() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_vector_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if (fbe_vector_offset == 0)
        return true;

    if ((_buffer.offset() + fbe_vector_offset + 4) > _buffer.size())
        return false;

    uint32_t fbe_vector_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_vector_offset);

    FieldModel<T> fbe_model(_buffer, fbe_vector_offset + 4);
    for (size_t i = fbe_vector_size; i-- > 0;)
    {
        if (!fbe_model.verify())
            return false;
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }

    return true;
}

template <typename T>
inline void FieldModelVector<T>::get(FastVec<T>& values, pmr::memory_resource* resource) const noexcept
{
    values.clear();

    size_t fbe_vector_size = size();
    if (fbe_vector_size == 0)
        return;

    values.reserve(fbe_vector_size);

    auto fbe_model = (*this)[0];
    for (size_t i = fbe_vector_size; i-- > 0;)
    {
        T value = T();
        fbe_model.get(value, resource);
        #if defined(USING_STD_VECTOR)
        values.emplace_back(std::move(value));
        #else
        values.template emplace_back<Safety::Unsafe>(std::move(value));
        #endif
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T>
inline void FieldModelVector<T>::get(std::list<T>& values, pmr::memory_resource* resource) const noexcept
{
    values.clear();

    size_t fbe_vector_size = size();
    if (fbe_vector_size == 0)
        return;

    auto fbe_model = (*this)[0];
    for (size_t i = fbe_vector_size; i-- > 0;)
    {
        T value = T();
        fbe_model.get(value, resource);
        values.emplace_back(std::move(value));
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T>
inline void FieldModelVector<T>::get(std::set<T>& values, pmr::memory_resource* resource) const noexcept
{
    values.clear();

    size_t fbe_vector_size = size();
    if (fbe_vector_size == 0)
        return;

    auto fbe_model = (*this)[0];
    for (size_t i = fbe_vector_size; i-- > 0;)
    {
        T value = T();
        fbe_model.get(value, resource);
        values.emplace(std::move(value));
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T>
inline void FieldModelVector<T>::get(pmr::vector<T>& values, pmr::memory_resource* resource) const noexcept
{
    values.clear();

    size_t fbe_vector_size = size();
    if (fbe_vector_size == 0)
        return;

    values.reserve(fbe_vector_size);

    auto fbe_model = (*this)[0];
    for (size_t i = fbe_vector_size; i-- > 0;)
    {
        if constexpr (std::is_constructible_v<T, pmr::polymorphic_allocator<char>> and not is_variant_v<T>) {
            T value{resource};
            fbe_model.get(value, resource);
            values.emplace_back(std::move(value));
            fbe_model.fbe_shift(fbe_model.fbe_size());
        } else {
            T value = T();
            fbe_model.get(value, resource);
            values.emplace_back(std::move(value));
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }
}

template <typename T>
inline void FieldModelVector<T>::get(pmr::list<T>& values, pmr::memory_resource* resource) const noexcept
{
    values.clear();

    size_t fbe_vector_size = size();
    if (fbe_vector_size == 0)
        return;

    auto fbe_model = (*this)[0];
    for (size_t i = fbe_vector_size; i-- > 0;)
    {
        if constexpr (std::is_constructible_v<T, pmr::polymorphic_allocator<char>> and not is_variant_v<T>) {
            T value{resource};
            fbe_model.get(value, resource);
            values.emplace_back(std::move(value));
            fbe_model.fbe_shift(fbe_model.fbe_size());
        } else {
            T value = T();
            fbe_model.get(value, resource);
            values.emplace_back(std::move(value));
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }
}

template <typename T>
inline void FieldModelVector<T>::get(pmr::set<T>& values, pmr::memory_resource* resource) const noexcept
{
    values.clear();

    size_t fbe_vector_size = size();
    if (fbe_vector_size == 0)
        return;

    auto fbe_model = (*this)[0];
    for (size_t i = fbe_vector_size; i-- > 0;)
    {

        if constexpr (std::is_constructible_v<T, pmr::polymorphic_allocator<char>> and not is_variant_v<T>) {
            T value{resource};
            fbe_model.get(value, resource);
            values.emplace(std::move(value));
            fbe_model.fbe_shift(fbe_model.fbe_size());
        } else {
            T value = T();
            fbe_model.get(value, resource);
            values.emplace(std::move(value));
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }
}

template <typename T>
inline void FieldModelVector<T>::set(const FastVec<T>& values, pmr::memory_resource* resource) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    auto fbe_model = resize(values.size());
    for (const auto& value : values)
    {
        fbe_model.set(value, resource);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T>
inline void FieldModelVector<T>::set(const std::list<T>& values, pmr::memory_resource* resource) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    auto fbe_model = resize(values.size());
    for (const auto& value : values)
    {
        fbe_model.set(value, resource);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T>
inline void FieldModelVector<T>::set(const std::set<T>& values, pmr::memory_resource* resource) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    auto fbe_model = resize(values.size());
    for (const auto& value : values)
    {
        fbe_model.set(value, resource);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T>
inline void FieldModelVector<T>::set(const pmr::vector<T>& values, pmr::memory_resource* resource) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    auto fbe_model = resize(values.size());
    for (const auto& value : values)
    {
        fbe_model.set(value, resource);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T>
inline void FieldModelVector<T>::set(const pmr::list<T>& values, pmr::memory_resource* resource) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    auto fbe_model = resize(values.size());
    for (const auto& value : values)
    {
        fbe_model.set(value, resource);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename T>
inline void FieldModelVector<T>::set(const pmr::set<T>& values, pmr::memory_resource* resource) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    auto fbe_model = resize(values.size());
    for (const auto& value : values)
    {
        fbe_model.set(value, resource);
        fbe_model.fbe_shift(fbe_model.fbe_size());
    }
}

template <typename TKey, typename TValue>
inline size_t FieldModelMap<TKey, TValue>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_map_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_map_offset == 0) || ((_buffer.offset() + fbe_map_offset + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_map_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_map_offset);

    size_t fbe_result = 4;
    FieldModel<TKey> fbe_model_key(_buffer, fbe_map_offset + 4);
    FieldModel<TValue> fbe_model_value(_buffer, fbe_map_offset + 4 + fbe_model_key.fbe_size());
    for (size_t i = fbe_map_size; i-- > 0;)
    {
        fbe_result += fbe_model_key.fbe_size() + fbe_model_key.fbe_extra();
        fbe_model_key.fbe_shift(fbe_model_key.fbe_size() + fbe_model_value.fbe_size());
        fbe_result += fbe_model_value.fbe_size() + fbe_model_value.fbe_extra();
        fbe_model_value.fbe_shift(fbe_model_key.fbe_size() + fbe_model_value.fbe_size());
    }
    return fbe_result;
}

template <typename TKey, typename TValue>
inline size_t FieldModelMap<TKey, TValue>::offset() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_map_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    return fbe_map_offset;
}

template <typename TKey, typename TValue>
inline size_t FieldModelMap<TKey, TValue>::size() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_map_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_map_offset == 0) || ((_buffer.offset() + fbe_map_offset + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_map_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_map_offset);
    return fbe_map_size;
}

template <typename TKey, typename TValue>
inline std::pair<FieldModel<TKey>, FieldModel<TValue>> FieldModelMap<TKey, TValue>::operator[](size_t index) const noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");

    uint32_t fbe_map_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_map_offset > 0) && ((_buffer.offset() + fbe_map_offset + 4) <= _buffer.size())) && "Model is broken!");

    [[maybe_unused]] uint32_t fbe_map_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_map_offset);
    assert((index < fbe_map_size) && "Index is out of bounds!");

    FieldModel<TKey> fbe_model_key(_buffer, fbe_map_offset + 4);
    FieldModel<TValue> fbe_model_value(_buffer, fbe_map_offset + 4 + fbe_model_key.fbe_size());
    fbe_model_key.fbe_shift(index * (fbe_model_key.fbe_size() + fbe_model_value.fbe_size()));
    fbe_model_value.fbe_shift(index * (fbe_model_key.fbe_size() + fbe_model_value.fbe_size()));
    return std::make_pair(fbe_model_key, fbe_model_value);
}

template <typename TKey, typename TValue>
inline std::pair<FieldModel<TKey>, FieldModel<TValue>> FieldModelMap<TKey, TValue>::resize(size_t size)
{
    FieldModel<TKey> fbe_model_key(_buffer, fbe_offset());
    FieldModel<TValue> fbe_model_value(_buffer, fbe_offset() + fbe_model_key.fbe_size());

    uint32_t fbe_map_size = (uint32_t)(size * (fbe_model_key.fbe_size() + fbe_model_value.fbe_size()));
    uint32_t fbe_map_offset = (uint32_t)(_buffer.allocate(4 + fbe_map_size) - _buffer.offset());
    assert(((fbe_map_offset > 0) && ((_buffer.offset() + fbe_map_offset + 4 + fbe_map_size) <= _buffer.size())) && "Model is broken!");

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_map_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_map_offset, size);


    memset((char*)(_buffer.data() + _buffer.offset() + fbe_map_offset + 4), 0, fbe_map_size);

    return std::make_pair(FieldModel<TKey>(_buffer, fbe_map_offset + 4), FieldModel<TValue>(_buffer, fbe_map_offset + 4 + fbe_model_key.fbe_size()));
}

template <typename TKey, typename TValue>
inline bool FieldModelMap<TKey, TValue>::verify() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_map_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if (fbe_map_offset == 0)
        return true;

    if ((_buffer.offset() + fbe_map_offset + 4) > _buffer.size())
        return false;

    uint32_t fbe_map_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_map_offset);

    FieldModel<TKey> fbe_model_key(_buffer, fbe_map_offset + 4);
    FieldModel<TValue> fbe_model_value(_buffer, fbe_map_offset + 4 + fbe_model_key.fbe_size());
    for (size_t i = fbe_map_size; i-- > 0;)
    {
        if (!fbe_model_key.verify())
            return false;
        fbe_model_key.fbe_shift(fbe_model_key.fbe_size() + fbe_model_value.fbe_size());
        if (!fbe_model_value.verify())
            return false;
        fbe_model_value.fbe_shift(fbe_model_key.fbe_size() + fbe_model_value.fbe_size());
    }

    return true;
}

template <typename TKey, typename TValue>
inline void FieldModelMap<TKey, TValue>::get(std::map<TKey, TValue>& values, pmr::memory_resource* resource) const noexcept
{
    values.clear();

    size_t fbe_map_size = size();
    if (fbe_map_size == 0)
        return;

    auto fbe_model = (*this)[0];
    for (size_t i = fbe_map_size; i-- > 0;)
    {
        TKey key;
        TValue value;
        fbe_model.first.get(key, resource);
        fbe_model.second.get(value, resource);
        values.emplace(std::move(key), std::move(value));
        fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
    }
}

template <typename TKey, typename TValue>
inline void FieldModelMap<TKey, TValue>::get(std::unordered_map<TKey, TValue>& values, pmr::memory_resource* resource) const noexcept
{
    values.clear();

    size_t fbe_map_size = size();
    if (fbe_map_size == 0)
        return;

    auto fbe_model = (*this)[0];
    for (size_t i = fbe_map_size; i-- > 0;)
    {
        TKey key;
        TValue value;
        fbe_model.first.get(key, resource);
        fbe_model.second.get(value, resource);
        values.emplace(std::move(key), std::move(value));
        fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
    }
}

template <typename TKey, typename TValue>
inline void FieldModelMap<TKey, TValue>::get(pmr::map<TKey, TValue>& values, pmr::memory_resource* resource) const noexcept
{
    values.clear();

    size_t fbe_map_size = size();
    if (fbe_map_size == 0)
        return;

    auto fbe_model = (*this)[0];
    for (size_t i = fbe_map_size; i-- > 0;)
    {
        std::unique_ptr<TKey> key_ptr = nullptr;
        std::unique_ptr<TValue> value_ptr = nullptr;
        if constexpr (std::is_constructible_v<TKey, pmr::polymorphic_allocator<char>> and not is_variant_v<TKey>) {
            key_ptr = std::make_unique<TKey>(resource);
        } else {
            key_ptr = std::make_unique<TKey>();
        }
        if constexpr (std::is_constructible_v<TValue, pmr::polymorphic_allocator<char>> and not is_variant_v<TValue>) {
            value_ptr = std::make_unique<TValue>(resource);
        } else {
            value_ptr = std::make_unique<TValue>();
        }
        fbe_model.first.get(*key_ptr, resource);
        fbe_model.second.get(*value_ptr, resource);
        values.emplace(std::move(*key_ptr), std::move(*value_ptr));
        fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
    }
}

template <typename TKey, typename TValue>
inline void FieldModelMap<TKey, TValue>::get(pmr::unordered_map<TKey, TValue>& values, pmr::memory_resource* resource) const noexcept
{
    values.clear();

    size_t fbe_map_size = size();
    if (fbe_map_size == 0)
        return;

    auto fbe_model = (*this)[0];
    for (size_t i = fbe_map_size; i-- > 0;)
    {
        std::unique_ptr<TKey> key_ptr = nullptr;
        std::unique_ptr<TValue> value_ptr = nullptr;
        if constexpr (std::is_constructible_v<TKey, pmr::polymorphic_allocator<char>> and not is_variant_v<TKey>) {
            key_ptr = std::make_unique<TKey>(resource);
        } else {
            key_ptr = std::make_unique<TKey>();
        }
        if constexpr (std::is_constructible_v<TValue, pmr::polymorphic_allocator<char>> and not is_variant_v<TValue>) {
            value_ptr = std::make_unique<TValue>(resource);
        } else {
            value_ptr = std::make_unique<TValue>();
        }
        fbe_model.first.get(*key_ptr, resource);
        fbe_model.second.get(*value_ptr, resource);
        values.emplace(std::move(*key_ptr), std::move(*value_ptr));
        fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
    }
}

template <typename TKey, typename TValue>
inline void FieldModelMap<TKey, TValue>::set(const std::map<TKey, TValue>& values, pmr::memory_resource* resource) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    auto fbe_model = resize(values.size());
    for (const auto& value : values)
    {
        fbe_model.first.set(value.first, resource);
        fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        fbe_model.second.set(value.second, resource);
        fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
    }
}

template <typename TKey, typename TValue>
inline void FieldModelMap<TKey, TValue>::set(const std::unordered_map<TKey, TValue>& values, pmr::memory_resource* resource) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    auto fbe_model = resize(values.size());
    for (const auto& value : values)
    {
        fbe_model.first.set(value.first, resource);
        fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        fbe_model.second.set(value.second, resource);
        fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
    }
}

template <typename TKey, typename TValue>
inline void FieldModelMap<TKey, TValue>::set(const pmr::map<TKey, TValue>& values, pmr::memory_resource* resource) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    auto fbe_model = resize(values.size());
    for (const auto& value : values)
    {
        fbe_model.first.set(value.first, resource);
        fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        fbe_model.second.set(value.second, resource);
        fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
    }
}

template <typename TKey, typename TValue>
inline void FieldModelMap<TKey, TValue>::set(const pmr::unordered_map<TKey, TValue>& values, pmr::memory_resource* resource) noexcept
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return;

    auto fbe_model = resize(values.size());
    for (const auto& value : values)
    {
        fbe_model.first.set(value.first, resource);
        fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        fbe_model.second.set(value.second, resource);
        fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
    }
}

} // namespace FBE
