//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: variants.fbe
// FBE version: 1.11.0.0
//------------------------------------------------------------------------------

#include "variants_final_models.h"

namespace FBE {

size_t FinalModel<::variants::Expr>::fbe_allocation_size(const ::variants::Expr& fbe_value) const noexcept
{
    size_t fbe_result = 4; // variant type index size
    std::visit(
        overloaded
        {
            [](std::monostate) { },
            [this, &fbe_result](bool v) {
                FinalModel<bool> fbe_model(_buffer, 0);
                fbe_result += fbe_model.fbe_allocation_size(v);
            },
            [this, &fbe_result](int32_t v) {
                FinalModel<int32_t> fbe_model(_buffer, 0);
                fbe_result += fbe_model.fbe_allocation_size(v);
            },
            [this, &fbe_result](const FBEString& v) {
                FinalModel<FBEString> fbe_model(_buffer, 0);
                fbe_result += fbe_model.fbe_allocation_size(v);
            },
        },
        fbe_value
    );
    return fbe_result;
}

size_t FinalModel<::variants::Expr>::verify() const noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    if ((fbe_full_offset + 4) > _buffer.size())
        return std::numeric_limits<std::size_t>::max();

    uint32_t fbe_variant_type = unaligned_load<uint32_t>(_buffer.data() + fbe_full_offset);
    if (fbe_variant_type > 3)
        return std::numeric_limits<std::size_t>::max();

    _buffer.shift(fbe_offset() + 4);
    size_t fbe_result = 4;
    switch (fbe_variant_type) {
        case 0: // std::monostate
            break;
        case 1: {
            FinalModel<bool> fbe_model(_buffer, 0);
            size_t fbe_field_size = fbe_model.verify();
            if (fbe_field_size == std::numeric_limits<std::size_t>::max()) {
                _buffer.unshift(fbe_offset() + 4);
                return std::numeric_limits<std::size_t>::max();
            }
            fbe_result += fbe_field_size;
            break;
        }
        case 2: {
            FinalModel<int32_t> fbe_model(_buffer, 0);
            size_t fbe_field_size = fbe_model.verify();
            if (fbe_field_size == std::numeric_limits<std::size_t>::max()) {
                _buffer.unshift(fbe_offset() + 4);
                return std::numeric_limits<std::size_t>::max();
            }
            fbe_result += fbe_field_size;
            break;
        }
        case 3: {
            FinalModel<FBEString> fbe_model(_buffer, 0);
            size_t fbe_field_size = fbe_model.verify();
            if (fbe_field_size == std::numeric_limits<std::size_t>::max()) {
                _buffer.unshift(fbe_offset() + 4);
                return std::numeric_limits<std::size_t>::max();
            }
            fbe_result += fbe_field_size;
            break;
        }
        default:
            _buffer.unshift(fbe_offset() + 4);
            return std::numeric_limits<std::size_t>::max();
    }
    _buffer.unshift(fbe_offset() + 4);
    return fbe_result;
}

size_t FinalModel<::variants::Expr>::get(::variants::Expr& fbe_value) const noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    uint32_t fbe_variant_type = unaligned_load<uint32_t>(_buffer.data() + fbe_full_offset);
    assert(fbe_variant_type <= 3 && "Model is broken!");

    _buffer.shift(fbe_offset() + 4);
    size_t fbe_result = 4;
    switch (fbe_variant_type) {
        case 0:
            fbe_value.emplace<std::monostate>();
            break;
        case 1: {
            FinalModel<bool> fbe_model(_buffer, 0);
            fbe_value.emplace<bool>();
            auto& value = std::get<1>(fbe_value);
            fbe_result += fbe_model.get(value);
            break;
        }
        case 2: {
            FinalModel<int32_t> fbe_model(_buffer, 0);
            fbe_value.emplace<int32_t>();
            auto& value = std::get<2>(fbe_value);
            fbe_result += fbe_model.get(value);
            break;
        }
        case 3: {
            FinalModel<FBEString> fbe_model(_buffer, 0);
            fbe_value.emplace<FBEString>();
            auto& value = std::get<3>(fbe_value);
            fbe_result += fbe_model.get(value);
            break;
        }
        default:
            break;
    }
    _buffer.unshift(fbe_offset() + 4);
    return fbe_result;
}

size_t FinalModel<::variants::Expr>::set(const ::variants::Expr& fbe_value) noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    size_t fbe_result = 4;
    uint32_t fbe_variant_type = static_cast<uint32_t>(fbe_value.index());
    unaligned_store<uint32_t>(_buffer.data() + fbe_full_offset, fbe_variant_type);

    _buffer.shift(fbe_offset() + 4);
    std::visit(
        overloaded
        {
            [](std::monostate) { },
            [this, &fbe_result](bool v) {
                FinalModel<bool> fbe_model(_buffer, 0);
                fbe_result += fbe_model.set(v);
            },
            [this, &fbe_result](int32_t v) {
                FinalModel<int32_t> fbe_model(_buffer, 0);
                fbe_result += fbe_model.set(v);
            },
            [this, &fbe_result](const FBEString& v) {
                FinalModel<FBEString> fbe_model(_buffer, 0);
                fbe_result += fbe_model.set(v);
            },
        },
        fbe_value
    );
    _buffer.unshift(fbe_offset() + 4);
    return fbe_result;
}


size_t FinalModel<::variants::V>::fbe_allocation_size(const ::variants::V& fbe_value) const noexcept
{
    size_t fbe_result = 4; // variant type index size
    std::visit(
        overloaded
        {
            [](std::monostate) { },
            [this, &fbe_result](const FBEString& v) {
                FinalModel<FBEString> fbe_model(_buffer, 0);
                fbe_result += fbe_model.fbe_allocation_size(v);
            },
            [this, &fbe_result](int32_t v) {
                FinalModel<int32_t> fbe_model(_buffer, 0);
                fbe_result += fbe_model.fbe_allocation_size(v);
            },
            [this, &fbe_result](double v) {
                FinalModel<double> fbe_model(_buffer, 0);
                fbe_result += fbe_model.fbe_allocation_size(v);
            },
            [this, &fbe_result](const ::variants::Simple& v) {
                FinalModel<::variants::Simple> fbe_model(_buffer, 0);
                fbe_result += fbe_model.fbe_allocation_size(v);
            },
            [this, &fbe_result](const FastVec<::variants::Simple>& v) {
                FinalModelVector<::variants::Simple> fbe_model(_buffer, 0);
                fbe_result += fbe_model.fbe_allocation_size(v);
            },
            [this, &fbe_result](const FastVec<int32_t>& v) {
                FinalModelVector<int32_t> fbe_model(_buffer, 0);
                fbe_result += fbe_model.fbe_allocation_size(v);
            },
            [this, &fbe_result](const std::unordered_map<int32_t, ::variants::Simple>& v) {
                FinalModelMap<int32_t, ::variants::Simple> fbe_model(_buffer, 0);
                fbe_result += fbe_model.fbe_allocation_size(v);
            },
            [this, &fbe_result](const FastVec<FBE::buffer_t>& v) {
                FinalModelVector<FBE::buffer_t> fbe_model(_buffer, 0);
                fbe_result += fbe_model.fbe_allocation_size(v);
            },
            [this, &fbe_result](const FastVec<FBEString>& v) {
                FinalModelVector<FBEString> fbe_model(_buffer, 0);
                fbe_result += fbe_model.fbe_allocation_size(v);
            },
            [this, &fbe_result](const std::unordered_map<int32_t, FBE::buffer_t>& v) {
                FinalModelMap<int32_t, FBE::buffer_t> fbe_model(_buffer, 0);
                fbe_result += fbe_model.fbe_allocation_size(v);
            },
            [this, &fbe_result](const std::unordered_map<FBEString, FBE::buffer_t>& v) {
                FinalModelMap<FBEString, FBE::buffer_t> fbe_model(_buffer, 0);
                fbe_result += fbe_model.fbe_allocation_size(v);
            },
            [this, &fbe_result](const ::variants::Expr& v) {
                FinalModel<::variants::Expr> fbe_model(_buffer, 0);
                fbe_result += fbe_model.fbe_allocation_size(v);
            },
        },
        fbe_value
    );
    return fbe_result;
}

size_t FinalModel<::variants::V>::verify() const noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    if ((fbe_full_offset + 4) > _buffer.size())
        return std::numeric_limits<std::size_t>::max();

    uint32_t fbe_variant_type = unaligned_load<uint32_t>(_buffer.data() + fbe_full_offset);
    if (fbe_variant_type > 12)
        return std::numeric_limits<std::size_t>::max();

    _buffer.shift(fbe_offset() + 4);
    size_t fbe_result = 4;
    switch (fbe_variant_type) {
        case 0: // std::monostate
            break;
        case 1: {
            FinalModel<FBEString> fbe_model(_buffer, 0);
            size_t fbe_field_size = fbe_model.verify();
            if (fbe_field_size == std::numeric_limits<std::size_t>::max()) {
                _buffer.unshift(fbe_offset() + 4);
                return std::numeric_limits<std::size_t>::max();
            }
            fbe_result += fbe_field_size;
            break;
        }
        case 2: {
            FinalModel<int32_t> fbe_model(_buffer, 0);
            size_t fbe_field_size = fbe_model.verify();
            if (fbe_field_size == std::numeric_limits<std::size_t>::max()) {
                _buffer.unshift(fbe_offset() + 4);
                return std::numeric_limits<std::size_t>::max();
            }
            fbe_result += fbe_field_size;
            break;
        }
        case 3: {
            FinalModel<double> fbe_model(_buffer, 0);
            size_t fbe_field_size = fbe_model.verify();
            if (fbe_field_size == std::numeric_limits<std::size_t>::max()) {
                _buffer.unshift(fbe_offset() + 4);
                return std::numeric_limits<std::size_t>::max();
            }
            fbe_result += fbe_field_size;
            break;
        }
        case 4: {
            FinalModel<::variants::Simple> fbe_model(_buffer, 0);
            size_t fbe_field_size = fbe_model.verify();
            if (fbe_field_size == std::numeric_limits<std::size_t>::max()) {
                _buffer.unshift(fbe_offset() + 4);
                return std::numeric_limits<std::size_t>::max();
            }
            fbe_result += fbe_field_size;
            break;
        }
        case 5: {
            FinalModelVector<::variants::Simple> fbe_model(_buffer, 0);
            size_t fbe_field_size = fbe_model.verify();
            if (fbe_field_size == std::numeric_limits<std::size_t>::max()) {
                _buffer.unshift(fbe_offset() + 4);
                return std::numeric_limits<std::size_t>::max();
            }
            fbe_result += fbe_field_size;
            break;
        }
        case 6: {
            FinalModelVector<int32_t> fbe_model(_buffer, 0);
            size_t fbe_field_size = fbe_model.verify();
            if (fbe_field_size == std::numeric_limits<std::size_t>::max()) {
                _buffer.unshift(fbe_offset() + 4);
                return std::numeric_limits<std::size_t>::max();
            }
            fbe_result += fbe_field_size;
            break;
        }
        case 7: {
            FinalModelMap<int32_t, ::variants::Simple> fbe_model(_buffer, 0);
            size_t fbe_field_size = fbe_model.verify();
            if (fbe_field_size == std::numeric_limits<std::size_t>::max()) {
                _buffer.unshift(fbe_offset() + 4);
                return std::numeric_limits<std::size_t>::max();
            }
            fbe_result += fbe_field_size;
            break;
        }
        case 8: {
            FinalModelVector<FBE::buffer_t> fbe_model(_buffer, 0);
            size_t fbe_field_size = fbe_model.verify();
            if (fbe_field_size == std::numeric_limits<std::size_t>::max()) {
                _buffer.unshift(fbe_offset() + 4);
                return std::numeric_limits<std::size_t>::max();
            }
            fbe_result += fbe_field_size;
            break;
        }
        case 9: {
            FinalModelVector<FBEString> fbe_model(_buffer, 0);
            size_t fbe_field_size = fbe_model.verify();
            if (fbe_field_size == std::numeric_limits<std::size_t>::max()) {
                _buffer.unshift(fbe_offset() + 4);
                return std::numeric_limits<std::size_t>::max();
            }
            fbe_result += fbe_field_size;
            break;
        }
        case 10: {
            FinalModelMap<int32_t, FBE::buffer_t> fbe_model(_buffer, 0);
            size_t fbe_field_size = fbe_model.verify();
            if (fbe_field_size == std::numeric_limits<std::size_t>::max()) {
                _buffer.unshift(fbe_offset() + 4);
                return std::numeric_limits<std::size_t>::max();
            }
            fbe_result += fbe_field_size;
            break;
        }
        case 11: {
            FinalModelMap<FBEString, FBE::buffer_t> fbe_model(_buffer, 0);
            size_t fbe_field_size = fbe_model.verify();
            if (fbe_field_size == std::numeric_limits<std::size_t>::max()) {
                _buffer.unshift(fbe_offset() + 4);
                return std::numeric_limits<std::size_t>::max();
            }
            fbe_result += fbe_field_size;
            break;
        }
        case 12: {
            FinalModel<::variants::Expr> fbe_model(_buffer, 0);
            size_t fbe_field_size = fbe_model.verify();
            if (fbe_field_size == std::numeric_limits<std::size_t>::max()) {
                _buffer.unshift(fbe_offset() + 4);
                return std::numeric_limits<std::size_t>::max();
            }
            fbe_result += fbe_field_size;
            break;
        }
        default:
            _buffer.unshift(fbe_offset() + 4);
            return std::numeric_limits<std::size_t>::max();
    }
    _buffer.unshift(fbe_offset() + 4);
    return fbe_result;
}

size_t FinalModel<::variants::V>::get(::variants::V& fbe_value) const noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    uint32_t fbe_variant_type = unaligned_load<uint32_t>(_buffer.data() + fbe_full_offset);
    assert(fbe_variant_type <= 12 && "Model is broken!");

    _buffer.shift(fbe_offset() + 4);
    size_t fbe_result = 4;
    switch (fbe_variant_type) {
        case 0:
            fbe_value.emplace<std::monostate>();
            break;
        case 1: {
            FinalModel<FBEString> fbe_model(_buffer, 0);
            fbe_value.emplace<FBEString>();
            auto& value = std::get<1>(fbe_value);
            fbe_result += fbe_model.get(value);
            break;
        }
        case 2: {
            FinalModel<int32_t> fbe_model(_buffer, 0);
            fbe_value.emplace<int32_t>();
            auto& value = std::get<2>(fbe_value);
            fbe_result += fbe_model.get(value);
            break;
        }
        case 3: {
            FinalModel<double> fbe_model(_buffer, 0);
            fbe_value.emplace<double>();
            auto& value = std::get<3>(fbe_value);
            fbe_result += fbe_model.get(value);
            break;
        }
        case 4: {
            FinalModel<::variants::Simple> fbe_model(_buffer, 0);
            fbe_value.emplace<::variants::Simple>();
            auto& value = std::get<4>(fbe_value);
            fbe_result += fbe_model.get(value);
            break;
        }
        case 5: {
            FinalModelVector<::variants::Simple> fbe_model(_buffer, 0);
            fbe_value.emplace<FastVec<::variants::Simple>>();
            auto& value = std::get<5>(fbe_value);
            fbe_result += fbe_model.get(value);
            break;
        }
        case 6: {
            FinalModelVector<int32_t> fbe_model(_buffer, 0);
            fbe_value.emplace<FastVec<int32_t>>();
            auto& value = std::get<6>(fbe_value);
            fbe_result += fbe_model.get(value);
            break;
        }
        case 7: {
            FinalModelMap<int32_t, ::variants::Simple> fbe_model(_buffer, 0);
            fbe_value.emplace<std::unordered_map<int32_t, ::variants::Simple>>();
            auto& value = std::get<7>(fbe_value);
            fbe_result += fbe_model.get(value);
            break;
        }
        case 8: {
            FinalModelVector<FBE::buffer_t> fbe_model(_buffer, 0);
            fbe_value.emplace<FastVec<FBE::buffer_t>>();
            auto& value = std::get<8>(fbe_value);
            fbe_result += fbe_model.get(value);
            break;
        }
        case 9: {
            FinalModelVector<FBEString> fbe_model(_buffer, 0);
            fbe_value.emplace<FastVec<FBEString>>();
            auto& value = std::get<9>(fbe_value);
            fbe_result += fbe_model.get(value);
            break;
        }
        case 10: {
            FinalModelMap<int32_t, FBE::buffer_t> fbe_model(_buffer, 0);
            fbe_value.emplace<std::unordered_map<int32_t, FBE::buffer_t>>();
            auto& value = std::get<10>(fbe_value);
            fbe_result += fbe_model.get(value);
            break;
        }
        case 11: {
            FinalModelMap<FBEString, FBE::buffer_t> fbe_model(_buffer, 0);
            fbe_value.emplace<std::unordered_map<FBEString, FBE::buffer_t>>();
            auto& value = std::get<11>(fbe_value);
            fbe_result += fbe_model.get(value);
            break;
        }
        case 12: {
            FinalModel<::variants::Expr> fbe_model(_buffer, 0);
            fbe_value.emplace<::variants::Expr>();
            auto& value = std::get<12>(fbe_value);
            fbe_result += fbe_model.get(value);
            break;
        }
        default:
            break;
    }
    _buffer.unshift(fbe_offset() + 4);
    return fbe_result;
}

size_t FinalModel<::variants::V>::set(const ::variants::V& fbe_value) noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    size_t fbe_result = 4;
    uint32_t fbe_variant_type = static_cast<uint32_t>(fbe_value.index());
    unaligned_store<uint32_t>(_buffer.data() + fbe_full_offset, fbe_variant_type);

    _buffer.shift(fbe_offset() + 4);
    std::visit(
        overloaded
        {
            [](std::monostate) { },
            [this, &fbe_result](const FBEString& v) {
                FinalModel<FBEString> fbe_model(_buffer, 0);
                fbe_result += fbe_model.set(v);
            },
            [this, &fbe_result](int32_t v) {
                FinalModel<int32_t> fbe_model(_buffer, 0);
                fbe_result += fbe_model.set(v);
            },
            [this, &fbe_result](double v) {
                FinalModel<double> fbe_model(_buffer, 0);
                fbe_result += fbe_model.set(v);
            },
            [this, &fbe_result](const ::variants::Simple& v) {
                FinalModel<::variants::Simple> fbe_model(_buffer, 0);
                fbe_result += fbe_model.set(v);
            },
            [this, &fbe_result](const FastVec<::variants::Simple>& v) {
                FinalModelVector<::variants::Simple> fbe_model(_buffer, 0);
                fbe_result += fbe_model.set(v);
            },
            [this, &fbe_result](const FastVec<int32_t>& v) {
                FinalModelVector<int32_t> fbe_model(_buffer, 0);
                fbe_result += fbe_model.set(v);
            },
            [this, &fbe_result](const std::unordered_map<int32_t, ::variants::Simple>& v) {
                FinalModelMap<int32_t, ::variants::Simple> fbe_model(_buffer, 0);
                fbe_result += fbe_model.set(v);
            },
            [this, &fbe_result](const FastVec<FBE::buffer_t>& v) {
                FinalModelVector<FBE::buffer_t> fbe_model(_buffer, 0);
                fbe_result += fbe_model.set(v);
            },
            [this, &fbe_result](const FastVec<FBEString>& v) {
                FinalModelVector<FBEString> fbe_model(_buffer, 0);
                fbe_result += fbe_model.set(v);
            },
            [this, &fbe_result](const std::unordered_map<int32_t, FBE::buffer_t>& v) {
                FinalModelMap<int32_t, FBE::buffer_t> fbe_model(_buffer, 0);
                fbe_result += fbe_model.set(v);
            },
            [this, &fbe_result](const std::unordered_map<FBEString, FBE::buffer_t>& v) {
                FinalModelMap<FBEString, FBE::buffer_t> fbe_model(_buffer, 0);
                fbe_result += fbe_model.set(v);
            },
            [this, &fbe_result](const ::variants::Expr& v) {
                FinalModel<::variants::Expr> fbe_model(_buffer, 0);
                fbe_result += fbe_model.set(v);
            },
        },
        fbe_value
    );
    _buffer.unshift(fbe_offset() + 4);
    return fbe_result;
}


FinalModel<::variants::Simple>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , name(buffer, 0)
{}

size_t FinalModel<::variants::Simple>::fbe_allocation_size(const ::variants::Simple& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + name.fbe_allocation_size(fbe_value.name)
        ;
    return fbe_result;
}

size_t FinalModel<::variants::Simple>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::variants::Simple>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    name.fbe_offset(fbe_current_offset);
    fbe_field_size = name.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    return fbe_current_offset;
}

size_t FinalModel<::variants::Simple>::get(::variants::Simple& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::variants::Simple>::get_fields([[maybe_unused]] ::variants::Simple& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    name.fbe_offset(fbe_current_offset);
    fbe_field_size = name.get(fbe_value.name);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::variants::Simple>::set(const ::variants::Simple& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::variants::Simple>::set_fields([[maybe_unused]] const ::variants::Simple& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    name.fbe_offset(fbe_current_offset);
    fbe_field_size = name.set(fbe_value.name);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

namespace variants {

bool SimpleFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t SimpleFinalModel::serialize(const ::variants::Simple& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t SimpleFinalModel::deserialize(::variants::Simple& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

} // namespace variants

FinalModel<::variants::Value>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , v(buffer, 0)
{}

size_t FinalModel<::variants::Value>::fbe_allocation_size(const ::variants::Value& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + v.fbe_allocation_size(fbe_value.v)
        ;
    return fbe_result;
}

size_t FinalModel<::variants::Value>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::variants::Value>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    v.fbe_offset(fbe_current_offset);
    fbe_field_size = v.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    return fbe_current_offset;
}

size_t FinalModel<::variants::Value>::get(::variants::Value& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::variants::Value>::get_fields([[maybe_unused]] ::variants::Value& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    v.fbe_offset(fbe_current_offset);
    fbe_field_size = v.get(fbe_value.v);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::variants::Value>::set(const ::variants::Value& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::variants::Value>::set_fields([[maybe_unused]] const ::variants::Value& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    v.fbe_offset(fbe_current_offset);
    fbe_field_size = v.set(fbe_value.v);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

namespace variants {

bool ValueFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t ValueFinalModel::serialize(const ::variants::Value& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t ValueFinalModel::deserialize(::variants::Value& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

} // namespace variants

} // namespace FBE
