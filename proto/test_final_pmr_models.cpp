//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: test.fbe
// FBE version: 1.11.0.0
//------------------------------------------------------------------------------

#include "test_final_pmr_models.h"

namespace FBE {

FinalModel<::test_pmr::StructSimple>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , id(buffer, 0)
    , f1(buffer, 0)
    , f2(buffer, 0)
    , f3(buffer, 0)
    , f4(buffer, 0)
    , f5(buffer, 0)
    , f6(buffer, 0)
    , f7(buffer, 0)
    , f8(buffer, 0)
    , f9(buffer, 0)
    , f10(buffer, 0)
    , f11(buffer, 0)
    , f12(buffer, 0)
    , f13(buffer, 0)
    , f14(buffer, 0)
    , f15(buffer, 0)
    , f16(buffer, 0)
    , f17(buffer, 0)
    , f18(buffer, 0)
    , f19(buffer, 0)
    , f20(buffer, 0)
    , f21(buffer, 0)
    , f22(buffer, 0)
    , f23(buffer, 0)
    , f24(buffer, 0)
    , f25(buffer, 0)
    , f26(buffer, 0)
    , f27(buffer, 0)
    , f28(buffer, 0)
    , f29(buffer, 0)
    , f30(buffer, 0)
    , f31(buffer, 0)
    , f32(buffer, 0)
    , f33(buffer, 0)
    , f34(buffer, 0)
    , f35(buffer, 0)
    , f36(buffer, 0)
    , f37(buffer, 0)
    , f38(buffer, 0)
    , f39(buffer, 0)
    , f40(buffer, 0)
    , f41(buffer, 0)
    , f42(buffer, 0)
    , f43(buffer, 0)
    , f44(buffer, 0)
{}

size_t FinalModel<::test_pmr::StructSimple>::fbe_allocation_size(const ::test_pmr::StructSimple& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + id.fbe_allocation_size(fbe_value.id)
        + f1.fbe_allocation_size(fbe_value.f1)
        + f2.fbe_allocation_size(fbe_value.f2)
        + f3.fbe_allocation_size(fbe_value.f3)
        + f4.fbe_allocation_size(fbe_value.f4)
        + f5.fbe_allocation_size(fbe_value.f5)
        + f6.fbe_allocation_size(fbe_value.f6)
        + f7.fbe_allocation_size(fbe_value.f7)
        + f8.fbe_allocation_size(fbe_value.f8)
        + f9.fbe_allocation_size(fbe_value.f9)
        + f10.fbe_allocation_size(fbe_value.f10)
        + f11.fbe_allocation_size(fbe_value.f11)
        + f12.fbe_allocation_size(fbe_value.f12)
        + f13.fbe_allocation_size(fbe_value.f13)
        + f14.fbe_allocation_size(fbe_value.f14)
        + f15.fbe_allocation_size(fbe_value.f15)
        + f16.fbe_allocation_size(fbe_value.f16)
        + f17.fbe_allocation_size(fbe_value.f17)
        + f18.fbe_allocation_size(fbe_value.f18)
        + f19.fbe_allocation_size(fbe_value.f19)
        + f20.fbe_allocation_size(fbe_value.f20)
        + f21.fbe_allocation_size(fbe_value.f21)
        + f22.fbe_allocation_size(fbe_value.f22)
        + f23.fbe_allocation_size(fbe_value.f23)
        + f24.fbe_allocation_size(fbe_value.f24)
        + f25.fbe_allocation_size(fbe_value.f25)
        + f26.fbe_allocation_size(fbe_value.f26)
        + f27.fbe_allocation_size(fbe_value.f27)
        + f28.fbe_allocation_size(fbe_value.f28)
        + f29.fbe_allocation_size(fbe_value.f29)
        + f30.fbe_allocation_size(fbe_value.f30)
        + f31.fbe_allocation_size(fbe_value.f31)
        + f32.fbe_allocation_size(fbe_value.f32)
        + f33.fbe_allocation_size(fbe_value.f33)
        + f34.fbe_allocation_size(fbe_value.f34)
        + f35.fbe_allocation_size(fbe_value.f35)
        + f36.fbe_allocation_size(fbe_value.f36)
        + f37.fbe_allocation_size(fbe_value.f37)
        + f38.fbe_allocation_size(fbe_value.f38)
        + f39.fbe_allocation_size(fbe_value.f39)
        + f40.fbe_allocation_size(fbe_value.f40)
        + f41.fbe_allocation_size(fbe_value.f41)
        + f42.fbe_allocation_size(fbe_value.f42)
        + f43.fbe_allocation_size(fbe_value.f43)
        + f44.fbe_allocation_size(fbe_value.f44)
        ;
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructSimple>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructSimple>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    // Batch verify 29 fixed-size fields (102 bytes)
    {
        if ((_buffer.offset() + fbe_current_offset + 102) > _buffer.size())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += 102;
    }

    f29.fbe_offset(fbe_current_offset);
    fbe_field_size = f29.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f30.fbe_offset(fbe_current_offset);
    fbe_field_size = f30.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f31.fbe_offset(fbe_current_offset);
    fbe_field_size = f31.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f32.fbe_offset(fbe_current_offset);
    fbe_field_size = f32.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    // Batch verify 6 fixed-size fields (72 bytes)
    {
        if ((_buffer.offset() + fbe_current_offset + 72) > _buffer.size())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += 72;
    }

    f39.fbe_offset(fbe_current_offset);
    fbe_field_size = f39.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f40.fbe_offset(fbe_current_offset);
    fbe_field_size = f40.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f41.fbe_offset(fbe_current_offset);
    fbe_field_size = f41.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f42.fbe_offset(fbe_current_offset);
    fbe_field_size = f42.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f43.fbe_offset(fbe_current_offset);
    fbe_field_size = f43.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f44.fbe_offset(fbe_current_offset);
    fbe_field_size = f44.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    return fbe_current_offset;
}

size_t FinalModel<::test_pmr::StructSimple>::get(::test_pmr::StructSimple& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructSimple>::get_fields([[maybe_unused]] ::test_pmr::StructSimple& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    // Batch read 29 fixed-size fields (102 bytes)
    {
        size_t fbe_batch_offset = _buffer.offset() + fbe_current_offset;
        if ((fbe_batch_offset + 102) > _buffer.size())
            return 0;
        const uint8_t* fbe_batch_ptr = _buffer.data() + fbe_batch_offset;
        fbe_value.id = unaligned_load<int32_t>(fbe_batch_ptr + 0);
        fbe_value.f1 = static_cast<bool>(unaligned_load<uint8_t>(fbe_batch_ptr + 4));
        fbe_value.f2 = static_cast<bool>(unaligned_load<uint8_t>(fbe_batch_ptr + 5));
        fbe_value.f3 = unaligned_load<uint8_t>(fbe_batch_ptr + 6);
        fbe_value.f4 = unaligned_load<uint8_t>(fbe_batch_ptr + 7);
        fbe_value.f5 = unaligned_load<uint8_t>(fbe_batch_ptr + 8);
        fbe_value.f6 = unaligned_load<uint8_t>(fbe_batch_ptr + 9);
        fbe_value.f7 = unaligned_load<uint32_t>(fbe_batch_ptr + 10);
        fbe_value.f8 = unaligned_load<uint32_t>(fbe_batch_ptr + 14);
        fbe_value.f9 = unaligned_load<int8_t>(fbe_batch_ptr + 18);
        fbe_value.f10 = unaligned_load<int8_t>(fbe_batch_ptr + 19);
        fbe_value.f11 = unaligned_load<uint8_t>(fbe_batch_ptr + 20);
        fbe_value.f12 = unaligned_load<uint8_t>(fbe_batch_ptr + 21);
        fbe_value.f13 = unaligned_load<int16_t>(fbe_batch_ptr + 22);
        fbe_value.f14 = unaligned_load<int16_t>(fbe_batch_ptr + 24);
        fbe_value.f15 = unaligned_load<uint16_t>(fbe_batch_ptr + 26);
        fbe_value.f16 = unaligned_load<uint16_t>(fbe_batch_ptr + 28);
        fbe_value.f17 = unaligned_load<int32_t>(fbe_batch_ptr + 30);
        fbe_value.f18 = unaligned_load<int32_t>(fbe_batch_ptr + 34);
        fbe_value.f19 = unaligned_load<uint32_t>(fbe_batch_ptr + 38);
        fbe_value.f20 = unaligned_load<uint32_t>(fbe_batch_ptr + 42);
        fbe_value.f21 = unaligned_load<int64_t>(fbe_batch_ptr + 46);
        fbe_value.f22 = unaligned_load<int64_t>(fbe_batch_ptr + 54);
        fbe_value.f23 = unaligned_load<uint64_t>(fbe_batch_ptr + 62);
        fbe_value.f24 = unaligned_load<uint64_t>(fbe_batch_ptr + 70);
        fbe_value.f25 = unaligned_load<float>(fbe_batch_ptr + 78);
        fbe_value.f26 = unaligned_load<float>(fbe_batch_ptr + 82);
        fbe_value.f27 = unaligned_load<double>(fbe_batch_ptr + 86);
        fbe_value.f28 = unaligned_load<double>(fbe_batch_ptr + 94);
        fbe_current_offset += 102;
        fbe_current_size += 102;
    }

    f29.fbe_offset(fbe_current_offset);
    fbe_field_size = f29.get(fbe_value.f29);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f30.fbe_offset(fbe_current_offset);
    fbe_field_size = f30.get(fbe_value.f30);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f31.fbe_offset(fbe_current_offset);
    fbe_field_size = f31.get(fbe_value.f31);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f32.fbe_offset(fbe_current_offset);
    fbe_field_size = f32.get(fbe_value.f32);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Batch read 6 fixed-size fields (72 bytes)
    {
        size_t fbe_batch_offset = _buffer.offset() + fbe_current_offset;
        if ((fbe_batch_offset + 72) > _buffer.size())
            return 0;
        const uint8_t* fbe_batch_ptr = _buffer.data() + fbe_batch_offset;
        fbe_value.f33 = unaligned_load<uint64_t>(fbe_batch_ptr + 0);
        fbe_value.f34 = unaligned_load<uint64_t>(fbe_batch_ptr + 8);
        fbe_value.f35 = unaligned_load<uint64_t>(fbe_batch_ptr + 16);
        std::memcpy(fbe_value.f36.data().data(), fbe_batch_ptr + 24, 16);
        std::memcpy(fbe_value.f37.data().data(), fbe_batch_ptr + 40, 16);
        std::memcpy(fbe_value.f38.data().data(), fbe_batch_ptr + 56, 16);
        fbe_current_offset += 72;
        fbe_current_size += 72;
    }

    f39.fbe_offset(fbe_current_offset);
    fbe_field_size = f39.get(fbe_value.f39);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f40.fbe_offset(fbe_current_offset);
    fbe_field_size = f40.get(fbe_value.f40);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f41.fbe_offset(fbe_current_offset);
    fbe_field_size = f41.get(fbe_value.f41);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f42.fbe_offset(fbe_current_offset);
    fbe_field_size = f42.get(fbe_value.f42);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f43.fbe_offset(fbe_current_offset);
    fbe_field_size = f43.get(fbe_value.f43);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f44.fbe_offset(fbe_current_offset);
    fbe_field_size = f44.get(fbe_value.f44);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructSimple>::get(::test_pmr::StructSimple& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value, resource);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructSimple>::get_fields([[maybe_unused]] ::test_pmr::StructSimple& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    // Batch read 29 fixed-size fields (102 bytes)
    {
        size_t fbe_batch_offset = _buffer.offset() + fbe_current_offset;
        if ((fbe_batch_offset + 102) > _buffer.size())
            return 0;
        const uint8_t* fbe_batch_ptr = _buffer.data() + fbe_batch_offset;
        fbe_value.id = unaligned_load<int32_t>(fbe_batch_ptr + 0);
        fbe_value.f1 = static_cast<bool>(unaligned_load<uint8_t>(fbe_batch_ptr + 4));
        fbe_value.f2 = static_cast<bool>(unaligned_load<uint8_t>(fbe_batch_ptr + 5));
        fbe_value.f3 = unaligned_load<uint8_t>(fbe_batch_ptr + 6);
        fbe_value.f4 = unaligned_load<uint8_t>(fbe_batch_ptr + 7);
        fbe_value.f5 = unaligned_load<uint8_t>(fbe_batch_ptr + 8);
        fbe_value.f6 = unaligned_load<uint8_t>(fbe_batch_ptr + 9);
        fbe_value.f7 = unaligned_load<uint32_t>(fbe_batch_ptr + 10);
        fbe_value.f8 = unaligned_load<uint32_t>(fbe_batch_ptr + 14);
        fbe_value.f9 = unaligned_load<int8_t>(fbe_batch_ptr + 18);
        fbe_value.f10 = unaligned_load<int8_t>(fbe_batch_ptr + 19);
        fbe_value.f11 = unaligned_load<uint8_t>(fbe_batch_ptr + 20);
        fbe_value.f12 = unaligned_load<uint8_t>(fbe_batch_ptr + 21);
        fbe_value.f13 = unaligned_load<int16_t>(fbe_batch_ptr + 22);
        fbe_value.f14 = unaligned_load<int16_t>(fbe_batch_ptr + 24);
        fbe_value.f15 = unaligned_load<uint16_t>(fbe_batch_ptr + 26);
        fbe_value.f16 = unaligned_load<uint16_t>(fbe_batch_ptr + 28);
        fbe_value.f17 = unaligned_load<int32_t>(fbe_batch_ptr + 30);
        fbe_value.f18 = unaligned_load<int32_t>(fbe_batch_ptr + 34);
        fbe_value.f19 = unaligned_load<uint32_t>(fbe_batch_ptr + 38);
        fbe_value.f20 = unaligned_load<uint32_t>(fbe_batch_ptr + 42);
        fbe_value.f21 = unaligned_load<int64_t>(fbe_batch_ptr + 46);
        fbe_value.f22 = unaligned_load<int64_t>(fbe_batch_ptr + 54);
        fbe_value.f23 = unaligned_load<uint64_t>(fbe_batch_ptr + 62);
        fbe_value.f24 = unaligned_load<uint64_t>(fbe_batch_ptr + 70);
        fbe_value.f25 = unaligned_load<float>(fbe_batch_ptr + 78);
        fbe_value.f26 = unaligned_load<float>(fbe_batch_ptr + 82);
        fbe_value.f27 = unaligned_load<double>(fbe_batch_ptr + 86);
        fbe_value.f28 = unaligned_load<double>(fbe_batch_ptr + 94);
        fbe_current_offset += 102;
        fbe_current_size += 102;
    }

    f29.fbe_offset(fbe_current_offset);
    fbe_field_size = f29.get(fbe_value.f29, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f30.fbe_offset(fbe_current_offset);
    fbe_field_size = f30.get(fbe_value.f30, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f31.fbe_offset(fbe_current_offset);
    fbe_field_size = f31.get(fbe_value.f31, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f32.fbe_offset(fbe_current_offset);
    fbe_field_size = f32.get(fbe_value.f32, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Batch read 6 fixed-size fields (72 bytes)
    {
        size_t fbe_batch_offset = _buffer.offset() + fbe_current_offset;
        if ((fbe_batch_offset + 72) > _buffer.size())
            return 0;
        const uint8_t* fbe_batch_ptr = _buffer.data() + fbe_batch_offset;
        fbe_value.f33 = unaligned_load<uint64_t>(fbe_batch_ptr + 0);
        fbe_value.f34 = unaligned_load<uint64_t>(fbe_batch_ptr + 8);
        fbe_value.f35 = unaligned_load<uint64_t>(fbe_batch_ptr + 16);
        std::memcpy(fbe_value.f36.data().data(), fbe_batch_ptr + 24, 16);
        std::memcpy(fbe_value.f37.data().data(), fbe_batch_ptr + 40, 16);
        std::memcpy(fbe_value.f38.data().data(), fbe_batch_ptr + 56, 16);
        fbe_current_offset += 72;
        fbe_current_size += 72;
    }

    f39.fbe_offset(fbe_current_offset);
    fbe_field_size = f39.get(fbe_value.f39, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f40.fbe_offset(fbe_current_offset);
    fbe_field_size = f40.get(fbe_value.f40, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f41.fbe_offset(fbe_current_offset);
    fbe_field_size = f41.get(fbe_value.f41, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f42.fbe_offset(fbe_current_offset);
    fbe_field_size = f42.get(fbe_value.f42, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f43.fbe_offset(fbe_current_offset);
    fbe_field_size = f43.get(fbe_value.f43, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f44.fbe_offset(fbe_current_offset);
    fbe_field_size = f44.get(fbe_value.f44, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructSimple>::set(const ::test_pmr::StructSimple& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructSimple>::set_fields([[maybe_unused]] const ::test_pmr::StructSimple& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    // Batch write 29 fixed-size fields (102 bytes)
    {
        size_t fbe_batch_offset = _buffer.offset() + fbe_current_offset;
        assert(((fbe_batch_offset + 102) <= _buffer.size()) && "Model is broken!");
        if ((fbe_batch_offset + 102) > _buffer.size())
            return 0;
        uint8_t* fbe_batch_ptr = _buffer.data() + fbe_batch_offset;
        unaligned_store<int32_t>(fbe_batch_ptr + 0, fbe_value.id);
        unaligned_store<uint8_t>(fbe_batch_ptr + 4, static_cast<uint8_t>(fbe_value.f1));
        unaligned_store<uint8_t>(fbe_batch_ptr + 5, static_cast<uint8_t>(fbe_value.f2));
        unaligned_store<uint8_t>(fbe_batch_ptr + 6, fbe_value.f3);
        unaligned_store<uint8_t>(fbe_batch_ptr + 7, fbe_value.f4);
        unaligned_store<uint8_t>(fbe_batch_ptr + 8, fbe_value.f5);
        unaligned_store<uint8_t>(fbe_batch_ptr + 9, fbe_value.f6);
        unaligned_store<uint32_t>(fbe_batch_ptr + 10, fbe_value.f7);
        unaligned_store<uint32_t>(fbe_batch_ptr + 14, fbe_value.f8);
        unaligned_store<int8_t>(fbe_batch_ptr + 18, fbe_value.f9);
        unaligned_store<int8_t>(fbe_batch_ptr + 19, fbe_value.f10);
        unaligned_store<uint8_t>(fbe_batch_ptr + 20, fbe_value.f11);
        unaligned_store<uint8_t>(fbe_batch_ptr + 21, fbe_value.f12);
        unaligned_store<int16_t>(fbe_batch_ptr + 22, fbe_value.f13);
        unaligned_store<int16_t>(fbe_batch_ptr + 24, fbe_value.f14);
        unaligned_store<uint16_t>(fbe_batch_ptr + 26, fbe_value.f15);
        unaligned_store<uint16_t>(fbe_batch_ptr + 28, fbe_value.f16);
        unaligned_store<int32_t>(fbe_batch_ptr + 30, fbe_value.f17);
        unaligned_store<int32_t>(fbe_batch_ptr + 34, fbe_value.f18);
        unaligned_store<uint32_t>(fbe_batch_ptr + 38, fbe_value.f19);
        unaligned_store<uint32_t>(fbe_batch_ptr + 42, fbe_value.f20);
        unaligned_store<int64_t>(fbe_batch_ptr + 46, fbe_value.f21);
        unaligned_store<int64_t>(fbe_batch_ptr + 54, fbe_value.f22);
        unaligned_store<uint64_t>(fbe_batch_ptr + 62, fbe_value.f23);
        unaligned_store<uint64_t>(fbe_batch_ptr + 70, fbe_value.f24);
        unaligned_store<float>(fbe_batch_ptr + 78, fbe_value.f25);
        unaligned_store<float>(fbe_batch_ptr + 82, fbe_value.f26);
        unaligned_store<double>(fbe_batch_ptr + 86, fbe_value.f27);
        unaligned_store<double>(fbe_batch_ptr + 94, fbe_value.f28);
        fbe_current_offset += 102;
        fbe_current_size += 102;
    }

    f29.fbe_offset(fbe_current_offset);
    fbe_field_size = f29.set(fbe_value.f29);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f30.fbe_offset(fbe_current_offset);
    fbe_field_size = f30.set(fbe_value.f30);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f31.fbe_offset(fbe_current_offset);
    fbe_field_size = f31.set(fbe_value.f31);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f32.fbe_offset(fbe_current_offset);
    fbe_field_size = f32.set(fbe_value.f32);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Batch write 6 fixed-size fields (72 bytes)
    {
        size_t fbe_batch_offset = _buffer.offset() + fbe_current_offset;
        assert(((fbe_batch_offset + 72) <= _buffer.size()) && "Model is broken!");
        if ((fbe_batch_offset + 72) > _buffer.size())
            return 0;
        uint8_t* fbe_batch_ptr = _buffer.data() + fbe_batch_offset;
        unaligned_store<uint64_t>(fbe_batch_ptr + 0, fbe_value.f33);
        unaligned_store<uint64_t>(fbe_batch_ptr + 8, fbe_value.f34);
        unaligned_store<uint64_t>(fbe_batch_ptr + 16, fbe_value.f35);
        std::memcpy(fbe_batch_ptr + 24, fbe_value.f36.data().data(), 16);
        std::memcpy(fbe_batch_ptr + 40, fbe_value.f37.data().data(), 16);
        std::memcpy(fbe_batch_ptr + 56, fbe_value.f38.data().data(), 16);
        fbe_current_offset += 72;
        fbe_current_size += 72;
    }

    f39.fbe_offset(fbe_current_offset);
    fbe_field_size = f39.set(fbe_value.f39);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f40.fbe_offset(fbe_current_offset);
    fbe_field_size = f40.set(fbe_value.f40);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f41.fbe_offset(fbe_current_offset);
    fbe_field_size = f41.set(fbe_value.f41);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f42.fbe_offset(fbe_current_offset);
    fbe_field_size = f42.set(fbe_value.f42);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f43.fbe_offset(fbe_current_offset);
    fbe_field_size = f43.set(fbe_value.f43);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f44.fbe_offset(fbe_current_offset);
    fbe_field_size = f44.set(fbe_value.f44);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

namespace test_pmr {

bool StructSimpleFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t StructSimpleFinalModel::serialize(const ::test_pmr::StructSimple& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t StructSimpleFinalModel::deserialize(::test_pmr::StructSimple& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

size_t StructSimpleFinalModel::deserialize(::test_pmr::StructSimple& value, std::pmr::memory_resource* resource) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value, resource);
}

} // namespace test_pmr

FinalModel<::test_pmr::StructOptional>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , parent(buffer, 0)
    , f100(buffer, 0)
    , f101(buffer, 0)
    , f102(buffer, 0)
    , f103(buffer, 0)
    , f104(buffer, 0)
    , f105(buffer, 0)
    , f106(buffer, 0)
    , f107(buffer, 0)
    , f108(buffer, 0)
    , f109(buffer, 0)
    , f110(buffer, 0)
    , f111(buffer, 0)
    , f112(buffer, 0)
    , f113(buffer, 0)
    , f114(buffer, 0)
    , f115(buffer, 0)
    , f116(buffer, 0)
    , f117(buffer, 0)
    , f118(buffer, 0)
    , f119(buffer, 0)
    , f120(buffer, 0)
    , f121(buffer, 0)
    , f122(buffer, 0)
    , f123(buffer, 0)
    , f124(buffer, 0)
    , f125(buffer, 0)
    , f126(buffer, 0)
    , f127(buffer, 0)
    , f128(buffer, 0)
    , f129(buffer, 0)
    , f130(buffer, 0)
    , f131(buffer, 0)
    , f132(buffer, 0)
    , f133(buffer, 0)
    , f134(buffer, 0)
    , f135(buffer, 0)
    , f136(buffer, 0)
    , f137(buffer, 0)
    , f138(buffer, 0)
    , f139(buffer, 0)
    , f140(buffer, 0)
    , f141(buffer, 0)
    , f142(buffer, 0)
    , f143(buffer, 0)
    , f144(buffer, 0)
    , f145(buffer, 0)
    , f146(buffer, 0)
    , f147(buffer, 0)
    , f148(buffer, 0)
    , f149(buffer, 0)
    , f150(buffer, 0)
    , f151(buffer, 0)
    , f152(buffer, 0)
    , f153(buffer, 0)
    , f154(buffer, 0)
    , f155(buffer, 0)
    , f156(buffer, 0)
    , f157(buffer, 0)
    , f158(buffer, 0)
    , f159(buffer, 0)
    , f160(buffer, 0)
    , f161(buffer, 0)
    , f162(buffer, 0)
    , f163(buffer, 0)
    , f164(buffer, 0)
    , f165(buffer, 0)
{}

size_t FinalModel<::test_pmr::StructOptional>::fbe_allocation_size(const ::test_pmr::StructOptional& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + parent.fbe_allocation_size(fbe_value)
        + f100.fbe_allocation_size(fbe_value.f100)
        + f101.fbe_allocation_size(fbe_value.f101)
        + f102.fbe_allocation_size(fbe_value.f102)
        + f103.fbe_allocation_size(fbe_value.f103)
        + f104.fbe_allocation_size(fbe_value.f104)
        + f105.fbe_allocation_size(fbe_value.f105)
        + f106.fbe_allocation_size(fbe_value.f106)
        + f107.fbe_allocation_size(fbe_value.f107)
        + f108.fbe_allocation_size(fbe_value.f108)
        + f109.fbe_allocation_size(fbe_value.f109)
        + f110.fbe_allocation_size(fbe_value.f110)
        + f111.fbe_allocation_size(fbe_value.f111)
        + f112.fbe_allocation_size(fbe_value.f112)
        + f113.fbe_allocation_size(fbe_value.f113)
        + f114.fbe_allocation_size(fbe_value.f114)
        + f115.fbe_allocation_size(fbe_value.f115)
        + f116.fbe_allocation_size(fbe_value.f116)
        + f117.fbe_allocation_size(fbe_value.f117)
        + f118.fbe_allocation_size(fbe_value.f118)
        + f119.fbe_allocation_size(fbe_value.f119)
        + f120.fbe_allocation_size(fbe_value.f120)
        + f121.fbe_allocation_size(fbe_value.f121)
        + f122.fbe_allocation_size(fbe_value.f122)
        + f123.fbe_allocation_size(fbe_value.f123)
        + f124.fbe_allocation_size(fbe_value.f124)
        + f125.fbe_allocation_size(fbe_value.f125)
        + f126.fbe_allocation_size(fbe_value.f126)
        + f127.fbe_allocation_size(fbe_value.f127)
        + f128.fbe_allocation_size(fbe_value.f128)
        + f129.fbe_allocation_size(fbe_value.f129)
        + f130.fbe_allocation_size(fbe_value.f130)
        + f131.fbe_allocation_size(fbe_value.f131)
        + f132.fbe_allocation_size(fbe_value.f132)
        + f133.fbe_allocation_size(fbe_value.f133)
        + f134.fbe_allocation_size(fbe_value.f134)
        + f135.fbe_allocation_size(fbe_value.f135)
        + f136.fbe_allocation_size(fbe_value.f136)
        + f137.fbe_allocation_size(fbe_value.f137)
        + f138.fbe_allocation_size(fbe_value.f138)
        + f139.fbe_allocation_size(fbe_value.f139)
        + f140.fbe_allocation_size(fbe_value.f140)
        + f141.fbe_allocation_size(fbe_value.f141)
        + f142.fbe_allocation_size(fbe_value.f142)
        + f143.fbe_allocation_size(fbe_value.f143)
        + f144.fbe_allocation_size(fbe_value.f144)
        + f145.fbe_allocation_size(fbe_value.f145)
        + f146.fbe_allocation_size(fbe_value.f146)
        + f147.fbe_allocation_size(fbe_value.f147)
        + f148.fbe_allocation_size(fbe_value.f148)
        + f149.fbe_allocation_size(fbe_value.f149)
        + f150.fbe_allocation_size(fbe_value.f150)
        + f151.fbe_allocation_size(fbe_value.f151)
        + f152.fbe_allocation_size(fbe_value.f152)
        + f153.fbe_allocation_size(fbe_value.f153)
        + f154.fbe_allocation_size(fbe_value.f154)
        + f155.fbe_allocation_size(fbe_value.f155)
        + f156.fbe_allocation_size(fbe_value.f156)
        + f157.fbe_allocation_size(fbe_value.f157)
        + f158.fbe_allocation_size(fbe_value.f158)
        + f159.fbe_allocation_size(fbe_value.f159)
        + f160.fbe_allocation_size(fbe_value.f160)
        + f161.fbe_allocation_size(fbe_value.f161)
        + f162.fbe_allocation_size(fbe_value.f162)
        + f163.fbe_allocation_size(fbe_value.f163)
        + f164.fbe_allocation_size(fbe_value.f164)
        + f165.fbe_allocation_size(fbe_value.f165)
        ;
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructOptional>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructOptional>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    parent.fbe_offset(fbe_current_offset);
    fbe_field_size = parent.verify_fields();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f100.fbe_offset(fbe_current_offset);
    fbe_field_size = f100.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f101.fbe_offset(fbe_current_offset);
    fbe_field_size = f101.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f102.fbe_offset(fbe_current_offset);
    fbe_field_size = f102.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f103.fbe_offset(fbe_current_offset);
    fbe_field_size = f103.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f104.fbe_offset(fbe_current_offset);
    fbe_field_size = f104.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f105.fbe_offset(fbe_current_offset);
    fbe_field_size = f105.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f106.fbe_offset(fbe_current_offset);
    fbe_field_size = f106.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f107.fbe_offset(fbe_current_offset);
    fbe_field_size = f107.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f108.fbe_offset(fbe_current_offset);
    fbe_field_size = f108.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f109.fbe_offset(fbe_current_offset);
    fbe_field_size = f109.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f110.fbe_offset(fbe_current_offset);
    fbe_field_size = f110.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f111.fbe_offset(fbe_current_offset);
    fbe_field_size = f111.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f112.fbe_offset(fbe_current_offset);
    fbe_field_size = f112.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f113.fbe_offset(fbe_current_offset);
    fbe_field_size = f113.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f114.fbe_offset(fbe_current_offset);
    fbe_field_size = f114.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f115.fbe_offset(fbe_current_offset);
    fbe_field_size = f115.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f116.fbe_offset(fbe_current_offset);
    fbe_field_size = f116.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f117.fbe_offset(fbe_current_offset);
    fbe_field_size = f117.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f118.fbe_offset(fbe_current_offset);
    fbe_field_size = f118.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f119.fbe_offset(fbe_current_offset);
    fbe_field_size = f119.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f120.fbe_offset(fbe_current_offset);
    fbe_field_size = f120.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f121.fbe_offset(fbe_current_offset);
    fbe_field_size = f121.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f122.fbe_offset(fbe_current_offset);
    fbe_field_size = f122.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f123.fbe_offset(fbe_current_offset);
    fbe_field_size = f123.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f124.fbe_offset(fbe_current_offset);
    fbe_field_size = f124.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f125.fbe_offset(fbe_current_offset);
    fbe_field_size = f125.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f126.fbe_offset(fbe_current_offset);
    fbe_field_size = f126.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f127.fbe_offset(fbe_current_offset);
    fbe_field_size = f127.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f128.fbe_offset(fbe_current_offset);
    fbe_field_size = f128.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f129.fbe_offset(fbe_current_offset);
    fbe_field_size = f129.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f130.fbe_offset(fbe_current_offset);
    fbe_field_size = f130.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f131.fbe_offset(fbe_current_offset);
    fbe_field_size = f131.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f132.fbe_offset(fbe_current_offset);
    fbe_field_size = f132.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f133.fbe_offset(fbe_current_offset);
    fbe_field_size = f133.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f134.fbe_offset(fbe_current_offset);
    fbe_field_size = f134.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f135.fbe_offset(fbe_current_offset);
    fbe_field_size = f135.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f136.fbe_offset(fbe_current_offset);
    fbe_field_size = f136.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f137.fbe_offset(fbe_current_offset);
    fbe_field_size = f137.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f138.fbe_offset(fbe_current_offset);
    fbe_field_size = f138.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f139.fbe_offset(fbe_current_offset);
    fbe_field_size = f139.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f140.fbe_offset(fbe_current_offset);
    fbe_field_size = f140.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f141.fbe_offset(fbe_current_offset);
    fbe_field_size = f141.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f142.fbe_offset(fbe_current_offset);
    fbe_field_size = f142.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f143.fbe_offset(fbe_current_offset);
    fbe_field_size = f143.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f144.fbe_offset(fbe_current_offset);
    fbe_field_size = f144.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f145.fbe_offset(fbe_current_offset);
    fbe_field_size = f145.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f146.fbe_offset(fbe_current_offset);
    fbe_field_size = f146.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f147.fbe_offset(fbe_current_offset);
    fbe_field_size = f147.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f148.fbe_offset(fbe_current_offset);
    fbe_field_size = f148.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f149.fbe_offset(fbe_current_offset);
    fbe_field_size = f149.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f150.fbe_offset(fbe_current_offset);
    fbe_field_size = f150.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f151.fbe_offset(fbe_current_offset);
    fbe_field_size = f151.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f152.fbe_offset(fbe_current_offset);
    fbe_field_size = f152.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f153.fbe_offset(fbe_current_offset);
    fbe_field_size = f153.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f154.fbe_offset(fbe_current_offset);
    fbe_field_size = f154.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f155.fbe_offset(fbe_current_offset);
    fbe_field_size = f155.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f156.fbe_offset(fbe_current_offset);
    fbe_field_size = f156.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f157.fbe_offset(fbe_current_offset);
    fbe_field_size = f157.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f158.fbe_offset(fbe_current_offset);
    fbe_field_size = f158.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f159.fbe_offset(fbe_current_offset);
    fbe_field_size = f159.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f160.fbe_offset(fbe_current_offset);
    fbe_field_size = f160.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f161.fbe_offset(fbe_current_offset);
    fbe_field_size = f161.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f162.fbe_offset(fbe_current_offset);
    fbe_field_size = f162.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f163.fbe_offset(fbe_current_offset);
    fbe_field_size = f163.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f164.fbe_offset(fbe_current_offset);
    fbe_field_size = f164.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f165.fbe_offset(fbe_current_offset);
    fbe_field_size = f165.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    return fbe_current_offset;
}

size_t FinalModel<::test_pmr::StructOptional>::get(::test_pmr::StructOptional& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructOptional>::get_fields([[maybe_unused]] ::test_pmr::StructOptional& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    parent.fbe_offset(fbe_current_offset);
    fbe_field_size = parent.get_fields(fbe_value);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f100.fbe_offset(fbe_current_offset);
    fbe_field_size = f100.get(fbe_value.f100);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f101.fbe_offset(fbe_current_offset);
    fbe_field_size = f101.get(fbe_value.f101);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f102.fbe_offset(fbe_current_offset);
    fbe_field_size = f102.get(fbe_value.f102);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f103.fbe_offset(fbe_current_offset);
    fbe_field_size = f103.get(fbe_value.f103);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f104.fbe_offset(fbe_current_offset);
    fbe_field_size = f104.get(fbe_value.f104);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f105.fbe_offset(fbe_current_offset);
    fbe_field_size = f105.get(fbe_value.f105);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f106.fbe_offset(fbe_current_offset);
    fbe_field_size = f106.get(fbe_value.f106);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f107.fbe_offset(fbe_current_offset);
    fbe_field_size = f107.get(fbe_value.f107);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f108.fbe_offset(fbe_current_offset);
    fbe_field_size = f108.get(fbe_value.f108);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f109.fbe_offset(fbe_current_offset);
    fbe_field_size = f109.get(fbe_value.f109);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f110.fbe_offset(fbe_current_offset);
    fbe_field_size = f110.get(fbe_value.f110);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f111.fbe_offset(fbe_current_offset);
    fbe_field_size = f111.get(fbe_value.f111);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f112.fbe_offset(fbe_current_offset);
    fbe_field_size = f112.get(fbe_value.f112);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f113.fbe_offset(fbe_current_offset);
    fbe_field_size = f113.get(fbe_value.f113);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f114.fbe_offset(fbe_current_offset);
    fbe_field_size = f114.get(fbe_value.f114);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f115.fbe_offset(fbe_current_offset);
    fbe_field_size = f115.get(fbe_value.f115);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f116.fbe_offset(fbe_current_offset);
    fbe_field_size = f116.get(fbe_value.f116);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f117.fbe_offset(fbe_current_offset);
    fbe_field_size = f117.get(fbe_value.f117);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f118.fbe_offset(fbe_current_offset);
    fbe_field_size = f118.get(fbe_value.f118);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f119.fbe_offset(fbe_current_offset);
    fbe_field_size = f119.get(fbe_value.f119);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f120.fbe_offset(fbe_current_offset);
    fbe_field_size = f120.get(fbe_value.f120);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f121.fbe_offset(fbe_current_offset);
    fbe_field_size = f121.get(fbe_value.f121);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f122.fbe_offset(fbe_current_offset);
    fbe_field_size = f122.get(fbe_value.f122);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f123.fbe_offset(fbe_current_offset);
    fbe_field_size = f123.get(fbe_value.f123);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f124.fbe_offset(fbe_current_offset);
    fbe_field_size = f124.get(fbe_value.f124);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f125.fbe_offset(fbe_current_offset);
    fbe_field_size = f125.get(fbe_value.f125);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f126.fbe_offset(fbe_current_offset);
    fbe_field_size = f126.get(fbe_value.f126);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f127.fbe_offset(fbe_current_offset);
    fbe_field_size = f127.get(fbe_value.f127);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f128.fbe_offset(fbe_current_offset);
    fbe_field_size = f128.get(fbe_value.f128);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f129.fbe_offset(fbe_current_offset);
    fbe_field_size = f129.get(fbe_value.f129);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f130.fbe_offset(fbe_current_offset);
    fbe_field_size = f130.get(fbe_value.f130);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f131.fbe_offset(fbe_current_offset);
    fbe_field_size = f131.get(fbe_value.f131);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f132.fbe_offset(fbe_current_offset);
    fbe_field_size = f132.get(fbe_value.f132);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f133.fbe_offset(fbe_current_offset);
    fbe_field_size = f133.get(fbe_value.f133);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f134.fbe_offset(fbe_current_offset);
    fbe_field_size = f134.get(fbe_value.f134);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f135.fbe_offset(fbe_current_offset);
    fbe_field_size = f135.get(fbe_value.f135);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f136.fbe_offset(fbe_current_offset);
    fbe_field_size = f136.get(fbe_value.f136);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f137.fbe_offset(fbe_current_offset);
    fbe_field_size = f137.get(fbe_value.f137);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f138.fbe_offset(fbe_current_offset);
    fbe_field_size = f138.get(fbe_value.f138);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f139.fbe_offset(fbe_current_offset);
    fbe_field_size = f139.get(fbe_value.f139);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f140.fbe_offset(fbe_current_offset);
    fbe_field_size = f140.get(fbe_value.f140);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f141.fbe_offset(fbe_current_offset);
    fbe_field_size = f141.get(fbe_value.f141);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f142.fbe_offset(fbe_current_offset);
    fbe_field_size = f142.get(fbe_value.f142);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f143.fbe_offset(fbe_current_offset);
    fbe_field_size = f143.get(fbe_value.f143);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f144.fbe_offset(fbe_current_offset);
    fbe_field_size = f144.get(fbe_value.f144);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f145.fbe_offset(fbe_current_offset);
    fbe_field_size = f145.get(fbe_value.f145);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f146.fbe_offset(fbe_current_offset);
    fbe_field_size = f146.get(fbe_value.f146);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f147.fbe_offset(fbe_current_offset);
    fbe_field_size = f147.get(fbe_value.f147);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f148.fbe_offset(fbe_current_offset);
    fbe_field_size = f148.get(fbe_value.f148);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f149.fbe_offset(fbe_current_offset);
    fbe_field_size = f149.get(fbe_value.f149);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f150.fbe_offset(fbe_current_offset);
    fbe_field_size = f150.get(fbe_value.f150);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f151.fbe_offset(fbe_current_offset);
    fbe_field_size = f151.get(fbe_value.f151);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f152.fbe_offset(fbe_current_offset);
    fbe_field_size = f152.get(fbe_value.f152);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f153.fbe_offset(fbe_current_offset);
    fbe_field_size = f153.get(fbe_value.f153);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f154.fbe_offset(fbe_current_offset);
    fbe_field_size = f154.get(fbe_value.f154);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f155.fbe_offset(fbe_current_offset);
    fbe_field_size = f155.get(fbe_value.f155);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f156.fbe_offset(fbe_current_offset);
    fbe_field_size = f156.get(fbe_value.f156);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f157.fbe_offset(fbe_current_offset);
    fbe_field_size = f157.get(fbe_value.f157);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f158.fbe_offset(fbe_current_offset);
    fbe_field_size = f158.get(fbe_value.f158);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f159.fbe_offset(fbe_current_offset);
    fbe_field_size = f159.get(fbe_value.f159);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f160.fbe_offset(fbe_current_offset);
    fbe_field_size = f160.get(fbe_value.f160);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f161.fbe_offset(fbe_current_offset);
    fbe_field_size = f161.get(fbe_value.f161);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f162.fbe_offset(fbe_current_offset);
    fbe_field_size = f162.get(fbe_value.f162);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f163.fbe_offset(fbe_current_offset);
    fbe_field_size = f163.get(fbe_value.f163);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f164.fbe_offset(fbe_current_offset);
    fbe_field_size = f164.get(fbe_value.f164);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f165.fbe_offset(fbe_current_offset);
    fbe_field_size = f165.get(fbe_value.f165);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructOptional>::get(::test_pmr::StructOptional& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value, resource);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructOptional>::get_fields([[maybe_unused]] ::test_pmr::StructOptional& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    parent.fbe_offset(fbe_current_offset);
    fbe_field_size = parent.get_fields(fbe_value, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f100.fbe_offset(fbe_current_offset);
    fbe_field_size = f100.get(fbe_value.f100, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f101.fbe_offset(fbe_current_offset);
    fbe_field_size = f101.get(fbe_value.f101, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f102.fbe_offset(fbe_current_offset);
    fbe_field_size = f102.get(fbe_value.f102, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f103.fbe_offset(fbe_current_offset);
    fbe_field_size = f103.get(fbe_value.f103, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f104.fbe_offset(fbe_current_offset);
    fbe_field_size = f104.get(fbe_value.f104, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f105.fbe_offset(fbe_current_offset);
    fbe_field_size = f105.get(fbe_value.f105, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f106.fbe_offset(fbe_current_offset);
    fbe_field_size = f106.get(fbe_value.f106, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f107.fbe_offset(fbe_current_offset);
    fbe_field_size = f107.get(fbe_value.f107, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f108.fbe_offset(fbe_current_offset);
    fbe_field_size = f108.get(fbe_value.f108, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f109.fbe_offset(fbe_current_offset);
    fbe_field_size = f109.get(fbe_value.f109, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f110.fbe_offset(fbe_current_offset);
    fbe_field_size = f110.get(fbe_value.f110, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f111.fbe_offset(fbe_current_offset);
    fbe_field_size = f111.get(fbe_value.f111, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f112.fbe_offset(fbe_current_offset);
    fbe_field_size = f112.get(fbe_value.f112, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f113.fbe_offset(fbe_current_offset);
    fbe_field_size = f113.get(fbe_value.f113, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f114.fbe_offset(fbe_current_offset);
    fbe_field_size = f114.get(fbe_value.f114, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f115.fbe_offset(fbe_current_offset);
    fbe_field_size = f115.get(fbe_value.f115, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f116.fbe_offset(fbe_current_offset);
    fbe_field_size = f116.get(fbe_value.f116, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f117.fbe_offset(fbe_current_offset);
    fbe_field_size = f117.get(fbe_value.f117, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f118.fbe_offset(fbe_current_offset);
    fbe_field_size = f118.get(fbe_value.f118, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f119.fbe_offset(fbe_current_offset);
    fbe_field_size = f119.get(fbe_value.f119, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f120.fbe_offset(fbe_current_offset);
    fbe_field_size = f120.get(fbe_value.f120, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f121.fbe_offset(fbe_current_offset);
    fbe_field_size = f121.get(fbe_value.f121, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f122.fbe_offset(fbe_current_offset);
    fbe_field_size = f122.get(fbe_value.f122, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f123.fbe_offset(fbe_current_offset);
    fbe_field_size = f123.get(fbe_value.f123, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f124.fbe_offset(fbe_current_offset);
    fbe_field_size = f124.get(fbe_value.f124, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f125.fbe_offset(fbe_current_offset);
    fbe_field_size = f125.get(fbe_value.f125, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f126.fbe_offset(fbe_current_offset);
    fbe_field_size = f126.get(fbe_value.f126, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f127.fbe_offset(fbe_current_offset);
    fbe_field_size = f127.get(fbe_value.f127, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f128.fbe_offset(fbe_current_offset);
    fbe_field_size = f128.get(fbe_value.f128, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f129.fbe_offset(fbe_current_offset);
    fbe_field_size = f129.get(fbe_value.f129, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f130.fbe_offset(fbe_current_offset);
    fbe_field_size = f130.get(fbe_value.f130, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f131.fbe_offset(fbe_current_offset);
    fbe_field_size = f131.get(fbe_value.f131, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f132.fbe_offset(fbe_current_offset);
    fbe_field_size = f132.get(fbe_value.f132, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f133.fbe_offset(fbe_current_offset);
    fbe_field_size = f133.get(fbe_value.f133, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f134.fbe_offset(fbe_current_offset);
    fbe_field_size = f134.get(fbe_value.f134, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f135.fbe_offset(fbe_current_offset);
    fbe_field_size = f135.get(fbe_value.f135, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f136.fbe_offset(fbe_current_offset);
    fbe_field_size = f136.get(fbe_value.f136, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f137.fbe_offset(fbe_current_offset);
    fbe_field_size = f137.get(fbe_value.f137, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f138.fbe_offset(fbe_current_offset);
    fbe_field_size = f138.get(fbe_value.f138, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f139.fbe_offset(fbe_current_offset);
    fbe_field_size = f139.get(fbe_value.f139, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f140.fbe_offset(fbe_current_offset);
    fbe_field_size = f140.get(fbe_value.f140, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f141.fbe_offset(fbe_current_offset);
    fbe_field_size = f141.get(fbe_value.f141, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f142.fbe_offset(fbe_current_offset);
    fbe_field_size = f142.get(fbe_value.f142, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f143.fbe_offset(fbe_current_offset);
    fbe_field_size = f143.get(fbe_value.f143, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f144.fbe_offset(fbe_current_offset);
    fbe_field_size = f144.get(fbe_value.f144, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f145.fbe_offset(fbe_current_offset);
    fbe_field_size = f145.get(fbe_value.f145, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f146.fbe_offset(fbe_current_offset);
    fbe_field_size = f146.get(fbe_value.f146, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f147.fbe_offset(fbe_current_offset);
    fbe_field_size = f147.get(fbe_value.f147, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f148.fbe_offset(fbe_current_offset);
    fbe_field_size = f148.get(fbe_value.f148, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f149.fbe_offset(fbe_current_offset);
    fbe_field_size = f149.get(fbe_value.f149, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f150.fbe_offset(fbe_current_offset);
    fbe_field_size = f150.get(fbe_value.f150, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f151.fbe_offset(fbe_current_offset);
    fbe_field_size = f151.get(fbe_value.f151, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f152.fbe_offset(fbe_current_offset);
    fbe_field_size = f152.get(fbe_value.f152, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f153.fbe_offset(fbe_current_offset);
    fbe_field_size = f153.get(fbe_value.f153, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f154.fbe_offset(fbe_current_offset);
    fbe_field_size = f154.get(fbe_value.f154, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f155.fbe_offset(fbe_current_offset);
    fbe_field_size = f155.get(fbe_value.f155, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f156.fbe_offset(fbe_current_offset);
    fbe_field_size = f156.get(fbe_value.f156, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f157.fbe_offset(fbe_current_offset);
    fbe_field_size = f157.get(fbe_value.f157, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f158.fbe_offset(fbe_current_offset);
    fbe_field_size = f158.get(fbe_value.f158, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f159.fbe_offset(fbe_current_offset);
    fbe_field_size = f159.get(fbe_value.f159, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f160.fbe_offset(fbe_current_offset);
    fbe_field_size = f160.get(fbe_value.f160, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f161.fbe_offset(fbe_current_offset);
    fbe_field_size = f161.get(fbe_value.f161, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f162.fbe_offset(fbe_current_offset);
    fbe_field_size = f162.get(fbe_value.f162, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f163.fbe_offset(fbe_current_offset);
    fbe_field_size = f163.get(fbe_value.f163, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f164.fbe_offset(fbe_current_offset);
    fbe_field_size = f164.get(fbe_value.f164, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f165.fbe_offset(fbe_current_offset);
    fbe_field_size = f165.get(fbe_value.f165, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructOptional>::set(const ::test_pmr::StructOptional& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructOptional>::set_fields([[maybe_unused]] const ::test_pmr::StructOptional& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    parent.fbe_offset(fbe_current_offset);
    fbe_field_size = parent.set_fields(fbe_value);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f100.fbe_offset(fbe_current_offset);
    fbe_field_size = f100.set(fbe_value.f100);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f101.fbe_offset(fbe_current_offset);
    fbe_field_size = f101.set(fbe_value.f101);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f102.fbe_offset(fbe_current_offset);
    fbe_field_size = f102.set(fbe_value.f102);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f103.fbe_offset(fbe_current_offset);
    fbe_field_size = f103.set(fbe_value.f103);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f104.fbe_offset(fbe_current_offset);
    fbe_field_size = f104.set(fbe_value.f104);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f105.fbe_offset(fbe_current_offset);
    fbe_field_size = f105.set(fbe_value.f105);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f106.fbe_offset(fbe_current_offset);
    fbe_field_size = f106.set(fbe_value.f106);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f107.fbe_offset(fbe_current_offset);
    fbe_field_size = f107.set(fbe_value.f107);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f108.fbe_offset(fbe_current_offset);
    fbe_field_size = f108.set(fbe_value.f108);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f109.fbe_offset(fbe_current_offset);
    fbe_field_size = f109.set(fbe_value.f109);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f110.fbe_offset(fbe_current_offset);
    fbe_field_size = f110.set(fbe_value.f110);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f111.fbe_offset(fbe_current_offset);
    fbe_field_size = f111.set(fbe_value.f111);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f112.fbe_offset(fbe_current_offset);
    fbe_field_size = f112.set(fbe_value.f112);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f113.fbe_offset(fbe_current_offset);
    fbe_field_size = f113.set(fbe_value.f113);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f114.fbe_offset(fbe_current_offset);
    fbe_field_size = f114.set(fbe_value.f114);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f115.fbe_offset(fbe_current_offset);
    fbe_field_size = f115.set(fbe_value.f115);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f116.fbe_offset(fbe_current_offset);
    fbe_field_size = f116.set(fbe_value.f116);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f117.fbe_offset(fbe_current_offset);
    fbe_field_size = f117.set(fbe_value.f117);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f118.fbe_offset(fbe_current_offset);
    fbe_field_size = f118.set(fbe_value.f118);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f119.fbe_offset(fbe_current_offset);
    fbe_field_size = f119.set(fbe_value.f119);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f120.fbe_offset(fbe_current_offset);
    fbe_field_size = f120.set(fbe_value.f120);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f121.fbe_offset(fbe_current_offset);
    fbe_field_size = f121.set(fbe_value.f121);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f122.fbe_offset(fbe_current_offset);
    fbe_field_size = f122.set(fbe_value.f122);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f123.fbe_offset(fbe_current_offset);
    fbe_field_size = f123.set(fbe_value.f123);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f124.fbe_offset(fbe_current_offset);
    fbe_field_size = f124.set(fbe_value.f124);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f125.fbe_offset(fbe_current_offset);
    fbe_field_size = f125.set(fbe_value.f125);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f126.fbe_offset(fbe_current_offset);
    fbe_field_size = f126.set(fbe_value.f126);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f127.fbe_offset(fbe_current_offset);
    fbe_field_size = f127.set(fbe_value.f127);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f128.fbe_offset(fbe_current_offset);
    fbe_field_size = f128.set(fbe_value.f128);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f129.fbe_offset(fbe_current_offset);
    fbe_field_size = f129.set(fbe_value.f129);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f130.fbe_offset(fbe_current_offset);
    fbe_field_size = f130.set(fbe_value.f130);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f131.fbe_offset(fbe_current_offset);
    fbe_field_size = f131.set(fbe_value.f131);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f132.fbe_offset(fbe_current_offset);
    fbe_field_size = f132.set(fbe_value.f132);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f133.fbe_offset(fbe_current_offset);
    fbe_field_size = f133.set(fbe_value.f133);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f134.fbe_offset(fbe_current_offset);
    fbe_field_size = f134.set(fbe_value.f134);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f135.fbe_offset(fbe_current_offset);
    fbe_field_size = f135.set(fbe_value.f135);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f136.fbe_offset(fbe_current_offset);
    fbe_field_size = f136.set(fbe_value.f136);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f137.fbe_offset(fbe_current_offset);
    fbe_field_size = f137.set(fbe_value.f137);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f138.fbe_offset(fbe_current_offset);
    fbe_field_size = f138.set(fbe_value.f138);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f139.fbe_offset(fbe_current_offset);
    fbe_field_size = f139.set(fbe_value.f139);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f140.fbe_offset(fbe_current_offset);
    fbe_field_size = f140.set(fbe_value.f140);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f141.fbe_offset(fbe_current_offset);
    fbe_field_size = f141.set(fbe_value.f141);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f142.fbe_offset(fbe_current_offset);
    fbe_field_size = f142.set(fbe_value.f142);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f143.fbe_offset(fbe_current_offset);
    fbe_field_size = f143.set(fbe_value.f143);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f144.fbe_offset(fbe_current_offset);
    fbe_field_size = f144.set(fbe_value.f144);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f145.fbe_offset(fbe_current_offset);
    fbe_field_size = f145.set(fbe_value.f145);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f146.fbe_offset(fbe_current_offset);
    fbe_field_size = f146.set(fbe_value.f146);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f147.fbe_offset(fbe_current_offset);
    fbe_field_size = f147.set(fbe_value.f147);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f148.fbe_offset(fbe_current_offset);
    fbe_field_size = f148.set(fbe_value.f148);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f149.fbe_offset(fbe_current_offset);
    fbe_field_size = f149.set(fbe_value.f149);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f150.fbe_offset(fbe_current_offset);
    fbe_field_size = f150.set(fbe_value.f150);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f151.fbe_offset(fbe_current_offset);
    fbe_field_size = f151.set(fbe_value.f151);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f152.fbe_offset(fbe_current_offset);
    fbe_field_size = f152.set(fbe_value.f152);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f153.fbe_offset(fbe_current_offset);
    fbe_field_size = f153.set(fbe_value.f153);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f154.fbe_offset(fbe_current_offset);
    fbe_field_size = f154.set(fbe_value.f154);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f155.fbe_offset(fbe_current_offset);
    fbe_field_size = f155.set(fbe_value.f155);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f156.fbe_offset(fbe_current_offset);
    fbe_field_size = f156.set(fbe_value.f156);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f157.fbe_offset(fbe_current_offset);
    fbe_field_size = f157.set(fbe_value.f157);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f158.fbe_offset(fbe_current_offset);
    fbe_field_size = f158.set(fbe_value.f158);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f159.fbe_offset(fbe_current_offset);
    fbe_field_size = f159.set(fbe_value.f159);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f160.fbe_offset(fbe_current_offset);
    fbe_field_size = f160.set(fbe_value.f160);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f161.fbe_offset(fbe_current_offset);
    fbe_field_size = f161.set(fbe_value.f161);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f162.fbe_offset(fbe_current_offset);
    fbe_field_size = f162.set(fbe_value.f162);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f163.fbe_offset(fbe_current_offset);
    fbe_field_size = f163.set(fbe_value.f163);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f164.fbe_offset(fbe_current_offset);
    fbe_field_size = f164.set(fbe_value.f164);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f165.fbe_offset(fbe_current_offset);
    fbe_field_size = f165.set(fbe_value.f165);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

namespace test_pmr {

bool StructOptionalFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t StructOptionalFinalModel::serialize(const ::test_pmr::StructOptional& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t StructOptionalFinalModel::deserialize(::test_pmr::StructOptional& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

size_t StructOptionalFinalModel::deserialize(::test_pmr::StructOptional& value, std::pmr::memory_resource* resource) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value, resource);
}

} // namespace test_pmr

FinalModel<::test_pmr::StructNested>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , parent(buffer, 0)
    , f1000(buffer, 0)
    , f1001(buffer, 0)
    , f1002(buffer, 0)
    , f1003(buffer, 0)
    , f1004(buffer, 0)
    , f1005(buffer, 0)
    , f1006(buffer, 0)
    , f1007(buffer, 0)
    , f1008(buffer, 0)
    , f1009(buffer, 0)
    , f1010(buffer, 0)
    , f1011(buffer, 0)
{}

size_t FinalModel<::test_pmr::StructNested>::fbe_allocation_size(const ::test_pmr::StructNested& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + parent.fbe_allocation_size(fbe_value)
        + f1000.fbe_allocation_size(fbe_value.f1000)
        + f1001.fbe_allocation_size(fbe_value.f1001)
        + f1002.fbe_allocation_size(fbe_value.f1002)
        + f1003.fbe_allocation_size(fbe_value.f1003)
        + f1004.fbe_allocation_size(fbe_value.f1004)
        + f1005.fbe_allocation_size(fbe_value.f1005)
        + f1006.fbe_allocation_size(fbe_value.f1006)
        + f1007.fbe_allocation_size(fbe_value.f1007)
        + f1008.fbe_allocation_size(fbe_value.f1008)
        + f1009.fbe_allocation_size(fbe_value.f1009)
        + f1010.fbe_allocation_size(fbe_value.f1010)
        + f1011.fbe_allocation_size(fbe_value.f1011)
        ;
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructNested>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructNested>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    parent.fbe_offset(fbe_current_offset);
    fbe_field_size = parent.verify_fields();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    // Inline verify of EnumSimple field f1000 (4 bytes)
    if ((_buffer.offset() + fbe_current_offset + 4) > _buffer.size())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += 4;

    f1001.fbe_offset(fbe_current_offset);
    fbe_field_size = f1001.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    // Inline verify of EnumTyped field f1002 (1 bytes)
    if ((_buffer.offset() + fbe_current_offset + 1) > _buffer.size())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += 1;

    f1003.fbe_offset(fbe_current_offset);
    fbe_field_size = f1003.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    // Inline verify of FlagsSimple field f1004 (4 bytes)
    if ((_buffer.offset() + fbe_current_offset + 4) > _buffer.size())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += 4;

    f1005.fbe_offset(fbe_current_offset);
    fbe_field_size = f1005.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    // Inline verify of FlagsTyped field f1006 (8 bytes)
    if ((_buffer.offset() + fbe_current_offset + 8) > _buffer.size())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += 8;

    f1007.fbe_offset(fbe_current_offset);
    fbe_field_size = f1007.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f1008.fbe_offset(fbe_current_offset);
    fbe_field_size = f1008.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f1009.fbe_offset(fbe_current_offset);
    fbe_field_size = f1009.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f1010.fbe_offset(fbe_current_offset);
    fbe_field_size = f1010.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f1011.fbe_offset(fbe_current_offset);
    fbe_field_size = f1011.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    return fbe_current_offset;
}

size_t FinalModel<::test_pmr::StructNested>::get(::test_pmr::StructNested& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructNested>::get_fields([[maybe_unused]] ::test_pmr::StructNested& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    parent.fbe_offset(fbe_current_offset);
    fbe_field_size = parent.get_fields(fbe_value);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Inline read of EnumSimple field f1000 (4 bytes)
    {
        size_t fbe_field_offset = _buffer.offset() + fbe_current_offset;
        if ((fbe_field_offset + 4) > _buffer.size())
            return 0;
        fbe_value.f1000 = static_cast<decltype(fbe_value.f1000)>(unaligned_load<int32_t>(_buffer.data() + fbe_field_offset));
        fbe_current_offset += 4;
        fbe_current_size += 4;
    }

    f1001.fbe_offset(fbe_current_offset);
    fbe_field_size = f1001.get(fbe_value.f1001);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Inline read of EnumTyped field f1002 (1 bytes)
    {
        size_t fbe_field_offset = _buffer.offset() + fbe_current_offset;
        if ((fbe_field_offset + 1) > _buffer.size())
            return 0;
        fbe_value.f1002 = static_cast<decltype(fbe_value.f1002)>(unaligned_load<uint8_t>(_buffer.data() + fbe_field_offset));
        fbe_current_offset += 1;
        fbe_current_size += 1;
    }

    f1003.fbe_offset(fbe_current_offset);
    fbe_field_size = f1003.get(fbe_value.f1003);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Inline read of FlagsSimple field f1004 (4 bytes)
    {
        size_t fbe_field_offset = _buffer.offset() + fbe_current_offset;
        if ((fbe_field_offset + 4) > _buffer.size())
            return 0;
        fbe_value.f1004 = static_cast<decltype(fbe_value.f1004)>(unaligned_load<int32_t>(_buffer.data() + fbe_field_offset));
        fbe_current_offset += 4;
        fbe_current_size += 4;
    }

    f1005.fbe_offset(fbe_current_offset);
    fbe_field_size = f1005.get(fbe_value.f1005);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Inline read of FlagsTyped field f1006 (8 bytes)
    {
        size_t fbe_field_offset = _buffer.offset() + fbe_current_offset;
        if ((fbe_field_offset + 8) > _buffer.size())
            return 0;
        fbe_value.f1006 = static_cast<decltype(fbe_value.f1006)>(unaligned_load<uint64_t>(_buffer.data() + fbe_field_offset));
        fbe_current_offset += 8;
        fbe_current_size += 8;
    }

    f1007.fbe_offset(fbe_current_offset);
    fbe_field_size = f1007.get(fbe_value.f1007);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f1008.fbe_offset(fbe_current_offset);
    fbe_field_size = f1008.get(fbe_value.f1008);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f1009.fbe_offset(fbe_current_offset);
    fbe_field_size = f1009.get(fbe_value.f1009);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f1010.fbe_offset(fbe_current_offset);
    fbe_field_size = f1010.get(fbe_value.f1010);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f1011.fbe_offset(fbe_current_offset);
    fbe_field_size = f1011.get(fbe_value.f1011);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructNested>::get(::test_pmr::StructNested& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value, resource);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructNested>::get_fields([[maybe_unused]] ::test_pmr::StructNested& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    parent.fbe_offset(fbe_current_offset);
    fbe_field_size = parent.get_fields(fbe_value, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Inline read of EnumSimple field f1000 (4 bytes)
    {
        size_t fbe_field_offset = _buffer.offset() + fbe_current_offset;
        if ((fbe_field_offset + 4) > _buffer.size())
            return 0;
        fbe_value.f1000 = static_cast<decltype(fbe_value.f1000)>(unaligned_load<int32_t>(_buffer.data() + fbe_field_offset));
        fbe_current_offset += 4;
        fbe_current_size += 4;
    }

    f1001.fbe_offset(fbe_current_offset);
    fbe_field_size = f1001.get(fbe_value.f1001, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Inline read of EnumTyped field f1002 (1 bytes)
    {
        size_t fbe_field_offset = _buffer.offset() + fbe_current_offset;
        if ((fbe_field_offset + 1) > _buffer.size())
            return 0;
        fbe_value.f1002 = static_cast<decltype(fbe_value.f1002)>(unaligned_load<uint8_t>(_buffer.data() + fbe_field_offset));
        fbe_current_offset += 1;
        fbe_current_size += 1;
    }

    f1003.fbe_offset(fbe_current_offset);
    fbe_field_size = f1003.get(fbe_value.f1003, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Inline read of FlagsSimple field f1004 (4 bytes)
    {
        size_t fbe_field_offset = _buffer.offset() + fbe_current_offset;
        if ((fbe_field_offset + 4) > _buffer.size())
            return 0;
        fbe_value.f1004 = static_cast<decltype(fbe_value.f1004)>(unaligned_load<int32_t>(_buffer.data() + fbe_field_offset));
        fbe_current_offset += 4;
        fbe_current_size += 4;
    }

    f1005.fbe_offset(fbe_current_offset);
    fbe_field_size = f1005.get(fbe_value.f1005, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Inline read of FlagsTyped field f1006 (8 bytes)
    {
        size_t fbe_field_offset = _buffer.offset() + fbe_current_offset;
        if ((fbe_field_offset + 8) > _buffer.size())
            return 0;
        fbe_value.f1006 = static_cast<decltype(fbe_value.f1006)>(unaligned_load<uint64_t>(_buffer.data() + fbe_field_offset));
        fbe_current_offset += 8;
        fbe_current_size += 8;
    }

    f1007.fbe_offset(fbe_current_offset);
    fbe_field_size = f1007.get(fbe_value.f1007, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f1008.fbe_offset(fbe_current_offset);
    fbe_field_size = f1008.get(fbe_value.f1008, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f1009.fbe_offset(fbe_current_offset);
    fbe_field_size = f1009.get(fbe_value.f1009, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f1010.fbe_offset(fbe_current_offset);
    fbe_field_size = f1010.get(fbe_value.f1010, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f1011.fbe_offset(fbe_current_offset);
    fbe_field_size = f1011.get(fbe_value.f1011, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructNested>::set(const ::test_pmr::StructNested& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructNested>::set_fields([[maybe_unused]] const ::test_pmr::StructNested& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    parent.fbe_offset(fbe_current_offset);
    fbe_field_size = parent.set_fields(fbe_value);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Inline write of EnumSimple field f1000 (4 bytes)
    {
        size_t fbe_field_offset = _buffer.offset() + fbe_current_offset;
        assert(((fbe_field_offset + 4) <= _buffer.size()) && "Model is broken!");
        if ((fbe_field_offset + 4) > _buffer.size())
            return 0;
        unaligned_store<int32_t>(_buffer.data() + fbe_field_offset, static_cast<int32_t>(fbe_value.f1000));
        fbe_current_offset += 4;
        fbe_current_size += 4;
    }

    f1001.fbe_offset(fbe_current_offset);
    fbe_field_size = f1001.set(fbe_value.f1001);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Inline write of EnumTyped field f1002 (1 bytes)
    {
        size_t fbe_field_offset = _buffer.offset() + fbe_current_offset;
        assert(((fbe_field_offset + 1) <= _buffer.size()) && "Model is broken!");
        if ((fbe_field_offset + 1) > _buffer.size())
            return 0;
        unaligned_store<uint8_t>(_buffer.data() + fbe_field_offset, static_cast<uint8_t>(fbe_value.f1002));
        fbe_current_offset += 1;
        fbe_current_size += 1;
    }

    f1003.fbe_offset(fbe_current_offset);
    fbe_field_size = f1003.set(fbe_value.f1003);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Inline write of FlagsSimple field f1004 (4 bytes)
    {
        size_t fbe_field_offset = _buffer.offset() + fbe_current_offset;
        assert(((fbe_field_offset + 4) <= _buffer.size()) && "Model is broken!");
        if ((fbe_field_offset + 4) > _buffer.size())
            return 0;
        unaligned_store<int32_t>(_buffer.data() + fbe_field_offset, static_cast<int32_t>(fbe_value.f1004));
        fbe_current_offset += 4;
        fbe_current_size += 4;
    }

    f1005.fbe_offset(fbe_current_offset);
    fbe_field_size = f1005.set(fbe_value.f1005);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    // Inline write of FlagsTyped field f1006 (8 bytes)
    {
        size_t fbe_field_offset = _buffer.offset() + fbe_current_offset;
        assert(((fbe_field_offset + 8) <= _buffer.size()) && "Model is broken!");
        if ((fbe_field_offset + 8) > _buffer.size())
            return 0;
        unaligned_store<uint64_t>(_buffer.data() + fbe_field_offset, static_cast<uint64_t>(fbe_value.f1006));
        fbe_current_offset += 8;
        fbe_current_size += 8;
    }

    f1007.fbe_offset(fbe_current_offset);
    fbe_field_size = f1007.set(fbe_value.f1007);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f1008.fbe_offset(fbe_current_offset);
    fbe_field_size = f1008.set(fbe_value.f1008);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f1009.fbe_offset(fbe_current_offset);
    fbe_field_size = f1009.set(fbe_value.f1009);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f1010.fbe_offset(fbe_current_offset);
    fbe_field_size = f1010.set(fbe_value.f1010);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f1011.fbe_offset(fbe_current_offset);
    fbe_field_size = f1011.set(fbe_value.f1011);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

namespace test_pmr {

bool StructNestedFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t StructNestedFinalModel::serialize(const ::test_pmr::StructNested& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t StructNestedFinalModel::deserialize(::test_pmr::StructNested& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

size_t StructNestedFinalModel::deserialize(::test_pmr::StructNested& value, std::pmr::memory_resource* resource) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value, resource);
}

} // namespace test_pmr

FinalModel<::test_pmr::StructBytes>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , f1(buffer, 0)
    , f2(buffer, 0)
    , f3(buffer, 0)
{}

size_t FinalModel<::test_pmr::StructBytes>::fbe_allocation_size(const ::test_pmr::StructBytes& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + f1.fbe_allocation_size(fbe_value.f1)
        + f2.fbe_allocation_size(fbe_value.f2)
        + f3.fbe_allocation_size(fbe_value.f3)
        ;
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructBytes>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructBytes>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    return fbe_current_offset;
}

size_t FinalModel<::test_pmr::StructBytes>::get(::test_pmr::StructBytes& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructBytes>::get_fields([[maybe_unused]] ::test_pmr::StructBytes& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.get(fbe_value.f1);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.get(fbe_value.f2);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.get(fbe_value.f3);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructBytes>::get(::test_pmr::StructBytes& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value, resource);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructBytes>::get_fields([[maybe_unused]] ::test_pmr::StructBytes& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.get(fbe_value.f1, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.get(fbe_value.f2, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.get(fbe_value.f3, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructBytes>::set(const ::test_pmr::StructBytes& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructBytes>::set_fields([[maybe_unused]] const ::test_pmr::StructBytes& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.set(fbe_value.f1);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.set(fbe_value.f2);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.set(fbe_value.f3);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

namespace test_pmr {

bool StructBytesFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t StructBytesFinalModel::serialize(const ::test_pmr::StructBytes& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t StructBytesFinalModel::deserialize(::test_pmr::StructBytes& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

size_t StructBytesFinalModel::deserialize(::test_pmr::StructBytes& value, std::pmr::memory_resource* resource) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value, resource);
}

} // namespace test_pmr

FinalModel<::test_pmr::StructArray>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , f1(buffer, 0)
    , f2(buffer, 0)
    , f3(buffer, 0)
    , f4(buffer, 0)
    , f5(buffer, 0)
    , f6(buffer, 0)
    , f7(buffer, 0)
    , f8(buffer, 0)
    , f9(buffer, 0)
    , f10(buffer, 0)
{}

size_t FinalModel<::test_pmr::StructArray>::fbe_allocation_size(const ::test_pmr::StructArray& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + f1.fbe_allocation_size(fbe_value.f1)
        + f2.fbe_allocation_size(fbe_value.f2)
        + f3.fbe_allocation_size(fbe_value.f3)
        + f4.fbe_allocation_size(fbe_value.f4)
        + f5.fbe_allocation_size(fbe_value.f5)
        + f6.fbe_allocation_size(fbe_value.f6)
        + f7.fbe_allocation_size(fbe_value.f7)
        + f8.fbe_allocation_size(fbe_value.f8)
        + f9.fbe_allocation_size(fbe_value.f9)
        + f10.fbe_allocation_size(fbe_value.f10)
        ;
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructArray>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructArray>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f5.fbe_offset(fbe_current_offset);
    fbe_field_size = f5.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f6.fbe_offset(fbe_current_offset);
    fbe_field_size = f6.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f7.fbe_offset(fbe_current_offset);
    fbe_field_size = f7.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f8.fbe_offset(fbe_current_offset);
    fbe_field_size = f8.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f9.fbe_offset(fbe_current_offset);
    fbe_field_size = f9.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f10.fbe_offset(fbe_current_offset);
    fbe_field_size = f10.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    return fbe_current_offset;
}

size_t FinalModel<::test_pmr::StructArray>::get(::test_pmr::StructArray& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructArray>::get_fields([[maybe_unused]] ::test_pmr::StructArray& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.get(fbe_value.f1);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.get(fbe_value.f2);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.get(fbe_value.f3);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.get(fbe_value.f4);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f5.fbe_offset(fbe_current_offset);
    fbe_field_size = f5.get(fbe_value.f5);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f6.fbe_offset(fbe_current_offset);
    fbe_field_size = f6.get(fbe_value.f6);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f7.fbe_offset(fbe_current_offset);
    fbe_field_size = f7.get(fbe_value.f7);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f8.fbe_offset(fbe_current_offset);
    fbe_field_size = f8.get(fbe_value.f8);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f9.fbe_offset(fbe_current_offset);
    fbe_field_size = f9.get(fbe_value.f9);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f10.fbe_offset(fbe_current_offset);
    fbe_field_size = f10.get(fbe_value.f10);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructArray>::get(::test_pmr::StructArray& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value, resource);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructArray>::get_fields([[maybe_unused]] ::test_pmr::StructArray& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.get(fbe_value.f1, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.get(fbe_value.f2, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.get(fbe_value.f3, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.get(fbe_value.f4, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f5.fbe_offset(fbe_current_offset);
    fbe_field_size = f5.get(fbe_value.f5, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f6.fbe_offset(fbe_current_offset);
    fbe_field_size = f6.get(fbe_value.f6, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f7.fbe_offset(fbe_current_offset);
    fbe_field_size = f7.get(fbe_value.f7, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f8.fbe_offset(fbe_current_offset);
    fbe_field_size = f8.get(fbe_value.f8, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f9.fbe_offset(fbe_current_offset);
    fbe_field_size = f9.get(fbe_value.f9, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f10.fbe_offset(fbe_current_offset);
    fbe_field_size = f10.get(fbe_value.f10, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructArray>::set(const ::test_pmr::StructArray& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructArray>::set_fields([[maybe_unused]] const ::test_pmr::StructArray& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.set(fbe_value.f1);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.set(fbe_value.f2);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.set(fbe_value.f3);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.set(fbe_value.f4);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f5.fbe_offset(fbe_current_offset);
    fbe_field_size = f5.set(fbe_value.f5);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f6.fbe_offset(fbe_current_offset);
    fbe_field_size = f6.set(fbe_value.f6);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f7.fbe_offset(fbe_current_offset);
    fbe_field_size = f7.set(fbe_value.f7);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f8.fbe_offset(fbe_current_offset);
    fbe_field_size = f8.set(fbe_value.f8);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f9.fbe_offset(fbe_current_offset);
    fbe_field_size = f9.set(fbe_value.f9);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f10.fbe_offset(fbe_current_offset);
    fbe_field_size = f10.set(fbe_value.f10);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

namespace test_pmr {

bool StructArrayFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t StructArrayFinalModel::serialize(const ::test_pmr::StructArray& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t StructArrayFinalModel::deserialize(::test_pmr::StructArray& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

size_t StructArrayFinalModel::deserialize(::test_pmr::StructArray& value, std::pmr::memory_resource* resource) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value, resource);
}

} // namespace test_pmr

FinalModel<::test_pmr::StructVector>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , f1(buffer, 0)
    , f2(buffer, 0)
    , f3(buffer, 0)
    , f4(buffer, 0)
    , f5(buffer, 0)
    , f6(buffer, 0)
    , f7(buffer, 0)
    , f8(buffer, 0)
    , f9(buffer, 0)
    , f10(buffer, 0)
{}

size_t FinalModel<::test_pmr::StructVector>::fbe_allocation_size(const ::test_pmr::StructVector& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + f1.fbe_allocation_size(fbe_value.f1)
        + f2.fbe_allocation_size(fbe_value.f2)
        + f3.fbe_allocation_size(fbe_value.f3)
        + f4.fbe_allocation_size(fbe_value.f4)
        + f5.fbe_allocation_size(fbe_value.f5)
        + f6.fbe_allocation_size(fbe_value.f6)
        + f7.fbe_allocation_size(fbe_value.f7)
        + f8.fbe_allocation_size(fbe_value.f8)
        + f9.fbe_allocation_size(fbe_value.f9)
        + f10.fbe_allocation_size(fbe_value.f10)
        ;
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructVector>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructVector>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f5.fbe_offset(fbe_current_offset);
    fbe_field_size = f5.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f6.fbe_offset(fbe_current_offset);
    fbe_field_size = f6.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f7.fbe_offset(fbe_current_offset);
    fbe_field_size = f7.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f8.fbe_offset(fbe_current_offset);
    fbe_field_size = f8.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f9.fbe_offset(fbe_current_offset);
    fbe_field_size = f9.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f10.fbe_offset(fbe_current_offset);
    fbe_field_size = f10.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    return fbe_current_offset;
}

size_t FinalModel<::test_pmr::StructVector>::get(::test_pmr::StructVector& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructVector>::get_fields([[maybe_unused]] ::test_pmr::StructVector& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.get(fbe_value.f1);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.get(fbe_value.f2);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.get(fbe_value.f3);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.get(fbe_value.f4);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f5.fbe_offset(fbe_current_offset);
    fbe_field_size = f5.get(fbe_value.f5);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f6.fbe_offset(fbe_current_offset);
    fbe_field_size = f6.get(fbe_value.f6);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f7.fbe_offset(fbe_current_offset);
    fbe_field_size = f7.get(fbe_value.f7);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f8.fbe_offset(fbe_current_offset);
    fbe_field_size = f8.get(fbe_value.f8);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f9.fbe_offset(fbe_current_offset);
    fbe_field_size = f9.get(fbe_value.f9);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f10.fbe_offset(fbe_current_offset);
    fbe_field_size = f10.get(fbe_value.f10);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructVector>::get(::test_pmr::StructVector& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value, resource);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructVector>::get_fields([[maybe_unused]] ::test_pmr::StructVector& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.get(fbe_value.f1, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.get(fbe_value.f2, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.get(fbe_value.f3, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.get(fbe_value.f4, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f5.fbe_offset(fbe_current_offset);
    fbe_field_size = f5.get(fbe_value.f5, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f6.fbe_offset(fbe_current_offset);
    fbe_field_size = f6.get(fbe_value.f6, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f7.fbe_offset(fbe_current_offset);
    fbe_field_size = f7.get(fbe_value.f7, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f8.fbe_offset(fbe_current_offset);
    fbe_field_size = f8.get(fbe_value.f8, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f9.fbe_offset(fbe_current_offset);
    fbe_field_size = f9.get(fbe_value.f9, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f10.fbe_offset(fbe_current_offset);
    fbe_field_size = f10.get(fbe_value.f10, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructVector>::set(const ::test_pmr::StructVector& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructVector>::set_fields([[maybe_unused]] const ::test_pmr::StructVector& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.set(fbe_value.f1);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.set(fbe_value.f2);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.set(fbe_value.f3);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.set(fbe_value.f4);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f5.fbe_offset(fbe_current_offset);
    fbe_field_size = f5.set(fbe_value.f5);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f6.fbe_offset(fbe_current_offset);
    fbe_field_size = f6.set(fbe_value.f6);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f7.fbe_offset(fbe_current_offset);
    fbe_field_size = f7.set(fbe_value.f7);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f8.fbe_offset(fbe_current_offset);
    fbe_field_size = f8.set(fbe_value.f8);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f9.fbe_offset(fbe_current_offset);
    fbe_field_size = f9.set(fbe_value.f9);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f10.fbe_offset(fbe_current_offset);
    fbe_field_size = f10.set(fbe_value.f10);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

namespace test_pmr {

bool StructVectorFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t StructVectorFinalModel::serialize(const ::test_pmr::StructVector& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t StructVectorFinalModel::deserialize(::test_pmr::StructVector& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

size_t StructVectorFinalModel::deserialize(::test_pmr::StructVector& value, std::pmr::memory_resource* resource) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value, resource);
}

} // namespace test_pmr

FinalModel<::test_pmr::StructList>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , f1(buffer, 0)
    , f2(buffer, 0)
    , f3(buffer, 0)
    , f4(buffer, 0)
    , f5(buffer, 0)
    , f6(buffer, 0)
    , f7(buffer, 0)
    , f8(buffer, 0)
    , f9(buffer, 0)
    , f10(buffer, 0)
{}

size_t FinalModel<::test_pmr::StructList>::fbe_allocation_size(const ::test_pmr::StructList& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + f1.fbe_allocation_size(fbe_value.f1)
        + f2.fbe_allocation_size(fbe_value.f2)
        + f3.fbe_allocation_size(fbe_value.f3)
        + f4.fbe_allocation_size(fbe_value.f4)
        + f5.fbe_allocation_size(fbe_value.f5)
        + f6.fbe_allocation_size(fbe_value.f6)
        + f7.fbe_allocation_size(fbe_value.f7)
        + f8.fbe_allocation_size(fbe_value.f8)
        + f9.fbe_allocation_size(fbe_value.f9)
        + f10.fbe_allocation_size(fbe_value.f10)
        ;
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructList>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructList>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f5.fbe_offset(fbe_current_offset);
    fbe_field_size = f5.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f6.fbe_offset(fbe_current_offset);
    fbe_field_size = f6.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f7.fbe_offset(fbe_current_offset);
    fbe_field_size = f7.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f8.fbe_offset(fbe_current_offset);
    fbe_field_size = f8.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f9.fbe_offset(fbe_current_offset);
    fbe_field_size = f9.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f10.fbe_offset(fbe_current_offset);
    fbe_field_size = f10.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    return fbe_current_offset;
}

size_t FinalModel<::test_pmr::StructList>::get(::test_pmr::StructList& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructList>::get_fields([[maybe_unused]] ::test_pmr::StructList& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.get(fbe_value.f1);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.get(fbe_value.f2);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.get(fbe_value.f3);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.get(fbe_value.f4);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f5.fbe_offset(fbe_current_offset);
    fbe_field_size = f5.get(fbe_value.f5);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f6.fbe_offset(fbe_current_offset);
    fbe_field_size = f6.get(fbe_value.f6);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f7.fbe_offset(fbe_current_offset);
    fbe_field_size = f7.get(fbe_value.f7);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f8.fbe_offset(fbe_current_offset);
    fbe_field_size = f8.get(fbe_value.f8);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f9.fbe_offset(fbe_current_offset);
    fbe_field_size = f9.get(fbe_value.f9);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f10.fbe_offset(fbe_current_offset);
    fbe_field_size = f10.get(fbe_value.f10);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructList>::get(::test_pmr::StructList& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value, resource);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructList>::get_fields([[maybe_unused]] ::test_pmr::StructList& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.get(fbe_value.f1, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.get(fbe_value.f2, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.get(fbe_value.f3, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.get(fbe_value.f4, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f5.fbe_offset(fbe_current_offset);
    fbe_field_size = f5.get(fbe_value.f5, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f6.fbe_offset(fbe_current_offset);
    fbe_field_size = f6.get(fbe_value.f6, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f7.fbe_offset(fbe_current_offset);
    fbe_field_size = f7.get(fbe_value.f7, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f8.fbe_offset(fbe_current_offset);
    fbe_field_size = f8.get(fbe_value.f8, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f9.fbe_offset(fbe_current_offset);
    fbe_field_size = f9.get(fbe_value.f9, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f10.fbe_offset(fbe_current_offset);
    fbe_field_size = f10.get(fbe_value.f10, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructList>::set(const ::test_pmr::StructList& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructList>::set_fields([[maybe_unused]] const ::test_pmr::StructList& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.set(fbe_value.f1);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.set(fbe_value.f2);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.set(fbe_value.f3);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.set(fbe_value.f4);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f5.fbe_offset(fbe_current_offset);
    fbe_field_size = f5.set(fbe_value.f5);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f6.fbe_offset(fbe_current_offset);
    fbe_field_size = f6.set(fbe_value.f6);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f7.fbe_offset(fbe_current_offset);
    fbe_field_size = f7.set(fbe_value.f7);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f8.fbe_offset(fbe_current_offset);
    fbe_field_size = f8.set(fbe_value.f8);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f9.fbe_offset(fbe_current_offset);
    fbe_field_size = f9.set(fbe_value.f9);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f10.fbe_offset(fbe_current_offset);
    fbe_field_size = f10.set(fbe_value.f10);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

namespace test_pmr {

bool StructListFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t StructListFinalModel::serialize(const ::test_pmr::StructList& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t StructListFinalModel::deserialize(::test_pmr::StructList& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

size_t StructListFinalModel::deserialize(::test_pmr::StructList& value, std::pmr::memory_resource* resource) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value, resource);
}

} // namespace test_pmr

FinalModel<::test_pmr::StructSet>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , f1(buffer, 0)
    , f2(buffer, 0)
    , f3(buffer, 0)
    , f4(buffer, 0)
{}

size_t FinalModel<::test_pmr::StructSet>::fbe_allocation_size(const ::test_pmr::StructSet& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + f1.fbe_allocation_size(fbe_value.f1)
        + f2.fbe_allocation_size(fbe_value.f2)
        + f3.fbe_allocation_size(fbe_value.f3)
        + f4.fbe_allocation_size(fbe_value.f4)
        ;
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructSet>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructSet>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    return fbe_current_offset;
}

size_t FinalModel<::test_pmr::StructSet>::get(::test_pmr::StructSet& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructSet>::get_fields([[maybe_unused]] ::test_pmr::StructSet& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.get(fbe_value.f1);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.get(fbe_value.f2);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.get(fbe_value.f3);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.get(fbe_value.f4);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructSet>::get(::test_pmr::StructSet& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value, resource);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructSet>::get_fields([[maybe_unused]] ::test_pmr::StructSet& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.get(fbe_value.f1, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.get(fbe_value.f2, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.get(fbe_value.f3, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.get(fbe_value.f4, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructSet>::set(const ::test_pmr::StructSet& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructSet>::set_fields([[maybe_unused]] const ::test_pmr::StructSet& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.set(fbe_value.f1);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.set(fbe_value.f2);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.set(fbe_value.f3);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.set(fbe_value.f4);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

namespace test_pmr {

bool StructSetFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t StructSetFinalModel::serialize(const ::test_pmr::StructSet& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t StructSetFinalModel::deserialize(::test_pmr::StructSet& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

size_t StructSetFinalModel::deserialize(::test_pmr::StructSet& value, std::pmr::memory_resource* resource) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value, resource);
}

} // namespace test_pmr

FinalModel<::test_pmr::StructMap>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , f1(buffer, 0)
    , f2(buffer, 0)
    , f3(buffer, 0)
    , f4(buffer, 0)
    , f5(buffer, 0)
    , f6(buffer, 0)
    , f7(buffer, 0)
    , f8(buffer, 0)
    , f9(buffer, 0)
    , f10(buffer, 0)
{}

size_t FinalModel<::test_pmr::StructMap>::fbe_allocation_size(const ::test_pmr::StructMap& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + f1.fbe_allocation_size(fbe_value.f1)
        + f2.fbe_allocation_size(fbe_value.f2)
        + f3.fbe_allocation_size(fbe_value.f3)
        + f4.fbe_allocation_size(fbe_value.f4)
        + f5.fbe_allocation_size(fbe_value.f5)
        + f6.fbe_allocation_size(fbe_value.f6)
        + f7.fbe_allocation_size(fbe_value.f7)
        + f8.fbe_allocation_size(fbe_value.f8)
        + f9.fbe_allocation_size(fbe_value.f9)
        + f10.fbe_allocation_size(fbe_value.f10)
        ;
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructMap>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructMap>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f5.fbe_offset(fbe_current_offset);
    fbe_field_size = f5.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f6.fbe_offset(fbe_current_offset);
    fbe_field_size = f6.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f7.fbe_offset(fbe_current_offset);
    fbe_field_size = f7.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f8.fbe_offset(fbe_current_offset);
    fbe_field_size = f8.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f9.fbe_offset(fbe_current_offset);
    fbe_field_size = f9.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f10.fbe_offset(fbe_current_offset);
    fbe_field_size = f10.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    return fbe_current_offset;
}

size_t FinalModel<::test_pmr::StructMap>::get(::test_pmr::StructMap& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructMap>::get_fields([[maybe_unused]] ::test_pmr::StructMap& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.get(fbe_value.f1);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.get(fbe_value.f2);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.get(fbe_value.f3);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.get(fbe_value.f4);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f5.fbe_offset(fbe_current_offset);
    fbe_field_size = f5.get(fbe_value.f5);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f6.fbe_offset(fbe_current_offset);
    fbe_field_size = f6.get(fbe_value.f6);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f7.fbe_offset(fbe_current_offset);
    fbe_field_size = f7.get(fbe_value.f7);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f8.fbe_offset(fbe_current_offset);
    fbe_field_size = f8.get(fbe_value.f8);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f9.fbe_offset(fbe_current_offset);
    fbe_field_size = f9.get(fbe_value.f9);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f10.fbe_offset(fbe_current_offset);
    fbe_field_size = f10.get(fbe_value.f10);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructMap>::get(::test_pmr::StructMap& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value, resource);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructMap>::get_fields([[maybe_unused]] ::test_pmr::StructMap& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.get(fbe_value.f1, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.get(fbe_value.f2, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.get(fbe_value.f3, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.get(fbe_value.f4, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f5.fbe_offset(fbe_current_offset);
    fbe_field_size = f5.get(fbe_value.f5, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f6.fbe_offset(fbe_current_offset);
    fbe_field_size = f6.get(fbe_value.f6, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f7.fbe_offset(fbe_current_offset);
    fbe_field_size = f7.get(fbe_value.f7, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f8.fbe_offset(fbe_current_offset);
    fbe_field_size = f8.get(fbe_value.f8, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f9.fbe_offset(fbe_current_offset);
    fbe_field_size = f9.get(fbe_value.f9, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f10.fbe_offset(fbe_current_offset);
    fbe_field_size = f10.get(fbe_value.f10, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructMap>::set(const ::test_pmr::StructMap& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructMap>::set_fields([[maybe_unused]] const ::test_pmr::StructMap& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.set(fbe_value.f1);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.set(fbe_value.f2);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.set(fbe_value.f3);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.set(fbe_value.f4);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f5.fbe_offset(fbe_current_offset);
    fbe_field_size = f5.set(fbe_value.f5);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f6.fbe_offset(fbe_current_offset);
    fbe_field_size = f6.set(fbe_value.f6);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f7.fbe_offset(fbe_current_offset);
    fbe_field_size = f7.set(fbe_value.f7);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f8.fbe_offset(fbe_current_offset);
    fbe_field_size = f8.set(fbe_value.f8);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f9.fbe_offset(fbe_current_offset);
    fbe_field_size = f9.set(fbe_value.f9);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f10.fbe_offset(fbe_current_offset);
    fbe_field_size = f10.set(fbe_value.f10);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

namespace test_pmr {

bool StructMapFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t StructMapFinalModel::serialize(const ::test_pmr::StructMap& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t StructMapFinalModel::deserialize(::test_pmr::StructMap& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

size_t StructMapFinalModel::deserialize(::test_pmr::StructMap& value, std::pmr::memory_resource* resource) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value, resource);
}

} // namespace test_pmr

FinalModel<::test_pmr::StructHash>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , f1(buffer, 0)
    , f2(buffer, 0)
    , f3(buffer, 0)
    , f4(buffer, 0)
    , f5(buffer, 0)
    , f6(buffer, 0)
    , f7(buffer, 0)
    , f8(buffer, 0)
    , f9(buffer, 0)
    , f10(buffer, 0)
{}

size_t FinalModel<::test_pmr::StructHash>::fbe_allocation_size(const ::test_pmr::StructHash& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + f1.fbe_allocation_size(fbe_value.f1)
        + f2.fbe_allocation_size(fbe_value.f2)
        + f3.fbe_allocation_size(fbe_value.f3)
        + f4.fbe_allocation_size(fbe_value.f4)
        + f5.fbe_allocation_size(fbe_value.f5)
        + f6.fbe_allocation_size(fbe_value.f6)
        + f7.fbe_allocation_size(fbe_value.f7)
        + f8.fbe_allocation_size(fbe_value.f8)
        + f9.fbe_allocation_size(fbe_value.f9)
        + f10.fbe_allocation_size(fbe_value.f10)
        ;
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructHash>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructHash>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f5.fbe_offset(fbe_current_offset);
    fbe_field_size = f5.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f6.fbe_offset(fbe_current_offset);
    fbe_field_size = f6.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f7.fbe_offset(fbe_current_offset);
    fbe_field_size = f7.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f8.fbe_offset(fbe_current_offset);
    fbe_field_size = f8.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f9.fbe_offset(fbe_current_offset);
    fbe_field_size = f9.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f10.fbe_offset(fbe_current_offset);
    fbe_field_size = f10.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    return fbe_current_offset;
}

size_t FinalModel<::test_pmr::StructHash>::get(::test_pmr::StructHash& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructHash>::get_fields([[maybe_unused]] ::test_pmr::StructHash& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.get(fbe_value.f1);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.get(fbe_value.f2);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.get(fbe_value.f3);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.get(fbe_value.f4);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f5.fbe_offset(fbe_current_offset);
    fbe_field_size = f5.get(fbe_value.f5);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f6.fbe_offset(fbe_current_offset);
    fbe_field_size = f6.get(fbe_value.f6);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f7.fbe_offset(fbe_current_offset);
    fbe_field_size = f7.get(fbe_value.f7);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f8.fbe_offset(fbe_current_offset);
    fbe_field_size = f8.get(fbe_value.f8);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f9.fbe_offset(fbe_current_offset);
    fbe_field_size = f9.get(fbe_value.f9);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f10.fbe_offset(fbe_current_offset);
    fbe_field_size = f10.get(fbe_value.f10);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructHash>::get(::test_pmr::StructHash& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value, resource);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructHash>::get_fields([[maybe_unused]] ::test_pmr::StructHash& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.get(fbe_value.f1, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.get(fbe_value.f2, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.get(fbe_value.f3, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.get(fbe_value.f4, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f5.fbe_offset(fbe_current_offset);
    fbe_field_size = f5.get(fbe_value.f5, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f6.fbe_offset(fbe_current_offset);
    fbe_field_size = f6.get(fbe_value.f6, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f7.fbe_offset(fbe_current_offset);
    fbe_field_size = f7.get(fbe_value.f7, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f8.fbe_offset(fbe_current_offset);
    fbe_field_size = f8.get(fbe_value.f8, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f9.fbe_offset(fbe_current_offset);
    fbe_field_size = f9.get(fbe_value.f9, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f10.fbe_offset(fbe_current_offset);
    fbe_field_size = f10.get(fbe_value.f10, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructHash>::set(const ::test_pmr::StructHash& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructHash>::set_fields([[maybe_unused]] const ::test_pmr::StructHash& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.set(fbe_value.f1);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.set(fbe_value.f2);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f3.fbe_offset(fbe_current_offset);
    fbe_field_size = f3.set(fbe_value.f3);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f4.fbe_offset(fbe_current_offset);
    fbe_field_size = f4.set(fbe_value.f4);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f5.fbe_offset(fbe_current_offset);
    fbe_field_size = f5.set(fbe_value.f5);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f6.fbe_offset(fbe_current_offset);
    fbe_field_size = f6.set(fbe_value.f6);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f7.fbe_offset(fbe_current_offset);
    fbe_field_size = f7.set(fbe_value.f7);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f8.fbe_offset(fbe_current_offset);
    fbe_field_size = f8.set(fbe_value.f8);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f9.fbe_offset(fbe_current_offset);
    fbe_field_size = f9.set(fbe_value.f9);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f10.fbe_offset(fbe_current_offset);
    fbe_field_size = f10.set(fbe_value.f10);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

namespace test_pmr {

bool StructHashFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t StructHashFinalModel::serialize(const ::test_pmr::StructHash& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t StructHashFinalModel::deserialize(::test_pmr::StructHash& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

size_t StructHashFinalModel::deserialize(::test_pmr::StructHash& value, std::pmr::memory_resource* resource) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value, resource);
}

} // namespace test_pmr

FinalModel<::test_pmr::StructHashEx>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , f1(buffer, 0)
    , f2(buffer, 0)
{}

size_t FinalModel<::test_pmr::StructHashEx>::fbe_allocation_size(const ::test_pmr::StructHashEx& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + f1.fbe_allocation_size(fbe_value.f1)
        + f2.fbe_allocation_size(fbe_value.f2)
        ;
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructHashEx>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructHashEx>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    return fbe_current_offset;
}

size_t FinalModel<::test_pmr::StructHashEx>::get(::test_pmr::StructHashEx& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructHashEx>::get_fields([[maybe_unused]] ::test_pmr::StructHashEx& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.get(fbe_value.f1);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.get(fbe_value.f2);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructHashEx>::get(::test_pmr::StructHashEx& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value, resource);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructHashEx>::get_fields([[maybe_unused]] ::test_pmr::StructHashEx& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.get(fbe_value.f1, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.get(fbe_value.f2, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructHashEx>::set(const ::test_pmr::StructHashEx& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructHashEx>::set_fields([[maybe_unused]] const ::test_pmr::StructHashEx& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    f1.fbe_offset(fbe_current_offset);
    fbe_field_size = f1.set(fbe_value.f1);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    f2.fbe_offset(fbe_current_offset);
    fbe_field_size = f2.set(fbe_value.f2);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

namespace test_pmr {

bool StructHashExFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t StructHashExFinalModel::serialize(const ::test_pmr::StructHashEx& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t StructHashExFinalModel::deserialize(::test_pmr::StructHashEx& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

size_t StructHashExFinalModel::deserialize(::test_pmr::StructHashEx& value, std::pmr::memory_resource* resource) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value, resource);
}

} // namespace test_pmr

FinalModel<::test_pmr::StructEmpty>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

size_t FinalModel<::test_pmr::StructEmpty>::fbe_allocation_size(const ::test_pmr::StructEmpty& fbe_value) const noexcept
{
    size_t fbe_result = 0
        ;
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructEmpty>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructEmpty>::verify_fields() const noexcept
{
    return 0;
}

size_t FinalModel<::test_pmr::StructEmpty>::get(::test_pmr::StructEmpty& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructEmpty>::get_fields([[maybe_unused]] ::test_pmr::StructEmpty& fbe_value) const noexcept
{
    return 0;
}

size_t FinalModel<::test_pmr::StructEmpty>::get(::test_pmr::StructEmpty& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value, resource);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructEmpty>::get_fields([[maybe_unused]] ::test_pmr::StructEmpty& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    return 0;
}

size_t FinalModel<::test_pmr::StructEmpty>::set(const ::test_pmr::StructEmpty& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructEmpty>::set_fields([[maybe_unused]] const ::test_pmr::StructEmpty& fbe_value) noexcept
{
    return 0;
}

namespace test_pmr {

bool StructEmptyFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t StructEmptyFinalModel::serialize(const ::test_pmr::StructEmpty& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t StructEmptyFinalModel::deserialize(::test_pmr::StructEmpty& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

size_t StructEmptyFinalModel::deserialize(::test_pmr::StructEmpty& value, std::pmr::memory_resource* resource) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value, resource);
}

} // namespace test_pmr

FinalModel<::test_pmr::StructFieldNamedString>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , string(buffer, 0)
{}

size_t FinalModel<::test_pmr::StructFieldNamedString>::fbe_allocation_size(const ::test_pmr::StructFieldNamedString& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + string.fbe_allocation_size(fbe_value.string)
        ;
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructFieldNamedString>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructFieldNamedString>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    return fbe_current_offset;
}

size_t FinalModel<::test_pmr::StructFieldNamedString>::get(::test_pmr::StructFieldNamedString& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructFieldNamedString>::get_fields([[maybe_unused]] ::test_pmr::StructFieldNamedString& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.get(fbe_value.string);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructFieldNamedString>::get(::test_pmr::StructFieldNamedString& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value, resource);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructFieldNamedString>::get_fields([[maybe_unused]] ::test_pmr::StructFieldNamedString& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.get(fbe_value.string, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StructFieldNamedString>::set(const ::test_pmr::StructFieldNamedString& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StructFieldNamedString>::set_fields([[maybe_unused]] const ::test_pmr::StructFieldNamedString& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.set(fbe_value.string);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

namespace test_pmr {

bool StructFieldNamedStringFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t StructFieldNamedStringFinalModel::serialize(const ::test_pmr::StructFieldNamedString& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t StructFieldNamedStringFinalModel::deserialize(::test_pmr::StructFieldNamedString& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

size_t StructFieldNamedStringFinalModel::deserialize(::test_pmr::StructFieldNamedString& value, std::pmr::memory_resource* resource) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value, resource);
}

} // namespace test_pmr

FinalModel<::test_pmr::StringFieldNamedString>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , string(buffer, 0)
{}

size_t FinalModel<::test_pmr::StringFieldNamedString>::fbe_allocation_size(const ::test_pmr::StringFieldNamedString& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + string.fbe_allocation_size(fbe_value.string)
        ;
    return fbe_result;
}

size_t FinalModel<::test_pmr::StringFieldNamedString>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StringFieldNamedString>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    return fbe_current_offset;
}

size_t FinalModel<::test_pmr::StringFieldNamedString>::get(::test_pmr::StringFieldNamedString& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StringFieldNamedString>::get_fields([[maybe_unused]] ::test_pmr::StringFieldNamedString& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.get(fbe_value.string);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StringFieldNamedString>::get(::test_pmr::StringFieldNamedString& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value, resource);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StringFieldNamedString>::get_fields([[maybe_unused]] ::test_pmr::StringFieldNamedString& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.get(fbe_value.string, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::StringFieldNamedString>::set(const ::test_pmr::StringFieldNamedString& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::StringFieldNamedString>::set_fields([[maybe_unused]] const ::test_pmr::StringFieldNamedString& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.set(fbe_value.string);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

namespace test_pmr {

bool StringFieldNamedStringFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t StringFieldNamedStringFinalModel::serialize(const ::test_pmr::StringFieldNamedString& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t StringFieldNamedStringFinalModel::deserialize(::test_pmr::StringFieldNamedString& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

size_t StringFieldNamedStringFinalModel::deserialize(::test_pmr::StringFieldNamedString& value, std::pmr::memory_resource* resource) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value, resource);
}

} // namespace test_pmr

FinalModel<::test_pmr::OptionalFieldNamedString>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , string(buffer, 0)
{}

size_t FinalModel<::test_pmr::OptionalFieldNamedString>::fbe_allocation_size(const ::test_pmr::OptionalFieldNamedString& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + string.fbe_allocation_size(fbe_value.string)
        ;
    return fbe_result;
}

size_t FinalModel<::test_pmr::OptionalFieldNamedString>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::OptionalFieldNamedString>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    return fbe_current_offset;
}

size_t FinalModel<::test_pmr::OptionalFieldNamedString>::get(::test_pmr::OptionalFieldNamedString& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::OptionalFieldNamedString>::get_fields([[maybe_unused]] ::test_pmr::OptionalFieldNamedString& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.get(fbe_value.string);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::OptionalFieldNamedString>::get(::test_pmr::OptionalFieldNamedString& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value, resource);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::OptionalFieldNamedString>::get_fields([[maybe_unused]] ::test_pmr::OptionalFieldNamedString& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.get(fbe_value.string, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::OptionalFieldNamedString>::set(const ::test_pmr::OptionalFieldNamedString& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::OptionalFieldNamedString>::set_fields([[maybe_unused]] const ::test_pmr::OptionalFieldNamedString& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.set(fbe_value.string);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

namespace test_pmr {

bool OptionalFieldNamedStringFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t OptionalFieldNamedStringFinalModel::serialize(const ::test_pmr::OptionalFieldNamedString& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t OptionalFieldNamedStringFinalModel::deserialize(::test_pmr::OptionalFieldNamedString& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

size_t OptionalFieldNamedStringFinalModel::deserialize(::test_pmr::OptionalFieldNamedString& value, std::pmr::memory_resource* resource) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value, resource);
}

} // namespace test_pmr

FinalModel<::test_pmr::ArrayFieldNamedString>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , string(buffer, 0)
{}

size_t FinalModel<::test_pmr::ArrayFieldNamedString>::fbe_allocation_size(const ::test_pmr::ArrayFieldNamedString& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + string.fbe_allocation_size(fbe_value.string)
        ;
    return fbe_result;
}

size_t FinalModel<::test_pmr::ArrayFieldNamedString>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::ArrayFieldNamedString>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    return fbe_current_offset;
}

size_t FinalModel<::test_pmr::ArrayFieldNamedString>::get(::test_pmr::ArrayFieldNamedString& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::ArrayFieldNamedString>::get_fields([[maybe_unused]] ::test_pmr::ArrayFieldNamedString& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.get(fbe_value.string);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::ArrayFieldNamedString>::get(::test_pmr::ArrayFieldNamedString& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value, resource);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::ArrayFieldNamedString>::get_fields([[maybe_unused]] ::test_pmr::ArrayFieldNamedString& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.get(fbe_value.string, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::ArrayFieldNamedString>::set(const ::test_pmr::ArrayFieldNamedString& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::ArrayFieldNamedString>::set_fields([[maybe_unused]] const ::test_pmr::ArrayFieldNamedString& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.set(fbe_value.string);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

namespace test_pmr {

bool ArrayFieldNamedStringFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t ArrayFieldNamedStringFinalModel::serialize(const ::test_pmr::ArrayFieldNamedString& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t ArrayFieldNamedStringFinalModel::deserialize(::test_pmr::ArrayFieldNamedString& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

size_t ArrayFieldNamedStringFinalModel::deserialize(::test_pmr::ArrayFieldNamedString& value, std::pmr::memory_resource* resource) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value, resource);
}

} // namespace test_pmr

FinalModel<::test_pmr::VectorFieldNamedString>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , string(buffer, 0)
{}

size_t FinalModel<::test_pmr::VectorFieldNamedString>::fbe_allocation_size(const ::test_pmr::VectorFieldNamedString& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + string.fbe_allocation_size(fbe_value.string)
        ;
    return fbe_result;
}

size_t FinalModel<::test_pmr::VectorFieldNamedString>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::VectorFieldNamedString>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    return fbe_current_offset;
}

size_t FinalModel<::test_pmr::VectorFieldNamedString>::get(::test_pmr::VectorFieldNamedString& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::VectorFieldNamedString>::get_fields([[maybe_unused]] ::test_pmr::VectorFieldNamedString& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.get(fbe_value.string);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::VectorFieldNamedString>::get(::test_pmr::VectorFieldNamedString& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value, resource);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::VectorFieldNamedString>::get_fields([[maybe_unused]] ::test_pmr::VectorFieldNamedString& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.get(fbe_value.string, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::VectorFieldNamedString>::set(const ::test_pmr::VectorFieldNamedString& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::VectorFieldNamedString>::set_fields([[maybe_unused]] const ::test_pmr::VectorFieldNamedString& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.set(fbe_value.string);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

namespace test_pmr {

bool VectorFieldNamedStringFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t VectorFieldNamedStringFinalModel::serialize(const ::test_pmr::VectorFieldNamedString& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t VectorFieldNamedStringFinalModel::deserialize(::test_pmr::VectorFieldNamedString& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

size_t VectorFieldNamedStringFinalModel::deserialize(::test_pmr::VectorFieldNamedString& value, std::pmr::memory_resource* resource) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value, resource);
}

} // namespace test_pmr

FinalModel<::test_pmr::BytesFieldNamedString>::FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , string(buffer, 0)
{}

size_t FinalModel<::test_pmr::BytesFieldNamedString>::fbe_allocation_size(const ::test_pmr::BytesFieldNamedString& fbe_value) const noexcept
{
    size_t fbe_result = 0
        + string.fbe_allocation_size(fbe_value.string)
        ;
    return fbe_result;
}

size_t FinalModel<::test_pmr::BytesFieldNamedString>::verify() const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = verify_fields();
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::BytesFieldNamedString>::verify_fields() const noexcept
{
    size_t fbe_current_offset = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.verify();
    if (fbe_field_size == std::numeric_limits<std::size_t>::max())
        return std::numeric_limits<std::size_t>::max();
    fbe_current_offset += fbe_field_size;

    return fbe_current_offset;
}

size_t FinalModel<::test_pmr::BytesFieldNamedString>::get(::test_pmr::BytesFieldNamedString& fbe_value) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::BytesFieldNamedString>::get_fields([[maybe_unused]] ::test_pmr::BytesFieldNamedString& fbe_value) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.get(fbe_value.string);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::BytesFieldNamedString>::get(::test_pmr::BytesFieldNamedString& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = get_fields(fbe_value, resource);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::BytesFieldNamedString>::get_fields([[maybe_unused]] ::test_pmr::BytesFieldNamedString& fbe_value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.get(fbe_value.string, resource);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

size_t FinalModel<::test_pmr::BytesFieldNamedString>::set(const ::test_pmr::BytesFieldNamedString& fbe_value) noexcept
{
    _buffer.shift(fbe_offset());
    size_t fbe_result = set_fields(fbe_value);
    _buffer.unshift(fbe_offset());
    return fbe_result;
}

size_t FinalModel<::test_pmr::BytesFieldNamedString>::set_fields([[maybe_unused]] const ::test_pmr::BytesFieldNamedString& fbe_value) noexcept
{
    size_t fbe_current_offset = 0;
    size_t fbe_current_size = 0;
    [[maybe_unused]] size_t fbe_field_size;

    string.fbe_offset(fbe_current_offset);
    fbe_field_size = string.set(fbe_value.string);
    fbe_current_offset += fbe_field_size;
    fbe_current_size += fbe_field_size;

    return fbe_current_size;
}

namespace test_pmr {

bool BytesFieldNamedStringFinalModel::verify()
{
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return false;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return false;

    return ((8 + _model.verify()) == fbe_struct_size);
}

size_t BytesFieldNamedStringFinalModel::serialize(const ::test_pmr::BytesFieldNamedString& value)
{
    size_t fbe_initial_size = this->buffer().size();

    uint32_t fbe_struct_type = (uint32_t)fbe_type();
    uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
    uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
    assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
        return 0;

    fbe_struct_size = (uint32_t)(8 + _model.set(value));
    this->buffer().resize(fbe_initial_size + fbe_struct_size);

    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

    return fbe_struct_size;
}

size_t BytesFieldNamedStringFinalModel::deserialize(::test_pmr::BytesFieldNamedString& value) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value);
}

size_t BytesFieldNamedStringFinalModel::deserialize(::test_pmr::BytesFieldNamedString& value, std::pmr::memory_resource* resource) const noexcept
{
    assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
    if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
        return 0;

    size_t fbe_struct_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8);
    size_t fbe_struct_type = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4);
    assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
    if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
        return 8;

    return 8 + _model.get(value, resource);
}

} // namespace test_pmr

} // namespace FBE
