//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: enums.fbe
// FBE version: 1.11.0.0
//------------------------------------------------------------------------------

#pragma once

#ifdef isset
#undef isset
#endif

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "fbe_final_models.h"

#include "enums_pmr.h"

namespace FBE {

// Fast Binary Encoding ::enums_pmr::EnumByte final model
template <>
class FinalModel<::enums_pmr::EnumByte> : public FinalModelBase<::enums_pmr::EnumByte, uint8_t>
{
public:
    using FinalModelBase<::enums_pmr::EnumByte, uint8_t>::FinalModelBase;
};

// Fast Binary Encoding ::enums_pmr::EnumChar final model
template <>
class FinalModel<::enums_pmr::EnumChar> : public FinalModelBase<::enums_pmr::EnumChar, uint8_t>
{
public:
    using FinalModelBase<::enums_pmr::EnumChar, uint8_t>::FinalModelBase;
};

// Fast Binary Encoding ::enums_pmr::EnumWChar final model
template <>
class FinalModel<::enums_pmr::EnumWChar> : public FinalModelBase<::enums_pmr::EnumWChar, uint32_t>
{
public:
    using FinalModelBase<::enums_pmr::EnumWChar, uint32_t>::FinalModelBase;
};

// Fast Binary Encoding ::enums_pmr::EnumInt8 final model
template <>
class FinalModel<::enums_pmr::EnumInt8> : public FinalModelBase<::enums_pmr::EnumInt8, int8_t>
{
public:
    using FinalModelBase<::enums_pmr::EnumInt8, int8_t>::FinalModelBase;
};

// Fast Binary Encoding ::enums_pmr::EnumUInt8 final model
template <>
class FinalModel<::enums_pmr::EnumUInt8> : public FinalModelBase<::enums_pmr::EnumUInt8, uint8_t>
{
public:
    using FinalModelBase<::enums_pmr::EnumUInt8, uint8_t>::FinalModelBase;
};

// Fast Binary Encoding ::enums_pmr::EnumInt16 final model
template <>
class FinalModel<::enums_pmr::EnumInt16> : public FinalModelBase<::enums_pmr::EnumInt16, int16_t>
{
public:
    using FinalModelBase<::enums_pmr::EnumInt16, int16_t>::FinalModelBase;
};

// Fast Binary Encoding ::enums_pmr::EnumUInt16 final model
template <>
class FinalModel<::enums_pmr::EnumUInt16> : public FinalModelBase<::enums_pmr::EnumUInt16, uint16_t>
{
public:
    using FinalModelBase<::enums_pmr::EnumUInt16, uint16_t>::FinalModelBase;
};

// Fast Binary Encoding ::enums_pmr::EnumInt32 final model
template <>
class FinalModel<::enums_pmr::EnumInt32> : public FinalModelBase<::enums_pmr::EnumInt32, int32_t>
{
public:
    using FinalModelBase<::enums_pmr::EnumInt32, int32_t>::FinalModelBase;
};

// Fast Binary Encoding ::enums_pmr::EnumUInt32 final model
template <>
class FinalModel<::enums_pmr::EnumUInt32> : public FinalModelBase<::enums_pmr::EnumUInt32, uint32_t>
{
public:
    using FinalModelBase<::enums_pmr::EnumUInt32, uint32_t>::FinalModelBase;
};

// Fast Binary Encoding ::enums_pmr::EnumInt64 final model
template <>
class FinalModel<::enums_pmr::EnumInt64> : public FinalModelBase<::enums_pmr::EnumInt64, int64_t>
{
public:
    using FinalModelBase<::enums_pmr::EnumInt64, int64_t>::FinalModelBase;
};

// Fast Binary Encoding ::enums_pmr::EnumUInt64 final model
template <>
class FinalModel<::enums_pmr::EnumUInt64> : public FinalModelBase<::enums_pmr::EnumUInt64, uint64_t>
{
public:
    using FinalModelBase<::enums_pmr::EnumUInt64, uint64_t>::FinalModelBase;
};

// Fast Binary Encoding ::enums_pmr::Enums final model
template <>
class FinalModel<::enums_pmr::Enums>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept;

    // Get the allocation size
    size_t fbe_allocation_size(const ::enums_pmr::Enums& fbe_value) const noexcept;
    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 1; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept;
    // Check if the struct fields are valid
    size_t verify_fields() const noexcept;

    // Get the struct value
    size_t get(::enums_pmr::Enums& fbe_value) const noexcept;
    // Get the struct fields values
    size_t get_fields(::enums_pmr::Enums& fbe_value) const noexcept;
    // Get the struct value with memory resource
    size_t get(::enums_pmr::Enums& fbe_value, std::pmr::memory_resource* resource) const noexcept;
    // Get the struct fields values with memory resource
    size_t get_fields(::enums_pmr::Enums& fbe_value, std::pmr::memory_resource* resource) const noexcept;

    // Set the struct value
    size_t set(const ::enums_pmr::Enums& fbe_value) noexcept;
    // Set the struct fields values
    size_t set_fields(const ::enums_pmr::Enums& fbe_value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<::enums_pmr::EnumByte> byte0;
    FinalModel<::enums_pmr::EnumByte> byte1;
    FinalModel<::enums_pmr::EnumByte> byte2;
    FinalModel<::enums_pmr::EnumByte> byte3;
    FinalModel<::enums_pmr::EnumByte> byte4;
    FinalModel<::enums_pmr::EnumByte> byte5;
    FinalModel<::enums_pmr::EnumChar> char0;
    FinalModel<::enums_pmr::EnumChar> char1;
    FinalModel<::enums_pmr::EnumChar> char2;
    FinalModel<::enums_pmr::EnumChar> char3;
    FinalModel<::enums_pmr::EnumChar> char4;
    FinalModel<::enums_pmr::EnumChar> char5;
    FinalModel<::enums_pmr::EnumWChar> wchar0;
    FinalModel<::enums_pmr::EnumWChar> wchar1;
    FinalModel<::enums_pmr::EnumWChar> wchar2;
    FinalModel<::enums_pmr::EnumWChar> wchar3;
    FinalModel<::enums_pmr::EnumWChar> wchar4;
    FinalModel<::enums_pmr::EnumWChar> wchar5;
    FinalModel<::enums_pmr::EnumInt8> int8b0;
    FinalModel<::enums_pmr::EnumInt8> int8b1;
    FinalModel<::enums_pmr::EnumInt8> int8b2;
    FinalModel<::enums_pmr::EnumInt8> int8b3;
    FinalModel<::enums_pmr::EnumInt8> int8b4;
    FinalModel<::enums_pmr::EnumInt8> int8b5;
    FinalModel<::enums_pmr::EnumUInt8> uint8b0;
    FinalModel<::enums_pmr::EnumUInt8> uint8b1;
    FinalModel<::enums_pmr::EnumUInt8> uint8b2;
    FinalModel<::enums_pmr::EnumUInt8> uint8b3;
    FinalModel<::enums_pmr::EnumUInt8> uint8b4;
    FinalModel<::enums_pmr::EnumUInt8> uint8b5;
    FinalModel<::enums_pmr::EnumInt16> int16b0;
    FinalModel<::enums_pmr::EnumInt16> int16b1;
    FinalModel<::enums_pmr::EnumInt16> int16b2;
    FinalModel<::enums_pmr::EnumInt16> int16b3;
    FinalModel<::enums_pmr::EnumInt16> int16b4;
    FinalModel<::enums_pmr::EnumInt16> int16b5;
    FinalModel<::enums_pmr::EnumUInt16> uint16b0;
    FinalModel<::enums_pmr::EnumUInt16> uint16b1;
    FinalModel<::enums_pmr::EnumUInt16> uint16b2;
    FinalModel<::enums_pmr::EnumUInt16> uint16b3;
    FinalModel<::enums_pmr::EnumUInt16> uint16b4;
    FinalModel<::enums_pmr::EnumUInt16> uint16b5;
    FinalModel<::enums_pmr::EnumInt32> int32b0;
    FinalModel<::enums_pmr::EnumInt32> int32b1;
    FinalModel<::enums_pmr::EnumInt32> int32b2;
    FinalModel<::enums_pmr::EnumInt32> int32b3;
    FinalModel<::enums_pmr::EnumInt32> int32b4;
    FinalModel<::enums_pmr::EnumInt32> int32b5;
    FinalModel<::enums_pmr::EnumUInt32> uint32b0;
    FinalModel<::enums_pmr::EnumUInt32> uint32b1;
    FinalModel<::enums_pmr::EnumUInt32> uint32b2;
    FinalModel<::enums_pmr::EnumUInt32> uint32b3;
    FinalModel<::enums_pmr::EnumUInt32> uint32b4;
    FinalModel<::enums_pmr::EnumUInt32> uint32b5;
    FinalModel<::enums_pmr::EnumInt64> int64b0;
    FinalModel<::enums_pmr::EnumInt64> int64b1;
    FinalModel<::enums_pmr::EnumInt64> int64b2;
    FinalModel<::enums_pmr::EnumInt64> int64b3;
    FinalModel<::enums_pmr::EnumInt64> int64b4;
    FinalModel<::enums_pmr::EnumInt64> int64b5;
    FinalModel<::enums_pmr::EnumUInt64> uint64b0;
    FinalModel<::enums_pmr::EnumUInt64> uint64b1;
    FinalModel<::enums_pmr::EnumUInt64> uint64b2;
    FinalModel<::enums_pmr::EnumUInt64> uint64b3;
    FinalModel<::enums_pmr::EnumUInt64> uint64b4;
    FinalModel<::enums_pmr::EnumUInt64> uint64b5;
};

namespace enums_pmr {

// Fast Binary Encoding Enums final model
class EnumsFinalModel : public FBE::Model
{
public:
    EnumsFinalModel() : _model(this->buffer(), 8) {}
    EnumsFinalModel(const std::shared_ptr<FBEBuffer>& buffer) : FBE::Model(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<::enums_pmr::Enums>::fbe_type(); }

    // Check if the struct value is valid
    bool verify();

    // Serialize the struct value
    size_t serialize(const ::enums_pmr::Enums& value);
    // Deserialize the struct value
    size_t deserialize(::enums_pmr::Enums& value) const noexcept;
    // Deserialize the struct value with memory resource
    size_t deserialize(::enums_pmr::Enums& value, std::pmr::memory_resource* resource) const noexcept;

    // Move to the next struct value
    void next(size_t prev) noexcept { _model.fbe_shift(prev); }

private:
    FinalModel<::enums_pmr::Enums> _model;
};

} // namespace enums_pmr

} // namespace FBE
