//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: FBE
// FBE version: 1.11.0.0
//------------------------------------------------------------------------------

#pragma once

#ifdef isset
#undef isset
#endif

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "fbe.h"

namespace FBE {

// Fast Binary Encoding base final model
template <typename T, typename TBase = T>
class FinalModelBase
{
public:
    FinalModelBase(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the allocation size
    size_t fbe_allocation_size(T value) const noexcept { return fbe_size(); }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }

    // Get the final size
    size_t fbe_size() const noexcept { return sizeof(TBase); }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the value is valid
    size_t verify() const noexcept;

    // Get the field value
    size_t get(T& value) const noexcept;
    // Get the field value (with memory resource, ignored for primitives)
    size_t get(T& value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept { return get(value); }
    // Set the field value
    size_t set(T value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;
};

// Fast Binary Encoding final model
template <typename T>
class FinalModel : public FinalModelBase<T>
{
public:
    using FinalModelBase<T>::FinalModelBase;
};

// Fast Binary Encoding final model bool specialization
template <>
class FinalModel<bool> : public FinalModelBase<bool, uint8_t>
{
public:
    using FinalModelBase<bool, uint8_t>::FinalModelBase;
};

// Fast Binary Encoding final model char specialization
template <>
class FinalModel<char> : public FinalModelBase<char, uint8_t>
{
public:
    using FinalModelBase<char, uint8_t>::FinalModelBase;
};

// Fast Binary Encoding final model wchar specialization
template <>
class FinalModel<wchar_t> : public FinalModelBase<wchar_t, uint32_t>
{
public:
    using FinalModelBase<wchar_t, uint32_t>::FinalModelBase;
};

// Helper function for PMR-aware variant value construction (used by FinalModel for variants)
template<typename V, typename T>
auto final_variant_emplace_value(V& fbe_value, std::pmr::memory_resource* resource) {
    if constexpr (std::is_integral_v<T> or std::is_floating_point_v<T> or std::is_enum_v<T> or std::is_same_v<T, std::string> or not std::is_constructible_v<T, std::pmr::memory_resource*>) {
        fbe_value.template emplace<T>();
    } else {
        fbe_value.template emplace<T>(resource);
    }
}

// Fast Binary Encoding final model decimal specialization
template <>
class FinalModel<decimal_t>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the allocation size
    size_t fbe_allocation_size(decimal_t value) const noexcept { return fbe_size(); }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }

    // Get the final size
    size_t fbe_size() const noexcept { return 16; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the decimal value is valid
    size_t verify() const noexcept;

    // Get the decimal value
    size_t get(decimal_t& value) const noexcept;
    // Get the decimal value (PMR version, resource ignored)
    size_t get(decimal_t& value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept { return get(value); }
    // Set the decimal value
    size_t set(decimal_t value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

    static uint64_t extract(double a) noexcept;
    static uint64_t uint32x32(uint32_t a, uint32_t b) noexcept;
    static void uint64x64(uint64_t a, uint64_t b, uint64_t& low64, uint32_t& high32) noexcept;
};

// Fast Binary Encoding final model UUID specialization
template <>
class FinalModel<uuid_t>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the allocation size
    size_t fbe_allocation_size(uuid_t value) const noexcept { return fbe_size(); }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }

    // Get the final size
    size_t fbe_size() const noexcept { return 16; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the UUID value is valid
    size_t verify() const noexcept;

    // Get the UUID value
    size_t get(uuid_t& value) const noexcept;
    // Get the UUID value (PMR version, resource ignored)
    size_t get(uuid_t& value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept { return get(value); }
    // Set the UUID value
    size_t set(uuid_t value) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;
};

// Fast Binary Encoding final model bytes specialization
template <>
class FinalModel<buffer_t>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the allocation size
    size_t fbe_allocation_size(const void* data, size_t size) const noexcept { return 4 + size; }
    template <size_t N>
    size_t fbe_allocation_size(const uint8_t (&data)[N]) const noexcept { return 4 + N; }
    template <size_t N>
    size_t fbe_allocation_size(const std::array<uint8_t, N>& data) const noexcept { return 4 + N; }
    size_t fbe_allocation_size(const FastVec<uint8_t>& value) const noexcept { return 4 + value.size(); }
    size_t fbe_allocation_size(const buffer_t& value) const noexcept { return 4 + value.size(); }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the bytes value is valid
    size_t verify() const noexcept;

    // Get the bytes value
    size_t get(void* data, size_t size) const noexcept;
    // Get the bytes value
    template <size_t N>
    size_t get(uint8_t (&data)[N]) const noexcept { return get(data, N); }
    // Get the bytes value
    template <size_t N>
    size_t get(std::array<uint8_t, N>& data) const noexcept { return get(data.data(), data.size()); }
    // Get the bytes value
    size_t get(FastVec<uint8_t>& value) const noexcept;
    // Get the bytes value
    size_t get(buffer_t& value) const noexcept { return get(value.buffer()); }

    // PMR versions (resource ignored for bytes)
    size_t get(void* data, size_t size, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept { return get(data, size); }
    template <size_t N>
    size_t get(uint8_t (&data)[N], [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept { return get(data, N); }
    template <size_t N>
    size_t get(std::array<uint8_t, N>& data, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept { return get(data.data(), data.size()); }
    size_t get(FastVec<uint8_t>& value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept { return get(value); }
    size_t get(buffer_t& value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept { return get(value.buffer()); }

    // Set the bytes value
    size_t set(const void* data, size_t size);
    // Set the bytes value
    template <size_t N>
    size_t set(const uint8_t (&data)[N]) { return set(data, N); }
    // Set the bytes value
    template <size_t N>
    size_t set(const std::array<uint8_t, N>& data) { return set(data.data(), data.size()); }
    // Set the bytes value
    size_t set(const FastVec<uint8_t>& value) { return set(value.data(), value.size()); }
    // Set the bytes value
    size_t set(const buffer_t& value) { return set(value.buffer()); }

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;
};

// Fast Binary Encoding final model pmr_buffer_t specialization
template <>
class FinalModel<pmr_buffer_t>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the allocation size
    size_t fbe_allocation_size(const void* data, size_t size) const noexcept { return 4 + size; }
    template <size_t N>
    size_t fbe_allocation_size(const uint8_t (&data)[N]) const noexcept { return 4 + N; }
    template <size_t N>
    size_t fbe_allocation_size(const std::array<uint8_t, N>& data) const noexcept { return 4 + N; }
    size_t fbe_allocation_size(const std::pmr::vector<uint8_t>& value) const noexcept { return 4 + value.size(); }
    size_t fbe_allocation_size(const pmr_buffer_t& value) const noexcept { return 4 + value.size(); }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the bytes value is valid
    size_t verify() const noexcept;

    // Get the bytes value
    size_t get(void* data, size_t size) const noexcept;
    // Get the bytes value
    template <size_t N>
    size_t get(uint8_t (&data)[N]) const noexcept { return get(data, N); }
    // Get the bytes value
    template <size_t N>
    size_t get(std::array<uint8_t, N>& data) const noexcept { return get(data.data(), data.size()); }
    // Get the bytes value (with optional memory resource)
    size_t get(std::pmr::vector<uint8_t>& value) const noexcept { return get(value, nullptr); }
    size_t get(std::pmr::vector<uint8_t>& value, std::pmr::memory_resource* resource) const noexcept;
    // Get the bytes value (with optional memory resource)
    size_t get(pmr_buffer_t& value) const noexcept { return get(value.buffer(), nullptr); }
    size_t get(pmr_buffer_t& value, std::pmr::memory_resource* resource) const noexcept { return get(value.buffer(), resource); }

    // Set the bytes value
    size_t set(const void* data, size_t size);
    // Set the bytes value
    template <size_t N>
    size_t set(const uint8_t (&data)[N]) { return set(data, N); }
    // Set the bytes value
    template <size_t N>
    size_t set(const std::array<uint8_t, N>& data) { return set(data.data(), data.size()); }
    // Set the bytes value
    size_t set(const std::pmr::vector<uint8_t>& value) { return set(value.data(), value.size()); }
    // Set the bytes value
    size_t set(const pmr_buffer_t& value) { return set(value.buffer()); }

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;
};

// Fast Binary Encoding final model string specialization
template <>
class FinalModel<FBEString>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the allocation size
    size_t fbe_allocation_size(const char* data, size_t size) const noexcept { return 4 + size; }
    template <size_t N>
    size_t fbe_allocation_size(const char (&data)[N]) const noexcept { return 4 + N; }
    template <size_t N>
    size_t fbe_allocation_size(const std::array<char, N>& data) const noexcept { return 4 + N; }
    size_t fbe_allocation_size(const FBEString& value) const noexcept { return 4 + value.size(); }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the string value is valid
    size_t verify() const noexcept;

    // Get the string value
    size_t get(char* data, size_t size) const noexcept;
    // Get the string value
    template <size_t N>
    size_t get(char (&data)[N]) const noexcept { return get(data, N); }
    // Get the string value
    template <size_t N>
    size_t get(std::array<char, N>& data) const noexcept { return get(data.data(), data.size()); }
    // Get the string value
    size_t get(FBEString& value) const noexcept;

    // PMR versions (resource ignored for FBEString)
    size_t get(char* data, size_t size, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept { return get(data, size); }
    template <size_t N>
    size_t get(char (&data)[N], [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept { return get(data, N); }
    template <size_t N>
    size_t get(std::array<char, N>& data, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept { return get(data.data(), data.size()); }
    size_t get(FBEString& value, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept { return get(value); }

    // Set the string value
    size_t set(const char* data, size_t size);
    // Set the string value
    template <size_t N>
    size_t set(const char (&data)[N]) { return set(data, N); }
    // Set the string value
    template <size_t N>
    size_t set(const std::array<char, N>& data) { return set(data.data(), data.size()); }
    // Set the string value
    size_t set(const FBEString& value);

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;
};

// Fast Binary Encoding final model ArenaString specialization
template <>
class FinalModel<ArenaString>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the allocation size
    size_t fbe_allocation_size(const char* data, size_t size) const noexcept { return 4 + size; }
    template <size_t N>
    size_t fbe_allocation_size(const char (&data)[N]) const noexcept { return 4 + N; }
    template <size_t N>
    size_t fbe_allocation_size(const std::array<char, N>& data) const noexcept { return 4 + N; }
    size_t fbe_allocation_size(const ArenaString& value) const noexcept { return 4 + value.size(); }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the string value is valid
    size_t verify() const noexcept;

    // Get the string value
    size_t get(char* data, size_t size) const noexcept;
    // Get the string value
    template <size_t N>
    size_t get(char (&data)[N]) const noexcept { return get(data, N); }
    // Get the string value
    template <size_t N>
    size_t get(std::array<char, N>& data) const noexcept { return get(data.data(), data.size()); }
    // Get the ArenaString value (with optional resource)
    size_t get(ArenaString& value) const noexcept { return get(value, nullptr); }
    size_t get(ArenaString& value, std::pmr::memory_resource* resource) const noexcept;

    // Set the string value
    size_t set(const char* data, size_t size);
    // Set the string value
    template <size_t N>
    size_t set(const char (&data)[N]) { return set(data, N); }
    // Set the string value
    template <size_t N>
    size_t set(const std::array<char, N>& data) { return set(data.data(), data.size()); }
    // Set the ArenaString value
    size_t set(const ArenaString& value);

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;
};

// Fast Binary Encoding final model optional specialization
template <typename T>
class FinalModel<std::optional<T>>
{
public:
    FinalModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset), value(buffer, 0) {}

    // Get the allocation size
    size_t fbe_allocation_size(const std::optional<T>& opt) const noexcept { return 1 + (opt ? value.fbe_allocation_size(opt.value()) : 0); }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    //! Is the value present?
    explicit operator bool() const noexcept { return has_value(); }

    // Checks if the object contains a value
    bool has_value() const noexcept;

    // Check if the optional value is valid
    size_t verify() const noexcept;

    // Get the optional value
    size_t get(std::optional<T>& opt) const noexcept;
    // Get the optional value (PMR version)
    size_t get(std::optional<T>& opt, std::pmr::memory_resource* resource) const noexcept;
    // Set the optional value
    size_t set(const std::optional<T>& opt);

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;

public:
    // Base final model value
    FinalModel<T> value;
};

// Fast Binary Encoding final model array
template <typename T, size_t N>
class FinalModelArray
{
public:
    FinalModelArray(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the allocation size
    template <size_t S>
    size_t fbe_allocation_size(const T (&values)[S]) const noexcept;
    template <size_t S>
    size_t fbe_allocation_size(const std::array<T, S>& values) const noexcept;
    size_t fbe_allocation_size(const FastVec<T>& values) const noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the array is valid
    size_t verify() const noexcept;

    // Get the array as C-array
    template <size_t S>
    size_t get(T (&values)[S]) const noexcept;
    // Get the array as std::array
    template <size_t S>
    size_t get(std::array<T, S>& values) const noexcept;
    // Get the array as FastVec
    size_t get(FastVec<T>& values) const noexcept;

    // Get the array as C-array (PMR version)
    template <size_t S>
    size_t get(T (&values)[S], std::pmr::memory_resource* resource) const noexcept;
    // Get the array as std::array (PMR version)
    template <size_t S>
    size_t get(std::array<T, S>& values, std::pmr::memory_resource* resource) const noexcept;
    // Get the array as FastVec (PMR version)
    size_t get(FastVec<T>& values, std::pmr::memory_resource* resource) const noexcept;

    // Set the array as C-array
    template <size_t S>
    size_t set(const T (&values)[S]) noexcept;
    // Set the array as std::array
    template <size_t S>
    size_t set(const std::array<T, S>& values) noexcept;
    // Set the array as FastVec
    size_t set(const FastVec<T>& values) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;
};

// Fast Binary Encoding final model vector
template <typename T>
class FinalModelVector
{
public:
    FinalModelVector(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the allocation size
    size_t fbe_allocation_size(const FastVec<T>& values) const noexcept;
    size_t fbe_allocation_size(const std::list<T>& values) const noexcept;
    size_t fbe_allocation_size(const std::set<T>& values) const noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the vector is valid
    size_t verify() const noexcept;

    // Get the vector as FastVec
    size_t get(FastVec<T>& values) const noexcept;
    // Get the vector as std::list
    size_t get(std::list<T>& values) const noexcept;
    // Get the vector as std::set
    size_t get(std::set<T>& values) const noexcept;

    // Get the vector as FastVec with memory resource
    size_t get(FastVec<T>& values, std::pmr::memory_resource* resource) const noexcept;
    // Get the vector as std::pmr::vector (with optional resource)
    size_t get(std::pmr::vector<T>& values) const noexcept { return get(values, nullptr); }
    size_t get(std::pmr::vector<T>& values, std::pmr::memory_resource* resource) const noexcept;
    // Get the vector as std::pmr::list (with optional resource)
    size_t get(std::pmr::list<T>& values) const noexcept { return get(values, nullptr); }
    size_t get(std::pmr::list<T>& values, std::pmr::memory_resource* resource) const noexcept;
    // Get the vector as std::pmr::set (with optional resource)
    size_t get(std::pmr::set<T>& values) const noexcept { return get(values, nullptr); }
    size_t get(std::pmr::set<T>& values, std::pmr::memory_resource* resource) const noexcept;

    // Set the vector as FastVec
    size_t set(const FastVec<T>& values) noexcept;
    // Set the vector as std::list
    size_t set(const std::list<T>& values) noexcept;
    // Set the vector as std::set
    size_t set(const std::set<T>& values) noexcept;

    // Set the vector as std::pmr::vector
    size_t set(const std::pmr::vector<T>& values) noexcept;
    // Set the vector as std::pmr::list
    size_t set(const std::pmr::list<T>& values) noexcept;
    // Set the vector as std::pmr::set
    size_t set(const std::pmr::set<T>& values) noexcept;

    // Get the allocation size for std::pmr::vector
    size_t fbe_allocation_size(const std::pmr::vector<T>& values) const noexcept;
    // Get the allocation size for std::pmr::list
    size_t fbe_allocation_size(const std::pmr::list<T>& values) const noexcept;
    // Get the allocation size for std::pmr::set
    size_t fbe_allocation_size(const std::pmr::set<T>& values) const noexcept;

    // Get the allocation size for FBE::set (dense_set)
    size_t fbe_allocation_size(const FBE::set<T>& values) const noexcept;
    // Get the allocation size for FBE::pmr::set (dense_set with pmr allocator)
    size_t fbe_allocation_size(const FBE::pmr::set<T>& values) const noexcept;
    // Get the vector as FBE::set (dense_set)
    size_t get(FBE::set<T>& values) const noexcept;
    // Get the vector as FBE::pmr::set (dense_set with pmr allocator, optional resource)
    size_t get(FBE::pmr::set<T>& values) const noexcept { return get(values, nullptr); }
    size_t get(FBE::pmr::set<T>& values, std::pmr::memory_resource* resource) const noexcept;
    // Set the vector as FBE::set (dense_set)
    size_t set(const FBE::set<T>& values) noexcept;
    // Set the vector as FBE::pmr::set (dense_set with pmr allocator)
    size_t set(const FBE::pmr::set<T>& values) noexcept;

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;
};

// Fast Binary Encoding final model map
template <typename TKey, typename TValue>
class FinalModelMap
{
public:
    FinalModelMap(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the allocation size
    size_t fbe_allocation_size(const std::map<TKey, TValue>& values) const noexcept;
    size_t fbe_allocation_size(const HashMap<TKey, TValue>& values) const noexcept;

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the map is valid
    size_t verify() const noexcept;

    // Get the map as std::map
    size_t get(std::map<TKey, TValue>& values) const noexcept;
    // Get the map as HashMap
    size_t get(HashMap<TKey, TValue>& values) const noexcept;

    // Get the map as std::map with memory resource
    size_t get(std::map<TKey, TValue>& values, std::pmr::memory_resource* resource) const noexcept;
    // Get the map as std::pmr::map (with optional resource)
    size_t get(std::pmr::map<TKey, TValue>& values) const noexcept { return get(values, nullptr); }
    size_t get(std::pmr::map<TKey, TValue>& values, std::pmr::memory_resource* resource) const noexcept;
    // Get the map as FBE::pmr::HashMap (with optional resource)
    size_t get(FBE::pmr::HashMap<TKey, TValue>& values) const noexcept { return get(values, nullptr); }
    size_t get(FBE::pmr::HashMap<TKey, TValue>& values, std::pmr::memory_resource* resource) const noexcept;

    // Set the map as std::map
    size_t set(const std::map<TKey, TValue>& values) noexcept;
    // Set the map as HashMap
    size_t set(const HashMap<TKey, TValue>& values) noexcept;

    // Set the map as std::pmr::map
    size_t set(const std::pmr::map<TKey, TValue>& values) noexcept;
    // Set the map as FBE::pmr::HashMap
    size_t set(const FBE::pmr::HashMap<TKey, TValue>& values) noexcept;

    // Get the allocation size for std::pmr::map
    size_t fbe_allocation_size(const std::pmr::map<TKey, TValue>& values) const noexcept;
    // Get the allocation size for FBE::pmr::HashMap
    size_t fbe_allocation_size(const FBE::pmr::HashMap<TKey, TValue>& values) const noexcept;

#if defined(USING_BTREE_MAP)
    // Get the allocation size for FBE::map (btree_map)
    size_t fbe_allocation_size(const FBE::map<TKey, TValue>& values) const noexcept;
    // Get the allocation size for FBE::pmr::map (btree_map with pmr allocator)
    size_t fbe_allocation_size(const FBE::pmr::map<TKey, TValue>& values) const noexcept;
    // Get the map as FBE::map (btree_map)
    size_t get(FBE::map<TKey, TValue>& values) const noexcept;
    // Get the map as FBE::pmr::map (btree_map with pmr allocator, optional resource)
    size_t get(FBE::pmr::map<TKey, TValue>& values) const noexcept { return get(values, nullptr); }
    size_t get(FBE::pmr::map<TKey, TValue>& values, std::pmr::memory_resource* resource) const noexcept;
    // Set the map as FBE::map (btree_map)
    size_t set(const FBE::map<TKey, TValue>& values) noexcept;
    // Set the map as FBE::pmr::map (btree_map with pmr allocator)
    size_t set(const FBE::pmr::map<TKey, TValue>& values) noexcept;
#endif

private:
    FBEBuffer& _buffer;
    mutable size_t _offset;
};

} // namespace FBE

#include "fbe_final_models.inl"
