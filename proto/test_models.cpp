//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: test.fbe
// FBE version: 1.10.0.0
//------------------------------------------------------------------------------

#include "test_models.h"

namespace FBE {

FieldModel<::test::StructSimple>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , id(buffer, 4 + 4)
    , f1(buffer, id.fbe_offset() + id.fbe_size())
    , f2(buffer, f1.fbe_offset() + f1.fbe_size())
    , f3(buffer, f2.fbe_offset() + f2.fbe_size())
    , f4(buffer, f3.fbe_offset() + f3.fbe_size())
    , f5(buffer, f4.fbe_offset() + f4.fbe_size())
    , f6(buffer, f5.fbe_offset() + f5.fbe_size())
    , f7(buffer, f6.fbe_offset() + f6.fbe_size())
    , f8(buffer, f7.fbe_offset() + f7.fbe_size())
    , f9(buffer, f8.fbe_offset() + f8.fbe_size())
    , f10(buffer, f9.fbe_offset() + f9.fbe_size())
    , f11(buffer, f10.fbe_offset() + f10.fbe_size())
    , f12(buffer, f11.fbe_offset() + f11.fbe_size())
    , f13(buffer, f12.fbe_offset() + f12.fbe_size())
    , f14(buffer, f13.fbe_offset() + f13.fbe_size())
    , f15(buffer, f14.fbe_offset() + f14.fbe_size())
    , f16(buffer, f15.fbe_offset() + f15.fbe_size())
    , f17(buffer, f16.fbe_offset() + f16.fbe_size())
    , f18(buffer, f17.fbe_offset() + f17.fbe_size())
    , f19(buffer, f18.fbe_offset() + f18.fbe_size())
    , f20(buffer, f19.fbe_offset() + f19.fbe_size())
    , f21(buffer, f20.fbe_offset() + f20.fbe_size())
    , f22(buffer, f21.fbe_offset() + f21.fbe_size())
    , f23(buffer, f22.fbe_offset() + f22.fbe_size())
    , f24(buffer, f23.fbe_offset() + f23.fbe_size())
    , f25(buffer, f24.fbe_offset() + f24.fbe_size())
    , f26(buffer, f25.fbe_offset() + f25.fbe_size())
    , f27(buffer, f26.fbe_offset() + f26.fbe_size())
    , f28(buffer, f27.fbe_offset() + f27.fbe_size())
    , f29(buffer, f28.fbe_offset() + f28.fbe_size())
    , f30(buffer, f29.fbe_offset() + f29.fbe_size())
    , f31(buffer, f30.fbe_offset() + f30.fbe_size())
    , f32(buffer, f31.fbe_offset() + f31.fbe_size())
    , f33(buffer, f32.fbe_offset() + f32.fbe_size())
    , f34(buffer, f33.fbe_offset() + f33.fbe_size())
    , f35(buffer, f34.fbe_offset() + f34.fbe_size())
    , f36(buffer, f35.fbe_offset() + f35.fbe_size())
    , f37(buffer, f36.fbe_offset() + f36.fbe_size())
    , f38(buffer, f37.fbe_offset() + f37.fbe_size())
    , f39(buffer, f38.fbe_offset() + f38.fbe_size())
    , f40(buffer, f39.fbe_offset() + f39.fbe_size())
    , f41(buffer, f40.fbe_offset() + f40.fbe_size())
    , f42(buffer, f41.fbe_offset() + f41.fbe_size())
    , f43(buffer, f42.fbe_offset() + f42.fbe_size())
    , f44(buffer, f43.fbe_offset() + f43.fbe_size())
{}

size_t FieldModel<::test::StructSimple>::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + id.fbe_size()
        + f1.fbe_size()
        + f2.fbe_size()
        + f3.fbe_size()
        + f4.fbe_size()
        + f5.fbe_size()
        + f6.fbe_size()
        + f7.fbe_size()
        + f8.fbe_size()
        + f9.fbe_size()
        + f10.fbe_size()
        + f11.fbe_size()
        + f12.fbe_size()
        + f13.fbe_size()
        + f14.fbe_size()
        + f15.fbe_size()
        + f16.fbe_size()
        + f17.fbe_size()
        + f18.fbe_size()
        + f19.fbe_size()
        + f20.fbe_size()
        + f21.fbe_size()
        + f22.fbe_size()
        + f23.fbe_size()
        + f24.fbe_size()
        + f25.fbe_size()
        + f26.fbe_size()
        + f27.fbe_size()
        + f28.fbe_size()
        + f29.fbe_size()
        + f30.fbe_size()
        + f31.fbe_size()
        + f32.fbe_size()
        + f33.fbe_size()
        + f34.fbe_size()
        + f35.fbe_size()
        + f36.fbe_size()
        + f37.fbe_size()
        + f38.fbe_size()
        + f39.fbe_size()
        + f40.fbe_size()
        + f41.fbe_size()
        + f42.fbe_size()
        + f43.fbe_size()
        + f44.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel<::test::StructSimple>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + id.fbe_extra()
        + f1.fbe_extra()
        + f2.fbe_extra()
        + f3.fbe_extra()
        + f4.fbe_extra()
        + f5.fbe_extra()
        + f6.fbe_extra()
        + f7.fbe_extra()
        + f8.fbe_extra()
        + f9.fbe_extra()
        + f10.fbe_extra()
        + f11.fbe_extra()
        + f12.fbe_extra()
        + f13.fbe_extra()
        + f14.fbe_extra()
        + f15.fbe_extra()
        + f16.fbe_extra()
        + f17.fbe_extra()
        + f18.fbe_extra()
        + f19.fbe_extra()
        + f20.fbe_extra()
        + f21.fbe_extra()
        + f22.fbe_extra()
        + f23.fbe_extra()
        + f24.fbe_extra()
        + f25.fbe_extra()
        + f26.fbe_extra()
        + f27.fbe_extra()
        + f28.fbe_extra()
        + f29.fbe_extra()
        + f30.fbe_extra()
        + f31.fbe_extra()
        + f32.fbe_extra()
        + f33.fbe_extra()
        + f34.fbe_extra()
        + f35.fbe_extra()
        + f36.fbe_extra()
        + f37.fbe_extra()
        + f38.fbe_extra()
        + f39.fbe_extra()
        + f40.fbe_extra()
        + f41.fbe_extra()
        + f42.fbe_extra()
        + f43.fbe_extra()
        + f44.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::test::StructSimple>::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel<::test::StructSimple>::verify_fields([[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + id.fbe_size()) > fbe_struct_size)
        return true;
    if (!id.verify())
        return false;
    fbe_current_size += id.fbe_size();

    if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
        return true;
    if (!f1.verify())
        return false;
    fbe_current_size += f1.fbe_size();

    if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
        return true;
    if (!f2.verify())
        return false;
    fbe_current_size += f2.fbe_size();

    if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
        return true;
    if (!f3.verify())
        return false;
    fbe_current_size += f3.fbe_size();

    if ((fbe_current_size + f4.fbe_size()) > fbe_struct_size)
        return true;
    if (!f4.verify())
        return false;
    fbe_current_size += f4.fbe_size();

    if ((fbe_current_size + f5.fbe_size()) > fbe_struct_size)
        return true;
    if (!f5.verify())
        return false;
    fbe_current_size += f5.fbe_size();

    if ((fbe_current_size + f6.fbe_size()) > fbe_struct_size)
        return true;
    if (!f6.verify())
        return false;
    fbe_current_size += f6.fbe_size();

    if ((fbe_current_size + f7.fbe_size()) > fbe_struct_size)
        return true;
    if (!f7.verify())
        return false;
    fbe_current_size += f7.fbe_size();

    if ((fbe_current_size + f8.fbe_size()) > fbe_struct_size)
        return true;
    if (!f8.verify())
        return false;
    fbe_current_size += f8.fbe_size();

    if ((fbe_current_size + f9.fbe_size()) > fbe_struct_size)
        return true;
    if (!f9.verify())
        return false;
    fbe_current_size += f9.fbe_size();

    if ((fbe_current_size + f10.fbe_size()) > fbe_struct_size)
        return true;
    if (!f10.verify())
        return false;
    fbe_current_size += f10.fbe_size();

    if ((fbe_current_size + f11.fbe_size()) > fbe_struct_size)
        return true;
    if (!f11.verify())
        return false;
    fbe_current_size += f11.fbe_size();

    if ((fbe_current_size + f12.fbe_size()) > fbe_struct_size)
        return true;
    if (!f12.verify())
        return false;
    fbe_current_size += f12.fbe_size();

    if ((fbe_current_size + f13.fbe_size()) > fbe_struct_size)
        return true;
    if (!f13.verify())
        return false;
    fbe_current_size += f13.fbe_size();

    if ((fbe_current_size + f14.fbe_size()) > fbe_struct_size)
        return true;
    if (!f14.verify())
        return false;
    fbe_current_size += f14.fbe_size();

    if ((fbe_current_size + f15.fbe_size()) > fbe_struct_size)
        return true;
    if (!f15.verify())
        return false;
    fbe_current_size += f15.fbe_size();

    if ((fbe_current_size + f16.fbe_size()) > fbe_struct_size)
        return true;
    if (!f16.verify())
        return false;
    fbe_current_size += f16.fbe_size();

    if ((fbe_current_size + f17.fbe_size()) > fbe_struct_size)
        return true;
    if (!f17.verify())
        return false;
    fbe_current_size += f17.fbe_size();

    if ((fbe_current_size + f18.fbe_size()) > fbe_struct_size)
        return true;
    if (!f18.verify())
        return false;
    fbe_current_size += f18.fbe_size();

    if ((fbe_current_size + f19.fbe_size()) > fbe_struct_size)
        return true;
    if (!f19.verify())
        return false;
    fbe_current_size += f19.fbe_size();

    if ((fbe_current_size + f20.fbe_size()) > fbe_struct_size)
        return true;
    if (!f20.verify())
        return false;
    fbe_current_size += f20.fbe_size();

    if ((fbe_current_size + f21.fbe_size()) > fbe_struct_size)
        return true;
    if (!f21.verify())
        return false;
    fbe_current_size += f21.fbe_size();

    if ((fbe_current_size + f22.fbe_size()) > fbe_struct_size)
        return true;
    if (!f22.verify())
        return false;
    fbe_current_size += f22.fbe_size();

    if ((fbe_current_size + f23.fbe_size()) > fbe_struct_size)
        return true;
    if (!f23.verify())
        return false;
    fbe_current_size += f23.fbe_size();

    if ((fbe_current_size + f24.fbe_size()) > fbe_struct_size)
        return true;
    if (!f24.verify())
        return false;
    fbe_current_size += f24.fbe_size();

    if ((fbe_current_size + f25.fbe_size()) > fbe_struct_size)
        return true;
    if (!f25.verify())
        return false;
    fbe_current_size += f25.fbe_size();

    if ((fbe_current_size + f26.fbe_size()) > fbe_struct_size)
        return true;
    if (!f26.verify())
        return false;
    fbe_current_size += f26.fbe_size();

    if ((fbe_current_size + f27.fbe_size()) > fbe_struct_size)
        return true;
    if (!f27.verify())
        return false;
    fbe_current_size += f27.fbe_size();

    if ((fbe_current_size + f28.fbe_size()) > fbe_struct_size)
        return true;
    if (!f28.verify())
        return false;
    fbe_current_size += f28.fbe_size();

    if ((fbe_current_size + f29.fbe_size()) > fbe_struct_size)
        return true;
    if (!f29.verify())
        return false;
    fbe_current_size += f29.fbe_size();

    if ((fbe_current_size + f30.fbe_size()) > fbe_struct_size)
        return true;
    if (!f30.verify())
        return false;
    fbe_current_size += f30.fbe_size();

    if ((fbe_current_size + f31.fbe_size()) > fbe_struct_size)
        return true;
    if (!f31.verify())
        return false;
    fbe_current_size += f31.fbe_size();

    if ((fbe_current_size + f32.fbe_size()) > fbe_struct_size)
        return true;
    if (!f32.verify())
        return false;
    fbe_current_size += f32.fbe_size();

    if ((fbe_current_size + f33.fbe_size()) > fbe_struct_size)
        return true;
    if (!f33.verify())
        return false;
    fbe_current_size += f33.fbe_size();

    if ((fbe_current_size + f34.fbe_size()) > fbe_struct_size)
        return true;
    if (!f34.verify())
        return false;
    fbe_current_size += f34.fbe_size();

    if ((fbe_current_size + f35.fbe_size()) > fbe_struct_size)
        return true;
    if (!f35.verify())
        return false;
    fbe_current_size += f35.fbe_size();

    if ((fbe_current_size + f36.fbe_size()) > fbe_struct_size)
        return true;
    if (!f36.verify())
        return false;
    fbe_current_size += f36.fbe_size();

    if ((fbe_current_size + f37.fbe_size()) > fbe_struct_size)
        return true;
    if (!f37.verify())
        return false;
    fbe_current_size += f37.fbe_size();

    if ((fbe_current_size + f38.fbe_size()) > fbe_struct_size)
        return true;
    if (!f38.verify())
        return false;
    fbe_current_size += f38.fbe_size();

    if ((fbe_current_size + f39.fbe_size()) > fbe_struct_size)
        return true;
    if (!f39.verify())
        return false;
    fbe_current_size += f39.fbe_size();

    if ((fbe_current_size + f40.fbe_size()) > fbe_struct_size)
        return true;
    if (!f40.verify())
        return false;
    fbe_current_size += f40.fbe_size();

    if ((fbe_current_size + f41.fbe_size()) > fbe_struct_size)
        return true;
    if (!f41.verify())
        return false;
    fbe_current_size += f41.fbe_size();

    if ((fbe_current_size + f42.fbe_size()) > fbe_struct_size)
        return true;
    if (!f42.verify())
        return false;
    fbe_current_size += f42.fbe_size();

    if ((fbe_current_size + f43.fbe_size()) > fbe_struct_size)
        return true;
    if (!f43.verify())
        return false;
    fbe_current_size += f43.fbe_size();

    if ((fbe_current_size + f44.fbe_size()) > fbe_struct_size)
        return true;
    if (!f44.verify())
        return false;
    fbe_current_size += f44.fbe_size();

    return true;
}

size_t FieldModel<::test::StructSimple>::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructSimple>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructSimple>::get(::test::StructSimple& fbe_value) const noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel<::test::StructSimple>::get_fields([[maybe_unused]] ::test::StructSimple& fbe_value, [[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + id.fbe_size()) <= fbe_struct_size)
        id.get(fbe_value.id);
    else
        fbe_value.id = (int32_t)0ll;
    fbe_current_size += id.fbe_size();

    if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
        f1.get(fbe_value.f1);
    else
        fbe_value.f1 = false;
    fbe_current_size += f1.fbe_size();

    if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
        f2.get(fbe_value.f2, true);
    else
        fbe_value.f2 = true;
    fbe_current_size += f2.fbe_size();

    if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
        f3.get(fbe_value.f3);
    else
        fbe_value.f3 = (uint8_t)0u;
    fbe_current_size += f3.fbe_size();

    if ((fbe_current_size + f4.fbe_size()) <= fbe_struct_size)
        f4.get(fbe_value.f4, (uint8_t)255u);
    else
        fbe_value.f4 = (uint8_t)255u;
    fbe_current_size += f4.fbe_size();

    if ((fbe_current_size + f5.fbe_size()) <= fbe_struct_size)
        f5.get(fbe_value.f5);
    else
        fbe_value.f5 = '\0';
    fbe_current_size += f5.fbe_size();

    if ((fbe_current_size + f6.fbe_size()) <= fbe_struct_size)
        f6.get(fbe_value.f6, (char)'!');
    else
        fbe_value.f6 = (char)'!';
    fbe_current_size += f6.fbe_size();

    if ((fbe_current_size + f7.fbe_size()) <= fbe_struct_size)
        f7.get(fbe_value.f7);
    else
        fbe_value.f7 = L'\0';
    fbe_current_size += f7.fbe_size();

    if ((fbe_current_size + f8.fbe_size()) <= fbe_struct_size)
        f8.get(fbe_value.f8, (wchar_t)0x0444);
    else
        fbe_value.f8 = (wchar_t)0x0444;
    fbe_current_size += f8.fbe_size();

    if ((fbe_current_size + f9.fbe_size()) <= fbe_struct_size)
        f9.get(fbe_value.f9);
    else
        fbe_value.f9 = (int8_t)0;
    fbe_current_size += f9.fbe_size();

    if ((fbe_current_size + f10.fbe_size()) <= fbe_struct_size)
        f10.get(fbe_value.f10, (int8_t)127);
    else
        fbe_value.f10 = (int8_t)127;
    fbe_current_size += f10.fbe_size();

    if ((fbe_current_size + f11.fbe_size()) <= fbe_struct_size)
        f11.get(fbe_value.f11, (uint8_t)0u);
    else
        fbe_value.f11 = (uint8_t)0u;
    fbe_current_size += f11.fbe_size();

    if ((fbe_current_size + f12.fbe_size()) <= fbe_struct_size)
        f12.get(fbe_value.f12, (uint8_t)255u);
    else
        fbe_value.f12 = (uint8_t)255u;
    fbe_current_size += f12.fbe_size();

    if ((fbe_current_size + f13.fbe_size()) <= fbe_struct_size)
        f13.get(fbe_value.f13);
    else
        fbe_value.f13 = (int16_t)0;
    fbe_current_size += f13.fbe_size();

    if ((fbe_current_size + f14.fbe_size()) <= fbe_struct_size)
        f14.get(fbe_value.f14, (int16_t)32767);
    else
        fbe_value.f14 = (int16_t)32767;
    fbe_current_size += f14.fbe_size();

    if ((fbe_current_size + f15.fbe_size()) <= fbe_struct_size)
        f15.get(fbe_value.f15, (uint16_t)0u);
    else
        fbe_value.f15 = (uint16_t)0u;
    fbe_current_size += f15.fbe_size();

    if ((fbe_current_size + f16.fbe_size()) <= fbe_struct_size)
        f16.get(fbe_value.f16, (uint16_t)65535u);
    else
        fbe_value.f16 = (uint16_t)65535u;
    fbe_current_size += f16.fbe_size();

    if ((fbe_current_size + f17.fbe_size()) <= fbe_struct_size)
        f17.get(fbe_value.f17);
    else
        fbe_value.f17 = (int32_t)0ll;
    fbe_current_size += f17.fbe_size();

    if ((fbe_current_size + f18.fbe_size()) <= fbe_struct_size)
        f18.get(fbe_value.f18, (int32_t)2147483647ll);
    else
        fbe_value.f18 = (int32_t)2147483647ll;
    fbe_current_size += f18.fbe_size();

    if ((fbe_current_size + f19.fbe_size()) <= fbe_struct_size)
        f19.get(fbe_value.f19, (uint32_t)0ull);
    else
        fbe_value.f19 = (uint32_t)0ull;
    fbe_current_size += f19.fbe_size();

    if ((fbe_current_size + f20.fbe_size()) <= fbe_struct_size)
        f20.get(fbe_value.f20, (uint32_t)4294967295ull);
    else
        fbe_value.f20 = (uint32_t)4294967295ull;
    fbe_current_size += f20.fbe_size();

    if ((fbe_current_size + f21.fbe_size()) <= fbe_struct_size)
        f21.get(fbe_value.f21);
    else
        fbe_value.f21 = (int64_t)0ll;
    fbe_current_size += f21.fbe_size();

    if ((fbe_current_size + f22.fbe_size()) <= fbe_struct_size)
        f22.get(fbe_value.f22, (int64_t)9223372036854775807ll);
    else
        fbe_value.f22 = (int64_t)9223372036854775807ll;
    fbe_current_size += f22.fbe_size();

    if ((fbe_current_size + f23.fbe_size()) <= fbe_struct_size)
        f23.get(fbe_value.f23, (uint64_t)0ull);
    else
        fbe_value.f23 = (uint64_t)0ull;
    fbe_current_size += f23.fbe_size();

    if ((fbe_current_size + f24.fbe_size()) <= fbe_struct_size)
        f24.get(fbe_value.f24, (uint64_t)18446744073709551615ull);
    else
        fbe_value.f24 = (uint64_t)18446744073709551615ull;
    fbe_current_size += f24.fbe_size();

    if ((fbe_current_size + f25.fbe_size()) <= fbe_struct_size)
        f25.get(fbe_value.f25);
    else
        fbe_value.f25 = 0.0f;
    fbe_current_size += f25.fbe_size();

    if ((fbe_current_size + f26.fbe_size()) <= fbe_struct_size)
        f26.get(fbe_value.f26, (float)123.456f);
    else
        fbe_value.f26 = (float)123.456f;
    fbe_current_size += f26.fbe_size();

    if ((fbe_current_size + f27.fbe_size()) <= fbe_struct_size)
        f27.get(fbe_value.f27);
    else
        fbe_value.f27 = 0.0;
    fbe_current_size += f27.fbe_size();

    if ((fbe_current_size + f28.fbe_size()) <= fbe_struct_size)
        f28.get(fbe_value.f28, (double)-123.456e+123);
    else
        fbe_value.f28 = (double)-123.456e+123;
    fbe_current_size += f28.fbe_size();

    if ((fbe_current_size + f29.fbe_size()) <= fbe_struct_size)
        f29.get(fbe_value.f29);
    else
        fbe_value.f29 = FBE::decimal_t();
    fbe_current_size += f29.fbe_size();

    if ((fbe_current_size + f30.fbe_size()) <= fbe_struct_size)
        f30.get(fbe_value.f30, FBE::decimal_t(123456.123456));
    else
        fbe_value.f30 = FBE::decimal_t(123456.123456);
    fbe_current_size += f30.fbe_size();

    if ((fbe_current_size + f31.fbe_size()) <= fbe_struct_size)
        f31.get(fbe_value.f31);
    else
        fbe_value.f31 = "";
    fbe_current_size += f31.fbe_size();

    if ((fbe_current_size + f32.fbe_size()) <= fbe_struct_size)
        f32.get(fbe_value.f32, "Initial string!");
    else
        fbe_value.f32 = "Initial string!";
    fbe_current_size += f32.fbe_size();

    if ((fbe_current_size + f33.fbe_size()) <= fbe_struct_size)
        f33.get(fbe_value.f33);
    else
        fbe_value.f33 = (uint64_t)0ull;
    fbe_current_size += f33.fbe_size();

    if ((fbe_current_size + f34.fbe_size()) <= fbe_struct_size)
        f34.get(fbe_value.f34, FBE::epoch());
    else
        fbe_value.f34 = FBE::epoch();
    fbe_current_size += f34.fbe_size();

    if ((fbe_current_size + f35.fbe_size()) <= fbe_struct_size)
        f35.get(fbe_value.f35, FBE::utc());
    else
        fbe_value.f35 = FBE::utc();
    fbe_current_size += f35.fbe_size();

    if ((fbe_current_size + f36.fbe_size()) <= fbe_struct_size)
        f36.get(fbe_value.f36);
    else
        fbe_value.f36 = FBE::uuid_t::nil();
    fbe_current_size += f36.fbe_size();

    if ((fbe_current_size + f37.fbe_size()) <= fbe_struct_size)
        f37.get(fbe_value.f37, FBE::uuid_t::sequential());
    else
        fbe_value.f37 = FBE::uuid_t::sequential();
    fbe_current_size += f37.fbe_size();

    if ((fbe_current_size + f38.fbe_size()) <= fbe_struct_size)
        f38.get(fbe_value.f38, FBE::uuid_t("123e4567-e89b-12d3-a456-426655440000"));
    else
        fbe_value.f38 = FBE::uuid_t("123e4567-e89b-12d3-a456-426655440000");
    fbe_current_size += f38.fbe_size();

    if ((fbe_current_size + f39.fbe_size()) <= fbe_struct_size)
        f39.get(fbe_value.f39);
    else
        fbe_value.f39 = ::proto::OrderSide();
    fbe_current_size += f39.fbe_size();

    if ((fbe_current_size + f40.fbe_size()) <= fbe_struct_size)
        f40.get(fbe_value.f40);
    else
        fbe_value.f40 = ::proto::OrderType();
    fbe_current_size += f40.fbe_size();

    if ((fbe_current_size + f41.fbe_size()) <= fbe_struct_size)
        f41.get(fbe_value.f41);
    else
        fbe_value.f41 = ::proto::Order();
    fbe_current_size += f41.fbe_size();

    if ((fbe_current_size + f42.fbe_size()) <= fbe_struct_size)
        f42.get(fbe_value.f42);
    else
        fbe_value.f42 = ::proto::Balance();
    fbe_current_size += f42.fbe_size();

    if ((fbe_current_size + f43.fbe_size()) <= fbe_struct_size)
        f43.get(fbe_value.f43);
    else
        fbe_value.f43 = ::proto::State();
    fbe_current_size += f43.fbe_size();

    if ((fbe_current_size + f44.fbe_size()) <= fbe_struct_size)
        f44.get(fbe_value.f44);
    else
        fbe_value.f44 = ::proto::Account();
    fbe_current_size += f44.fbe_size();
}

size_t FieldModel<::test::StructSimple>::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, (uint32_t)fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructSimple>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructSimple>::set(const ::test::StructSimple& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel<::test::StructSimple>::set_fields([[maybe_unused]] const ::test::StructSimple& fbe_value) noexcept
{
    id.set(fbe_value.id);
    f1.set(fbe_value.f1);
    f2.set(fbe_value.f2);
    f3.set(fbe_value.f3);
    f4.set(fbe_value.f4);
    f5.set(fbe_value.f5);
    f6.set(fbe_value.f6);
    f7.set(fbe_value.f7);
    f8.set(fbe_value.f8);
    f9.set(fbe_value.f9);
    f10.set(fbe_value.f10);
    f11.set(fbe_value.f11);
    f12.set(fbe_value.f12);
    f13.set(fbe_value.f13);
    f14.set(fbe_value.f14);
    f15.set(fbe_value.f15);
    f16.set(fbe_value.f16);
    f17.set(fbe_value.f17);
    f18.set(fbe_value.f18);
    f19.set(fbe_value.f19);
    f20.set(fbe_value.f20);
    f21.set(fbe_value.f21);
    f22.set(fbe_value.f22);
    f23.set(fbe_value.f23);
    f24.set(fbe_value.f24);
    f25.set(fbe_value.f25);
    f26.set(fbe_value.f26);
    f27.set(fbe_value.f27);
    f28.set(fbe_value.f28);
    f29.set(fbe_value.f29);
    f30.set(fbe_value.f30);
    f31.set(fbe_value.f31);
    f32.set(fbe_value.f32);
    f33.set(fbe_value.f33);
    f34.set(fbe_value.f34);
    f35.set(fbe_value.f35);
    f36.set(fbe_value.f36);
    f37.set(fbe_value.f37);
    f38.set(fbe_value.f38);
    f39.set(fbe_value.f39);
    f40.set(fbe_value.f40);
    f41.set(fbe_value.f41);
    f42.set(fbe_value.f42);
    f43.set(fbe_value.f43);
    f44.set(fbe_value.f44);
}

namespace test {

bool StructSimpleModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t StructSimpleModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t StructSimpleModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t StructSimpleModel::serialize(const ::test::StructSimple& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t StructSimpleModel::deserialize(::test::StructSimple& value) const noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace test

FieldModel<::test::StructOptional>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , parent(buffer, 4 + 4)
    , f100(buffer, parent.fbe_offset() + parent.fbe_body() - 4 - 4)
    , f101(buffer, f100.fbe_offset() + f100.fbe_size())
    , f102(buffer, f101.fbe_offset() + f101.fbe_size())
    , f103(buffer, f102.fbe_offset() + f102.fbe_size())
    , f104(buffer, f103.fbe_offset() + f103.fbe_size())
    , f105(buffer, f104.fbe_offset() + f104.fbe_size())
    , f106(buffer, f105.fbe_offset() + f105.fbe_size())
    , f107(buffer, f106.fbe_offset() + f106.fbe_size())
    , f108(buffer, f107.fbe_offset() + f107.fbe_size())
    , f109(buffer, f108.fbe_offset() + f108.fbe_size())
    , f110(buffer, f109.fbe_offset() + f109.fbe_size())
    , f111(buffer, f110.fbe_offset() + f110.fbe_size())
    , f112(buffer, f111.fbe_offset() + f111.fbe_size())
    , f113(buffer, f112.fbe_offset() + f112.fbe_size())
    , f114(buffer, f113.fbe_offset() + f113.fbe_size())
    , f115(buffer, f114.fbe_offset() + f114.fbe_size())
    , f116(buffer, f115.fbe_offset() + f115.fbe_size())
    , f117(buffer, f116.fbe_offset() + f116.fbe_size())
    , f118(buffer, f117.fbe_offset() + f117.fbe_size())
    , f119(buffer, f118.fbe_offset() + f118.fbe_size())
    , f120(buffer, f119.fbe_offset() + f119.fbe_size())
    , f121(buffer, f120.fbe_offset() + f120.fbe_size())
    , f122(buffer, f121.fbe_offset() + f121.fbe_size())
    , f123(buffer, f122.fbe_offset() + f122.fbe_size())
    , f124(buffer, f123.fbe_offset() + f123.fbe_size())
    , f125(buffer, f124.fbe_offset() + f124.fbe_size())
    , f126(buffer, f125.fbe_offset() + f125.fbe_size())
    , f127(buffer, f126.fbe_offset() + f126.fbe_size())
    , f128(buffer, f127.fbe_offset() + f127.fbe_size())
    , f129(buffer, f128.fbe_offset() + f128.fbe_size())
    , f130(buffer, f129.fbe_offset() + f129.fbe_size())
    , f131(buffer, f130.fbe_offset() + f130.fbe_size())
    , f132(buffer, f131.fbe_offset() + f131.fbe_size())
    , f133(buffer, f132.fbe_offset() + f132.fbe_size())
    , f134(buffer, f133.fbe_offset() + f133.fbe_size())
    , f135(buffer, f134.fbe_offset() + f134.fbe_size())
    , f136(buffer, f135.fbe_offset() + f135.fbe_size())
    , f137(buffer, f136.fbe_offset() + f136.fbe_size())
    , f138(buffer, f137.fbe_offset() + f137.fbe_size())
    , f139(buffer, f138.fbe_offset() + f138.fbe_size())
    , f140(buffer, f139.fbe_offset() + f139.fbe_size())
    , f141(buffer, f140.fbe_offset() + f140.fbe_size())
    , f142(buffer, f141.fbe_offset() + f141.fbe_size())
    , f143(buffer, f142.fbe_offset() + f142.fbe_size())
    , f144(buffer, f143.fbe_offset() + f143.fbe_size())
    , f145(buffer, f144.fbe_offset() + f144.fbe_size())
    , f146(buffer, f145.fbe_offset() + f145.fbe_size())
    , f147(buffer, f146.fbe_offset() + f146.fbe_size())
    , f148(buffer, f147.fbe_offset() + f147.fbe_size())
    , f149(buffer, f148.fbe_offset() + f148.fbe_size())
    , f150(buffer, f149.fbe_offset() + f149.fbe_size())
    , f151(buffer, f150.fbe_offset() + f150.fbe_size())
    , f152(buffer, f151.fbe_offset() + f151.fbe_size())
    , f153(buffer, f152.fbe_offset() + f152.fbe_size())
    , f154(buffer, f153.fbe_offset() + f153.fbe_size())
    , f155(buffer, f154.fbe_offset() + f154.fbe_size())
    , f156(buffer, f155.fbe_offset() + f155.fbe_size())
    , f157(buffer, f156.fbe_offset() + f156.fbe_size())
    , f158(buffer, f157.fbe_offset() + f157.fbe_size())
    , f159(buffer, f158.fbe_offset() + f158.fbe_size())
    , f160(buffer, f159.fbe_offset() + f159.fbe_size())
    , f161(buffer, f160.fbe_offset() + f160.fbe_size())
    , f162(buffer, f161.fbe_offset() + f161.fbe_size())
    , f163(buffer, f162.fbe_offset() + f162.fbe_size())
    , f164(buffer, f163.fbe_offset() + f163.fbe_size())
    , f165(buffer, f164.fbe_offset() + f164.fbe_size())
{}

size_t FieldModel<::test::StructOptional>::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + parent.fbe_body() - 4 - 4
        + f100.fbe_size()
        + f101.fbe_size()
        + f102.fbe_size()
        + f103.fbe_size()
        + f104.fbe_size()
        + f105.fbe_size()
        + f106.fbe_size()
        + f107.fbe_size()
        + f108.fbe_size()
        + f109.fbe_size()
        + f110.fbe_size()
        + f111.fbe_size()
        + f112.fbe_size()
        + f113.fbe_size()
        + f114.fbe_size()
        + f115.fbe_size()
        + f116.fbe_size()
        + f117.fbe_size()
        + f118.fbe_size()
        + f119.fbe_size()
        + f120.fbe_size()
        + f121.fbe_size()
        + f122.fbe_size()
        + f123.fbe_size()
        + f124.fbe_size()
        + f125.fbe_size()
        + f126.fbe_size()
        + f127.fbe_size()
        + f128.fbe_size()
        + f129.fbe_size()
        + f130.fbe_size()
        + f131.fbe_size()
        + f132.fbe_size()
        + f133.fbe_size()
        + f134.fbe_size()
        + f135.fbe_size()
        + f136.fbe_size()
        + f137.fbe_size()
        + f138.fbe_size()
        + f139.fbe_size()
        + f140.fbe_size()
        + f141.fbe_size()
        + f142.fbe_size()
        + f143.fbe_size()
        + f144.fbe_size()
        + f145.fbe_size()
        + f146.fbe_size()
        + f147.fbe_size()
        + f148.fbe_size()
        + f149.fbe_size()
        + f150.fbe_size()
        + f151.fbe_size()
        + f152.fbe_size()
        + f153.fbe_size()
        + f154.fbe_size()
        + f155.fbe_size()
        + f156.fbe_size()
        + f157.fbe_size()
        + f158.fbe_size()
        + f159.fbe_size()
        + f160.fbe_size()
        + f161.fbe_size()
        + f162.fbe_size()
        + f163.fbe_size()
        + f164.fbe_size()
        + f165.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel<::test::StructOptional>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + parent.fbe_extra()
        + f100.fbe_extra()
        + f101.fbe_extra()
        + f102.fbe_extra()
        + f103.fbe_extra()
        + f104.fbe_extra()
        + f105.fbe_extra()
        + f106.fbe_extra()
        + f107.fbe_extra()
        + f108.fbe_extra()
        + f109.fbe_extra()
        + f110.fbe_extra()
        + f111.fbe_extra()
        + f112.fbe_extra()
        + f113.fbe_extra()
        + f114.fbe_extra()
        + f115.fbe_extra()
        + f116.fbe_extra()
        + f117.fbe_extra()
        + f118.fbe_extra()
        + f119.fbe_extra()
        + f120.fbe_extra()
        + f121.fbe_extra()
        + f122.fbe_extra()
        + f123.fbe_extra()
        + f124.fbe_extra()
        + f125.fbe_extra()
        + f126.fbe_extra()
        + f127.fbe_extra()
        + f128.fbe_extra()
        + f129.fbe_extra()
        + f130.fbe_extra()
        + f131.fbe_extra()
        + f132.fbe_extra()
        + f133.fbe_extra()
        + f134.fbe_extra()
        + f135.fbe_extra()
        + f136.fbe_extra()
        + f137.fbe_extra()
        + f138.fbe_extra()
        + f139.fbe_extra()
        + f140.fbe_extra()
        + f141.fbe_extra()
        + f142.fbe_extra()
        + f143.fbe_extra()
        + f144.fbe_extra()
        + f145.fbe_extra()
        + f146.fbe_extra()
        + f147.fbe_extra()
        + f148.fbe_extra()
        + f149.fbe_extra()
        + f150.fbe_extra()
        + f151.fbe_extra()
        + f152.fbe_extra()
        + f153.fbe_extra()
        + f154.fbe_extra()
        + f155.fbe_extra()
        + f156.fbe_extra()
        + f157.fbe_extra()
        + f158.fbe_extra()
        + f159.fbe_extra()
        + f160.fbe_extra()
        + f161.fbe_extra()
        + f162.fbe_extra()
        + f163.fbe_extra()
        + f164.fbe_extra()
        + f165.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::test::StructOptional>::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel<::test::StructOptional>::verify_fields([[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + parent.fbe_body() - 4 - 4) > fbe_struct_size)
        return true;
    if (!parent.verify_fields(fbe_struct_size))
        return false;
    fbe_current_size += parent.fbe_body() - 4 - 4;

    if ((fbe_current_size + f100.fbe_size()) > fbe_struct_size)
        return true;
    if (!f100.verify())
        return false;
    fbe_current_size += f100.fbe_size();

    if ((fbe_current_size + f101.fbe_size()) > fbe_struct_size)
        return true;
    if (!f101.verify())
        return false;
    fbe_current_size += f101.fbe_size();

    if ((fbe_current_size + f102.fbe_size()) > fbe_struct_size)
        return true;
    if (!f102.verify())
        return false;
    fbe_current_size += f102.fbe_size();

    if ((fbe_current_size + f103.fbe_size()) > fbe_struct_size)
        return true;
    if (!f103.verify())
        return false;
    fbe_current_size += f103.fbe_size();

    if ((fbe_current_size + f104.fbe_size()) > fbe_struct_size)
        return true;
    if (!f104.verify())
        return false;
    fbe_current_size += f104.fbe_size();

    if ((fbe_current_size + f105.fbe_size()) > fbe_struct_size)
        return true;
    if (!f105.verify())
        return false;
    fbe_current_size += f105.fbe_size();

    if ((fbe_current_size + f106.fbe_size()) > fbe_struct_size)
        return true;
    if (!f106.verify())
        return false;
    fbe_current_size += f106.fbe_size();

    if ((fbe_current_size + f107.fbe_size()) > fbe_struct_size)
        return true;
    if (!f107.verify())
        return false;
    fbe_current_size += f107.fbe_size();

    if ((fbe_current_size + f108.fbe_size()) > fbe_struct_size)
        return true;
    if (!f108.verify())
        return false;
    fbe_current_size += f108.fbe_size();

    if ((fbe_current_size + f109.fbe_size()) > fbe_struct_size)
        return true;
    if (!f109.verify())
        return false;
    fbe_current_size += f109.fbe_size();

    if ((fbe_current_size + f110.fbe_size()) > fbe_struct_size)
        return true;
    if (!f110.verify())
        return false;
    fbe_current_size += f110.fbe_size();

    if ((fbe_current_size + f111.fbe_size()) > fbe_struct_size)
        return true;
    if (!f111.verify())
        return false;
    fbe_current_size += f111.fbe_size();

    if ((fbe_current_size + f112.fbe_size()) > fbe_struct_size)
        return true;
    if (!f112.verify())
        return false;
    fbe_current_size += f112.fbe_size();

    if ((fbe_current_size + f113.fbe_size()) > fbe_struct_size)
        return true;
    if (!f113.verify())
        return false;
    fbe_current_size += f113.fbe_size();

    if ((fbe_current_size + f114.fbe_size()) > fbe_struct_size)
        return true;
    if (!f114.verify())
        return false;
    fbe_current_size += f114.fbe_size();

    if ((fbe_current_size + f115.fbe_size()) > fbe_struct_size)
        return true;
    if (!f115.verify())
        return false;
    fbe_current_size += f115.fbe_size();

    if ((fbe_current_size + f116.fbe_size()) > fbe_struct_size)
        return true;
    if (!f116.verify())
        return false;
    fbe_current_size += f116.fbe_size();

    if ((fbe_current_size + f117.fbe_size()) > fbe_struct_size)
        return true;
    if (!f117.verify())
        return false;
    fbe_current_size += f117.fbe_size();

    if ((fbe_current_size + f118.fbe_size()) > fbe_struct_size)
        return true;
    if (!f118.verify())
        return false;
    fbe_current_size += f118.fbe_size();

    if ((fbe_current_size + f119.fbe_size()) > fbe_struct_size)
        return true;
    if (!f119.verify())
        return false;
    fbe_current_size += f119.fbe_size();

    if ((fbe_current_size + f120.fbe_size()) > fbe_struct_size)
        return true;
    if (!f120.verify())
        return false;
    fbe_current_size += f120.fbe_size();

    if ((fbe_current_size + f121.fbe_size()) > fbe_struct_size)
        return true;
    if (!f121.verify())
        return false;
    fbe_current_size += f121.fbe_size();

    if ((fbe_current_size + f122.fbe_size()) > fbe_struct_size)
        return true;
    if (!f122.verify())
        return false;
    fbe_current_size += f122.fbe_size();

    if ((fbe_current_size + f123.fbe_size()) > fbe_struct_size)
        return true;
    if (!f123.verify())
        return false;
    fbe_current_size += f123.fbe_size();

    if ((fbe_current_size + f124.fbe_size()) > fbe_struct_size)
        return true;
    if (!f124.verify())
        return false;
    fbe_current_size += f124.fbe_size();

    if ((fbe_current_size + f125.fbe_size()) > fbe_struct_size)
        return true;
    if (!f125.verify())
        return false;
    fbe_current_size += f125.fbe_size();

    if ((fbe_current_size + f126.fbe_size()) > fbe_struct_size)
        return true;
    if (!f126.verify())
        return false;
    fbe_current_size += f126.fbe_size();

    if ((fbe_current_size + f127.fbe_size()) > fbe_struct_size)
        return true;
    if (!f127.verify())
        return false;
    fbe_current_size += f127.fbe_size();

    if ((fbe_current_size + f128.fbe_size()) > fbe_struct_size)
        return true;
    if (!f128.verify())
        return false;
    fbe_current_size += f128.fbe_size();

    if ((fbe_current_size + f129.fbe_size()) > fbe_struct_size)
        return true;
    if (!f129.verify())
        return false;
    fbe_current_size += f129.fbe_size();

    if ((fbe_current_size + f130.fbe_size()) > fbe_struct_size)
        return true;
    if (!f130.verify())
        return false;
    fbe_current_size += f130.fbe_size();

    if ((fbe_current_size + f131.fbe_size()) > fbe_struct_size)
        return true;
    if (!f131.verify())
        return false;
    fbe_current_size += f131.fbe_size();

    if ((fbe_current_size + f132.fbe_size()) > fbe_struct_size)
        return true;
    if (!f132.verify())
        return false;
    fbe_current_size += f132.fbe_size();

    if ((fbe_current_size + f133.fbe_size()) > fbe_struct_size)
        return true;
    if (!f133.verify())
        return false;
    fbe_current_size += f133.fbe_size();

    if ((fbe_current_size + f134.fbe_size()) > fbe_struct_size)
        return true;
    if (!f134.verify())
        return false;
    fbe_current_size += f134.fbe_size();

    if ((fbe_current_size + f135.fbe_size()) > fbe_struct_size)
        return true;
    if (!f135.verify())
        return false;
    fbe_current_size += f135.fbe_size();

    if ((fbe_current_size + f136.fbe_size()) > fbe_struct_size)
        return true;
    if (!f136.verify())
        return false;
    fbe_current_size += f136.fbe_size();

    if ((fbe_current_size + f137.fbe_size()) > fbe_struct_size)
        return true;
    if (!f137.verify())
        return false;
    fbe_current_size += f137.fbe_size();

    if ((fbe_current_size + f138.fbe_size()) > fbe_struct_size)
        return true;
    if (!f138.verify())
        return false;
    fbe_current_size += f138.fbe_size();

    if ((fbe_current_size + f139.fbe_size()) > fbe_struct_size)
        return true;
    if (!f139.verify())
        return false;
    fbe_current_size += f139.fbe_size();

    if ((fbe_current_size + f140.fbe_size()) > fbe_struct_size)
        return true;
    if (!f140.verify())
        return false;
    fbe_current_size += f140.fbe_size();

    if ((fbe_current_size + f141.fbe_size()) > fbe_struct_size)
        return true;
    if (!f141.verify())
        return false;
    fbe_current_size += f141.fbe_size();

    if ((fbe_current_size + f142.fbe_size()) > fbe_struct_size)
        return true;
    if (!f142.verify())
        return false;
    fbe_current_size += f142.fbe_size();

    if ((fbe_current_size + f143.fbe_size()) > fbe_struct_size)
        return true;
    if (!f143.verify())
        return false;
    fbe_current_size += f143.fbe_size();

    if ((fbe_current_size + f144.fbe_size()) > fbe_struct_size)
        return true;
    if (!f144.verify())
        return false;
    fbe_current_size += f144.fbe_size();

    if ((fbe_current_size + f145.fbe_size()) > fbe_struct_size)
        return true;
    if (!f145.verify())
        return false;
    fbe_current_size += f145.fbe_size();

    if ((fbe_current_size + f146.fbe_size()) > fbe_struct_size)
        return true;
    if (!f146.verify())
        return false;
    fbe_current_size += f146.fbe_size();

    if ((fbe_current_size + f147.fbe_size()) > fbe_struct_size)
        return true;
    if (!f147.verify())
        return false;
    fbe_current_size += f147.fbe_size();

    if ((fbe_current_size + f148.fbe_size()) > fbe_struct_size)
        return true;
    if (!f148.verify())
        return false;
    fbe_current_size += f148.fbe_size();

    if ((fbe_current_size + f149.fbe_size()) > fbe_struct_size)
        return true;
    if (!f149.verify())
        return false;
    fbe_current_size += f149.fbe_size();

    if ((fbe_current_size + f150.fbe_size()) > fbe_struct_size)
        return true;
    if (!f150.verify())
        return false;
    fbe_current_size += f150.fbe_size();

    if ((fbe_current_size + f151.fbe_size()) > fbe_struct_size)
        return true;
    if (!f151.verify())
        return false;
    fbe_current_size += f151.fbe_size();

    if ((fbe_current_size + f152.fbe_size()) > fbe_struct_size)
        return true;
    if (!f152.verify())
        return false;
    fbe_current_size += f152.fbe_size();

    if ((fbe_current_size + f153.fbe_size()) > fbe_struct_size)
        return true;
    if (!f153.verify())
        return false;
    fbe_current_size += f153.fbe_size();

    if ((fbe_current_size + f154.fbe_size()) > fbe_struct_size)
        return true;
    if (!f154.verify())
        return false;
    fbe_current_size += f154.fbe_size();

    if ((fbe_current_size + f155.fbe_size()) > fbe_struct_size)
        return true;
    if (!f155.verify())
        return false;
    fbe_current_size += f155.fbe_size();

    if ((fbe_current_size + f156.fbe_size()) > fbe_struct_size)
        return true;
    if (!f156.verify())
        return false;
    fbe_current_size += f156.fbe_size();

    if ((fbe_current_size + f157.fbe_size()) > fbe_struct_size)
        return true;
    if (!f157.verify())
        return false;
    fbe_current_size += f157.fbe_size();

    if ((fbe_current_size + f158.fbe_size()) > fbe_struct_size)
        return true;
    if (!f158.verify())
        return false;
    fbe_current_size += f158.fbe_size();

    if ((fbe_current_size + f159.fbe_size()) > fbe_struct_size)
        return true;
    if (!f159.verify())
        return false;
    fbe_current_size += f159.fbe_size();

    if ((fbe_current_size + f160.fbe_size()) > fbe_struct_size)
        return true;
    if (!f160.verify())
        return false;
    fbe_current_size += f160.fbe_size();

    if ((fbe_current_size + f161.fbe_size()) > fbe_struct_size)
        return true;
    if (!f161.verify())
        return false;
    fbe_current_size += f161.fbe_size();

    if ((fbe_current_size + f162.fbe_size()) > fbe_struct_size)
        return true;
    if (!f162.verify())
        return false;
    fbe_current_size += f162.fbe_size();

    if ((fbe_current_size + f163.fbe_size()) > fbe_struct_size)
        return true;
    if (!f163.verify())
        return false;
    fbe_current_size += f163.fbe_size();

    if ((fbe_current_size + f164.fbe_size()) > fbe_struct_size)
        return true;
    if (!f164.verify())
        return false;
    fbe_current_size += f164.fbe_size();

    if ((fbe_current_size + f165.fbe_size()) > fbe_struct_size)
        return true;
    if (!f165.verify())
        return false;
    fbe_current_size += f165.fbe_size();

    return true;
}

size_t FieldModel<::test::StructOptional>::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructOptional>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructOptional>::get(::test::StructOptional& fbe_value) const noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel<::test::StructOptional>::get_fields([[maybe_unused]] ::test::StructOptional& fbe_value, [[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + parent.fbe_body() - 4 - 4) <= fbe_struct_size)
        parent.get_fields(fbe_value, fbe_struct_size);
    fbe_current_size += parent.fbe_body() - 4 - 4;

    if ((fbe_current_size + f100.fbe_size()) <= fbe_struct_size)
        f100.get(fbe_value.f100);
    else
        fbe_value.f100 = std::nullopt;
    fbe_current_size += f100.fbe_size();

    if ((fbe_current_size + f101.fbe_size()) <= fbe_struct_size)
        f101.get(fbe_value.f101, true);
    else
        fbe_value.f101 = true;
    fbe_current_size += f101.fbe_size();

    if ((fbe_current_size + f102.fbe_size()) <= fbe_struct_size)
        f102.get(fbe_value.f102, std::nullopt);
    else
        fbe_value.f102 = std::nullopt;
    fbe_current_size += f102.fbe_size();

    if ((fbe_current_size + f103.fbe_size()) <= fbe_struct_size)
        f103.get(fbe_value.f103);
    else
        fbe_value.f103 = std::nullopt;
    fbe_current_size += f103.fbe_size();

    if ((fbe_current_size + f104.fbe_size()) <= fbe_struct_size)
        f104.get(fbe_value.f104, (uint8_t)255u);
    else
        fbe_value.f104 = (uint8_t)255u;
    fbe_current_size += f104.fbe_size();

    if ((fbe_current_size + f105.fbe_size()) <= fbe_struct_size)
        f105.get(fbe_value.f105, std::nullopt);
    else
        fbe_value.f105 = std::nullopt;
    fbe_current_size += f105.fbe_size();

    if ((fbe_current_size + f106.fbe_size()) <= fbe_struct_size)
        f106.get(fbe_value.f106);
    else
        fbe_value.f106 = std::nullopt;
    fbe_current_size += f106.fbe_size();

    if ((fbe_current_size + f107.fbe_size()) <= fbe_struct_size)
        f107.get(fbe_value.f107, (char)'!');
    else
        fbe_value.f107 = (char)'!';
    fbe_current_size += f107.fbe_size();

    if ((fbe_current_size + f108.fbe_size()) <= fbe_struct_size)
        f108.get(fbe_value.f108, std::nullopt);
    else
        fbe_value.f108 = std::nullopt;
    fbe_current_size += f108.fbe_size();

    if ((fbe_current_size + f109.fbe_size()) <= fbe_struct_size)
        f109.get(fbe_value.f109);
    else
        fbe_value.f109 = std::nullopt;
    fbe_current_size += f109.fbe_size();

    if ((fbe_current_size + f110.fbe_size()) <= fbe_struct_size)
        f110.get(fbe_value.f110, (wchar_t)0x0444);
    else
        fbe_value.f110 = (wchar_t)0x0444;
    fbe_current_size += f110.fbe_size();

    if ((fbe_current_size + f111.fbe_size()) <= fbe_struct_size)
        f111.get(fbe_value.f111, std::nullopt);
    else
        fbe_value.f111 = std::nullopt;
    fbe_current_size += f111.fbe_size();

    if ((fbe_current_size + f112.fbe_size()) <= fbe_struct_size)
        f112.get(fbe_value.f112);
    else
        fbe_value.f112 = std::nullopt;
    fbe_current_size += f112.fbe_size();

    if ((fbe_current_size + f113.fbe_size()) <= fbe_struct_size)
        f113.get(fbe_value.f113, (int8_t)127);
    else
        fbe_value.f113 = (int8_t)127;
    fbe_current_size += f113.fbe_size();

    if ((fbe_current_size + f114.fbe_size()) <= fbe_struct_size)
        f114.get(fbe_value.f114, std::nullopt);
    else
        fbe_value.f114 = std::nullopt;
    fbe_current_size += f114.fbe_size();

    if ((fbe_current_size + f115.fbe_size()) <= fbe_struct_size)
        f115.get(fbe_value.f115);
    else
        fbe_value.f115 = std::nullopt;
    fbe_current_size += f115.fbe_size();

    if ((fbe_current_size + f116.fbe_size()) <= fbe_struct_size)
        f116.get(fbe_value.f116, (uint8_t)255u);
    else
        fbe_value.f116 = (uint8_t)255u;
    fbe_current_size += f116.fbe_size();

    if ((fbe_current_size + f117.fbe_size()) <= fbe_struct_size)
        f117.get(fbe_value.f117, std::nullopt);
    else
        fbe_value.f117 = std::nullopt;
    fbe_current_size += f117.fbe_size();

    if ((fbe_current_size + f118.fbe_size()) <= fbe_struct_size)
        f118.get(fbe_value.f118);
    else
        fbe_value.f118 = std::nullopt;
    fbe_current_size += f118.fbe_size();

    if ((fbe_current_size + f119.fbe_size()) <= fbe_struct_size)
        f119.get(fbe_value.f119, (int16_t)32767);
    else
        fbe_value.f119 = (int16_t)32767;
    fbe_current_size += f119.fbe_size();

    if ((fbe_current_size + f120.fbe_size()) <= fbe_struct_size)
        f120.get(fbe_value.f120, std::nullopt);
    else
        fbe_value.f120 = std::nullopt;
    fbe_current_size += f120.fbe_size();

    if ((fbe_current_size + f121.fbe_size()) <= fbe_struct_size)
        f121.get(fbe_value.f121);
    else
        fbe_value.f121 = std::nullopt;
    fbe_current_size += f121.fbe_size();

    if ((fbe_current_size + f122.fbe_size()) <= fbe_struct_size)
        f122.get(fbe_value.f122, (uint16_t)65535u);
    else
        fbe_value.f122 = (uint16_t)65535u;
    fbe_current_size += f122.fbe_size();

    if ((fbe_current_size + f123.fbe_size()) <= fbe_struct_size)
        f123.get(fbe_value.f123, std::nullopt);
    else
        fbe_value.f123 = std::nullopt;
    fbe_current_size += f123.fbe_size();

    if ((fbe_current_size + f124.fbe_size()) <= fbe_struct_size)
        f124.get(fbe_value.f124);
    else
        fbe_value.f124 = std::nullopt;
    fbe_current_size += f124.fbe_size();

    if ((fbe_current_size + f125.fbe_size()) <= fbe_struct_size)
        f125.get(fbe_value.f125, (int32_t)2147483647ll);
    else
        fbe_value.f125 = (int32_t)2147483647ll;
    fbe_current_size += f125.fbe_size();

    if ((fbe_current_size + f126.fbe_size()) <= fbe_struct_size)
        f126.get(fbe_value.f126, std::nullopt);
    else
        fbe_value.f126 = std::nullopt;
    fbe_current_size += f126.fbe_size();

    if ((fbe_current_size + f127.fbe_size()) <= fbe_struct_size)
        f127.get(fbe_value.f127);
    else
        fbe_value.f127 = std::nullopt;
    fbe_current_size += f127.fbe_size();

    if ((fbe_current_size + f128.fbe_size()) <= fbe_struct_size)
        f128.get(fbe_value.f128, (uint32_t)4294967295ull);
    else
        fbe_value.f128 = (uint32_t)4294967295ull;
    fbe_current_size += f128.fbe_size();

    if ((fbe_current_size + f129.fbe_size()) <= fbe_struct_size)
        f129.get(fbe_value.f129, std::nullopt);
    else
        fbe_value.f129 = std::nullopt;
    fbe_current_size += f129.fbe_size();

    if ((fbe_current_size + f130.fbe_size()) <= fbe_struct_size)
        f130.get(fbe_value.f130);
    else
        fbe_value.f130 = std::nullopt;
    fbe_current_size += f130.fbe_size();

    if ((fbe_current_size + f131.fbe_size()) <= fbe_struct_size)
        f131.get(fbe_value.f131, (int64_t)9223372036854775807ll);
    else
        fbe_value.f131 = (int64_t)9223372036854775807ll;
    fbe_current_size += f131.fbe_size();

    if ((fbe_current_size + f132.fbe_size()) <= fbe_struct_size)
        f132.get(fbe_value.f132, std::nullopt);
    else
        fbe_value.f132 = std::nullopt;
    fbe_current_size += f132.fbe_size();

    if ((fbe_current_size + f133.fbe_size()) <= fbe_struct_size)
        f133.get(fbe_value.f133);
    else
        fbe_value.f133 = std::nullopt;
    fbe_current_size += f133.fbe_size();

    if ((fbe_current_size + f134.fbe_size()) <= fbe_struct_size)
        f134.get(fbe_value.f134, (uint64_t)18446744073709551615ull);
    else
        fbe_value.f134 = (uint64_t)18446744073709551615ull;
    fbe_current_size += f134.fbe_size();

    if ((fbe_current_size + f135.fbe_size()) <= fbe_struct_size)
        f135.get(fbe_value.f135, std::nullopt);
    else
        fbe_value.f135 = std::nullopt;
    fbe_current_size += f135.fbe_size();

    if ((fbe_current_size + f136.fbe_size()) <= fbe_struct_size)
        f136.get(fbe_value.f136);
    else
        fbe_value.f136 = std::nullopt;
    fbe_current_size += f136.fbe_size();

    if ((fbe_current_size + f137.fbe_size()) <= fbe_struct_size)
        f137.get(fbe_value.f137, (float)123.456f);
    else
        fbe_value.f137 = (float)123.456f;
    fbe_current_size += f137.fbe_size();

    if ((fbe_current_size + f138.fbe_size()) <= fbe_struct_size)
        f138.get(fbe_value.f138, std::nullopt);
    else
        fbe_value.f138 = std::nullopt;
    fbe_current_size += f138.fbe_size();

    if ((fbe_current_size + f139.fbe_size()) <= fbe_struct_size)
        f139.get(fbe_value.f139);
    else
        fbe_value.f139 = std::nullopt;
    fbe_current_size += f139.fbe_size();

    if ((fbe_current_size + f140.fbe_size()) <= fbe_struct_size)
        f140.get(fbe_value.f140, (double)-123.456e+123);
    else
        fbe_value.f140 = (double)-123.456e+123;
    fbe_current_size += f140.fbe_size();

    if ((fbe_current_size + f141.fbe_size()) <= fbe_struct_size)
        f141.get(fbe_value.f141, std::nullopt);
    else
        fbe_value.f141 = std::nullopt;
    fbe_current_size += f141.fbe_size();

    if ((fbe_current_size + f142.fbe_size()) <= fbe_struct_size)
        f142.get(fbe_value.f142);
    else
        fbe_value.f142 = std::nullopt;
    fbe_current_size += f142.fbe_size();

    if ((fbe_current_size + f143.fbe_size()) <= fbe_struct_size)
        f143.get(fbe_value.f143, FBE::decimal_t(123456.123456));
    else
        fbe_value.f143 = FBE::decimal_t(123456.123456);
    fbe_current_size += f143.fbe_size();

    if ((fbe_current_size + f144.fbe_size()) <= fbe_struct_size)
        f144.get(fbe_value.f144, std::nullopt);
    else
        fbe_value.f144 = std::nullopt;
    fbe_current_size += f144.fbe_size();

    if ((fbe_current_size + f145.fbe_size()) <= fbe_struct_size)
        f145.get(fbe_value.f145);
    else
        fbe_value.f145 = std::nullopt;
    fbe_current_size += f145.fbe_size();

    if ((fbe_current_size + f146.fbe_size()) <= fbe_struct_size)
        f146.get(fbe_value.f146, "Initial string!");
    else
        fbe_value.f146 = "Initial string!";
    fbe_current_size += f146.fbe_size();

    if ((fbe_current_size + f147.fbe_size()) <= fbe_struct_size)
        f147.get(fbe_value.f147, std::nullopt);
    else
        fbe_value.f147 = std::nullopt;
    fbe_current_size += f147.fbe_size();

    if ((fbe_current_size + f148.fbe_size()) <= fbe_struct_size)
        f148.get(fbe_value.f148);
    else
        fbe_value.f148 = std::nullopt;
    fbe_current_size += f148.fbe_size();

    if ((fbe_current_size + f149.fbe_size()) <= fbe_struct_size)
        f149.get(fbe_value.f149, FBE::utc());
    else
        fbe_value.f149 = FBE::utc();
    fbe_current_size += f149.fbe_size();

    if ((fbe_current_size + f150.fbe_size()) <= fbe_struct_size)
        f150.get(fbe_value.f150, std::nullopt);
    else
        fbe_value.f150 = std::nullopt;
    fbe_current_size += f150.fbe_size();

    if ((fbe_current_size + f151.fbe_size()) <= fbe_struct_size)
        f151.get(fbe_value.f151);
    else
        fbe_value.f151 = std::nullopt;
    fbe_current_size += f151.fbe_size();

    if ((fbe_current_size + f152.fbe_size()) <= fbe_struct_size)
        f152.get(fbe_value.f152, FBE::uuid_t("123e4567-e89b-12d3-a456-426655440000"));
    else
        fbe_value.f152 = FBE::uuid_t("123e4567-e89b-12d3-a456-426655440000");
    fbe_current_size += f152.fbe_size();

    if ((fbe_current_size + f153.fbe_size()) <= fbe_struct_size)
        f153.get(fbe_value.f153, std::nullopt);
    else
        fbe_value.f153 = std::nullopt;
    fbe_current_size += f153.fbe_size();

    if ((fbe_current_size + f154.fbe_size()) <= fbe_struct_size)
        f154.get(fbe_value.f154);
    else
        fbe_value.f154 = std::nullopt;
    fbe_current_size += f154.fbe_size();

    if ((fbe_current_size + f155.fbe_size()) <= fbe_struct_size)
        f155.get(fbe_value.f155, std::nullopt);
    else
        fbe_value.f155 = std::nullopt;
    fbe_current_size += f155.fbe_size();

    if ((fbe_current_size + f156.fbe_size()) <= fbe_struct_size)
        f156.get(fbe_value.f156);
    else
        fbe_value.f156 = std::nullopt;
    fbe_current_size += f156.fbe_size();

    if ((fbe_current_size + f157.fbe_size()) <= fbe_struct_size)
        f157.get(fbe_value.f157, std::nullopt);
    else
        fbe_value.f157 = std::nullopt;
    fbe_current_size += f157.fbe_size();

    if ((fbe_current_size + f158.fbe_size()) <= fbe_struct_size)
        f158.get(fbe_value.f158);
    else
        fbe_value.f158 = std::nullopt;
    fbe_current_size += f158.fbe_size();

    if ((fbe_current_size + f159.fbe_size()) <= fbe_struct_size)
        f159.get(fbe_value.f159, std::nullopt);
    else
        fbe_value.f159 = std::nullopt;
    fbe_current_size += f159.fbe_size();

    if ((fbe_current_size + f160.fbe_size()) <= fbe_struct_size)
        f160.get(fbe_value.f160);
    else
        fbe_value.f160 = std::nullopt;
    fbe_current_size += f160.fbe_size();

    if ((fbe_current_size + f161.fbe_size()) <= fbe_struct_size)
        f161.get(fbe_value.f161, std::nullopt);
    else
        fbe_value.f161 = std::nullopt;
    fbe_current_size += f161.fbe_size();

    if ((fbe_current_size + f162.fbe_size()) <= fbe_struct_size)
        f162.get(fbe_value.f162);
    else
        fbe_value.f162 = std::nullopt;
    fbe_current_size += f162.fbe_size();

    if ((fbe_current_size + f163.fbe_size()) <= fbe_struct_size)
        f163.get(fbe_value.f163, std::nullopt);
    else
        fbe_value.f163 = std::nullopt;
    fbe_current_size += f163.fbe_size();

    if ((fbe_current_size + f164.fbe_size()) <= fbe_struct_size)
        f164.get(fbe_value.f164);
    else
        fbe_value.f164 = std::nullopt;
    fbe_current_size += f164.fbe_size();

    if ((fbe_current_size + f165.fbe_size()) <= fbe_struct_size)
        f165.get(fbe_value.f165, std::nullopt);
    else
        fbe_value.f165 = std::nullopt;
    fbe_current_size += f165.fbe_size();
}

size_t FieldModel<::test::StructOptional>::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, (uint32_t)fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructOptional>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructOptional>::set(const ::test::StructOptional& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel<::test::StructOptional>::set_fields([[maybe_unused]] const ::test::StructOptional& fbe_value) noexcept
{
    parent.set_fields(fbe_value);
    f100.set(fbe_value.f100);
    f101.set(fbe_value.f101);
    f102.set(fbe_value.f102);
    f103.set(fbe_value.f103);
    f104.set(fbe_value.f104);
    f105.set(fbe_value.f105);
    f106.set(fbe_value.f106);
    f107.set(fbe_value.f107);
    f108.set(fbe_value.f108);
    f109.set(fbe_value.f109);
    f110.set(fbe_value.f110);
    f111.set(fbe_value.f111);
    f112.set(fbe_value.f112);
    f113.set(fbe_value.f113);
    f114.set(fbe_value.f114);
    f115.set(fbe_value.f115);
    f116.set(fbe_value.f116);
    f117.set(fbe_value.f117);
    f118.set(fbe_value.f118);
    f119.set(fbe_value.f119);
    f120.set(fbe_value.f120);
    f121.set(fbe_value.f121);
    f122.set(fbe_value.f122);
    f123.set(fbe_value.f123);
    f124.set(fbe_value.f124);
    f125.set(fbe_value.f125);
    f126.set(fbe_value.f126);
    f127.set(fbe_value.f127);
    f128.set(fbe_value.f128);
    f129.set(fbe_value.f129);
    f130.set(fbe_value.f130);
    f131.set(fbe_value.f131);
    f132.set(fbe_value.f132);
    f133.set(fbe_value.f133);
    f134.set(fbe_value.f134);
    f135.set(fbe_value.f135);
    f136.set(fbe_value.f136);
    f137.set(fbe_value.f137);
    f138.set(fbe_value.f138);
    f139.set(fbe_value.f139);
    f140.set(fbe_value.f140);
    f141.set(fbe_value.f141);
    f142.set(fbe_value.f142);
    f143.set(fbe_value.f143);
    f144.set(fbe_value.f144);
    f145.set(fbe_value.f145);
    f146.set(fbe_value.f146);
    f147.set(fbe_value.f147);
    f148.set(fbe_value.f148);
    f149.set(fbe_value.f149);
    f150.set(fbe_value.f150);
    f151.set(fbe_value.f151);
    f152.set(fbe_value.f152);
    f153.set(fbe_value.f153);
    f154.set(fbe_value.f154);
    f155.set(fbe_value.f155);
    f156.set(fbe_value.f156);
    f157.set(fbe_value.f157);
    f158.set(fbe_value.f158);
    f159.set(fbe_value.f159);
    f160.set(fbe_value.f160);
    f161.set(fbe_value.f161);
    f162.set(fbe_value.f162);
    f163.set(fbe_value.f163);
    f164.set(fbe_value.f164);
    f165.set(fbe_value.f165);
}

namespace test {

bool StructOptionalModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t StructOptionalModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t StructOptionalModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t StructOptionalModel::serialize(const ::test::StructOptional& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t StructOptionalModel::deserialize(::test::StructOptional& value) const noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace test

FieldModel<::test::StructNested>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , parent(buffer, 4 + 4)
    , f1000(buffer, parent.fbe_offset() + parent.fbe_body() - 4 - 4)
    , f1001(buffer, f1000.fbe_offset() + f1000.fbe_size())
    , f1002(buffer, f1001.fbe_offset() + f1001.fbe_size())
    , f1003(buffer, f1002.fbe_offset() + f1002.fbe_size())
    , f1004(buffer, f1003.fbe_offset() + f1003.fbe_size())
    , f1005(buffer, f1004.fbe_offset() + f1004.fbe_size())
    , f1006(buffer, f1005.fbe_offset() + f1005.fbe_size())
    , f1007(buffer, f1006.fbe_offset() + f1006.fbe_size())
    , f1008(buffer, f1007.fbe_offset() + f1007.fbe_size())
    , f1009(buffer, f1008.fbe_offset() + f1008.fbe_size())
    , f1010(buffer, f1009.fbe_offset() + f1009.fbe_size())
    , f1011(buffer, f1010.fbe_offset() + f1010.fbe_size())
{}

size_t FieldModel<::test::StructNested>::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + parent.fbe_body() - 4 - 4
        + f1000.fbe_size()
        + f1001.fbe_size()
        + f1002.fbe_size()
        + f1003.fbe_size()
        + f1004.fbe_size()
        + f1005.fbe_size()
        + f1006.fbe_size()
        + f1007.fbe_size()
        + f1008.fbe_size()
        + f1009.fbe_size()
        + f1010.fbe_size()
        + f1011.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel<::test::StructNested>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + parent.fbe_extra()
        + f1000.fbe_extra()
        + f1001.fbe_extra()
        + f1002.fbe_extra()
        + f1003.fbe_extra()
        + f1004.fbe_extra()
        + f1005.fbe_extra()
        + f1006.fbe_extra()
        + f1007.fbe_extra()
        + f1008.fbe_extra()
        + f1009.fbe_extra()
        + f1010.fbe_extra()
        + f1011.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::test::StructNested>::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel<::test::StructNested>::verify_fields([[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + parent.fbe_body() - 4 - 4) > fbe_struct_size)
        return true;
    if (!parent.verify_fields(fbe_struct_size))
        return false;
    fbe_current_size += parent.fbe_body() - 4 - 4;

    if ((fbe_current_size + f1000.fbe_size()) > fbe_struct_size)
        return true;
    if (!f1000.verify())
        return false;
    fbe_current_size += f1000.fbe_size();

    if ((fbe_current_size + f1001.fbe_size()) > fbe_struct_size)
        return true;
    if (!f1001.verify())
        return false;
    fbe_current_size += f1001.fbe_size();

    if ((fbe_current_size + f1002.fbe_size()) > fbe_struct_size)
        return true;
    if (!f1002.verify())
        return false;
    fbe_current_size += f1002.fbe_size();

    if ((fbe_current_size + f1003.fbe_size()) > fbe_struct_size)
        return true;
    if (!f1003.verify())
        return false;
    fbe_current_size += f1003.fbe_size();

    if ((fbe_current_size + f1004.fbe_size()) > fbe_struct_size)
        return true;
    if (!f1004.verify())
        return false;
    fbe_current_size += f1004.fbe_size();

    if ((fbe_current_size + f1005.fbe_size()) > fbe_struct_size)
        return true;
    if (!f1005.verify())
        return false;
    fbe_current_size += f1005.fbe_size();

    if ((fbe_current_size + f1006.fbe_size()) > fbe_struct_size)
        return true;
    if (!f1006.verify())
        return false;
    fbe_current_size += f1006.fbe_size();

    if ((fbe_current_size + f1007.fbe_size()) > fbe_struct_size)
        return true;
    if (!f1007.verify())
        return false;
    fbe_current_size += f1007.fbe_size();

    if ((fbe_current_size + f1008.fbe_size()) > fbe_struct_size)
        return true;
    if (!f1008.verify())
        return false;
    fbe_current_size += f1008.fbe_size();

    if ((fbe_current_size + f1009.fbe_size()) > fbe_struct_size)
        return true;
    if (!f1009.verify())
        return false;
    fbe_current_size += f1009.fbe_size();

    if ((fbe_current_size + f1010.fbe_size()) > fbe_struct_size)
        return true;
    if (!f1010.verify())
        return false;
    fbe_current_size += f1010.fbe_size();

    if ((fbe_current_size + f1011.fbe_size()) > fbe_struct_size)
        return true;
    if (!f1011.verify())
        return false;
    fbe_current_size += f1011.fbe_size();

    return true;
}

size_t FieldModel<::test::StructNested>::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructNested>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructNested>::get(::test::StructNested& fbe_value) const noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel<::test::StructNested>::get_fields([[maybe_unused]] ::test::StructNested& fbe_value, [[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + parent.fbe_body() - 4 - 4) <= fbe_struct_size)
        parent.get_fields(fbe_value, fbe_struct_size);
    fbe_current_size += parent.fbe_body() - 4 - 4;

    if ((fbe_current_size + f1000.fbe_size()) <= fbe_struct_size)
        f1000.get(fbe_value.f1000);
    else
        fbe_value.f1000 = ::test::EnumSimple();
    fbe_current_size += f1000.fbe_size();

    if ((fbe_current_size + f1001.fbe_size()) <= fbe_struct_size)
        f1001.get(fbe_value.f1001);
    else
        fbe_value.f1001 = std::nullopt;
    fbe_current_size += f1001.fbe_size();

    if ((fbe_current_size + f1002.fbe_size()) <= fbe_struct_size)
        f1002.get(fbe_value.f1002, EnumTyped::ENUM_VALUE_2);
    else
        fbe_value.f1002 = EnumTyped::ENUM_VALUE_2;
    fbe_current_size += f1002.fbe_size();

    if ((fbe_current_size + f1003.fbe_size()) <= fbe_struct_size)
        f1003.get(fbe_value.f1003, std::nullopt);
    else
        fbe_value.f1003 = std::nullopt;
    fbe_current_size += f1003.fbe_size();

    if ((fbe_current_size + f1004.fbe_size()) <= fbe_struct_size)
        f1004.get(fbe_value.f1004);
    else
        fbe_value.f1004 = ::test::FlagsSimple();
    fbe_current_size += f1004.fbe_size();

    if ((fbe_current_size + f1005.fbe_size()) <= fbe_struct_size)
        f1005.get(fbe_value.f1005);
    else
        fbe_value.f1005 = std::nullopt;
    fbe_current_size += f1005.fbe_size();

    if ((fbe_current_size + f1006.fbe_size()) <= fbe_struct_size)
        f1006.get(fbe_value.f1006, FlagsTyped::FLAG_VALUE_2  |  FlagsTyped::FLAG_VALUE_4  |  FlagsTyped::FLAG_VALUE_6);
    else
        fbe_value.f1006 = FlagsTyped::FLAG_VALUE_2  |  FlagsTyped::FLAG_VALUE_4  |  FlagsTyped::FLAG_VALUE_6;
    fbe_current_size += f1006.fbe_size();

    if ((fbe_current_size + f1007.fbe_size()) <= fbe_struct_size)
        f1007.get(fbe_value.f1007, std::nullopt);
    else
        fbe_value.f1007 = std::nullopt;
    fbe_current_size += f1007.fbe_size();

    if ((fbe_current_size + f1008.fbe_size()) <= fbe_struct_size)
        f1008.get(fbe_value.f1008);
    else
        fbe_value.f1008 = ::test::StructSimple();
    fbe_current_size += f1008.fbe_size();

    if ((fbe_current_size + f1009.fbe_size()) <= fbe_struct_size)
        f1009.get(fbe_value.f1009);
    else
        fbe_value.f1009 = std::nullopt;
    fbe_current_size += f1009.fbe_size();

    if ((fbe_current_size + f1010.fbe_size()) <= fbe_struct_size)
        f1010.get(fbe_value.f1010);
    else
        fbe_value.f1010 = ::test::StructOptional();
    fbe_current_size += f1010.fbe_size();

    if ((fbe_current_size + f1011.fbe_size()) <= fbe_struct_size)
        f1011.get(fbe_value.f1011, std::nullopt);
    else
        fbe_value.f1011 = std::nullopt;
    fbe_current_size += f1011.fbe_size();
}

size_t FieldModel<::test::StructNested>::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, (uint32_t)fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructNested>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructNested>::set(const ::test::StructNested& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel<::test::StructNested>::set_fields([[maybe_unused]] const ::test::StructNested& fbe_value) noexcept
{
    parent.set_fields(fbe_value);
    f1000.set(fbe_value.f1000);
    f1001.set(fbe_value.f1001);
    f1002.set(fbe_value.f1002);
    f1003.set(fbe_value.f1003);
    f1004.set(fbe_value.f1004);
    f1005.set(fbe_value.f1005);
    f1006.set(fbe_value.f1006);
    f1007.set(fbe_value.f1007);
    f1008.set(fbe_value.f1008);
    f1009.set(fbe_value.f1009);
    f1010.set(fbe_value.f1010);
    f1011.set(fbe_value.f1011);
}

namespace test {

bool StructNestedModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t StructNestedModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t StructNestedModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t StructNestedModel::serialize(const ::test::StructNested& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t StructNestedModel::deserialize(::test::StructNested& value) const noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace test

FieldModel<::test::StructBytes>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , f1(buffer, 4 + 4)
    , f2(buffer, f1.fbe_offset() + f1.fbe_size())
    , f3(buffer, f2.fbe_offset() + f2.fbe_size())
{}

size_t FieldModel<::test::StructBytes>::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + f1.fbe_size()
        + f2.fbe_size()
        + f3.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel<::test::StructBytes>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + f1.fbe_extra()
        + f2.fbe_extra()
        + f3.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::test::StructBytes>::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel<::test::StructBytes>::verify_fields([[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
        return true;
    if (!f1.verify())
        return false;
    fbe_current_size += f1.fbe_size();

    if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
        return true;
    if (!f2.verify())
        return false;
    fbe_current_size += f2.fbe_size();

    if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
        return true;
    if (!f3.verify())
        return false;
    fbe_current_size += f3.fbe_size();

    return true;
}

size_t FieldModel<::test::StructBytes>::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructBytes>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructBytes>::get(::test::StructBytes& fbe_value) const noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel<::test::StructBytes>::get_fields([[maybe_unused]] ::test::StructBytes& fbe_value, [[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
        f1.get(fbe_value.f1);
    else
        fbe_value.f1.clear();
    fbe_current_size += f1.fbe_size();

    if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
        f2.get(fbe_value.f2);
    else
        fbe_value.f2 = std::nullopt;
    fbe_current_size += f2.fbe_size();

    if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
        f3.get(fbe_value.f3, std::nullopt);
    else
        fbe_value.f3 = std::nullopt;
    fbe_current_size += f3.fbe_size();
}

size_t FieldModel<::test::StructBytes>::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, (uint32_t)fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructBytes>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructBytes>::set(const ::test::StructBytes& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel<::test::StructBytes>::set_fields([[maybe_unused]] const ::test::StructBytes& fbe_value) noexcept
{
    f1.set(fbe_value.f1);
    f2.set(fbe_value.f2);
    f3.set(fbe_value.f3);
}

namespace test {

bool StructBytesModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t StructBytesModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t StructBytesModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t StructBytesModel::serialize(const ::test::StructBytes& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t StructBytesModel::deserialize(::test::StructBytes& value) const noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace test

FieldModel<::test::StructArray>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , f1(buffer, 4 + 4)
    , f2(buffer, f1.fbe_offset() + f1.fbe_size())
    , f3(buffer, f2.fbe_offset() + f2.fbe_size())
    , f4(buffer, f3.fbe_offset() + f3.fbe_size())
    , f5(buffer, f4.fbe_offset() + f4.fbe_size())
    , f6(buffer, f5.fbe_offset() + f5.fbe_size())
    , f7(buffer, f6.fbe_offset() + f6.fbe_size())
    , f8(buffer, f7.fbe_offset() + f7.fbe_size())
    , f9(buffer, f8.fbe_offset() + f8.fbe_size())
    , f10(buffer, f9.fbe_offset() + f9.fbe_size())
{}

size_t FieldModel<::test::StructArray>::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + f1.fbe_size()
        + f2.fbe_size()
        + f3.fbe_size()
        + f4.fbe_size()
        + f5.fbe_size()
        + f6.fbe_size()
        + f7.fbe_size()
        + f8.fbe_size()
        + f9.fbe_size()
        + f10.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel<::test::StructArray>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + f1.fbe_extra()
        + f2.fbe_extra()
        + f3.fbe_extra()
        + f4.fbe_extra()
        + f5.fbe_extra()
        + f6.fbe_extra()
        + f7.fbe_extra()
        + f8.fbe_extra()
        + f9.fbe_extra()
        + f10.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::test::StructArray>::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel<::test::StructArray>::verify_fields([[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
        return true;
    if (!f1.verify())
        return false;
    fbe_current_size += f1.fbe_size();

    if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
        return true;
    if (!f2.verify())
        return false;
    fbe_current_size += f2.fbe_size();

    if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
        return true;
    if (!f3.verify())
        return false;
    fbe_current_size += f3.fbe_size();

    if ((fbe_current_size + f4.fbe_size()) > fbe_struct_size)
        return true;
    if (!f4.verify())
        return false;
    fbe_current_size += f4.fbe_size();

    if ((fbe_current_size + f5.fbe_size()) > fbe_struct_size)
        return true;
    if (!f5.verify())
        return false;
    fbe_current_size += f5.fbe_size();

    if ((fbe_current_size + f6.fbe_size()) > fbe_struct_size)
        return true;
    if (!f6.verify())
        return false;
    fbe_current_size += f6.fbe_size();

    if ((fbe_current_size + f7.fbe_size()) > fbe_struct_size)
        return true;
    if (!f7.verify())
        return false;
    fbe_current_size += f7.fbe_size();

    if ((fbe_current_size + f8.fbe_size()) > fbe_struct_size)
        return true;
    if (!f8.verify())
        return false;
    fbe_current_size += f8.fbe_size();

    if ((fbe_current_size + f9.fbe_size()) > fbe_struct_size)
        return true;
    if (!f9.verify())
        return false;
    fbe_current_size += f9.fbe_size();

    if ((fbe_current_size + f10.fbe_size()) > fbe_struct_size)
        return true;
    if (!f10.verify())
        return false;
    fbe_current_size += f10.fbe_size();

    return true;
}

size_t FieldModel<::test::StructArray>::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructArray>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructArray>::get(::test::StructArray& fbe_value) const noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel<::test::StructArray>::get_fields([[maybe_unused]] ::test::StructArray& fbe_value, [[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
        f1.get(fbe_value.f1);
    else
    fbe_current_size += f1.fbe_size();

    if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
        f2.get(fbe_value.f2);
    else
    fbe_current_size += f2.fbe_size();

    if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
        f3.get(fbe_value.f3);
    else
    fbe_current_size += f3.fbe_size();

    if ((fbe_current_size + f4.fbe_size()) <= fbe_struct_size)
        f4.get(fbe_value.f4);
    else
    fbe_current_size += f4.fbe_size();

    if ((fbe_current_size + f5.fbe_size()) <= fbe_struct_size)
        f5.get(fbe_value.f5);
    else
    fbe_current_size += f5.fbe_size();

    if ((fbe_current_size + f6.fbe_size()) <= fbe_struct_size)
        f6.get(fbe_value.f6);
    else
    fbe_current_size += f6.fbe_size();

    if ((fbe_current_size + f7.fbe_size()) <= fbe_struct_size)
        f7.get(fbe_value.f7);
    else
    fbe_current_size += f7.fbe_size();

    if ((fbe_current_size + f8.fbe_size()) <= fbe_struct_size)
        f8.get(fbe_value.f8);
    else
    fbe_current_size += f8.fbe_size();

    if ((fbe_current_size + f9.fbe_size()) <= fbe_struct_size)
        f9.get(fbe_value.f9);
    else
    fbe_current_size += f9.fbe_size();

    if ((fbe_current_size + f10.fbe_size()) <= fbe_struct_size)
        f10.get(fbe_value.f10);
    else
    fbe_current_size += f10.fbe_size();
}

size_t FieldModel<::test::StructArray>::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, (uint32_t)fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructArray>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructArray>::set(const ::test::StructArray& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel<::test::StructArray>::set_fields([[maybe_unused]] const ::test::StructArray& fbe_value) noexcept
{
    f1.set(fbe_value.f1);
    f2.set(fbe_value.f2);
    f3.set(fbe_value.f3);
    f4.set(fbe_value.f4);
    f5.set(fbe_value.f5);
    f6.set(fbe_value.f6);
    f7.set(fbe_value.f7);
    f8.set(fbe_value.f8);
    f9.set(fbe_value.f9);
    f10.set(fbe_value.f10);
}

namespace test {

bool StructArrayModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t StructArrayModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t StructArrayModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t StructArrayModel::serialize(const ::test::StructArray& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t StructArrayModel::deserialize(::test::StructArray& value) const noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace test

FieldModel<::test::StructVector>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , f1(buffer, 4 + 4)
    , f2(buffer, f1.fbe_offset() + f1.fbe_size())
    , f3(buffer, f2.fbe_offset() + f2.fbe_size())
    , f4(buffer, f3.fbe_offset() + f3.fbe_size())
    , f5(buffer, f4.fbe_offset() + f4.fbe_size())
    , f6(buffer, f5.fbe_offset() + f5.fbe_size())
    , f7(buffer, f6.fbe_offset() + f6.fbe_size())
    , f8(buffer, f7.fbe_offset() + f7.fbe_size())
    , f9(buffer, f8.fbe_offset() + f8.fbe_size())
    , f10(buffer, f9.fbe_offset() + f9.fbe_size())
{}

size_t FieldModel<::test::StructVector>::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + f1.fbe_size()
        + f2.fbe_size()
        + f3.fbe_size()
        + f4.fbe_size()
        + f5.fbe_size()
        + f6.fbe_size()
        + f7.fbe_size()
        + f8.fbe_size()
        + f9.fbe_size()
        + f10.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel<::test::StructVector>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + f1.fbe_extra()
        + f2.fbe_extra()
        + f3.fbe_extra()
        + f4.fbe_extra()
        + f5.fbe_extra()
        + f6.fbe_extra()
        + f7.fbe_extra()
        + f8.fbe_extra()
        + f9.fbe_extra()
        + f10.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::test::StructVector>::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel<::test::StructVector>::verify_fields([[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
        return true;
    if (!f1.verify())
        return false;
    fbe_current_size += f1.fbe_size();

    if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
        return true;
    if (!f2.verify())
        return false;
    fbe_current_size += f2.fbe_size();

    if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
        return true;
    if (!f3.verify())
        return false;
    fbe_current_size += f3.fbe_size();

    if ((fbe_current_size + f4.fbe_size()) > fbe_struct_size)
        return true;
    if (!f4.verify())
        return false;
    fbe_current_size += f4.fbe_size();

    if ((fbe_current_size + f5.fbe_size()) > fbe_struct_size)
        return true;
    if (!f5.verify())
        return false;
    fbe_current_size += f5.fbe_size();

    if ((fbe_current_size + f6.fbe_size()) > fbe_struct_size)
        return true;
    if (!f6.verify())
        return false;
    fbe_current_size += f6.fbe_size();

    if ((fbe_current_size + f7.fbe_size()) > fbe_struct_size)
        return true;
    if (!f7.verify())
        return false;
    fbe_current_size += f7.fbe_size();

    if ((fbe_current_size + f8.fbe_size()) > fbe_struct_size)
        return true;
    if (!f8.verify())
        return false;
    fbe_current_size += f8.fbe_size();

    if ((fbe_current_size + f9.fbe_size()) > fbe_struct_size)
        return true;
    if (!f9.verify())
        return false;
    fbe_current_size += f9.fbe_size();

    if ((fbe_current_size + f10.fbe_size()) > fbe_struct_size)
        return true;
    if (!f10.verify())
        return false;
    fbe_current_size += f10.fbe_size();

    return true;
}

size_t FieldModel<::test::StructVector>::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructVector>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructVector>::get(::test::StructVector& fbe_value) const noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel<::test::StructVector>::get_fields([[maybe_unused]] ::test::StructVector& fbe_value, [[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
        f1.get(fbe_value.f1);
    else
        fbe_value.f1.clear();
    fbe_current_size += f1.fbe_size();

    if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
        f2.get(fbe_value.f2);
    else
        fbe_value.f2.clear();
    fbe_current_size += f2.fbe_size();

    if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
        f3.get(fbe_value.f3);
    else
        fbe_value.f3.clear();
    fbe_current_size += f3.fbe_size();

    if ((fbe_current_size + f4.fbe_size()) <= fbe_struct_size)
        f4.get(fbe_value.f4);
    else
        fbe_value.f4.clear();
    fbe_current_size += f4.fbe_size();

    if ((fbe_current_size + f5.fbe_size()) <= fbe_struct_size)
        f5.get(fbe_value.f5);
    else
        fbe_value.f5.clear();
    fbe_current_size += f5.fbe_size();

    if ((fbe_current_size + f6.fbe_size()) <= fbe_struct_size)
        f6.get(fbe_value.f6);
    else
        fbe_value.f6.clear();
    fbe_current_size += f6.fbe_size();

    if ((fbe_current_size + f7.fbe_size()) <= fbe_struct_size)
        f7.get(fbe_value.f7);
    else
        fbe_value.f7.clear();
    fbe_current_size += f7.fbe_size();

    if ((fbe_current_size + f8.fbe_size()) <= fbe_struct_size)
        f8.get(fbe_value.f8);
    else
        fbe_value.f8.clear();
    fbe_current_size += f8.fbe_size();

    if ((fbe_current_size + f9.fbe_size()) <= fbe_struct_size)
        f9.get(fbe_value.f9);
    else
        fbe_value.f9.clear();
    fbe_current_size += f9.fbe_size();

    if ((fbe_current_size + f10.fbe_size()) <= fbe_struct_size)
        f10.get(fbe_value.f10);
    else
        fbe_value.f10.clear();
    fbe_current_size += f10.fbe_size();
}

size_t FieldModel<::test::StructVector>::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, (uint32_t)fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructVector>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructVector>::set(const ::test::StructVector& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel<::test::StructVector>::set_fields([[maybe_unused]] const ::test::StructVector& fbe_value) noexcept
{
    f1.set(fbe_value.f1);
    f2.set(fbe_value.f2);
    f3.set(fbe_value.f3);
    f4.set(fbe_value.f4);
    f5.set(fbe_value.f5);
    f6.set(fbe_value.f6);
    f7.set(fbe_value.f7);
    f8.set(fbe_value.f8);
    f9.set(fbe_value.f9);
    f10.set(fbe_value.f10);
}

namespace test {

bool StructVectorModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t StructVectorModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t StructVectorModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t StructVectorModel::serialize(const ::test::StructVector& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t StructVectorModel::deserialize(::test::StructVector& value) const noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace test

FieldModel<::test::StructList>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , f1(buffer, 4 + 4)
    , f2(buffer, f1.fbe_offset() + f1.fbe_size())
    , f3(buffer, f2.fbe_offset() + f2.fbe_size())
    , f4(buffer, f3.fbe_offset() + f3.fbe_size())
    , f5(buffer, f4.fbe_offset() + f4.fbe_size())
    , f6(buffer, f5.fbe_offset() + f5.fbe_size())
    , f7(buffer, f6.fbe_offset() + f6.fbe_size())
    , f8(buffer, f7.fbe_offset() + f7.fbe_size())
    , f9(buffer, f8.fbe_offset() + f8.fbe_size())
    , f10(buffer, f9.fbe_offset() + f9.fbe_size())
{}

size_t FieldModel<::test::StructList>::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + f1.fbe_size()
        + f2.fbe_size()
        + f3.fbe_size()
        + f4.fbe_size()
        + f5.fbe_size()
        + f6.fbe_size()
        + f7.fbe_size()
        + f8.fbe_size()
        + f9.fbe_size()
        + f10.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel<::test::StructList>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + f1.fbe_extra()
        + f2.fbe_extra()
        + f3.fbe_extra()
        + f4.fbe_extra()
        + f5.fbe_extra()
        + f6.fbe_extra()
        + f7.fbe_extra()
        + f8.fbe_extra()
        + f9.fbe_extra()
        + f10.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::test::StructList>::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel<::test::StructList>::verify_fields([[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
        return true;
    if (!f1.verify())
        return false;
    fbe_current_size += f1.fbe_size();

    if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
        return true;
    if (!f2.verify())
        return false;
    fbe_current_size += f2.fbe_size();

    if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
        return true;
    if (!f3.verify())
        return false;
    fbe_current_size += f3.fbe_size();

    if ((fbe_current_size + f4.fbe_size()) > fbe_struct_size)
        return true;
    if (!f4.verify())
        return false;
    fbe_current_size += f4.fbe_size();

    if ((fbe_current_size + f5.fbe_size()) > fbe_struct_size)
        return true;
    if (!f5.verify())
        return false;
    fbe_current_size += f5.fbe_size();

    if ((fbe_current_size + f6.fbe_size()) > fbe_struct_size)
        return true;
    if (!f6.verify())
        return false;
    fbe_current_size += f6.fbe_size();

    if ((fbe_current_size + f7.fbe_size()) > fbe_struct_size)
        return true;
    if (!f7.verify())
        return false;
    fbe_current_size += f7.fbe_size();

    if ((fbe_current_size + f8.fbe_size()) > fbe_struct_size)
        return true;
    if (!f8.verify())
        return false;
    fbe_current_size += f8.fbe_size();

    if ((fbe_current_size + f9.fbe_size()) > fbe_struct_size)
        return true;
    if (!f9.verify())
        return false;
    fbe_current_size += f9.fbe_size();

    if ((fbe_current_size + f10.fbe_size()) > fbe_struct_size)
        return true;
    if (!f10.verify())
        return false;
    fbe_current_size += f10.fbe_size();

    return true;
}

size_t FieldModel<::test::StructList>::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructList>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructList>::get(::test::StructList& fbe_value) const noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel<::test::StructList>::get_fields([[maybe_unused]] ::test::StructList& fbe_value, [[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
        f1.get(fbe_value.f1);
    else
        fbe_value.f1.clear();
    fbe_current_size += f1.fbe_size();

    if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
        f2.get(fbe_value.f2);
    else
        fbe_value.f2.clear();
    fbe_current_size += f2.fbe_size();

    if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
        f3.get(fbe_value.f3);
    else
        fbe_value.f3.clear();
    fbe_current_size += f3.fbe_size();

    if ((fbe_current_size + f4.fbe_size()) <= fbe_struct_size)
        f4.get(fbe_value.f4);
    else
        fbe_value.f4.clear();
    fbe_current_size += f4.fbe_size();

    if ((fbe_current_size + f5.fbe_size()) <= fbe_struct_size)
        f5.get(fbe_value.f5);
    else
        fbe_value.f5.clear();
    fbe_current_size += f5.fbe_size();

    if ((fbe_current_size + f6.fbe_size()) <= fbe_struct_size)
        f6.get(fbe_value.f6);
    else
        fbe_value.f6.clear();
    fbe_current_size += f6.fbe_size();

    if ((fbe_current_size + f7.fbe_size()) <= fbe_struct_size)
        f7.get(fbe_value.f7);
    else
        fbe_value.f7.clear();
    fbe_current_size += f7.fbe_size();

    if ((fbe_current_size + f8.fbe_size()) <= fbe_struct_size)
        f8.get(fbe_value.f8);
    else
        fbe_value.f8.clear();
    fbe_current_size += f8.fbe_size();

    if ((fbe_current_size + f9.fbe_size()) <= fbe_struct_size)
        f9.get(fbe_value.f9);
    else
        fbe_value.f9.clear();
    fbe_current_size += f9.fbe_size();

    if ((fbe_current_size + f10.fbe_size()) <= fbe_struct_size)
        f10.get(fbe_value.f10);
    else
        fbe_value.f10.clear();
    fbe_current_size += f10.fbe_size();
}

size_t FieldModel<::test::StructList>::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, (uint32_t)fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructList>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructList>::set(const ::test::StructList& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel<::test::StructList>::set_fields([[maybe_unused]] const ::test::StructList& fbe_value) noexcept
{
    f1.set(fbe_value.f1);
    f2.set(fbe_value.f2);
    f3.set(fbe_value.f3);
    f4.set(fbe_value.f4);
    f5.set(fbe_value.f5);
    f6.set(fbe_value.f6);
    f7.set(fbe_value.f7);
    f8.set(fbe_value.f8);
    f9.set(fbe_value.f9);
    f10.set(fbe_value.f10);
}

namespace test {

bool StructListModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t StructListModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t StructListModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t StructListModel::serialize(const ::test::StructList& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t StructListModel::deserialize(::test::StructList& value) const noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace test

FieldModel<::test::StructSet>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , f1(buffer, 4 + 4)
    , f2(buffer, f1.fbe_offset() + f1.fbe_size())
    , f3(buffer, f2.fbe_offset() + f2.fbe_size())
    , f4(buffer, f3.fbe_offset() + f3.fbe_size())
{}

size_t FieldModel<::test::StructSet>::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + f1.fbe_size()
        + f2.fbe_size()
        + f3.fbe_size()
        + f4.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel<::test::StructSet>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + f1.fbe_extra()
        + f2.fbe_extra()
        + f3.fbe_extra()
        + f4.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::test::StructSet>::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel<::test::StructSet>::verify_fields([[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
        return true;
    if (!f1.verify())
        return false;
    fbe_current_size += f1.fbe_size();

    if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
        return true;
    if (!f2.verify())
        return false;
    fbe_current_size += f2.fbe_size();

    if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
        return true;
    if (!f3.verify())
        return false;
    fbe_current_size += f3.fbe_size();

    if ((fbe_current_size + f4.fbe_size()) > fbe_struct_size)
        return true;
    if (!f4.verify())
        return false;
    fbe_current_size += f4.fbe_size();

    return true;
}

size_t FieldModel<::test::StructSet>::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructSet>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructSet>::get(::test::StructSet& fbe_value) const noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel<::test::StructSet>::get_fields([[maybe_unused]] ::test::StructSet& fbe_value, [[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
        f1.get(fbe_value.f1);
    else
        fbe_value.f1.clear();
    fbe_current_size += f1.fbe_size();

    if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
        f2.get(fbe_value.f2);
    else
        fbe_value.f2.clear();
    fbe_current_size += f2.fbe_size();

    if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
        f3.get(fbe_value.f3);
    else
        fbe_value.f3.clear();
    fbe_current_size += f3.fbe_size();

    if ((fbe_current_size + f4.fbe_size()) <= fbe_struct_size)
        f4.get(fbe_value.f4);
    else
        fbe_value.f4.clear();
    fbe_current_size += f4.fbe_size();
}

size_t FieldModel<::test::StructSet>::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, (uint32_t)fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructSet>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructSet>::set(const ::test::StructSet& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel<::test::StructSet>::set_fields([[maybe_unused]] const ::test::StructSet& fbe_value) noexcept
{
    f1.set(fbe_value.f1);
    f2.set(fbe_value.f2);
    f3.set(fbe_value.f3);
    f4.set(fbe_value.f4);
}

namespace test {

bool StructSetModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t StructSetModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t StructSetModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t StructSetModel::serialize(const ::test::StructSet& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t StructSetModel::deserialize(::test::StructSet& value) const noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace test

FieldModel<::test::StructMap>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , f1(buffer, 4 + 4)
    , f2(buffer, f1.fbe_offset() + f1.fbe_size())
    , f3(buffer, f2.fbe_offset() + f2.fbe_size())
    , f4(buffer, f3.fbe_offset() + f3.fbe_size())
    , f5(buffer, f4.fbe_offset() + f4.fbe_size())
    , f6(buffer, f5.fbe_offset() + f5.fbe_size())
    , f7(buffer, f6.fbe_offset() + f6.fbe_size())
    , f8(buffer, f7.fbe_offset() + f7.fbe_size())
    , f9(buffer, f8.fbe_offset() + f8.fbe_size())
    , f10(buffer, f9.fbe_offset() + f9.fbe_size())
{}

size_t FieldModel<::test::StructMap>::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + f1.fbe_size()
        + f2.fbe_size()
        + f3.fbe_size()
        + f4.fbe_size()
        + f5.fbe_size()
        + f6.fbe_size()
        + f7.fbe_size()
        + f8.fbe_size()
        + f9.fbe_size()
        + f10.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel<::test::StructMap>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + f1.fbe_extra()
        + f2.fbe_extra()
        + f3.fbe_extra()
        + f4.fbe_extra()
        + f5.fbe_extra()
        + f6.fbe_extra()
        + f7.fbe_extra()
        + f8.fbe_extra()
        + f9.fbe_extra()
        + f10.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::test::StructMap>::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel<::test::StructMap>::verify_fields([[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
        return true;
    if (!f1.verify())
        return false;
    fbe_current_size += f1.fbe_size();

    if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
        return true;
    if (!f2.verify())
        return false;
    fbe_current_size += f2.fbe_size();

    if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
        return true;
    if (!f3.verify())
        return false;
    fbe_current_size += f3.fbe_size();

    if ((fbe_current_size + f4.fbe_size()) > fbe_struct_size)
        return true;
    if (!f4.verify())
        return false;
    fbe_current_size += f4.fbe_size();

    if ((fbe_current_size + f5.fbe_size()) > fbe_struct_size)
        return true;
    if (!f5.verify())
        return false;
    fbe_current_size += f5.fbe_size();

    if ((fbe_current_size + f6.fbe_size()) > fbe_struct_size)
        return true;
    if (!f6.verify())
        return false;
    fbe_current_size += f6.fbe_size();

    if ((fbe_current_size + f7.fbe_size()) > fbe_struct_size)
        return true;
    if (!f7.verify())
        return false;
    fbe_current_size += f7.fbe_size();

    if ((fbe_current_size + f8.fbe_size()) > fbe_struct_size)
        return true;
    if (!f8.verify())
        return false;
    fbe_current_size += f8.fbe_size();

    if ((fbe_current_size + f9.fbe_size()) > fbe_struct_size)
        return true;
    if (!f9.verify())
        return false;
    fbe_current_size += f9.fbe_size();

    if ((fbe_current_size + f10.fbe_size()) > fbe_struct_size)
        return true;
    if (!f10.verify())
        return false;
    fbe_current_size += f10.fbe_size();

    return true;
}

size_t FieldModel<::test::StructMap>::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructMap>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructMap>::get(::test::StructMap& fbe_value) const noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel<::test::StructMap>::get_fields([[maybe_unused]] ::test::StructMap& fbe_value, [[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
        f1.get(fbe_value.f1);
    else
        fbe_value.f1.clear();
    fbe_current_size += f1.fbe_size();

    if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
        f2.get(fbe_value.f2);
    else
        fbe_value.f2.clear();
    fbe_current_size += f2.fbe_size();

    if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
        f3.get(fbe_value.f3);
    else
        fbe_value.f3.clear();
    fbe_current_size += f3.fbe_size();

    if ((fbe_current_size + f4.fbe_size()) <= fbe_struct_size)
        f4.get(fbe_value.f4);
    else
        fbe_value.f4.clear();
    fbe_current_size += f4.fbe_size();

    if ((fbe_current_size + f5.fbe_size()) <= fbe_struct_size)
        f5.get(fbe_value.f5);
    else
        fbe_value.f5.clear();
    fbe_current_size += f5.fbe_size();

    if ((fbe_current_size + f6.fbe_size()) <= fbe_struct_size)
        f6.get(fbe_value.f6);
    else
        fbe_value.f6.clear();
    fbe_current_size += f6.fbe_size();

    if ((fbe_current_size + f7.fbe_size()) <= fbe_struct_size)
        f7.get(fbe_value.f7);
    else
        fbe_value.f7.clear();
    fbe_current_size += f7.fbe_size();

    if ((fbe_current_size + f8.fbe_size()) <= fbe_struct_size)
        f8.get(fbe_value.f8);
    else
        fbe_value.f8.clear();
    fbe_current_size += f8.fbe_size();

    if ((fbe_current_size + f9.fbe_size()) <= fbe_struct_size)
        f9.get(fbe_value.f9);
    else
        fbe_value.f9.clear();
    fbe_current_size += f9.fbe_size();

    if ((fbe_current_size + f10.fbe_size()) <= fbe_struct_size)
        f10.get(fbe_value.f10);
    else
        fbe_value.f10.clear();
    fbe_current_size += f10.fbe_size();
}

size_t FieldModel<::test::StructMap>::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, (uint32_t)fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructMap>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructMap>::set(const ::test::StructMap& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel<::test::StructMap>::set_fields([[maybe_unused]] const ::test::StructMap& fbe_value) noexcept
{
    f1.set(fbe_value.f1);
    f2.set(fbe_value.f2);
    f3.set(fbe_value.f3);
    f4.set(fbe_value.f4);
    f5.set(fbe_value.f5);
    f6.set(fbe_value.f6);
    f7.set(fbe_value.f7);
    f8.set(fbe_value.f8);
    f9.set(fbe_value.f9);
    f10.set(fbe_value.f10);
}

namespace test {

bool StructMapModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t StructMapModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t StructMapModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t StructMapModel::serialize(const ::test::StructMap& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t StructMapModel::deserialize(::test::StructMap& value) const noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace test

FieldModel<::test::StructHash>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , f1(buffer, 4 + 4)
    , f2(buffer, f1.fbe_offset() + f1.fbe_size())
    , f3(buffer, f2.fbe_offset() + f2.fbe_size())
    , f4(buffer, f3.fbe_offset() + f3.fbe_size())
    , f5(buffer, f4.fbe_offset() + f4.fbe_size())
    , f6(buffer, f5.fbe_offset() + f5.fbe_size())
    , f7(buffer, f6.fbe_offset() + f6.fbe_size())
    , f8(buffer, f7.fbe_offset() + f7.fbe_size())
    , f9(buffer, f8.fbe_offset() + f8.fbe_size())
    , f10(buffer, f9.fbe_offset() + f9.fbe_size())
{}

size_t FieldModel<::test::StructHash>::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + f1.fbe_size()
        + f2.fbe_size()
        + f3.fbe_size()
        + f4.fbe_size()
        + f5.fbe_size()
        + f6.fbe_size()
        + f7.fbe_size()
        + f8.fbe_size()
        + f9.fbe_size()
        + f10.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel<::test::StructHash>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + f1.fbe_extra()
        + f2.fbe_extra()
        + f3.fbe_extra()
        + f4.fbe_extra()
        + f5.fbe_extra()
        + f6.fbe_extra()
        + f7.fbe_extra()
        + f8.fbe_extra()
        + f9.fbe_extra()
        + f10.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::test::StructHash>::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel<::test::StructHash>::verify_fields([[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
        return true;
    if (!f1.verify())
        return false;
    fbe_current_size += f1.fbe_size();

    if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
        return true;
    if (!f2.verify())
        return false;
    fbe_current_size += f2.fbe_size();

    if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
        return true;
    if (!f3.verify())
        return false;
    fbe_current_size += f3.fbe_size();

    if ((fbe_current_size + f4.fbe_size()) > fbe_struct_size)
        return true;
    if (!f4.verify())
        return false;
    fbe_current_size += f4.fbe_size();

    if ((fbe_current_size + f5.fbe_size()) > fbe_struct_size)
        return true;
    if (!f5.verify())
        return false;
    fbe_current_size += f5.fbe_size();

    if ((fbe_current_size + f6.fbe_size()) > fbe_struct_size)
        return true;
    if (!f6.verify())
        return false;
    fbe_current_size += f6.fbe_size();

    if ((fbe_current_size + f7.fbe_size()) > fbe_struct_size)
        return true;
    if (!f7.verify())
        return false;
    fbe_current_size += f7.fbe_size();

    if ((fbe_current_size + f8.fbe_size()) > fbe_struct_size)
        return true;
    if (!f8.verify())
        return false;
    fbe_current_size += f8.fbe_size();

    if ((fbe_current_size + f9.fbe_size()) > fbe_struct_size)
        return true;
    if (!f9.verify())
        return false;
    fbe_current_size += f9.fbe_size();

    if ((fbe_current_size + f10.fbe_size()) > fbe_struct_size)
        return true;
    if (!f10.verify())
        return false;
    fbe_current_size += f10.fbe_size();

    return true;
}

size_t FieldModel<::test::StructHash>::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructHash>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructHash>::get(::test::StructHash& fbe_value) const noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel<::test::StructHash>::get_fields([[maybe_unused]] ::test::StructHash& fbe_value, [[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
        f1.get(fbe_value.f1);
    else
        fbe_value.f1.clear();
    fbe_current_size += f1.fbe_size();

    if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
        f2.get(fbe_value.f2);
    else
        fbe_value.f2.clear();
    fbe_current_size += f2.fbe_size();

    if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
        f3.get(fbe_value.f3);
    else
        fbe_value.f3.clear();
    fbe_current_size += f3.fbe_size();

    if ((fbe_current_size + f4.fbe_size()) <= fbe_struct_size)
        f4.get(fbe_value.f4);
    else
        fbe_value.f4.clear();
    fbe_current_size += f4.fbe_size();

    if ((fbe_current_size + f5.fbe_size()) <= fbe_struct_size)
        f5.get(fbe_value.f5);
    else
        fbe_value.f5.clear();
    fbe_current_size += f5.fbe_size();

    if ((fbe_current_size + f6.fbe_size()) <= fbe_struct_size)
        f6.get(fbe_value.f6);
    else
        fbe_value.f6.clear();
    fbe_current_size += f6.fbe_size();

    if ((fbe_current_size + f7.fbe_size()) <= fbe_struct_size)
        f7.get(fbe_value.f7);
    else
        fbe_value.f7.clear();
    fbe_current_size += f7.fbe_size();

    if ((fbe_current_size + f8.fbe_size()) <= fbe_struct_size)
        f8.get(fbe_value.f8);
    else
        fbe_value.f8.clear();
    fbe_current_size += f8.fbe_size();

    if ((fbe_current_size + f9.fbe_size()) <= fbe_struct_size)
        f9.get(fbe_value.f9);
    else
        fbe_value.f9.clear();
    fbe_current_size += f9.fbe_size();

    if ((fbe_current_size + f10.fbe_size()) <= fbe_struct_size)
        f10.get(fbe_value.f10);
    else
        fbe_value.f10.clear();
    fbe_current_size += f10.fbe_size();
}

size_t FieldModel<::test::StructHash>::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, (uint32_t)fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructHash>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructHash>::set(const ::test::StructHash& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel<::test::StructHash>::set_fields([[maybe_unused]] const ::test::StructHash& fbe_value) noexcept
{
    f1.set(fbe_value.f1);
    f2.set(fbe_value.f2);
    f3.set(fbe_value.f3);
    f4.set(fbe_value.f4);
    f5.set(fbe_value.f5);
    f6.set(fbe_value.f6);
    f7.set(fbe_value.f7);
    f8.set(fbe_value.f8);
    f9.set(fbe_value.f9);
    f10.set(fbe_value.f10);
}

namespace test {

bool StructHashModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t StructHashModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t StructHashModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t StructHashModel::serialize(const ::test::StructHash& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t StructHashModel::deserialize(::test::StructHash& value) const noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace test

FieldModel<::test::StructHashEx>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , f1(buffer, 4 + 4)
    , f2(buffer, f1.fbe_offset() + f1.fbe_size())
{}

size_t FieldModel<::test::StructHashEx>::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + f1.fbe_size()
        + f2.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel<::test::StructHashEx>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + f1.fbe_extra()
        + f2.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::test::StructHashEx>::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel<::test::StructHashEx>::verify_fields([[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
        return true;
    if (!f1.verify())
        return false;
    fbe_current_size += f1.fbe_size();

    if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
        return true;
    if (!f2.verify())
        return false;
    fbe_current_size += f2.fbe_size();

    return true;
}

size_t FieldModel<::test::StructHashEx>::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructHashEx>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructHashEx>::get(::test::StructHashEx& fbe_value) const noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel<::test::StructHashEx>::get_fields([[maybe_unused]] ::test::StructHashEx& fbe_value, [[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
        f1.get(fbe_value.f1);
    else
        fbe_value.f1.clear();
    fbe_current_size += f1.fbe_size();

    if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
        f2.get(fbe_value.f2);
    else
        fbe_value.f2.clear();
    fbe_current_size += f2.fbe_size();
}

size_t FieldModel<::test::StructHashEx>::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, (uint32_t)fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructHashEx>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructHashEx>::set(const ::test::StructHashEx& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel<::test::StructHashEx>::set_fields([[maybe_unused]] const ::test::StructHashEx& fbe_value) noexcept
{
    f1.set(fbe_value.f1);
    f2.set(fbe_value.f2);
}

namespace test {

bool StructHashExModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t StructHashExModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t StructHashExModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t StructHashExModel::serialize(const ::test::StructHashEx& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t StructHashExModel::deserialize(::test::StructHashEx& value) const noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace test

FieldModel<::test::StructEmpty>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
{}

size_t FieldModel<::test::StructEmpty>::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        ;
    return fbe_result;
}

size_t FieldModel<::test::StructEmpty>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::test::StructEmpty>::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4);
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel<::test::StructEmpty>::verify_fields([[maybe_unused]] size_t fbe_struct_size) const noexcept
{
    return true;
}

size_t FieldModel<::test::StructEmpty>::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset);
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructEmpty>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructEmpty>::get(::test::StructEmpty& fbe_value) const noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset());
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel<::test::StructEmpty>::get_fields([[maybe_unused]] ::test::StructEmpty& fbe_value, [[maybe_unused]] size_t fbe_struct_size) const noexcept
{
}

size_t FieldModel<::test::StructEmpty>::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset(), fbe_struct_offset);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset, fbe_struct_size);
    unaligned_store<uint32_t>(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4, (uint32_t)fbe_type());

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::test::StructEmpty>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::test::StructEmpty>::set(const ::test::StructEmpty& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel<::test::StructEmpty>::set_fields([[maybe_unused]] const ::test::StructEmpty& fbe_value) noexcept
{
}

namespace test {

bool StructEmptyModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t StructEmptyModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t StructEmptyModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t StructEmptyModel::serialize(const ::test::StructEmpty& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t StructEmptyModel::deserialize(::test::StructEmpty& value) const noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = unaligned_load<uint32_t>(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4);
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace test

} // namespace FBE
