//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: FBE
// FBE version: 1.11.0.0
//------------------------------------------------------------------------------

namespace FBE {

template <typename T, typename TBase>
inline size_t FinalModelBase<T, TBase>::verify() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return std::numeric_limits<std::size_t>::max();

    return fbe_size();
}

template <typename T, typename TBase>
inline size_t FinalModelBase<T, TBase>::get(T& value) const noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    if ((fbe_full_offset + fbe_size()) > _buffer.size())
        return 0;

    value = unaligned_load<T>(_buffer.data() + fbe_full_offset);

    return fbe_size();
}

template <typename T, typename TBase>
inline size_t FinalModelBase<T, TBase>::set(T value) noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + fbe_size()) > _buffer.size())
        return 0;

    unaligned_store<TBase>(_buffer.data() + fbe_full_offset, (TBase)value);
    return fbe_size();
}

template <typename T>
inline bool FinalModel<std::optional<T>>::has_value() const noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    if ((fbe_full_offset + 1) > _buffer.size())
        return false;

    uint8_t fbe_has_value = *((const uint8_t*)(_buffer.data() + fbe_full_offset));
    return (fbe_has_value != 0);
}

template <typename T>
inline size_t FinalModel<std::optional<T>>::verify() const noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    if ((fbe_full_offset + 1) > _buffer.size())
        return std::numeric_limits<std::size_t>::max();

    uint8_t fbe_has_value = *((const uint8_t*)(_buffer.data() + fbe_full_offset));
    if (fbe_has_value == 0)
        return 1;

    _buffer.shift(fbe_offset() + 1);
    size_t fbe_result = value.verify();
    _buffer.unshift(fbe_offset() + 1);
    return 1 + fbe_result;
}

template <typename T>
inline size_t FinalModel<std::optional<T>>::get(std::optional<T>& opt) const noexcept
{
    opt = std::nullopt;

    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 1) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 1) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = *((const uint8_t*)(_buffer.data() + fbe_full_offset));
    if (fbe_has_value == 0)
        return 1;

    _buffer.shift(fbe_offset() + 1);
    T temp = T();
    size_t size = value.get(temp);
    opt.emplace(temp);
    _buffer.unshift(fbe_offset() + 1);
    return 1 + size;
}

template <typename T>
inline size_t FinalModel<std::optional<T>>::get(std::optional<T>& opt, std::pmr::memory_resource* resource) const noexcept
{
    opt = std::nullopt;

    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 1) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 1) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = *((const uint8_t*)(_buffer.data() + fbe_full_offset));
    if (fbe_has_value == 0)
        return 1;

    _buffer.shift(fbe_offset() + 1);
    T temp{};
    if constexpr (std::is_constructible_v<T, std::pmr::memory_resource*>) {
        temp = T(resource);
    }
    size_t size = value.get(temp, resource);
    opt.emplace(std::move(temp));
    _buffer.unshift(fbe_offset() + 1);
    return 1 + size;
}

template <typename T>
inline size_t FinalModel<std::optional<T>>::set(const std::optional<T>& opt)
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 1) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 1) > _buffer.size())
        return 0;

    uint8_t fbe_has_value = opt ? 1 : 0;
    *((uint8_t*)(_buffer.data() + fbe_full_offset)) = fbe_has_value;
    if (fbe_has_value == 0)
        return 1;

    _buffer.shift(fbe_offset() + 1);
    size_t size = 0;
    if (opt)
        size = value.set(opt.value());
    _buffer.unshift(fbe_offset() + 1);
    return 1 + size;
}

template <typename T, size_t N>
template <size_t S>
inline size_t FinalModelArray<T, N>::fbe_allocation_size(const T (&values)[S]) const noexcept
{
    constexpr size_t count = (S < N) ? S : N;
    if constexpr (is_fbe_final_primitive_v<T>) {
        return count * sizeof(T);
    } else {
        size_t size = 0;
        FinalModel<T> fbe_model(_buffer, fbe_offset());
        for (size_t i = 0; i < count; ++i)
            size += fbe_model.fbe_allocation_size(values[i]);
        return size;
    }
}

template <typename T, size_t N>
template <size_t S>
inline size_t FinalModelArray<T, N>::fbe_allocation_size(const std::array<T, S>& values) const noexcept
{
    constexpr size_t count = (S < N) ? S : N;
    if constexpr (is_fbe_final_primitive_v<T>) {
        return count * sizeof(T);
    } else {
        size_t size = 0;
        FinalModel<T> fbe_model(_buffer, fbe_offset());
        for (size_t i = 0; i < count; ++i)
            size += fbe_model.fbe_allocation_size(values[i]);
        return size;
    }
}

template <typename T, size_t N>
inline size_t FinalModelArray<T, N>::fbe_allocation_size(const FastVec<T>& values) const noexcept
{
    const size_t count = std::min(values.size(), N);
    if constexpr (is_fbe_final_primitive_v<T>) {
        return count * sizeof(T);
    } else {
        size_t size = 0;
        FinalModel<T> fbe_model(_buffer, fbe_offset());
        for (size_t i = 0; i < count; ++i)
            size += fbe_model.fbe_allocation_size(values[i]);
        return size;
    }
}

template <typename T, size_t N>
inline size_t FinalModelArray<T, N>::verify() const noexcept
{
    if ((_buffer.offset() + fbe_offset()) > _buffer.size())
        return std::numeric_limits<std::size_t>::max();

    if constexpr (is_fbe_final_primitive_v<T>) {
        // Bulk verification for primitive types - just check total size
        constexpr size_t total_size = N * sizeof(T);
        if ((_buffer.offset() + fbe_offset() + total_size) > _buffer.size())
            return std::numeric_limits<std::size_t>::max();
        return total_size;
    } else {
        size_t size = 0;
        FinalModel<T> fbe_model(_buffer, fbe_offset());
        for (size_t i = 0; i < N; ++i)
        {
            size_t offset = fbe_model.verify();
            if (offset == std::numeric_limits<std::size_t>::max())
                return std::numeric_limits<std::size_t>::max();
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }
}

template <typename T, size_t N>
template <size_t S>
inline size_t FinalModelArray<T, N>::get(T (&values)[S]) const noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert((fbe_full_offset <= _buffer.size()) && "Model is broken!");
    if (fbe_full_offset > _buffer.size())
        return 0;

    constexpr size_t count = (S < N) ? S : N;

    if constexpr (is_fbe_final_primitive_v<T>) {
        // Bulk copy for primitive types
        constexpr size_t total_size = count * sizeof(T);
        memcpy(values, _buffer.data() + fbe_full_offset, total_size);
        return total_size;
    } else {
        size_t size = 0;
        FinalModel<T> fbe_model(_buffer, fbe_offset());
        for (size_t i = 0; i < count; ++i)
        {
            size_t offset = fbe_model.get(values[i]);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }
}

template <typename T, size_t N>
template <size_t S>
inline size_t FinalModelArray<T, N>::get(std::array<T, S>& values) const noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert((fbe_full_offset <= _buffer.size()) && "Model is broken!");
    if (fbe_full_offset > _buffer.size())
        return 0;

    constexpr size_t count = (S < N) ? S : N;

    if constexpr (is_fbe_final_primitive_v<T>) {
        // Bulk copy for primitive types
        constexpr size_t total_size = count * sizeof(T);
        memcpy(values.data(), _buffer.data() + fbe_full_offset, total_size);
        return total_size;
    } else {
        size_t size = 0;
        FinalModel<T> fbe_model(_buffer, fbe_offset());
        for (size_t i = 0; i < count; ++i)
        {
            size_t offset = fbe_model.get(values[i]);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }
}

template <typename T, size_t N>
inline size_t FinalModelArray<T, N>::get(FastVec<T>& values) const noexcept
{
    values.clear();

    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert((fbe_full_offset <= _buffer.size()) && "Model is broken!");
    if (fbe_full_offset > _buffer.size())
        return 0;

    values.reserve(N);

    if constexpr (is_fbe_final_primitive_v<T>) {
        // Bulk copy for primitive types
        constexpr size_t total_size = N * sizeof(T);
        values.resize(N);
        memcpy(values.data(), _buffer.data() + fbe_full_offset, total_size);
        return total_size;
    } else {
        size_t size = 0;
        FinalModel<T> fbe_model(_buffer, fbe_offset());
        for (size_t i = 0; i < N; ++i)
        {
            T value{};
            size_t offset = fbe_model.get(value);
            values.emplace_back(std::move(value));
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }
}

// PMR versions of get methods
template <typename T, size_t N>
template <size_t S>
inline size_t FinalModelArray<T, N>::get(T (&values)[S], std::pmr::memory_resource* resource) const noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert((fbe_full_offset <= _buffer.size()) && "Model is broken!");
    if (fbe_full_offset > _buffer.size())
        return 0;

    constexpr size_t count = (S < N) ? S : N;

    if constexpr (is_fbe_final_primitive_v<T>) {
        constexpr size_t total_size = count * sizeof(T);
        memcpy(values, _buffer.data() + fbe_full_offset, total_size);
        return total_size;
    } else {
        size_t size = 0;
        FinalModel<T> fbe_model(_buffer, fbe_offset());
        for (size_t i = 0; i < count; ++i)
        {
            size_t offset = fbe_model.get(values[i], resource);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }
}

template <typename T, size_t N>
template <size_t S>
inline size_t FinalModelArray<T, N>::get(std::array<T, S>& values, std::pmr::memory_resource* resource) const noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert((fbe_full_offset <= _buffer.size()) && "Model is broken!");
    if (fbe_full_offset > _buffer.size())
        return 0;

    constexpr size_t count = (S < N) ? S : N;

    if constexpr (is_fbe_final_primitive_v<T>) {
        constexpr size_t total_size = count * sizeof(T);
        memcpy(values.data(), _buffer.data() + fbe_full_offset, total_size);
        return total_size;
    } else {
        size_t size = 0;
        FinalModel<T> fbe_model(_buffer, fbe_offset());
        for (size_t i = 0; i < count; ++i)
        {
            size_t offset = fbe_model.get(values[i], resource);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }
}

template <typename T, size_t N>
inline size_t FinalModelArray<T, N>::get(FastVec<T>& values, std::pmr::memory_resource* resource) const noexcept
{
    values.clear();

    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert((fbe_full_offset <= _buffer.size()) && "Model is broken!");
    if (fbe_full_offset > _buffer.size())
        return 0;

    values.reserve(N);

    if constexpr (is_fbe_final_primitive_v<T>) {
        constexpr size_t total_size = N * sizeof(T);
        values.resize(N);
        memcpy(values.data(), _buffer.data() + fbe_full_offset, total_size);
        return total_size;
    } else {
        size_t size = 0;
        FinalModel<T> fbe_model(_buffer, fbe_offset());
        for (size_t i = 0; i < N; ++i)
        {
            T value{};
            if constexpr (std::is_constructible_v<T, std::pmr::memory_resource*>) {
                value = T(resource);
            }
            size_t offset = fbe_model.get(value, resource);
            values.emplace_back(std::move(value));
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }
}

template <typename T, size_t N>
template <size_t S>
inline size_t FinalModelArray<T, N>::set(const T (&values)[S]) noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert((fbe_full_offset <= _buffer.size()) && "Model is broken!");
    if (fbe_full_offset > _buffer.size())
        return 0;

    constexpr size_t count = (S < N) ? S : N;

    if constexpr (is_fbe_final_primitive_v<T>) {
        // Bulk copy for primitive types
        constexpr size_t total_size = count * sizeof(T);
        memcpy(_buffer.data() + fbe_full_offset, values, total_size);
        return total_size;
    } else {
        size_t size = 0;
        FinalModel<T> fbe_model(_buffer, fbe_offset());
        for (size_t i = 0; i < count; ++i)
        {
            size_t offset = fbe_model.set(values[i]);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }
}

template <typename T, size_t N>
template <size_t S>
inline size_t FinalModelArray<T, N>::set(const std::array<T, S>& values) noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert((fbe_full_offset <= _buffer.size()) && "Model is broken!");
    if (fbe_full_offset > _buffer.size())
        return 0;

    constexpr size_t count = (S < N) ? S : N;

    if constexpr (is_fbe_final_primitive_v<T>) {
        // Bulk copy for primitive types
        constexpr size_t total_size = count * sizeof(T);
        memcpy(_buffer.data() + fbe_full_offset, values.data(), total_size);
        return total_size;
    } else {
        size_t size = 0;
        FinalModel<T> fbe_model(_buffer, fbe_offset());
        for (size_t i = 0; i < count; ++i)
        {
            size_t offset = fbe_model.set(values[i]);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }
}

template <typename T, size_t N>
inline size_t FinalModelArray<T, N>::set(const FastVec<T>& values) noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert((fbe_full_offset <= _buffer.size()) && "Model is broken!");
    if (fbe_full_offset > _buffer.size())
        return 0;

    const size_t count = std::min(values.size(), N);

    if constexpr (is_fbe_final_primitive_v<T>) {
        // Bulk copy for primitive types
        const size_t total_size = count * sizeof(T);
        memcpy(_buffer.data() + fbe_full_offset, values.data(), total_size);
        return total_size;
    } else {
        size_t size = 0;
        FinalModel<T> fbe_model(_buffer, fbe_offset());
        for (size_t i = 0; i < count; ++i)
        {
            size_t offset = fbe_model.set(values[i]);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }
}

template <typename T>
inline size_t FinalModelVector<T>::fbe_allocation_size(const FastVec<T>& values) const noexcept
{
    if constexpr (is_fbe_final_primitive_v<T>) {
        // Fixed size for primitive types
        return 4 + values.size() * sizeof(T);
    } else {
        size_t size = 4;
        FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
        for (const auto& value : values)
            size += fbe_model.fbe_allocation_size(value);
        return size;
    }
}

template <typename T>
inline size_t FinalModelVector<T>::fbe_allocation_size(const std::list<T>& values) const noexcept
{
    size_t size = 4;
    FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
        size += fbe_model.fbe_allocation_size(value);
    return size;
}

template <typename T>
inline size_t FinalModelVector<T>::fbe_allocation_size(const std::set<T>& values) const noexcept
{
    size_t size = 4;
    FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
        size += fbe_model.fbe_allocation_size(value);
    return size;
}

template <typename T>
inline size_t FinalModelVector<T>::verify() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
        return std::numeric_limits<std::size_t>::max();

    uint32_t fbe_vector_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());

    if constexpr (is_fbe_final_primitive_v<T>) {
        // Bulk verification for primitive types - just check total size
        size_t total_size = 4 + fbe_vector_size * sizeof(T);
        if ((_buffer.offset() + fbe_offset() + total_size) > _buffer.size())
            return std::numeric_limits<std::size_t>::max();
        return total_size;
    } else {
        size_t size = 4;
        FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
        for (size_t i = 0; i < fbe_vector_size; ++i)
        {
            size_t offset = fbe_model.verify();
            if (offset == std::numeric_limits<std::size_t>::max())
                return std::numeric_limits<std::size_t>::max();
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }
}

template <typename T>
inline size_t FinalModelVector<T>::get(FastVec<T>& values) const noexcept
{
    values.clear();

    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    size_t fbe_vector_size = unaligned_load<uint32_t>(_buffer.data() + fbe_full_offset);
    if (fbe_vector_size == 0)
        return 4;

    if constexpr (is_fbe_final_primitive_v<T>) {
        // Bulk copy for primitive types
        const size_t data_size = fbe_vector_size * sizeof(T);
        values.resize(fbe_vector_size);
        memcpy(values.data(), _buffer.data() + fbe_full_offset + 4, data_size);
        return 4 + data_size;
    } else if constexpr (std::is_same_v<T, bool>) {
        // Special case for vector<bool> - uses proxy objects, can't pass by reference
        values.resize(fbe_vector_size);
        size_t size = 4;
        FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
        for (size_t i = 0; i < fbe_vector_size; ++i)
        {
            T temp{};
            size_t offset = fbe_model.get(temp);
            values[i] = temp;
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    } else {
        // Pre-allocate and deserialize directly into elements
        values.resize(fbe_vector_size);
        size_t size = 4;
        FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
        for (size_t i = 0; i < fbe_vector_size; ++i)
        {
            size_t offset = fbe_model.get(values[i]);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }
}

template <typename T>
inline size_t FinalModelVector<T>::get(std::list<T>& values) const noexcept
{
    values.clear();

    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    size_t fbe_vector_size = unaligned_load<uint32_t>(_buffer.data() + fbe_full_offset);
    if (fbe_vector_size == 0)
        return 4;

    size_t size = 4;
    FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
    for (size_t i = 0; i < fbe_vector_size; ++i)
    {
        T value{};
        size_t offset = fbe_model.get(value);
        values.emplace_back(std::move(value));
        fbe_model.fbe_shift(offset);
        size += offset;
    }
    return size;
}

template <typename T>
inline size_t FinalModelVector<T>::get(std::set<T>& values) const noexcept
{
    values.clear();

    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    size_t fbe_vector_size = unaligned_load<uint32_t>(_buffer.data() + fbe_full_offset);
    if (fbe_vector_size == 0)
        return 4;

    size_t size = 4;
    FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
    // Use hint-based insertion for O(1) amortized insertion (data is already sorted)
    auto hint = values.end();
    for (size_t i = 0; i < fbe_vector_size; ++i)
    {
        T value{};
        size_t offset = fbe_model.get(value);
        values.emplace(std::move(value));
        fbe_model.fbe_shift(offset);
        size += offset;
    }
    return size;
}

template <typename T>
inline size_t FinalModelVector<T>::set(const FastVec<T>& values) noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + fbe_full_offset, (uint32_t)values.size());

    if constexpr (is_fbe_final_primitive_v<T>) {
        // Bulk copy for primitive types
        const size_t data_size = values.size() * sizeof(T);
        if (!values.empty()) {
            memcpy(_buffer.data() + fbe_full_offset + 4, values.data(), data_size);
        }
        return 4 + data_size;
    } else {
        size_t size = 4;
        FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
        for (const auto& value : values)
        {
            size_t offset = fbe_model.set(value);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }
}

template <typename T>
inline size_t FinalModelVector<T>::set(const std::list<T>& values) noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + fbe_full_offset, (uint32_t)values.size());

    size_t size = 4;
    FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
    {
        size_t offset = fbe_model.set(value);
        fbe_model.fbe_shift(offset);
        size += offset;
    }
    return size;
}

template <typename T>
inline size_t FinalModelVector<T>::set(const std::set<T>& values) noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + fbe_full_offset, (uint32_t)values.size());

    size_t size = 4;
    FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
    {
        size_t offset = fbe_model.set(value);
        fbe_model.fbe_shift(offset);
        size += offset;
    }
    return size;
}

// PMR allocation size methods
template <typename T>
inline size_t FinalModelVector<T>::fbe_allocation_size(const std::pmr::vector<T>& values) const noexcept
{
    if constexpr (is_fbe_final_primitive_v<T>) {
        return 4 + values.size() * sizeof(T);
    } else {
        size_t size = 4;
        FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
        for (const auto& value : values)
            size += fbe_model.fbe_allocation_size(value);
        return size;
    }
}

template <typename T>
inline size_t FinalModelVector<T>::fbe_allocation_size(const std::pmr::list<T>& values) const noexcept
{
    size_t size = 4;
    FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
        size += fbe_model.fbe_allocation_size(value);
    return size;
}

template <typename T>
inline size_t FinalModelVector<T>::fbe_allocation_size(const std::pmr::set<T>& values) const noexcept
{
    size_t size = 4;
    FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
        size += fbe_model.fbe_allocation_size(value);
    return size;
}

// PMR get methods with memory_resource
template <typename T>
inline size_t FinalModelVector<T>::get(FastVec<T>& values, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    // For non-PMR container, just delegate to the regular get
    return get(values);
}

template <typename T>
inline size_t FinalModelVector<T>::get(std::pmr::vector<T>& values, std::pmr::memory_resource* resource) const noexcept
{
    values.clear();

    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    size_t fbe_vector_size = unaligned_load<uint32_t>(_buffer.data() + fbe_full_offset);
    if (fbe_vector_size == 0)
        return 4;

    if constexpr (is_fbe_final_primitive_v<T>) {
        const size_t data_size = fbe_vector_size * sizeof(T);
        values.resize(fbe_vector_size);
        memcpy(values.data(), _buffer.data() + fbe_full_offset + 4, data_size);
        return 4 + data_size;
    } else {
        // Pre-allocate and deserialize directly into elements
        values.resize(fbe_vector_size);
        size_t size = 4;
        FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
        for (size_t i = 0; i < fbe_vector_size; ++i)
        {
            size_t offset = fbe_model.get(values[i], resource);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }
}

template <typename T>
inline size_t FinalModelVector<T>::get(std::pmr::list<T>& values, std::pmr::memory_resource* resource) const noexcept
{
    values.clear();

    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    size_t fbe_vector_size = unaligned_load<uint32_t>(_buffer.data() + fbe_full_offset);
    if (fbe_vector_size == 0)
        return 4;

    // Pre-allocate and deserialize directly into elements
    values.resize(fbe_vector_size);
    size_t size = 4;
    FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
    auto it = values.begin();
    for (size_t i = 0; i < fbe_vector_size; ++i, ++it)
    {
        size_t offset = fbe_model.get(*it, resource);
        fbe_model.fbe_shift(offset);
        size += offset;
    }
    return size;
}

template <typename T>
inline size_t FinalModelVector<T>::get(std::pmr::set<T>& values, std::pmr::memory_resource* resource) const noexcept
{
    values.clear();

    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    size_t fbe_vector_size = unaligned_load<uint32_t>(_buffer.data() + fbe_full_offset);
    if (fbe_vector_size == 0)
        return 4;

    size_t size = 4;
    FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
    auto hint = values.end();
    for (size_t i = 0; i < fbe_vector_size; ++i)
    {
        T value{};
        if constexpr (std::is_constructible_v<T, std::pmr::memory_resource*>) {
            value = T(resource);
        }
        size_t offset = fbe_model.get(value, resource);
        values.emplace(std::move(value));
        fbe_model.fbe_shift(offset);
        size += offset;
    }
    return size;
}

// PMR set methods
template <typename T>
inline size_t FinalModelVector<T>::set(const std::pmr::vector<T>& values) noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + fbe_full_offset, (uint32_t)values.size());

    if constexpr (is_fbe_final_primitive_v<T>) {
        const size_t data_size = values.size() * sizeof(T);
        if (!values.empty()) {
            memcpy(_buffer.data() + fbe_full_offset + 4, values.data(), data_size);
        }
        return 4 + data_size;
    } else {
        size_t size = 4;
        FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
        for (const auto& value : values)
        {
            size_t offset = fbe_model.set(value);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }
}

template <typename T>
inline size_t FinalModelVector<T>::set(const std::pmr::list<T>& values) noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + fbe_full_offset, (uint32_t)values.size());

    size_t size = 4;
    FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
    {
        size_t offset = fbe_model.set(value);
        fbe_model.fbe_shift(offset);
        size += offset;
    }
    return size;
}

template <typename T>
inline size_t FinalModelVector<T>::set(const std::pmr::set<T>& values) noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + fbe_full_offset, (uint32_t)values.size());

    size_t size = 4;
    FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
    {
        size_t offset = fbe_model.set(value);
        fbe_model.fbe_shift(offset);
        size += offset;
    }
    return size;
}

template <typename T>
inline size_t FinalModelVector<T>::fbe_allocation_size(const FBE::set<T>& values) const noexcept
{
    size_t size = 4;
    FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
        size += fbe_model.fbe_allocation_size(value);
    return size;
}

template <typename T>
inline size_t FinalModelVector<T>::get(FBE::set<T>& values) const noexcept
{
    values.clear();

    assert(((_buffer.offset() + fbe_offset() + 4) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
        return 0;

    uint32_t fbe_vector_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());

    size_t size = 4;
    FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
    // Use hint-based insertion for O(1) amortized insertion (data is already sorted)
    auto hint = values.end();
    for (size_t i = 0; i < fbe_vector_size; ++i)
    {
        T value = T();
        size_t offset = fbe_model.get(value);
        values.emplace(std::move(value));
        fbe_model.fbe_shift(offset);
        size += offset;
    }
    return size;
}

template <typename T>
inline size_t FinalModelVector<T>::set(const FBE::set<T>& values) noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + fbe_full_offset, (uint32_t)values.size());

    size_t size = 4;
    FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
    {
        size_t offset = fbe_model.set(value);
        fbe_model.fbe_shift(offset);
        size += offset;
    }
    return size;
}

// FBE::pmr::set PMR methods
template <typename T>
inline size_t FinalModelVector<T>::fbe_allocation_size(const FBE::pmr::set<T>& values) const noexcept
{
    size_t size = 4;
    FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
        size += fbe_model.fbe_allocation_size(value);
    return size;
}

template <typename T>
inline size_t FinalModelVector<T>::get(FBE::pmr::set<T>& values, std::pmr::memory_resource* resource) const noexcept
{
    values.clear();

    assert(((_buffer.offset() + fbe_offset() + 4) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
        return 0;

    uint32_t fbe_vector_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());

    size_t size = 4;
    FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
    auto hint = values.end();
    for (size_t i = 0; i < fbe_vector_size; ++i)
    {
        T value{};
        if constexpr (std::is_constructible_v<T, std::pmr::memory_resource*>) {
            value = T(resource);
        }
        size_t offset = fbe_model.get(value, resource);
        values.emplace(std::move(value));
        fbe_model.fbe_shift(offset);
        size += offset;
    }
    return size;
}

template <typename T>
inline size_t FinalModelVector<T>::set(const FBE::pmr::set<T>& values) noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + fbe_full_offset, (uint32_t)values.size());

    size_t size = 4;
    FinalModel<T> fbe_model(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
    {
        size_t offset = fbe_model.set(value);
        fbe_model.fbe_shift(offset);
        size += offset;
    }
    return size;
}

template <typename TKey, typename TValue>
inline size_t FinalModelMap<TKey, TValue>::fbe_allocation_size(const std::map<TKey, TValue>& values) const noexcept
{
    size_t size = 4;
    FinalModel<TKey> fbe_model_key(_buffer, fbe_offset() + 4);
    FinalModel<TValue> fbe_model_value(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
    {
        size += fbe_model_key.fbe_allocation_size(value.first);
        size += fbe_model_value.fbe_allocation_size(value.second);
    }
    return size;
}

template <typename TKey, typename TValue>
inline size_t FinalModelMap<TKey, TValue>::fbe_allocation_size(const HashMap<TKey, TValue>& values) const noexcept
{
    size_t size = 4;
    FinalModel<TKey> fbe_model_key(_buffer, fbe_offset() + 4);
    FinalModel<TValue> fbe_model_value(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
    {
        size += fbe_model_key.fbe_allocation_size(value.first);
        size += fbe_model_value.fbe_allocation_size(value.second);
    }
    return size;
}

template <typename TKey, typename TValue>
inline size_t FinalModelMap<TKey, TValue>::verify() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
        return std::numeric_limits<std::size_t>::max();

    uint32_t fbe_map_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());

    size_t size = 4;
    FinalModel<TKey> fbe_model_key(_buffer, fbe_offset() + 4);
    FinalModel<TValue> fbe_model_value(_buffer, fbe_offset() + 4);
    for (size_t i = fbe_map_size; i-- > 0;)
    {
        size_t offset_key = fbe_model_key.verify();
        if (offset_key == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_model_key.fbe_shift(offset_key);
        fbe_model_value.fbe_shift(offset_key);
        size += offset_key;
        size_t offset_value = fbe_model_value.verify();
        if (offset_value == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_model_key.fbe_shift(offset_value);
        fbe_model_value.fbe_shift(offset_value);
        size += offset_value;
    }
    return size;
}

template <typename TKey, typename TValue>
inline size_t FinalModelMap<TKey, TValue>::get(std::map<TKey, TValue>& values) const noexcept
{
    values.clear();

    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    size_t fbe_map_size = unaligned_load<uint32_t>(_buffer.data() + fbe_full_offset);
    if (fbe_map_size == 0)
        return 4;

    size_t size = 4;
    FinalModel<TKey> fbe_model_key(_buffer, fbe_offset() + 4);
    FinalModel<TValue> fbe_model_value(_buffer, fbe_offset() + 4);
    for (size_t i = 0; i < fbe_map_size; ++i)
    {
        TKey key{};
        TValue value{};
        size_t offset_key = fbe_model_key.get(key);
        fbe_model_key.fbe_shift(offset_key);
        fbe_model_value.fbe_shift(offset_key);
        size_t offset_value = fbe_model_value.get(value);
        fbe_model_key.fbe_shift(offset_value);
        fbe_model_value.fbe_shift(offset_value);
        values.emplace(std::move(key), std::move(value));
        size += offset_key + offset_value;
    }
    return size;
}

template <typename TKey, typename TValue>
inline size_t FinalModelMap<TKey, TValue>::get(HashMap<TKey, TValue>& values) const noexcept
{
    values.clear();

    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    size_t fbe_map_size = unaligned_load<uint32_t>(_buffer.data() + fbe_full_offset);
    if (fbe_map_size == 0)
        return 4;

    values.reserve(fbe_map_size);
    size_t size = 4;
    FinalModel<TKey> fbe_model_key(_buffer, fbe_offset() + 4);
    FinalModel<TValue> fbe_model_value(_buffer, fbe_offset() + 4);
    for (size_t i = 0; i < fbe_map_size; ++i)
    {
        TKey key{};
        TValue value{};
        size_t offset_key = fbe_model_key.get(key);
        fbe_model_key.fbe_shift(offset_key);
        fbe_model_value.fbe_shift(offset_key);
        size_t offset_value = fbe_model_value.get(value);
        fbe_model_key.fbe_shift(offset_value);
        fbe_model_value.fbe_shift(offset_value);
        values.emplace(std::move(key), std::move(value));
        size += offset_key + offset_value;
    }
    return size;
}

template <typename TKey, typename TValue>
inline size_t FinalModelMap<TKey, TValue>::set(const std::map<TKey, TValue>& values) noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + fbe_full_offset, (uint32_t)values.size());

    size_t size = 4;
    FinalModel<TKey> fbe_model_key(_buffer, fbe_offset() + 4);
    FinalModel<TValue> fbe_model_value(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
    {
        size_t offset_key = fbe_model_key.set(value.first);
        fbe_model_key.fbe_shift(offset_key);
        fbe_model_value.fbe_shift(offset_key);
        size_t offset_value = fbe_model_value.set(value.second);
        fbe_model_key.fbe_shift(offset_value);
        fbe_model_value.fbe_shift(offset_value);
        size += offset_key + offset_value;
    }
    return size;
}

template <typename TKey, typename TValue>
inline size_t FinalModelMap<TKey, TValue>::set(const HashMap<TKey, TValue>& values) noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + fbe_full_offset, (uint32_t)values.size());

    size_t size = 4;
    FinalModel<TKey> fbe_model_key(_buffer, fbe_offset() + 4);
    FinalModel<TValue> fbe_model_value(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
    {
        size_t offset_key = fbe_model_key.set(value.first);
        fbe_model_key.fbe_shift(offset_key);
        fbe_model_value.fbe_shift(offset_key);
        size_t offset_value = fbe_model_value.set(value.second);
        fbe_model_key.fbe_shift(offset_value);
        fbe_model_value.fbe_shift(offset_value);
        size += offset_key + offset_value;
    }
    return size;
}

// PMR allocation size methods
template <typename TKey, typename TValue>
inline size_t FinalModelMap<TKey, TValue>::fbe_allocation_size(const std::pmr::map<TKey, TValue>& values) const noexcept
{
    size_t size = 4;
    FinalModel<TKey> fbe_model_key(_buffer, fbe_offset() + 4);
    FinalModel<TValue> fbe_model_value(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
    {
        size += fbe_model_key.fbe_allocation_size(value.first);
        size += fbe_model_value.fbe_allocation_size(value.second);
    }
    return size;
}

template <typename TKey, typename TValue>
inline size_t FinalModelMap<TKey, TValue>::fbe_allocation_size(const FBE::pmr::HashMap<TKey, TValue>& values) const noexcept
{
    size_t size = 4;
    FinalModel<TKey> fbe_model_key(_buffer, fbe_offset() + 4);
    FinalModel<TValue> fbe_model_value(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
    {
        size += fbe_model_key.fbe_allocation_size(value.first);
        size += fbe_model_value.fbe_allocation_size(value.second);
    }
    return size;
}

// PMR get methods with memory_resource
template <typename TKey, typename TValue>
inline size_t FinalModelMap<TKey, TValue>::get(std::map<TKey, TValue>& values, [[maybe_unused]] std::pmr::memory_resource* resource) const noexcept
{
    // For non-PMR container, just delegate to the regular get
    return get(values);
}

template <typename TKey, typename TValue>
inline size_t FinalModelMap<TKey, TValue>::get(std::pmr::map<TKey, TValue>& values, std::pmr::memory_resource* resource) const noexcept
{
    values.clear();

    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    size_t fbe_map_size = unaligned_load<uint32_t>(_buffer.data() + fbe_full_offset);
    if (fbe_map_size == 0)
        return 4;

    size_t size = 4;
    FinalModel<TKey> fbe_model_key(_buffer, fbe_offset() + 4);
    FinalModel<TValue> fbe_model_value(_buffer, fbe_offset() + 4);
    for (size_t i = 0; i < fbe_map_size; ++i)
    {
        TKey key{};
        TValue value{};
        if constexpr (std::is_constructible_v<TKey, std::pmr::memory_resource*>) {
            key = TKey(resource);
        }
        if constexpr (std::is_constructible_v<TValue, std::pmr::memory_resource*>) {
            value = TValue(resource);
        }
        size_t offset_key = fbe_model_key.get(key, resource);
        fbe_model_key.fbe_shift(offset_key);
        fbe_model_value.fbe_shift(offset_key);
        size_t offset_value = fbe_model_value.get(value, resource);
        fbe_model_key.fbe_shift(offset_value);
        fbe_model_value.fbe_shift(offset_value);
        values.emplace(std::move(key), std::move(value));
        size += offset_key + offset_value;
    }
    return size;
}

template <typename TKey, typename TValue>
inline size_t FinalModelMap<TKey, TValue>::get(FBE::pmr::HashMap<TKey, TValue>& values, std::pmr::memory_resource* resource) const noexcept
{
    values.clear();

    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    size_t fbe_map_size = unaligned_load<uint32_t>(_buffer.data() + fbe_full_offset);
    if (fbe_map_size == 0)
        return 4;

    values.reserve(fbe_map_size);
    size_t size = 4;
    FinalModel<TKey> fbe_model_key(_buffer, fbe_offset() + 4);
    FinalModel<TValue> fbe_model_value(_buffer, fbe_offset() + 4);
    for (size_t i = 0; i < fbe_map_size; ++i)
    {
        TKey key{};
        TValue value{};
        if constexpr (std::is_constructible_v<TKey, std::pmr::memory_resource*>) {
            key = TKey(resource);
        }
        if constexpr (std::is_constructible_v<TValue, std::pmr::memory_resource*>) {
            value = TValue(resource);
        }
        size_t offset_key = fbe_model_key.get(key, resource);
        fbe_model_key.fbe_shift(offset_key);
        fbe_model_value.fbe_shift(offset_key);
        size_t offset_value = fbe_model_value.get(value, resource);
        fbe_model_key.fbe_shift(offset_value);
        fbe_model_value.fbe_shift(offset_value);
        values.emplace(std::move(key), std::move(value));
        size += offset_key + offset_value;
    }
    return size;
}

// PMR set methods
template <typename TKey, typename TValue>
inline size_t FinalModelMap<TKey, TValue>::set(const std::pmr::map<TKey, TValue>& values) noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + fbe_full_offset, (uint32_t)values.size());

    size_t size = 4;
    FinalModel<TKey> fbe_model_key(_buffer, fbe_offset() + 4);
    FinalModel<TValue> fbe_model_value(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
    {
        size_t offset_key = fbe_model_key.set(value.first);
        fbe_model_key.fbe_shift(offset_key);
        fbe_model_value.fbe_shift(offset_key);
        size_t offset_value = fbe_model_value.set(value.second);
        fbe_model_key.fbe_shift(offset_value);
        fbe_model_value.fbe_shift(offset_value);
        size += offset_key + offset_value;
    }
    return size;
}

template <typename TKey, typename TValue>
inline size_t FinalModelMap<TKey, TValue>::set(const FBE::pmr::HashMap<TKey, TValue>& values) noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + fbe_full_offset, (uint32_t)values.size());

    size_t size = 4;
    FinalModel<TKey> fbe_model_key(_buffer, fbe_offset() + 4);
    FinalModel<TValue> fbe_model_value(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
    {
        size_t offset_key = fbe_model_key.set(value.first);
        fbe_model_key.fbe_shift(offset_key);
        fbe_model_value.fbe_shift(offset_key);
        size_t offset_value = fbe_model_value.set(value.second);
        fbe_model_key.fbe_shift(offset_value);
        fbe_model_value.fbe_shift(offset_value);
        size += offset_key + offset_value;
    }
    return size;
}

#if defined(USING_BTREE_MAP)
template <typename TKey, typename TValue>
inline size_t FinalModelMap<TKey, TValue>::fbe_allocation_size(const FBE::map<TKey, TValue>& values) const noexcept
{
    size_t size = 4;
    FinalModel<TKey> fbe_model_key(_buffer, fbe_offset() + 4);
    FinalModel<TValue> fbe_model_value(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
        size += fbe_model_key.fbe_allocation_size(value.first) + fbe_model_value.fbe_allocation_size(value.second);
    return size;
}

template <typename TKey, typename TValue>
inline size_t FinalModelMap<TKey, TValue>::get(FBE::map<TKey, TValue>& values) const noexcept
{
    values.clear();

    assert(((_buffer.offset() + fbe_offset() + 4) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
        return 0;

    uint32_t fbe_map_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());

    size_t size = 4;
    FinalModel<TKey> fbe_model_key(_buffer, fbe_offset() + 4);
    FinalModel<TValue> fbe_model_value(_buffer, fbe_offset() + 4);
    for (size_t i = 0; i < fbe_map_size; ++i)
    {
        TKey key = TKey();
        TValue value = TValue();
        size_t offset_key = fbe_model_key.get(key);
        fbe_model_key.fbe_shift(offset_key);
        fbe_model_value.fbe_shift(offset_key);
        size_t offset_value = fbe_model_value.get(value);
        fbe_model_key.fbe_shift(offset_value);
        fbe_model_value.fbe_shift(offset_value);
        values.emplace(std::move(key), std::move(value));
        size += offset_key + offset_value;
    }
    return size;
}

template <typename TKey, typename TValue>
inline size_t FinalModelMap<TKey, TValue>::set(const FBE::map<TKey, TValue>& values) noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + fbe_full_offset, (uint32_t)values.size());

    size_t size = 4;
    FinalModel<TKey> fbe_model_key(_buffer, fbe_offset() + 4);
    FinalModel<TValue> fbe_model_value(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
    {
        size_t offset_key = fbe_model_key.set(value.first);
        fbe_model_key.fbe_shift(offset_key);
        fbe_model_value.fbe_shift(offset_key);
        size_t offset_value = fbe_model_value.set(value.second);
        fbe_model_key.fbe_shift(offset_value);
        fbe_model_value.fbe_shift(offset_value);
        size += offset_key + offset_value;
    }
    return size;
}

// FBE::pmr::map PMR methods
template <typename TKey, typename TValue>
inline size_t FinalModelMap<TKey, TValue>::fbe_allocation_size(const FBE::pmr::map<TKey, TValue>& values) const noexcept
{
    size_t size = 4;
    FinalModel<TKey> fbe_model_key(_buffer, fbe_offset() + 4);
    FinalModel<TValue> fbe_model_value(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
        size += fbe_model_key.fbe_allocation_size(value.first) + fbe_model_value.fbe_allocation_size(value.second);
    return size;
}

template <typename TKey, typename TValue>
inline size_t FinalModelMap<TKey, TValue>::get(FBE::pmr::map<TKey, TValue>& values, std::pmr::memory_resource* resource) const noexcept
{
    values.clear();

    assert(((_buffer.offset() + fbe_offset() + 4) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
        return 0;

    uint32_t fbe_map_size = unaligned_load<uint32_t>(_buffer.data() + _buffer.offset() + fbe_offset());

    size_t size = 4;
    FinalModel<TKey> fbe_model_key(_buffer, fbe_offset() + 4);
    FinalModel<TValue> fbe_model_value(_buffer, fbe_offset() + 4);
    for (size_t i = 0; i < fbe_map_size; ++i)
    {
        TKey key{};
        TValue value{};
        if constexpr (std::is_constructible_v<TKey, std::pmr::memory_resource*>) {
            key = TKey(resource);
        }
        if constexpr (std::is_constructible_v<TValue, std::pmr::memory_resource*>) {
            value = TValue(resource);
        }
        size_t offset_key = fbe_model_key.get(key, resource);
        fbe_model_key.fbe_shift(offset_key);
        fbe_model_value.fbe_shift(offset_key);
        size_t offset_value = fbe_model_value.get(value, resource);
        fbe_model_key.fbe_shift(offset_value);
        fbe_model_value.fbe_shift(offset_value);
        values.emplace(std::move(key), std::move(value));
        size += offset_key + offset_value;
    }
    return size;
}

template <typename TKey, typename TValue>
inline size_t FinalModelMap<TKey, TValue>::set(const FBE::pmr::map<TKey, TValue>& values) noexcept
{
    size_t fbe_full_offset = _buffer.offset() + fbe_offset();
    assert(((fbe_full_offset + 4) <= _buffer.size()) && "Model is broken!");
    if ((fbe_full_offset + 4) > _buffer.size())
        return 0;

    unaligned_store<uint32_t>(_buffer.data() + fbe_full_offset, (uint32_t)values.size());

    size_t size = 4;
    FinalModel<TKey> fbe_model_key(_buffer, fbe_offset() + 4);
    FinalModel<TValue> fbe_model_value(_buffer, fbe_offset() + 4);
    for (const auto& value : values)
    {
        size_t offset_key = fbe_model_key.set(value.first);
        fbe_model_key.fbe_shift(offset_key);
        fbe_model_value.fbe_shift(offset_key);
        size_t offset_value = fbe_model_value.set(value.second);
        fbe_model_key.fbe_shift(offset_value);
        fbe_model_value.fbe_shift(offset_value);
        size += offset_key + offset_value;
    }
    return size;
}
#endif

} // namespace FBE
