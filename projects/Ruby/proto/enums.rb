#------------------------------------------------------------------------------
# Automatically generated by the Fast Binary Encoding compiler, do not modify!
# https://github.com/chronoxor/FastBinaryEncoding
# Source: enums.fbe
# FBE version: 1.10.0.0
#------------------------------------------------------------------------------

# rubocop:disable Lint/MissingCopEnableDirective
# rubocop:disable Lint/UnneededCopDisableDirective
# rubocop:disable Metrics/AbcSize
# rubocop:disable Metrics/ClassLength
# rubocop:disable Metrics/CyclomaticComplexity
# rubocop:disable Metrics/LineLength
# rubocop:disable Metrics/MethodLength
# rubocop:disable Metrics/PerceivedComplexity

require 'base64'
require 'bigdecimal'
require 'json'
require 'set'
require 'uuidtools'

require_relative 'fbe'

module Enums

  module EnumByte
    class Enum
      include FBE::Enum

      define :ENUM_VALUE_0, 0 + 0
      define :ENUM_VALUE_1, 0 + 0
      define :ENUM_VALUE_2, 0 + 1
      define :ENUM_VALUE_3, 254 + 0
      define :ENUM_VALUE_4, 254 + 1
      define :ENUM_VALUE_5, Enum.value(:ENUM_VALUE_3)

      def initialize(value = 0)
        @value = value.is_a?(Enum) ? value.value : value
      end

      # Enum compare operators
      def ==(value) @value == value.value end
      def !=(value) @value != value.value end

      # Enum equals
      def eql?(other)
        self == other
      end

      # Enum hash code
      def hash
        @value.hash
      end

      # Get enum integer value
      def to_i
        @value
      end

      # Get enum string value
      def to_s
        if @value == Enum.ENUM_VALUE_0
          return 'ENUM_VALUE_0'
        end
        if @value == Enum.ENUM_VALUE_1
          return 'ENUM_VALUE_1'
        end
        if @value == Enum.ENUM_VALUE_2
          return 'ENUM_VALUE_2'
        end
        if @value == Enum.ENUM_VALUE_3
          return 'ENUM_VALUE_3'
        end
        if @value == Enum.ENUM_VALUE_4
          return 'ENUM_VALUE_4'
        end
        if @value == Enum.ENUM_VALUE_5
          return 'ENUM_VALUE_5'
        end
        '<unknown>'
      end

      # Get enum JSON value
      def __to_json_map__
        @value
      end
    end

    class << self
      attr_accessor :ENUM_VALUE_0
      attr_accessor :ENUM_VALUE_1
      attr_accessor :ENUM_VALUE_2
      attr_accessor :ENUM_VALUE_3
      attr_accessor :ENUM_VALUE_4
      attr_accessor :ENUM_VALUE_5
    end

    self.ENUM_VALUE_0 = Enum.new(Enum.ENUM_VALUE_0)
    self.ENUM_VALUE_1 = Enum.new(Enum.ENUM_VALUE_1)
    self.ENUM_VALUE_2 = Enum.new(Enum.ENUM_VALUE_2)
    self.ENUM_VALUE_3 = Enum.new(Enum.ENUM_VALUE_3)
    self.ENUM_VALUE_4 = Enum.new(Enum.ENUM_VALUE_4)
    self.ENUM_VALUE_5 = Enum.new(Enum.ENUM_VALUE_5)

    def self.new(value = 0)
      Enum.new(value)
    end

    # Get enum value from JSON
    def self.__from_json_map__(json)
      Enum.new(json)
    end
  end

  EnumByte.freeze

  # Fast Binary Encoding EnumByte field model
  class FieldModelEnumByte < FBE::FieldModel
    def initialize(buffer, offset)
        super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      1
    end

    # Get the value
    def get(defaults = EnumByte.new)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      EnumByte.new(read_byte(fbe_offset))
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_byte(fbe_offset, value.value)
    end
  end

  # Fast Binary Encoding EnumByte final model
  class FinalModelEnumByte < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      1
    end

    # Is the enum value valid?
    def valid?
      verify
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return FBE::Integer::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [EnumByte.new, 0]
      end

      [EnumByte.new(read_byte(fbe_offset)), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_byte(fbe_offset, value.value)
      fbe_size
    end
  end

  module EnumChar
    class Enum
      include FBE::Enum

      define :ENUM_VALUE_0, 0 + 0
      define :ENUM_VALUE_1, '1'.ord + 0
      define :ENUM_VALUE_2, '1'.ord + 1
      define :ENUM_VALUE_3, '3'.ord + 0
      define :ENUM_VALUE_4, '3'.ord + 1
      define :ENUM_VALUE_5, Enum.value(:ENUM_VALUE_3)

      def initialize(value = 0)
        @value = value.is_a?(Enum) ? value.value : value
      end

      # Enum compare operators
      def ==(value) @value == value.value end
      def !=(value) @value != value.value end

      # Enum equals
      def eql?(other)
        self == other
      end

      # Enum hash code
      def hash
        @value.hash
      end

      # Get enum integer value
      def to_i
        @value
      end

      # Get enum string value
      def to_s
        if @value == Enum.ENUM_VALUE_0
          return 'ENUM_VALUE_0'
        end
        if @value == Enum.ENUM_VALUE_1
          return 'ENUM_VALUE_1'
        end
        if @value == Enum.ENUM_VALUE_2
          return 'ENUM_VALUE_2'
        end
        if @value == Enum.ENUM_VALUE_3
          return 'ENUM_VALUE_3'
        end
        if @value == Enum.ENUM_VALUE_4
          return 'ENUM_VALUE_4'
        end
        if @value == Enum.ENUM_VALUE_5
          return 'ENUM_VALUE_5'
        end
        '<unknown>'
      end

      # Get enum JSON value
      def __to_json_map__
        @value
      end
    end

    class << self
      attr_accessor :ENUM_VALUE_0
      attr_accessor :ENUM_VALUE_1
      attr_accessor :ENUM_VALUE_2
      attr_accessor :ENUM_VALUE_3
      attr_accessor :ENUM_VALUE_4
      attr_accessor :ENUM_VALUE_5
    end

    self.ENUM_VALUE_0 = Enum.new(Enum.ENUM_VALUE_0)
    self.ENUM_VALUE_1 = Enum.new(Enum.ENUM_VALUE_1)
    self.ENUM_VALUE_2 = Enum.new(Enum.ENUM_VALUE_2)
    self.ENUM_VALUE_3 = Enum.new(Enum.ENUM_VALUE_3)
    self.ENUM_VALUE_4 = Enum.new(Enum.ENUM_VALUE_4)
    self.ENUM_VALUE_5 = Enum.new(Enum.ENUM_VALUE_5)

    def self.new(value = 0)
      Enum.new(value)
    end

    # Get enum value from JSON
    def self.__from_json_map__(json)
      Enum.new(json)
    end
  end

  EnumChar.freeze

  # Fast Binary Encoding EnumChar field model
  class FieldModelEnumChar < FBE::FieldModel
    def initialize(buffer, offset)
        super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      1
    end

    # Get the value
    def get(defaults = EnumChar.new)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      EnumChar.new(read_uint8(fbe_offset))
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_uint8(fbe_offset, value.value)
    end
  end

  # Fast Binary Encoding EnumChar final model
  class FinalModelEnumChar < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      1
    end

    # Is the enum value valid?
    def valid?
      verify
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return FBE::Integer::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [EnumChar.new, 0]
      end

      [EnumChar.new(read_uint8(fbe_offset)), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_uint8(fbe_offset, value.value)
      fbe_size
    end
  end

  module EnumWChar
    class Enum
      include FBE::Enum

      define :ENUM_VALUE_0, 0 + 0
      define :ENUM_VALUE_1, 0x0444 + 0
      define :ENUM_VALUE_2, 0x0444 + 1
      define :ENUM_VALUE_3, 0x0555 + 0
      define :ENUM_VALUE_4, 0x0555 + 1
      define :ENUM_VALUE_5, Enum.value(:ENUM_VALUE_3)

      def initialize(value = 0)
        @value = value.is_a?(Enum) ? value.value : value
      end

      # Enum compare operators
      def ==(value) @value == value.value end
      def !=(value) @value != value.value end

      # Enum equals
      def eql?(other)
        self == other
      end

      # Enum hash code
      def hash
        @value.hash
      end

      # Get enum integer value
      def to_i
        @value
      end

      # Get enum string value
      def to_s
        if @value == Enum.ENUM_VALUE_0
          return 'ENUM_VALUE_0'
        end
        if @value == Enum.ENUM_VALUE_1
          return 'ENUM_VALUE_1'
        end
        if @value == Enum.ENUM_VALUE_2
          return 'ENUM_VALUE_2'
        end
        if @value == Enum.ENUM_VALUE_3
          return 'ENUM_VALUE_3'
        end
        if @value == Enum.ENUM_VALUE_4
          return 'ENUM_VALUE_4'
        end
        if @value == Enum.ENUM_VALUE_5
          return 'ENUM_VALUE_5'
        end
        '<unknown>'
      end

      # Get enum JSON value
      def __to_json_map__
        @value
      end
    end

    class << self
      attr_accessor :ENUM_VALUE_0
      attr_accessor :ENUM_VALUE_1
      attr_accessor :ENUM_VALUE_2
      attr_accessor :ENUM_VALUE_3
      attr_accessor :ENUM_VALUE_4
      attr_accessor :ENUM_VALUE_5
    end

    self.ENUM_VALUE_0 = Enum.new(Enum.ENUM_VALUE_0)
    self.ENUM_VALUE_1 = Enum.new(Enum.ENUM_VALUE_1)
    self.ENUM_VALUE_2 = Enum.new(Enum.ENUM_VALUE_2)
    self.ENUM_VALUE_3 = Enum.new(Enum.ENUM_VALUE_3)
    self.ENUM_VALUE_4 = Enum.new(Enum.ENUM_VALUE_4)
    self.ENUM_VALUE_5 = Enum.new(Enum.ENUM_VALUE_5)

    def self.new(value = 0)
      Enum.new(value)
    end

    # Get enum value from JSON
    def self.__from_json_map__(json)
      Enum.new(json)
    end
  end

  EnumWChar.freeze

  # Fast Binary Encoding EnumWChar field model
  class FieldModelEnumWChar < FBE::FieldModel
    def initialize(buffer, offset)
        super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      4
    end

    # Get the value
    def get(defaults = EnumWChar.new)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      EnumWChar.new(read_uint32(fbe_offset))
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_uint32(fbe_offset, value.value)
    end
  end

  # Fast Binary Encoding EnumWChar final model
  class FinalModelEnumWChar < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      4
    end

    # Is the enum value valid?
    def valid?
      verify
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return FBE::Integer::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [EnumWChar.new, 0]
      end

      [EnumWChar.new(read_uint32(fbe_offset)), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_uint32(fbe_offset, value.value)
      fbe_size
    end
  end

  module EnumInt8
    class Enum
      include FBE::Enum

      define :ENUM_VALUE_0, 0 + 0
      define :ENUM_VALUE_1, -128 + 0
      define :ENUM_VALUE_2, -128 + 1
      define :ENUM_VALUE_3, 126 + 0
      define :ENUM_VALUE_4, 126 + 1
      define :ENUM_VALUE_5, Enum.value(:ENUM_VALUE_3)

      def initialize(value = 0)
        @value = value.is_a?(Enum) ? value.value : value
      end

      # Enum compare operators
      def ==(value) @value == value.value end
      def !=(value) @value != value.value end

      # Enum equals
      def eql?(other)
        self == other
      end

      # Enum hash code
      def hash
        @value.hash
      end

      # Get enum integer value
      def to_i
        @value
      end

      # Get enum string value
      def to_s
        if @value == Enum.ENUM_VALUE_0
          return 'ENUM_VALUE_0'
        end
        if @value == Enum.ENUM_VALUE_1
          return 'ENUM_VALUE_1'
        end
        if @value == Enum.ENUM_VALUE_2
          return 'ENUM_VALUE_2'
        end
        if @value == Enum.ENUM_VALUE_3
          return 'ENUM_VALUE_3'
        end
        if @value == Enum.ENUM_VALUE_4
          return 'ENUM_VALUE_4'
        end
        if @value == Enum.ENUM_VALUE_5
          return 'ENUM_VALUE_5'
        end
        '<unknown>'
      end

      # Get enum JSON value
      def __to_json_map__
        @value
      end
    end

    class << self
      attr_accessor :ENUM_VALUE_0
      attr_accessor :ENUM_VALUE_1
      attr_accessor :ENUM_VALUE_2
      attr_accessor :ENUM_VALUE_3
      attr_accessor :ENUM_VALUE_4
      attr_accessor :ENUM_VALUE_5
    end

    self.ENUM_VALUE_0 = Enum.new(Enum.ENUM_VALUE_0)
    self.ENUM_VALUE_1 = Enum.new(Enum.ENUM_VALUE_1)
    self.ENUM_VALUE_2 = Enum.new(Enum.ENUM_VALUE_2)
    self.ENUM_VALUE_3 = Enum.new(Enum.ENUM_VALUE_3)
    self.ENUM_VALUE_4 = Enum.new(Enum.ENUM_VALUE_4)
    self.ENUM_VALUE_5 = Enum.new(Enum.ENUM_VALUE_5)

    def self.new(value = 0)
      Enum.new(value)
    end

    # Get enum value from JSON
    def self.__from_json_map__(json)
      Enum.new(json)
    end
  end

  EnumInt8.freeze

  # Fast Binary Encoding EnumInt8 field model
  class FieldModelEnumInt8 < FBE::FieldModel
    def initialize(buffer, offset)
        super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      1
    end

    # Get the value
    def get(defaults = EnumInt8.new)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      EnumInt8.new(read_int8(fbe_offset))
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_int8(fbe_offset, value.value)
    end
  end

  # Fast Binary Encoding EnumInt8 final model
  class FinalModelEnumInt8 < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      1
    end

    # Is the enum value valid?
    def valid?
      verify
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return FBE::Integer::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [EnumInt8.new, 0]
      end

      [EnumInt8.new(read_int8(fbe_offset)), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_int8(fbe_offset, value.value)
      fbe_size
    end
  end

  module EnumUInt8
    class Enum
      include FBE::Enum

      define :ENUM_VALUE_0, 0 + 0
      define :ENUM_VALUE_1, 0 + 0
      define :ENUM_VALUE_2, 0 + 1
      define :ENUM_VALUE_3, 254 + 0
      define :ENUM_VALUE_4, 254 + 1
      define :ENUM_VALUE_5, Enum.value(:ENUM_VALUE_3)

      def initialize(value = 0)
        @value = value.is_a?(Enum) ? value.value : value
      end

      # Enum compare operators
      def ==(value) @value == value.value end
      def !=(value) @value != value.value end

      # Enum equals
      def eql?(other)
        self == other
      end

      # Enum hash code
      def hash
        @value.hash
      end

      # Get enum integer value
      def to_i
        @value
      end

      # Get enum string value
      def to_s
        if @value == Enum.ENUM_VALUE_0
          return 'ENUM_VALUE_0'
        end
        if @value == Enum.ENUM_VALUE_1
          return 'ENUM_VALUE_1'
        end
        if @value == Enum.ENUM_VALUE_2
          return 'ENUM_VALUE_2'
        end
        if @value == Enum.ENUM_VALUE_3
          return 'ENUM_VALUE_3'
        end
        if @value == Enum.ENUM_VALUE_4
          return 'ENUM_VALUE_4'
        end
        if @value == Enum.ENUM_VALUE_5
          return 'ENUM_VALUE_5'
        end
        '<unknown>'
      end

      # Get enum JSON value
      def __to_json_map__
        @value
      end
    end

    class << self
      attr_accessor :ENUM_VALUE_0
      attr_accessor :ENUM_VALUE_1
      attr_accessor :ENUM_VALUE_2
      attr_accessor :ENUM_VALUE_3
      attr_accessor :ENUM_VALUE_4
      attr_accessor :ENUM_VALUE_5
    end

    self.ENUM_VALUE_0 = Enum.new(Enum.ENUM_VALUE_0)
    self.ENUM_VALUE_1 = Enum.new(Enum.ENUM_VALUE_1)
    self.ENUM_VALUE_2 = Enum.new(Enum.ENUM_VALUE_2)
    self.ENUM_VALUE_3 = Enum.new(Enum.ENUM_VALUE_3)
    self.ENUM_VALUE_4 = Enum.new(Enum.ENUM_VALUE_4)
    self.ENUM_VALUE_5 = Enum.new(Enum.ENUM_VALUE_5)

    def self.new(value = 0)
      Enum.new(value)
    end

    # Get enum value from JSON
    def self.__from_json_map__(json)
      Enum.new(json)
    end
  end

  EnumUInt8.freeze

  # Fast Binary Encoding EnumUInt8 field model
  class FieldModelEnumUInt8 < FBE::FieldModel
    def initialize(buffer, offset)
        super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      1
    end

    # Get the value
    def get(defaults = EnumUInt8.new)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      EnumUInt8.new(read_uint8(fbe_offset))
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_uint8(fbe_offset, value.value)
    end
  end

  # Fast Binary Encoding EnumUInt8 final model
  class FinalModelEnumUInt8 < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      1
    end

    # Is the enum value valid?
    def valid?
      verify
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return FBE::Integer::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [EnumUInt8.new, 0]
      end

      [EnumUInt8.new(read_uint8(fbe_offset)), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_uint8(fbe_offset, value.value)
      fbe_size
    end
  end

  module EnumInt16
    class Enum
      include FBE::Enum

      define :ENUM_VALUE_0, 0 + 0
      define :ENUM_VALUE_1, -32768 + 0
      define :ENUM_VALUE_2, -32768 + 1
      define :ENUM_VALUE_3, 32766 + 0
      define :ENUM_VALUE_4, 32766 + 1
      define :ENUM_VALUE_5, Enum.value(:ENUM_VALUE_3)

      def initialize(value = 0)
        @value = value.is_a?(Enum) ? value.value : value
      end

      # Enum compare operators
      def ==(value) @value == value.value end
      def !=(value) @value != value.value end

      # Enum equals
      def eql?(other)
        self == other
      end

      # Enum hash code
      def hash
        @value.hash
      end

      # Get enum integer value
      def to_i
        @value
      end

      # Get enum string value
      def to_s
        if @value == Enum.ENUM_VALUE_0
          return 'ENUM_VALUE_0'
        end
        if @value == Enum.ENUM_VALUE_1
          return 'ENUM_VALUE_1'
        end
        if @value == Enum.ENUM_VALUE_2
          return 'ENUM_VALUE_2'
        end
        if @value == Enum.ENUM_VALUE_3
          return 'ENUM_VALUE_3'
        end
        if @value == Enum.ENUM_VALUE_4
          return 'ENUM_VALUE_4'
        end
        if @value == Enum.ENUM_VALUE_5
          return 'ENUM_VALUE_5'
        end
        '<unknown>'
      end

      # Get enum JSON value
      def __to_json_map__
        @value
      end
    end

    class << self
      attr_accessor :ENUM_VALUE_0
      attr_accessor :ENUM_VALUE_1
      attr_accessor :ENUM_VALUE_2
      attr_accessor :ENUM_VALUE_3
      attr_accessor :ENUM_VALUE_4
      attr_accessor :ENUM_VALUE_5
    end

    self.ENUM_VALUE_0 = Enum.new(Enum.ENUM_VALUE_0)
    self.ENUM_VALUE_1 = Enum.new(Enum.ENUM_VALUE_1)
    self.ENUM_VALUE_2 = Enum.new(Enum.ENUM_VALUE_2)
    self.ENUM_VALUE_3 = Enum.new(Enum.ENUM_VALUE_3)
    self.ENUM_VALUE_4 = Enum.new(Enum.ENUM_VALUE_4)
    self.ENUM_VALUE_5 = Enum.new(Enum.ENUM_VALUE_5)

    def self.new(value = 0)
      Enum.new(value)
    end

    # Get enum value from JSON
    def self.__from_json_map__(json)
      Enum.new(json)
    end
  end

  EnumInt16.freeze

  # Fast Binary Encoding EnumInt16 field model
  class FieldModelEnumInt16 < FBE::FieldModel
    def initialize(buffer, offset)
        super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      2
    end

    # Get the value
    def get(defaults = EnumInt16.new)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      EnumInt16.new(read_int16(fbe_offset))
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_int16(fbe_offset, value.value)
    end
  end

  # Fast Binary Encoding EnumInt16 final model
  class FinalModelEnumInt16 < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      2
    end

    # Is the enum value valid?
    def valid?
      verify
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return FBE::Integer::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [EnumInt16.new, 0]
      end

      [EnumInt16.new(read_int16(fbe_offset)), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_int16(fbe_offset, value.value)
      fbe_size
    end
  end

  module EnumUInt16
    class Enum
      include FBE::Enum

      define :ENUM_VALUE_0, 0 + 0
      define :ENUM_VALUE_1, 0 + 0
      define :ENUM_VALUE_2, 0 + 1
      define :ENUM_VALUE_3, 65534 + 0
      define :ENUM_VALUE_4, 65534 + 1
      define :ENUM_VALUE_5, Enum.value(:ENUM_VALUE_3)

      def initialize(value = 0)
        @value = value.is_a?(Enum) ? value.value : value
      end

      # Enum compare operators
      def ==(value) @value == value.value end
      def !=(value) @value != value.value end

      # Enum equals
      def eql?(other)
        self == other
      end

      # Enum hash code
      def hash
        @value.hash
      end

      # Get enum integer value
      def to_i
        @value
      end

      # Get enum string value
      def to_s
        if @value == Enum.ENUM_VALUE_0
          return 'ENUM_VALUE_0'
        end
        if @value == Enum.ENUM_VALUE_1
          return 'ENUM_VALUE_1'
        end
        if @value == Enum.ENUM_VALUE_2
          return 'ENUM_VALUE_2'
        end
        if @value == Enum.ENUM_VALUE_3
          return 'ENUM_VALUE_3'
        end
        if @value == Enum.ENUM_VALUE_4
          return 'ENUM_VALUE_4'
        end
        if @value == Enum.ENUM_VALUE_5
          return 'ENUM_VALUE_5'
        end
        '<unknown>'
      end

      # Get enum JSON value
      def __to_json_map__
        @value
      end
    end

    class << self
      attr_accessor :ENUM_VALUE_0
      attr_accessor :ENUM_VALUE_1
      attr_accessor :ENUM_VALUE_2
      attr_accessor :ENUM_VALUE_3
      attr_accessor :ENUM_VALUE_4
      attr_accessor :ENUM_VALUE_5
    end

    self.ENUM_VALUE_0 = Enum.new(Enum.ENUM_VALUE_0)
    self.ENUM_VALUE_1 = Enum.new(Enum.ENUM_VALUE_1)
    self.ENUM_VALUE_2 = Enum.new(Enum.ENUM_VALUE_2)
    self.ENUM_VALUE_3 = Enum.new(Enum.ENUM_VALUE_3)
    self.ENUM_VALUE_4 = Enum.new(Enum.ENUM_VALUE_4)
    self.ENUM_VALUE_5 = Enum.new(Enum.ENUM_VALUE_5)

    def self.new(value = 0)
      Enum.new(value)
    end

    # Get enum value from JSON
    def self.__from_json_map__(json)
      Enum.new(json)
    end
  end

  EnumUInt16.freeze

  # Fast Binary Encoding EnumUInt16 field model
  class FieldModelEnumUInt16 < FBE::FieldModel
    def initialize(buffer, offset)
        super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      2
    end

    # Get the value
    def get(defaults = EnumUInt16.new)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      EnumUInt16.new(read_uint16(fbe_offset))
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_uint16(fbe_offset, value.value)
    end
  end

  # Fast Binary Encoding EnumUInt16 final model
  class FinalModelEnumUInt16 < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      2
    end

    # Is the enum value valid?
    def valid?
      verify
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return FBE::Integer::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [EnumUInt16.new, 0]
      end

      [EnumUInt16.new(read_uint16(fbe_offset)), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_uint16(fbe_offset, value.value)
      fbe_size
    end
  end

  module EnumInt32
    class Enum
      include FBE::Enum

      define :ENUM_VALUE_0, 0 + 0
      define :ENUM_VALUE_1, -2147483648 + 0
      define :ENUM_VALUE_2, -2147483648 + 1
      define :ENUM_VALUE_3, 2147483646 + 0
      define :ENUM_VALUE_4, 2147483646 + 1
      define :ENUM_VALUE_5, Enum.value(:ENUM_VALUE_3)

      def initialize(value = 0)
        @value = value.is_a?(Enum) ? value.value : value
      end

      # Enum compare operators
      def ==(value) @value == value.value end
      def !=(value) @value != value.value end

      # Enum equals
      def eql?(other)
        self == other
      end

      # Enum hash code
      def hash
        @value.hash
      end

      # Get enum integer value
      def to_i
        @value
      end

      # Get enum string value
      def to_s
        if @value == Enum.ENUM_VALUE_0
          return 'ENUM_VALUE_0'
        end
        if @value == Enum.ENUM_VALUE_1
          return 'ENUM_VALUE_1'
        end
        if @value == Enum.ENUM_VALUE_2
          return 'ENUM_VALUE_2'
        end
        if @value == Enum.ENUM_VALUE_3
          return 'ENUM_VALUE_3'
        end
        if @value == Enum.ENUM_VALUE_4
          return 'ENUM_VALUE_4'
        end
        if @value == Enum.ENUM_VALUE_5
          return 'ENUM_VALUE_5'
        end
        '<unknown>'
      end

      # Get enum JSON value
      def __to_json_map__
        @value
      end
    end

    class << self
      attr_accessor :ENUM_VALUE_0
      attr_accessor :ENUM_VALUE_1
      attr_accessor :ENUM_VALUE_2
      attr_accessor :ENUM_VALUE_3
      attr_accessor :ENUM_VALUE_4
      attr_accessor :ENUM_VALUE_5
    end

    self.ENUM_VALUE_0 = Enum.new(Enum.ENUM_VALUE_0)
    self.ENUM_VALUE_1 = Enum.new(Enum.ENUM_VALUE_1)
    self.ENUM_VALUE_2 = Enum.new(Enum.ENUM_VALUE_2)
    self.ENUM_VALUE_3 = Enum.new(Enum.ENUM_VALUE_3)
    self.ENUM_VALUE_4 = Enum.new(Enum.ENUM_VALUE_4)
    self.ENUM_VALUE_5 = Enum.new(Enum.ENUM_VALUE_5)

    def self.new(value = 0)
      Enum.new(value)
    end

    # Get enum value from JSON
    def self.__from_json_map__(json)
      Enum.new(json)
    end
  end

  EnumInt32.freeze

  # Fast Binary Encoding EnumInt32 field model
  class FieldModelEnumInt32 < FBE::FieldModel
    def initialize(buffer, offset)
        super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      4
    end

    # Get the value
    def get(defaults = EnumInt32.new)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      EnumInt32.new(read_int32(fbe_offset))
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_int32(fbe_offset, value.value)
    end
  end

  # Fast Binary Encoding EnumInt32 final model
  class FinalModelEnumInt32 < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      4
    end

    # Is the enum value valid?
    def valid?
      verify
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return FBE::Integer::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [EnumInt32.new, 0]
      end

      [EnumInt32.new(read_int32(fbe_offset)), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_int32(fbe_offset, value.value)
      fbe_size
    end
  end

  module EnumUInt32
    class Enum
      include FBE::Enum

      define :ENUM_VALUE_0, 0 + 0
      define :ENUM_VALUE_1, 0 + 0
      define :ENUM_VALUE_2, 0 + 1
      define :ENUM_VALUE_3, 0xFFFFFFFE + 0
      define :ENUM_VALUE_4, 0xFFFFFFFE + 1
      define :ENUM_VALUE_5, Enum.value(:ENUM_VALUE_3)

      def initialize(value = 0)
        @value = value.is_a?(Enum) ? value.value : value
      end

      # Enum compare operators
      def ==(value) @value == value.value end
      def !=(value) @value != value.value end

      # Enum equals
      def eql?(other)
        self == other
      end

      # Enum hash code
      def hash
        @value.hash
      end

      # Get enum integer value
      def to_i
        @value
      end

      # Get enum string value
      def to_s
        if @value == Enum.ENUM_VALUE_0
          return 'ENUM_VALUE_0'
        end
        if @value == Enum.ENUM_VALUE_1
          return 'ENUM_VALUE_1'
        end
        if @value == Enum.ENUM_VALUE_2
          return 'ENUM_VALUE_2'
        end
        if @value == Enum.ENUM_VALUE_3
          return 'ENUM_VALUE_3'
        end
        if @value == Enum.ENUM_VALUE_4
          return 'ENUM_VALUE_4'
        end
        if @value == Enum.ENUM_VALUE_5
          return 'ENUM_VALUE_5'
        end
        '<unknown>'
      end

      # Get enum JSON value
      def __to_json_map__
        @value
      end
    end

    class << self
      attr_accessor :ENUM_VALUE_0
      attr_accessor :ENUM_VALUE_1
      attr_accessor :ENUM_VALUE_2
      attr_accessor :ENUM_VALUE_3
      attr_accessor :ENUM_VALUE_4
      attr_accessor :ENUM_VALUE_5
    end

    self.ENUM_VALUE_0 = Enum.new(Enum.ENUM_VALUE_0)
    self.ENUM_VALUE_1 = Enum.new(Enum.ENUM_VALUE_1)
    self.ENUM_VALUE_2 = Enum.new(Enum.ENUM_VALUE_2)
    self.ENUM_VALUE_3 = Enum.new(Enum.ENUM_VALUE_3)
    self.ENUM_VALUE_4 = Enum.new(Enum.ENUM_VALUE_4)
    self.ENUM_VALUE_5 = Enum.new(Enum.ENUM_VALUE_5)

    def self.new(value = 0)
      Enum.new(value)
    end

    # Get enum value from JSON
    def self.__from_json_map__(json)
      Enum.new(json)
    end
  end

  EnumUInt32.freeze

  # Fast Binary Encoding EnumUInt32 field model
  class FieldModelEnumUInt32 < FBE::FieldModel
    def initialize(buffer, offset)
        super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      4
    end

    # Get the value
    def get(defaults = EnumUInt32.new)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      EnumUInt32.new(read_uint32(fbe_offset))
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_uint32(fbe_offset, value.value)
    end
  end

  # Fast Binary Encoding EnumUInt32 final model
  class FinalModelEnumUInt32 < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      4
    end

    # Is the enum value valid?
    def valid?
      verify
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return FBE::Integer::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [EnumUInt32.new, 0]
      end

      [EnumUInt32.new(read_uint32(fbe_offset)), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_uint32(fbe_offset, value.value)
      fbe_size
    end
  end

  module EnumInt64
    class Enum
      include FBE::Enum

      define :ENUM_VALUE_0, 0 + 0
      define :ENUM_VALUE_1, -9223372036854775807 + 0
      define :ENUM_VALUE_2, -9223372036854775807 + 1
      define :ENUM_VALUE_3, 9223372036854775806 + 0
      define :ENUM_VALUE_4, 9223372036854775806 + 1
      define :ENUM_VALUE_5, Enum.value(:ENUM_VALUE_3)

      def initialize(value = 0)
        @value = value.is_a?(Enum) ? value.value : value
      end

      # Enum compare operators
      def ==(value) @value == value.value end
      def !=(value) @value != value.value end

      # Enum equals
      def eql?(other)
        self == other
      end

      # Enum hash code
      def hash
        @value.hash
      end

      # Get enum integer value
      def to_i
        @value
      end

      # Get enum string value
      def to_s
        if @value == Enum.ENUM_VALUE_0
          return 'ENUM_VALUE_0'
        end
        if @value == Enum.ENUM_VALUE_1
          return 'ENUM_VALUE_1'
        end
        if @value == Enum.ENUM_VALUE_2
          return 'ENUM_VALUE_2'
        end
        if @value == Enum.ENUM_VALUE_3
          return 'ENUM_VALUE_3'
        end
        if @value == Enum.ENUM_VALUE_4
          return 'ENUM_VALUE_4'
        end
        if @value == Enum.ENUM_VALUE_5
          return 'ENUM_VALUE_5'
        end
        '<unknown>'
      end

      # Get enum JSON value
      def __to_json_map__
        @value
      end
    end

    class << self
      attr_accessor :ENUM_VALUE_0
      attr_accessor :ENUM_VALUE_1
      attr_accessor :ENUM_VALUE_2
      attr_accessor :ENUM_VALUE_3
      attr_accessor :ENUM_VALUE_4
      attr_accessor :ENUM_VALUE_5
    end

    self.ENUM_VALUE_0 = Enum.new(Enum.ENUM_VALUE_0)
    self.ENUM_VALUE_1 = Enum.new(Enum.ENUM_VALUE_1)
    self.ENUM_VALUE_2 = Enum.new(Enum.ENUM_VALUE_2)
    self.ENUM_VALUE_3 = Enum.new(Enum.ENUM_VALUE_3)
    self.ENUM_VALUE_4 = Enum.new(Enum.ENUM_VALUE_4)
    self.ENUM_VALUE_5 = Enum.new(Enum.ENUM_VALUE_5)

    def self.new(value = 0)
      Enum.new(value)
    end

    # Get enum value from JSON
    def self.__from_json_map__(json)
      Enum.new(json)
    end
  end

  EnumInt64.freeze

  # Fast Binary Encoding EnumInt64 field model
  class FieldModelEnumInt64 < FBE::FieldModel
    def initialize(buffer, offset)
        super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      8
    end

    # Get the value
    def get(defaults = EnumInt64.new)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      EnumInt64.new(read_int64(fbe_offset))
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_int64(fbe_offset, value.value)
    end
  end

  # Fast Binary Encoding EnumInt64 final model
  class FinalModelEnumInt64 < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      8
    end

    # Is the enum value valid?
    def valid?
      verify
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return FBE::Integer::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [EnumInt64.new, 0]
      end

      [EnumInt64.new(read_int64(fbe_offset)), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_int64(fbe_offset, value.value)
      fbe_size
    end
  end

  module EnumUInt64
    class Enum
      include FBE::Enum

      define :ENUM_VALUE_0, 0 + 0
      define :ENUM_VALUE_1, 0 + 0
      define :ENUM_VALUE_2, 0 + 1
      define :ENUM_VALUE_3, 0xFFFFFFFFFFFFFFFE + 0
      define :ENUM_VALUE_4, 0xFFFFFFFFFFFFFFFE + 1
      define :ENUM_VALUE_5, Enum.value(:ENUM_VALUE_3)

      def initialize(value = 0)
        @value = value.is_a?(Enum) ? value.value : value
      end

      # Enum compare operators
      def ==(value) @value == value.value end
      def !=(value) @value != value.value end

      # Enum equals
      def eql?(other)
        self == other
      end

      # Enum hash code
      def hash
        @value.hash
      end

      # Get enum integer value
      def to_i
        @value
      end

      # Get enum string value
      def to_s
        if @value == Enum.ENUM_VALUE_0
          return 'ENUM_VALUE_0'
        end
        if @value == Enum.ENUM_VALUE_1
          return 'ENUM_VALUE_1'
        end
        if @value == Enum.ENUM_VALUE_2
          return 'ENUM_VALUE_2'
        end
        if @value == Enum.ENUM_VALUE_3
          return 'ENUM_VALUE_3'
        end
        if @value == Enum.ENUM_VALUE_4
          return 'ENUM_VALUE_4'
        end
        if @value == Enum.ENUM_VALUE_5
          return 'ENUM_VALUE_5'
        end
        '<unknown>'
      end

      # Get enum JSON value
      def __to_json_map__
        @value
      end
    end

    class << self
      attr_accessor :ENUM_VALUE_0
      attr_accessor :ENUM_VALUE_1
      attr_accessor :ENUM_VALUE_2
      attr_accessor :ENUM_VALUE_3
      attr_accessor :ENUM_VALUE_4
      attr_accessor :ENUM_VALUE_5
    end

    self.ENUM_VALUE_0 = Enum.new(Enum.ENUM_VALUE_0)
    self.ENUM_VALUE_1 = Enum.new(Enum.ENUM_VALUE_1)
    self.ENUM_VALUE_2 = Enum.new(Enum.ENUM_VALUE_2)
    self.ENUM_VALUE_3 = Enum.new(Enum.ENUM_VALUE_3)
    self.ENUM_VALUE_4 = Enum.new(Enum.ENUM_VALUE_4)
    self.ENUM_VALUE_5 = Enum.new(Enum.ENUM_VALUE_5)

    def self.new(value = 0)
      Enum.new(value)
    end

    # Get enum value from JSON
    def self.__from_json_map__(json)
      Enum.new(json)
    end
  end

  EnumUInt64.freeze

  # Fast Binary Encoding EnumUInt64 field model
  class FieldModelEnumUInt64 < FBE::FieldModel
    def initialize(buffer, offset)
        super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      8
    end

    # Get the value
    def get(defaults = EnumUInt64.new)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      EnumUInt64.new(read_uint64(fbe_offset))
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_uint64(fbe_offset, value.value)
    end
  end

  # Fast Binary Encoding EnumUInt64 final model
  class FinalModelEnumUInt64 < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      8
    end

    # Is the enum value valid?
    def valid?
      verify
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return FBE::Integer::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [EnumUInt64.new, 0]
      end

      [EnumUInt64.new(read_uint64(fbe_offset)), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_uint64(fbe_offset, value.value)
      fbe_size
    end
  end

  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class Enums
    include Comparable

    attr_accessor :byte0
    attr_accessor :byte1
    attr_accessor :byte2
    attr_accessor :byte3
    attr_accessor :byte4
    attr_accessor :byte5
    attr_accessor :char0
    attr_accessor :char1
    attr_accessor :char2
    attr_accessor :char3
    attr_accessor :char4
    attr_accessor :char5
    attr_accessor :wchar0
    attr_accessor :wchar1
    attr_accessor :wchar2
    attr_accessor :wchar3
    attr_accessor :wchar4
    attr_accessor :wchar5
    attr_accessor :int8b0
    attr_accessor :int8b1
    attr_accessor :int8b2
    attr_accessor :int8b3
    attr_accessor :int8b4
    attr_accessor :int8b5
    attr_accessor :uint8b0
    attr_accessor :uint8b1
    attr_accessor :uint8b2
    attr_accessor :uint8b3
    attr_accessor :uint8b4
    attr_accessor :uint8b5
    attr_accessor :int16b0
    attr_accessor :int16b1
    attr_accessor :int16b2
    attr_accessor :int16b3
    attr_accessor :int16b4
    attr_accessor :int16b5
    attr_accessor :uint16b0
    attr_accessor :uint16b1
    attr_accessor :uint16b2
    attr_accessor :uint16b3
    attr_accessor :uint16b4
    attr_accessor :uint16b5
    attr_accessor :int32b0
    attr_accessor :int32b1
    attr_accessor :int32b2
    attr_accessor :int32b3
    attr_accessor :int32b4
    attr_accessor :int32b5
    attr_accessor :uint32b0
    attr_accessor :uint32b1
    attr_accessor :uint32b2
    attr_accessor :uint32b3
    attr_accessor :uint32b4
    attr_accessor :uint32b5
    attr_accessor :int64b0
    attr_accessor :int64b1
    attr_accessor :int64b2
    attr_accessor :int64b3
    attr_accessor :int64b4
    attr_accessor :int64b5
    attr_accessor :uint64b0
    attr_accessor :uint64b1
    attr_accessor :uint64b2
    attr_accessor :uint64b3
    attr_accessor :uint64b4
    attr_accessor :uint64b5

    def initialize(byte0 = EnumByte.ENUM_VALUE_0, byte1 = EnumByte.ENUM_VALUE_1, byte2 = EnumByte.ENUM_VALUE_2, byte3 = EnumByte.ENUM_VALUE_3, byte4 = EnumByte.ENUM_VALUE_4, byte5 = EnumByte.ENUM_VALUE_5, char0 = EnumChar.ENUM_VALUE_0, char1 = EnumChar.ENUM_VALUE_1, char2 = EnumChar.ENUM_VALUE_2, char3 = EnumChar.ENUM_VALUE_3, char4 = EnumChar.ENUM_VALUE_4, char5 = EnumChar.ENUM_VALUE_5, wchar0 = EnumWChar.ENUM_VALUE_0, wchar1 = EnumWChar.ENUM_VALUE_1, wchar2 = EnumWChar.ENUM_VALUE_2, wchar3 = EnumWChar.ENUM_VALUE_3, wchar4 = EnumWChar.ENUM_VALUE_4, wchar5 = EnumWChar.ENUM_VALUE_5, int8b0 = EnumInt8.ENUM_VALUE_0, int8b1 = EnumInt8.ENUM_VALUE_1, int8b2 = EnumInt8.ENUM_VALUE_2, int8b3 = EnumInt8.ENUM_VALUE_3, int8b4 = EnumInt8.ENUM_VALUE_4, int8b5 = EnumInt8.ENUM_VALUE_5, uint8b0 = EnumUInt8.ENUM_VALUE_0, uint8b1 = EnumUInt8.ENUM_VALUE_1, uint8b2 = EnumUInt8.ENUM_VALUE_2, uint8b3 = EnumUInt8.ENUM_VALUE_3, uint8b4 = EnumUInt8.ENUM_VALUE_4, uint8b5 = EnumUInt8.ENUM_VALUE_5, int16b0 = EnumInt16.ENUM_VALUE_0, int16b1 = EnumInt16.ENUM_VALUE_1, int16b2 = EnumInt16.ENUM_VALUE_2, int16b3 = EnumInt16.ENUM_VALUE_3, int16b4 = EnumInt16.ENUM_VALUE_4, int16b5 = EnumInt16.ENUM_VALUE_5, uint16b0 = EnumUInt16.ENUM_VALUE_0, uint16b1 = EnumUInt16.ENUM_VALUE_1, uint16b2 = EnumUInt16.ENUM_VALUE_2, uint16b3 = EnumUInt16.ENUM_VALUE_3, uint16b4 = EnumUInt16.ENUM_VALUE_4, uint16b5 = EnumUInt16.ENUM_VALUE_5, int32b0 = EnumInt32.ENUM_VALUE_0, int32b1 = EnumInt32.ENUM_VALUE_1, int32b2 = EnumInt32.ENUM_VALUE_2, int32b3 = EnumInt32.ENUM_VALUE_3, int32b4 = EnumInt32.ENUM_VALUE_4, int32b5 = EnumInt32.ENUM_VALUE_5, uint32b0 = EnumUInt32.ENUM_VALUE_0, uint32b1 = EnumUInt32.ENUM_VALUE_1, uint32b2 = EnumUInt32.ENUM_VALUE_2, uint32b3 = EnumUInt32.ENUM_VALUE_3, uint32b4 = EnumUInt32.ENUM_VALUE_4, uint32b5 = EnumUInt32.ENUM_VALUE_5, int64b0 = EnumInt64.ENUM_VALUE_0, int64b1 = EnumInt64.ENUM_VALUE_1, int64b2 = EnumInt64.ENUM_VALUE_2, int64b3 = EnumInt64.ENUM_VALUE_3, int64b4 = EnumInt64.ENUM_VALUE_4, int64b5 = EnumInt64.ENUM_VALUE_5, uint64b0 = EnumUInt64.ENUM_VALUE_0, uint64b1 = EnumUInt64.ENUM_VALUE_1, uint64b2 = EnumUInt64.ENUM_VALUE_2, uint64b3 = EnumUInt64.ENUM_VALUE_3, uint64b4 = EnumUInt64.ENUM_VALUE_4, uint64b5 = EnumUInt64.ENUM_VALUE_5)
      @byte0 = byte0
      @byte1 = byte1
      @byte2 = byte2
      @byte3 = byte3
      @byte4 = byte4
      @byte5 = byte5
      @char0 = char0
      @char1 = char1
      @char2 = char2
      @char3 = char3
      @char4 = char4
      @char5 = char5
      @wchar0 = wchar0
      @wchar1 = wchar1
      @wchar2 = wchar2
      @wchar3 = wchar3
      @wchar4 = wchar4
      @wchar5 = wchar5
      @int8b0 = int8b0
      @int8b1 = int8b1
      @int8b2 = int8b2
      @int8b3 = int8b3
      @int8b4 = int8b4
      @int8b5 = int8b5
      @uint8b0 = uint8b0
      @uint8b1 = uint8b1
      @uint8b2 = uint8b2
      @uint8b3 = uint8b3
      @uint8b4 = uint8b4
      @uint8b5 = uint8b5
      @int16b0 = int16b0
      @int16b1 = int16b1
      @int16b2 = int16b2
      @int16b3 = int16b3
      @int16b4 = int16b4
      @int16b5 = int16b5
      @uint16b0 = uint16b0
      @uint16b1 = uint16b1
      @uint16b2 = uint16b2
      @uint16b3 = uint16b3
      @uint16b4 = uint16b4
      @uint16b5 = uint16b5
      @int32b0 = int32b0
      @int32b1 = int32b1
      @int32b2 = int32b2
      @int32b3 = int32b3
      @int32b4 = int32b4
      @int32b5 = int32b5
      @uint32b0 = uint32b0
      @uint32b1 = uint32b1
      @uint32b2 = uint32b2
      @uint32b3 = uint32b3
      @uint32b4 = uint32b4
      @uint32b5 = uint32b5
      @int64b0 = int64b0
      @int64b1 = int64b1
      @int64b2 = int64b2
      @int64b3 = int64b3
      @int64b4 = int64b4
      @int64b5 = int64b5
      @uint64b0 = uint64b0
      @uint64b1 = uint64b1
      @uint64b2 = uint64b2
      @uint64b3 = uint64b3
      @uint64b4 = uint64b4
      @uint64b5 = uint64b5
    end

    def initialize_copy(other)
      @byte0 = other.byte0
      @byte1 = other.byte1
      @byte2 = other.byte2
      @byte3 = other.byte3
      @byte4 = other.byte4
      @byte5 = other.byte5
      @char0 = other.char0
      @char1 = other.char1
      @char2 = other.char2
      @char3 = other.char3
      @char4 = other.char4
      @char5 = other.char5
      @wchar0 = other.wchar0
      @wchar1 = other.wchar1
      @wchar2 = other.wchar2
      @wchar3 = other.wchar3
      @wchar4 = other.wchar4
      @wchar5 = other.wchar5
      @int8b0 = other.int8b0
      @int8b1 = other.int8b1
      @int8b2 = other.int8b2
      @int8b3 = other.int8b3
      @int8b4 = other.int8b4
      @int8b5 = other.int8b5
      @uint8b0 = other.uint8b0
      @uint8b1 = other.uint8b1
      @uint8b2 = other.uint8b2
      @uint8b3 = other.uint8b3
      @uint8b4 = other.uint8b4
      @uint8b5 = other.uint8b5
      @int16b0 = other.int16b0
      @int16b1 = other.int16b1
      @int16b2 = other.int16b2
      @int16b3 = other.int16b3
      @int16b4 = other.int16b4
      @int16b5 = other.int16b5
      @uint16b0 = other.uint16b0
      @uint16b1 = other.uint16b1
      @uint16b2 = other.uint16b2
      @uint16b3 = other.uint16b3
      @uint16b4 = other.uint16b4
      @uint16b5 = other.uint16b5
      @int32b0 = other.int32b0
      @int32b1 = other.int32b1
      @int32b2 = other.int32b2
      @int32b3 = other.int32b3
      @int32b4 = other.int32b4
      @int32b5 = other.int32b5
      @uint32b0 = other.uint32b0
      @uint32b1 = other.uint32b1
      @uint32b2 = other.uint32b2
      @uint32b3 = other.uint32b3
      @uint32b4 = other.uint32b4
      @uint32b5 = other.uint32b5
      @int64b0 = other.int64b0
      @int64b1 = other.int64b1
      @int64b2 = other.int64b2
      @int64b3 = other.int64b3
      @int64b4 = other.int64b4
      @int64b5 = other.int64b5
      @uint64b0 = other.uint64b0
      @uint64b1 = other.uint64b1
      @uint64b2 = other.uint64b2
      @uint64b3 = other.uint64b3
      @uint64b4 = other.uint64b4
      @uint64b5 = other.uint64b5
    end

    # Struct shallow copy
    def copy(other)
      initialize_copy(other)
      self
    end

    # Struct deep clone
    def clone
      data = Marshal.dump(self)
      clone = Marshal.load(data)
      clone.freeze if frozen?
      clone
    end

    # Struct compare operators
    def <=>(other)
      return nil unless other.is_a?(Enums)

      # noinspection RubyUnusedLocalVariable
      result = 0
      # noinspection RubyUnnecessaryReturnValue
      result
    end

    # Struct equals
    def eql?(other)
      self == other
    end

    # Struct keys
    def key
      result = []
      # noinspection RubyUnnecessaryReturnValue
      result
    end

    # Struct hash code
    def hash
      key.hash
    end

    # Get struct string value
    def to_s
      result = ''
      result << 'Enums('
      result << 'byte0='
      if !@byte0.nil?
        result << @byte0.to_s
      else
        result << 'null'
      end
      result << ',byte1='
      if !@byte1.nil?
        result << @byte1.to_s
      else
        result << 'null'
      end
      result << ',byte2='
      if !@byte2.nil?
        result << @byte2.to_s
      else
        result << 'null'
      end
      result << ',byte3='
      if !@byte3.nil?
        result << @byte3.to_s
      else
        result << 'null'
      end
      result << ',byte4='
      if !@byte4.nil?
        result << @byte4.to_s
      else
        result << 'null'
      end
      result << ',byte5='
      if !@byte5.nil?
        result << @byte5.to_s
      else
        result << 'null'
      end
      result << ',char0='
      if !@char0.nil?
        result << @char0.to_s
      else
        result << 'null'
      end
      result << ',char1='
      if !@char1.nil?
        result << @char1.to_s
      else
        result << 'null'
      end
      result << ',char2='
      if !@char2.nil?
        result << @char2.to_s
      else
        result << 'null'
      end
      result << ',char3='
      if !@char3.nil?
        result << @char3.to_s
      else
        result << 'null'
      end
      result << ',char4='
      if !@char4.nil?
        result << @char4.to_s
      else
        result << 'null'
      end
      result << ',char5='
      if !@char5.nil?
        result << @char5.to_s
      else
        result << 'null'
      end
      result << ',wchar0='
      if !@wchar0.nil?
        result << @wchar0.to_s
      else
        result << 'null'
      end
      result << ',wchar1='
      if !@wchar1.nil?
        result << @wchar1.to_s
      else
        result << 'null'
      end
      result << ',wchar2='
      if !@wchar2.nil?
        result << @wchar2.to_s
      else
        result << 'null'
      end
      result << ',wchar3='
      if !@wchar3.nil?
        result << @wchar3.to_s
      else
        result << 'null'
      end
      result << ',wchar4='
      if !@wchar4.nil?
        result << @wchar4.to_s
      else
        result << 'null'
      end
      result << ',wchar5='
      if !@wchar5.nil?
        result << @wchar5.to_s
      else
        result << 'null'
      end
      result << ',int8b0='
      if !@int8b0.nil?
        result << @int8b0.to_s
      else
        result << 'null'
      end
      result << ',int8b1='
      if !@int8b1.nil?
        result << @int8b1.to_s
      else
        result << 'null'
      end
      result << ',int8b2='
      if !@int8b2.nil?
        result << @int8b2.to_s
      else
        result << 'null'
      end
      result << ',int8b3='
      if !@int8b3.nil?
        result << @int8b3.to_s
      else
        result << 'null'
      end
      result << ',int8b4='
      if !@int8b4.nil?
        result << @int8b4.to_s
      else
        result << 'null'
      end
      result << ',int8b5='
      if !@int8b5.nil?
        result << @int8b5.to_s
      else
        result << 'null'
      end
      result << ',uint8b0='
      if !@uint8b0.nil?
        result << @uint8b0.to_s
      else
        result << 'null'
      end
      result << ',uint8b1='
      if !@uint8b1.nil?
        result << @uint8b1.to_s
      else
        result << 'null'
      end
      result << ',uint8b2='
      if !@uint8b2.nil?
        result << @uint8b2.to_s
      else
        result << 'null'
      end
      result << ',uint8b3='
      if !@uint8b3.nil?
        result << @uint8b3.to_s
      else
        result << 'null'
      end
      result << ',uint8b4='
      if !@uint8b4.nil?
        result << @uint8b4.to_s
      else
        result << 'null'
      end
      result << ',uint8b5='
      if !@uint8b5.nil?
        result << @uint8b5.to_s
      else
        result << 'null'
      end
      result << ',int16b0='
      if !@int16b0.nil?
        result << @int16b0.to_s
      else
        result << 'null'
      end
      result << ',int16b1='
      if !@int16b1.nil?
        result << @int16b1.to_s
      else
        result << 'null'
      end
      result << ',int16b2='
      if !@int16b2.nil?
        result << @int16b2.to_s
      else
        result << 'null'
      end
      result << ',int16b3='
      if !@int16b3.nil?
        result << @int16b3.to_s
      else
        result << 'null'
      end
      result << ',int16b4='
      if !@int16b4.nil?
        result << @int16b4.to_s
      else
        result << 'null'
      end
      result << ',int16b5='
      if !@int16b5.nil?
        result << @int16b5.to_s
      else
        result << 'null'
      end
      result << ',uint16b0='
      if !@uint16b0.nil?
        result << @uint16b0.to_s
      else
        result << 'null'
      end
      result << ',uint16b1='
      if !@uint16b1.nil?
        result << @uint16b1.to_s
      else
        result << 'null'
      end
      result << ',uint16b2='
      if !@uint16b2.nil?
        result << @uint16b2.to_s
      else
        result << 'null'
      end
      result << ',uint16b3='
      if !@uint16b3.nil?
        result << @uint16b3.to_s
      else
        result << 'null'
      end
      result << ',uint16b4='
      if !@uint16b4.nil?
        result << @uint16b4.to_s
      else
        result << 'null'
      end
      result << ',uint16b5='
      if !@uint16b5.nil?
        result << @uint16b5.to_s
      else
        result << 'null'
      end
      result << ',int32b0='
      if !@int32b0.nil?
        result << @int32b0.to_s
      else
        result << 'null'
      end
      result << ',int32b1='
      if !@int32b1.nil?
        result << @int32b1.to_s
      else
        result << 'null'
      end
      result << ',int32b2='
      if !@int32b2.nil?
        result << @int32b2.to_s
      else
        result << 'null'
      end
      result << ',int32b3='
      if !@int32b3.nil?
        result << @int32b3.to_s
      else
        result << 'null'
      end
      result << ',int32b4='
      if !@int32b4.nil?
        result << @int32b4.to_s
      else
        result << 'null'
      end
      result << ',int32b5='
      if !@int32b5.nil?
        result << @int32b5.to_s
      else
        result << 'null'
      end
      result << ',uint32b0='
      if !@uint32b0.nil?
        result << @uint32b0.to_s
      else
        result << 'null'
      end
      result << ',uint32b1='
      if !@uint32b1.nil?
        result << @uint32b1.to_s
      else
        result << 'null'
      end
      result << ',uint32b2='
      if !@uint32b2.nil?
        result << @uint32b2.to_s
      else
        result << 'null'
      end
      result << ',uint32b3='
      if !@uint32b3.nil?
        result << @uint32b3.to_s
      else
        result << 'null'
      end
      result << ',uint32b4='
      if !@uint32b4.nil?
        result << @uint32b4.to_s
      else
        result << 'null'
      end
      result << ',uint32b5='
      if !@uint32b5.nil?
        result << @uint32b5.to_s
      else
        result << 'null'
      end
      result << ',int64b0='
      if !@int64b0.nil?
        result << @int64b0.to_s
      else
        result << 'null'
      end
      result << ',int64b1='
      if !@int64b1.nil?
        result << @int64b1.to_s
      else
        result << 'null'
      end
      result << ',int64b2='
      if !@int64b2.nil?
        result << @int64b2.to_s
      else
        result << 'null'
      end
      result << ',int64b3='
      if !@int64b3.nil?
        result << @int64b3.to_s
      else
        result << 'null'
      end
      result << ',int64b4='
      if !@int64b4.nil?
        result << @int64b4.to_s
      else
        result << 'null'
      end
      result << ',int64b5='
      if !@int64b5.nil?
        result << @int64b5.to_s
      else
        result << 'null'
      end
      result << ',uint64b0='
      if !@uint64b0.nil?
        result << @uint64b0.to_s
      else
        result << 'null'
      end
      result << ',uint64b1='
      if !@uint64b1.nil?
        result << @uint64b1.to_s
      else
        result << 'null'
      end
      result << ',uint64b2='
      if !@uint64b2.nil?
        result << @uint64b2.to_s
      else
        result << 'null'
      end
      result << ',uint64b3='
      if !@uint64b3.nil?
        result << @uint64b3.to_s
      else
        result << 'null'
      end
      result << ',uint64b4='
      if !@uint64b4.nil?
        result << @uint64b4.to_s
      else
        result << 'null'
      end
      result << ',uint64b5='
      if !@uint64b5.nil?
        result << @uint64b5.to_s
      else
        result << 'null'
      end
      result << ')'
      result
    end

    # Dump the struct
    def marshal_dump
      # Serialize the struct to the FBE stream
      writer = EnumsModel.new(FBE::WriteBuffer.new)
      writer.serialize(self)
      writer.buffer
    end

    # Load the struct
    def marshal_load(data)
      # Deserialize the struct from the FBE stream
      reader = EnumsModel.new(FBE::ReadBuffer.new)
      reader.attach_buffer(data)
      initialize_copy(reader.deserialize[0])
    end

    # Get struct JSON value
    def to_json
      JSON.generate(__to_json_map__)
    end

    # Get struct JSON map (internal method)
    def __to_json_map__
      result = {}
      key = 'byte0'
      value = (byte0.nil? ? nil : byte0.__to_json_map__)
      result.store(key, value)
      key = 'byte1'
      value = (byte1.nil? ? nil : byte1.__to_json_map__)
      result.store(key, value)
      key = 'byte2'
      value = (byte2.nil? ? nil : byte2.__to_json_map__)
      result.store(key, value)
      key = 'byte3'
      value = (byte3.nil? ? nil : byte3.__to_json_map__)
      result.store(key, value)
      key = 'byte4'
      value = (byte4.nil? ? nil : byte4.__to_json_map__)
      result.store(key, value)
      key = 'byte5'
      value = (byte5.nil? ? nil : byte5.__to_json_map__)
      result.store(key, value)
      key = 'char0'
      value = (char0.nil? ? nil : char0.__to_json_map__)
      result.store(key, value)
      key = 'char1'
      value = (char1.nil? ? nil : char1.__to_json_map__)
      result.store(key, value)
      key = 'char2'
      value = (char2.nil? ? nil : char2.__to_json_map__)
      result.store(key, value)
      key = 'char3'
      value = (char3.nil? ? nil : char3.__to_json_map__)
      result.store(key, value)
      key = 'char4'
      value = (char4.nil? ? nil : char4.__to_json_map__)
      result.store(key, value)
      key = 'char5'
      value = (char5.nil? ? nil : char5.__to_json_map__)
      result.store(key, value)
      key = 'wchar0'
      value = (wchar0.nil? ? nil : wchar0.__to_json_map__)
      result.store(key, value)
      key = 'wchar1'
      value = (wchar1.nil? ? nil : wchar1.__to_json_map__)
      result.store(key, value)
      key = 'wchar2'
      value = (wchar2.nil? ? nil : wchar2.__to_json_map__)
      result.store(key, value)
      key = 'wchar3'
      value = (wchar3.nil? ? nil : wchar3.__to_json_map__)
      result.store(key, value)
      key = 'wchar4'
      value = (wchar4.nil? ? nil : wchar4.__to_json_map__)
      result.store(key, value)
      key = 'wchar5'
      value = (wchar5.nil? ? nil : wchar5.__to_json_map__)
      result.store(key, value)
      key = 'int8b0'
      value = (int8b0.nil? ? nil : int8b0.__to_json_map__)
      result.store(key, value)
      key = 'int8b1'
      value = (int8b1.nil? ? nil : int8b1.__to_json_map__)
      result.store(key, value)
      key = 'int8b2'
      value = (int8b2.nil? ? nil : int8b2.__to_json_map__)
      result.store(key, value)
      key = 'int8b3'
      value = (int8b3.nil? ? nil : int8b3.__to_json_map__)
      result.store(key, value)
      key = 'int8b4'
      value = (int8b4.nil? ? nil : int8b4.__to_json_map__)
      result.store(key, value)
      key = 'int8b5'
      value = (int8b5.nil? ? nil : int8b5.__to_json_map__)
      result.store(key, value)
      key = 'uint8b0'
      value = (uint8b0.nil? ? nil : uint8b0.__to_json_map__)
      result.store(key, value)
      key = 'uint8b1'
      value = (uint8b1.nil? ? nil : uint8b1.__to_json_map__)
      result.store(key, value)
      key = 'uint8b2'
      value = (uint8b2.nil? ? nil : uint8b2.__to_json_map__)
      result.store(key, value)
      key = 'uint8b3'
      value = (uint8b3.nil? ? nil : uint8b3.__to_json_map__)
      result.store(key, value)
      key = 'uint8b4'
      value = (uint8b4.nil? ? nil : uint8b4.__to_json_map__)
      result.store(key, value)
      key = 'uint8b5'
      value = (uint8b5.nil? ? nil : uint8b5.__to_json_map__)
      result.store(key, value)
      key = 'int16b0'
      value = (int16b0.nil? ? nil : int16b0.__to_json_map__)
      result.store(key, value)
      key = 'int16b1'
      value = (int16b1.nil? ? nil : int16b1.__to_json_map__)
      result.store(key, value)
      key = 'int16b2'
      value = (int16b2.nil? ? nil : int16b2.__to_json_map__)
      result.store(key, value)
      key = 'int16b3'
      value = (int16b3.nil? ? nil : int16b3.__to_json_map__)
      result.store(key, value)
      key = 'int16b4'
      value = (int16b4.nil? ? nil : int16b4.__to_json_map__)
      result.store(key, value)
      key = 'int16b5'
      value = (int16b5.nil? ? nil : int16b5.__to_json_map__)
      result.store(key, value)
      key = 'uint16b0'
      value = (uint16b0.nil? ? nil : uint16b0.__to_json_map__)
      result.store(key, value)
      key = 'uint16b1'
      value = (uint16b1.nil? ? nil : uint16b1.__to_json_map__)
      result.store(key, value)
      key = 'uint16b2'
      value = (uint16b2.nil? ? nil : uint16b2.__to_json_map__)
      result.store(key, value)
      key = 'uint16b3'
      value = (uint16b3.nil? ? nil : uint16b3.__to_json_map__)
      result.store(key, value)
      key = 'uint16b4'
      value = (uint16b4.nil? ? nil : uint16b4.__to_json_map__)
      result.store(key, value)
      key = 'uint16b5'
      value = (uint16b5.nil? ? nil : uint16b5.__to_json_map__)
      result.store(key, value)
      key = 'int32b0'
      value = (int32b0.nil? ? nil : int32b0.__to_json_map__)
      result.store(key, value)
      key = 'int32b1'
      value = (int32b1.nil? ? nil : int32b1.__to_json_map__)
      result.store(key, value)
      key = 'int32b2'
      value = (int32b2.nil? ? nil : int32b2.__to_json_map__)
      result.store(key, value)
      key = 'int32b3'
      value = (int32b3.nil? ? nil : int32b3.__to_json_map__)
      result.store(key, value)
      key = 'int32b4'
      value = (int32b4.nil? ? nil : int32b4.__to_json_map__)
      result.store(key, value)
      key = 'int32b5'
      value = (int32b5.nil? ? nil : int32b5.__to_json_map__)
      result.store(key, value)
      key = 'uint32b0'
      value = (uint32b0.nil? ? nil : uint32b0.__to_json_map__)
      result.store(key, value)
      key = 'uint32b1'
      value = (uint32b1.nil? ? nil : uint32b1.__to_json_map__)
      result.store(key, value)
      key = 'uint32b2'
      value = (uint32b2.nil? ? nil : uint32b2.__to_json_map__)
      result.store(key, value)
      key = 'uint32b3'
      value = (uint32b3.nil? ? nil : uint32b3.__to_json_map__)
      result.store(key, value)
      key = 'uint32b4'
      value = (uint32b4.nil? ? nil : uint32b4.__to_json_map__)
      result.store(key, value)
      key = 'uint32b5'
      value = (uint32b5.nil? ? nil : uint32b5.__to_json_map__)
      result.store(key, value)
      key = 'int64b0'
      value = (int64b0.nil? ? nil : int64b0.__to_json_map__)
      result.store(key, value)
      key = 'int64b1'
      value = (int64b1.nil? ? nil : int64b1.__to_json_map__)
      result.store(key, value)
      key = 'int64b2'
      value = (int64b2.nil? ? nil : int64b2.__to_json_map__)
      result.store(key, value)
      key = 'int64b3'
      value = (int64b3.nil? ? nil : int64b3.__to_json_map__)
      result.store(key, value)
      key = 'int64b4'
      value = (int64b4.nil? ? nil : int64b4.__to_json_map__)
      result.store(key, value)
      key = 'int64b5'
      value = (int64b5.nil? ? nil : int64b5.__to_json_map__)
      result.store(key, value)
      key = 'uint64b0'
      value = (uint64b0.nil? ? nil : uint64b0.__to_json_map__)
      result.store(key, value)
      key = 'uint64b1'
      value = (uint64b1.nil? ? nil : uint64b1.__to_json_map__)
      result.store(key, value)
      key = 'uint64b2'
      value = (uint64b2.nil? ? nil : uint64b2.__to_json_map__)
      result.store(key, value)
      key = 'uint64b3'
      value = (uint64b3.nil? ? nil : uint64b3.__to_json_map__)
      result.store(key, value)
      key = 'uint64b4'
      value = (uint64b4.nil? ? nil : uint64b4.__to_json_map__)
      result.store(key, value)
      key = 'uint64b5'
      value = (uint64b5.nil? ? nil : uint64b5.__to_json_map__)
      result.store(key, value)
      result
    end

    # Get struct from JSON
    def self.from_json(json)
      __from_json_map__(JSON.parse(json))
    end

    # Get struct map from JSON (internal method)
    def self.__from_json_map__(json)
      result = Enums.new
      value = json.fetch('byte0', nil)
      result.byte0 = (value.nil? ? nil : EnumByte.__from_json_map__(value))
      value = json.fetch('byte1', nil)
      result.byte1 = (value.nil? ? nil : EnumByte.__from_json_map__(value))
      value = json.fetch('byte2', nil)
      result.byte2 = (value.nil? ? nil : EnumByte.__from_json_map__(value))
      value = json.fetch('byte3', nil)
      result.byte3 = (value.nil? ? nil : EnumByte.__from_json_map__(value))
      value = json.fetch('byte4', nil)
      result.byte4 = (value.nil? ? nil : EnumByte.__from_json_map__(value))
      value = json.fetch('byte5', nil)
      result.byte5 = (value.nil? ? nil : EnumByte.__from_json_map__(value))
      value = json.fetch('char0', nil)
      result.char0 = (value.nil? ? nil : EnumChar.__from_json_map__(value))
      value = json.fetch('char1', nil)
      result.char1 = (value.nil? ? nil : EnumChar.__from_json_map__(value))
      value = json.fetch('char2', nil)
      result.char2 = (value.nil? ? nil : EnumChar.__from_json_map__(value))
      value = json.fetch('char3', nil)
      result.char3 = (value.nil? ? nil : EnumChar.__from_json_map__(value))
      value = json.fetch('char4', nil)
      result.char4 = (value.nil? ? nil : EnumChar.__from_json_map__(value))
      value = json.fetch('char5', nil)
      result.char5 = (value.nil? ? nil : EnumChar.__from_json_map__(value))
      value = json.fetch('wchar0', nil)
      result.wchar0 = (value.nil? ? nil : EnumWChar.__from_json_map__(value))
      value = json.fetch('wchar1', nil)
      result.wchar1 = (value.nil? ? nil : EnumWChar.__from_json_map__(value))
      value = json.fetch('wchar2', nil)
      result.wchar2 = (value.nil? ? nil : EnumWChar.__from_json_map__(value))
      value = json.fetch('wchar3', nil)
      result.wchar3 = (value.nil? ? nil : EnumWChar.__from_json_map__(value))
      value = json.fetch('wchar4', nil)
      result.wchar4 = (value.nil? ? nil : EnumWChar.__from_json_map__(value))
      value = json.fetch('wchar5', nil)
      result.wchar5 = (value.nil? ? nil : EnumWChar.__from_json_map__(value))
      value = json.fetch('int8b0', nil)
      result.int8b0 = (value.nil? ? nil : EnumInt8.__from_json_map__(value))
      value = json.fetch('int8b1', nil)
      result.int8b1 = (value.nil? ? nil : EnumInt8.__from_json_map__(value))
      value = json.fetch('int8b2', nil)
      result.int8b2 = (value.nil? ? nil : EnumInt8.__from_json_map__(value))
      value = json.fetch('int8b3', nil)
      result.int8b3 = (value.nil? ? nil : EnumInt8.__from_json_map__(value))
      value = json.fetch('int8b4', nil)
      result.int8b4 = (value.nil? ? nil : EnumInt8.__from_json_map__(value))
      value = json.fetch('int8b5', nil)
      result.int8b5 = (value.nil? ? nil : EnumInt8.__from_json_map__(value))
      value = json.fetch('uint8b0', nil)
      result.uint8b0 = (value.nil? ? nil : EnumUInt8.__from_json_map__(value))
      value = json.fetch('uint8b1', nil)
      result.uint8b1 = (value.nil? ? nil : EnumUInt8.__from_json_map__(value))
      value = json.fetch('uint8b2', nil)
      result.uint8b2 = (value.nil? ? nil : EnumUInt8.__from_json_map__(value))
      value = json.fetch('uint8b3', nil)
      result.uint8b3 = (value.nil? ? nil : EnumUInt8.__from_json_map__(value))
      value = json.fetch('uint8b4', nil)
      result.uint8b4 = (value.nil? ? nil : EnumUInt8.__from_json_map__(value))
      value = json.fetch('uint8b5', nil)
      result.uint8b5 = (value.nil? ? nil : EnumUInt8.__from_json_map__(value))
      value = json.fetch('int16b0', nil)
      result.int16b0 = (value.nil? ? nil : EnumInt16.__from_json_map__(value))
      value = json.fetch('int16b1', nil)
      result.int16b1 = (value.nil? ? nil : EnumInt16.__from_json_map__(value))
      value = json.fetch('int16b2', nil)
      result.int16b2 = (value.nil? ? nil : EnumInt16.__from_json_map__(value))
      value = json.fetch('int16b3', nil)
      result.int16b3 = (value.nil? ? nil : EnumInt16.__from_json_map__(value))
      value = json.fetch('int16b4', nil)
      result.int16b4 = (value.nil? ? nil : EnumInt16.__from_json_map__(value))
      value = json.fetch('int16b5', nil)
      result.int16b5 = (value.nil? ? nil : EnumInt16.__from_json_map__(value))
      value = json.fetch('uint16b0', nil)
      result.uint16b0 = (value.nil? ? nil : EnumUInt16.__from_json_map__(value))
      value = json.fetch('uint16b1', nil)
      result.uint16b1 = (value.nil? ? nil : EnumUInt16.__from_json_map__(value))
      value = json.fetch('uint16b2', nil)
      result.uint16b2 = (value.nil? ? nil : EnumUInt16.__from_json_map__(value))
      value = json.fetch('uint16b3', nil)
      result.uint16b3 = (value.nil? ? nil : EnumUInt16.__from_json_map__(value))
      value = json.fetch('uint16b4', nil)
      result.uint16b4 = (value.nil? ? nil : EnumUInt16.__from_json_map__(value))
      value = json.fetch('uint16b5', nil)
      result.uint16b5 = (value.nil? ? nil : EnumUInt16.__from_json_map__(value))
      value = json.fetch('int32b0', nil)
      result.int32b0 = (value.nil? ? nil : EnumInt32.__from_json_map__(value))
      value = json.fetch('int32b1', nil)
      result.int32b1 = (value.nil? ? nil : EnumInt32.__from_json_map__(value))
      value = json.fetch('int32b2', nil)
      result.int32b2 = (value.nil? ? nil : EnumInt32.__from_json_map__(value))
      value = json.fetch('int32b3', nil)
      result.int32b3 = (value.nil? ? nil : EnumInt32.__from_json_map__(value))
      value = json.fetch('int32b4', nil)
      result.int32b4 = (value.nil? ? nil : EnumInt32.__from_json_map__(value))
      value = json.fetch('int32b5', nil)
      result.int32b5 = (value.nil? ? nil : EnumInt32.__from_json_map__(value))
      value = json.fetch('uint32b0', nil)
      result.uint32b0 = (value.nil? ? nil : EnumUInt32.__from_json_map__(value))
      value = json.fetch('uint32b1', nil)
      result.uint32b1 = (value.nil? ? nil : EnumUInt32.__from_json_map__(value))
      value = json.fetch('uint32b2', nil)
      result.uint32b2 = (value.nil? ? nil : EnumUInt32.__from_json_map__(value))
      value = json.fetch('uint32b3', nil)
      result.uint32b3 = (value.nil? ? nil : EnumUInt32.__from_json_map__(value))
      value = json.fetch('uint32b4', nil)
      result.uint32b4 = (value.nil? ? nil : EnumUInt32.__from_json_map__(value))
      value = json.fetch('uint32b5', nil)
      result.uint32b5 = (value.nil? ? nil : EnumUInt32.__from_json_map__(value))
      value = json.fetch('int64b0', nil)
      result.int64b0 = (value.nil? ? nil : EnumInt64.__from_json_map__(value))
      value = json.fetch('int64b1', nil)
      result.int64b1 = (value.nil? ? nil : EnumInt64.__from_json_map__(value))
      value = json.fetch('int64b2', nil)
      result.int64b2 = (value.nil? ? nil : EnumInt64.__from_json_map__(value))
      value = json.fetch('int64b3', nil)
      result.int64b3 = (value.nil? ? nil : EnumInt64.__from_json_map__(value))
      value = json.fetch('int64b4', nil)
      result.int64b4 = (value.nil? ? nil : EnumInt64.__from_json_map__(value))
      value = json.fetch('int64b5', nil)
      result.int64b5 = (value.nil? ? nil : EnumInt64.__from_json_map__(value))
      value = json.fetch('uint64b0', nil)
      result.uint64b0 = (value.nil? ? nil : EnumUInt64.__from_json_map__(value))
      value = json.fetch('uint64b1', nil)
      result.uint64b1 = (value.nil? ? nil : EnumUInt64.__from_json_map__(value))
      value = json.fetch('uint64b2', nil)
      result.uint64b2 = (value.nil? ? nil : EnumUInt64.__from_json_map__(value))
      value = json.fetch('uint64b3', nil)
      result.uint64b3 = (value.nil? ? nil : EnumUInt64.__from_json_map__(value))
      value = json.fetch('uint64b4', nil)
      result.uint64b4 = (value.nil? ? nil : EnumUInt64.__from_json_map__(value))
      value = json.fetch('uint64b5', nil)
      result.uint64b5 = (value.nil? ? nil : EnumUInt64.__from_json_map__(value))
      result
    end

    # Get the FBE type
    def fbe_type
      TYPE
    end

    TYPE = 1
  end

  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class FieldModelEnums < FBE::FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
      @_byte0 = FieldModelEnumByte.new(self.buffer, 4 + 4)
      @_byte1 = FieldModelEnumByte.new(self.buffer, @_byte0.fbe_offset + @_byte0.fbe_size)
      @_byte2 = FieldModelEnumByte.new(self.buffer, @_byte1.fbe_offset + @_byte1.fbe_size)
      @_byte3 = FieldModelEnumByte.new(self.buffer, @_byte2.fbe_offset + @_byte2.fbe_size)
      @_byte4 = FieldModelEnumByte.new(self.buffer, @_byte3.fbe_offset + @_byte3.fbe_size)
      @_byte5 = FieldModelEnumByte.new(self.buffer, @_byte4.fbe_offset + @_byte4.fbe_size)
      @_char0 = FieldModelEnumChar.new(self.buffer, @_byte5.fbe_offset + @_byte5.fbe_size)
      @_char1 = FieldModelEnumChar.new(self.buffer, @_char0.fbe_offset + @_char0.fbe_size)
      @_char2 = FieldModelEnumChar.new(self.buffer, @_char1.fbe_offset + @_char1.fbe_size)
      @_char3 = FieldModelEnumChar.new(self.buffer, @_char2.fbe_offset + @_char2.fbe_size)
      @_char4 = FieldModelEnumChar.new(self.buffer, @_char3.fbe_offset + @_char3.fbe_size)
      @_char5 = FieldModelEnumChar.new(self.buffer, @_char4.fbe_offset + @_char4.fbe_size)
      @_wchar0 = FieldModelEnumWChar.new(self.buffer, @_char5.fbe_offset + @_char5.fbe_size)
      @_wchar1 = FieldModelEnumWChar.new(self.buffer, @_wchar0.fbe_offset + @_wchar0.fbe_size)
      @_wchar2 = FieldModelEnumWChar.new(self.buffer, @_wchar1.fbe_offset + @_wchar1.fbe_size)
      @_wchar3 = FieldModelEnumWChar.new(self.buffer, @_wchar2.fbe_offset + @_wchar2.fbe_size)
      @_wchar4 = FieldModelEnumWChar.new(self.buffer, @_wchar3.fbe_offset + @_wchar3.fbe_size)
      @_wchar5 = FieldModelEnumWChar.new(self.buffer, @_wchar4.fbe_offset + @_wchar4.fbe_size)
      @_int8b0 = FieldModelEnumInt8.new(self.buffer, @_wchar5.fbe_offset + @_wchar5.fbe_size)
      @_int8b1 = FieldModelEnumInt8.new(self.buffer, @_int8b0.fbe_offset + @_int8b0.fbe_size)
      @_int8b2 = FieldModelEnumInt8.new(self.buffer, @_int8b1.fbe_offset + @_int8b1.fbe_size)
      @_int8b3 = FieldModelEnumInt8.new(self.buffer, @_int8b2.fbe_offset + @_int8b2.fbe_size)
      @_int8b4 = FieldModelEnumInt8.new(self.buffer, @_int8b3.fbe_offset + @_int8b3.fbe_size)
      @_int8b5 = FieldModelEnumInt8.new(self.buffer, @_int8b4.fbe_offset + @_int8b4.fbe_size)
      @_uint8b0 = FieldModelEnumUInt8.new(self.buffer, @_int8b5.fbe_offset + @_int8b5.fbe_size)
      @_uint8b1 = FieldModelEnumUInt8.new(self.buffer, @_uint8b0.fbe_offset + @_uint8b0.fbe_size)
      @_uint8b2 = FieldModelEnumUInt8.new(self.buffer, @_uint8b1.fbe_offset + @_uint8b1.fbe_size)
      @_uint8b3 = FieldModelEnumUInt8.new(self.buffer, @_uint8b2.fbe_offset + @_uint8b2.fbe_size)
      @_uint8b4 = FieldModelEnumUInt8.new(self.buffer, @_uint8b3.fbe_offset + @_uint8b3.fbe_size)
      @_uint8b5 = FieldModelEnumUInt8.new(self.buffer, @_uint8b4.fbe_offset + @_uint8b4.fbe_size)
      @_int16b0 = FieldModelEnumInt16.new(self.buffer, @_uint8b5.fbe_offset + @_uint8b5.fbe_size)
      @_int16b1 = FieldModelEnumInt16.new(self.buffer, @_int16b0.fbe_offset + @_int16b0.fbe_size)
      @_int16b2 = FieldModelEnumInt16.new(self.buffer, @_int16b1.fbe_offset + @_int16b1.fbe_size)
      @_int16b3 = FieldModelEnumInt16.new(self.buffer, @_int16b2.fbe_offset + @_int16b2.fbe_size)
      @_int16b4 = FieldModelEnumInt16.new(self.buffer, @_int16b3.fbe_offset + @_int16b3.fbe_size)
      @_int16b5 = FieldModelEnumInt16.new(self.buffer, @_int16b4.fbe_offset + @_int16b4.fbe_size)
      @_uint16b0 = FieldModelEnumUInt16.new(self.buffer, @_int16b5.fbe_offset + @_int16b5.fbe_size)
      @_uint16b1 = FieldModelEnumUInt16.new(self.buffer, @_uint16b0.fbe_offset + @_uint16b0.fbe_size)
      @_uint16b2 = FieldModelEnumUInt16.new(self.buffer, @_uint16b1.fbe_offset + @_uint16b1.fbe_size)
      @_uint16b3 = FieldModelEnumUInt16.new(self.buffer, @_uint16b2.fbe_offset + @_uint16b2.fbe_size)
      @_uint16b4 = FieldModelEnumUInt16.new(self.buffer, @_uint16b3.fbe_offset + @_uint16b3.fbe_size)
      @_uint16b5 = FieldModelEnumUInt16.new(self.buffer, @_uint16b4.fbe_offset + @_uint16b4.fbe_size)
      @_int32b0 = FieldModelEnumInt32.new(self.buffer, @_uint16b5.fbe_offset + @_uint16b5.fbe_size)
      @_int32b1 = FieldModelEnumInt32.new(self.buffer, @_int32b0.fbe_offset + @_int32b0.fbe_size)
      @_int32b2 = FieldModelEnumInt32.new(self.buffer, @_int32b1.fbe_offset + @_int32b1.fbe_size)
      @_int32b3 = FieldModelEnumInt32.new(self.buffer, @_int32b2.fbe_offset + @_int32b2.fbe_size)
      @_int32b4 = FieldModelEnumInt32.new(self.buffer, @_int32b3.fbe_offset + @_int32b3.fbe_size)
      @_int32b5 = FieldModelEnumInt32.new(self.buffer, @_int32b4.fbe_offset + @_int32b4.fbe_size)
      @_uint32b0 = FieldModelEnumUInt32.new(self.buffer, @_int32b5.fbe_offset + @_int32b5.fbe_size)
      @_uint32b1 = FieldModelEnumUInt32.new(self.buffer, @_uint32b0.fbe_offset + @_uint32b0.fbe_size)
      @_uint32b2 = FieldModelEnumUInt32.new(self.buffer, @_uint32b1.fbe_offset + @_uint32b1.fbe_size)
      @_uint32b3 = FieldModelEnumUInt32.new(self.buffer, @_uint32b2.fbe_offset + @_uint32b2.fbe_size)
      @_uint32b4 = FieldModelEnumUInt32.new(self.buffer, @_uint32b3.fbe_offset + @_uint32b3.fbe_size)
      @_uint32b5 = FieldModelEnumUInt32.new(self.buffer, @_uint32b4.fbe_offset + @_uint32b4.fbe_size)
      @_int64b0 = FieldModelEnumInt64.new(self.buffer, @_uint32b5.fbe_offset + @_uint32b5.fbe_size)
      @_int64b1 = FieldModelEnumInt64.new(self.buffer, @_int64b0.fbe_offset + @_int64b0.fbe_size)
      @_int64b2 = FieldModelEnumInt64.new(self.buffer, @_int64b1.fbe_offset + @_int64b1.fbe_size)
      @_int64b3 = FieldModelEnumInt64.new(self.buffer, @_int64b2.fbe_offset + @_int64b2.fbe_size)
      @_int64b4 = FieldModelEnumInt64.new(self.buffer, @_int64b3.fbe_offset + @_int64b3.fbe_size)
      @_int64b5 = FieldModelEnumInt64.new(self.buffer, @_int64b4.fbe_offset + @_int64b4.fbe_size)
      @_uint64b0 = FieldModelEnumUInt64.new(self.buffer, @_int64b5.fbe_offset + @_int64b5.fbe_size)
      @_uint64b1 = FieldModelEnumUInt64.new(self.buffer, @_uint64b0.fbe_offset + @_uint64b0.fbe_size)
      @_uint64b2 = FieldModelEnumUInt64.new(self.buffer, @_uint64b1.fbe_offset + @_uint64b1.fbe_size)
      @_uint64b3 = FieldModelEnumUInt64.new(self.buffer, @_uint64b2.fbe_offset + @_uint64b2.fbe_size)
      @_uint64b4 = FieldModelEnumUInt64.new(self.buffer, @_uint64b3.fbe_offset + @_uint64b3.fbe_size)
      @_uint64b5 = FieldModelEnumUInt64.new(self.buffer, @_uint64b4.fbe_offset + @_uint64b4.fbe_size)
    end

    def byte0
      @_byte0
    end

    def byte1
      @_byte1
    end

    def byte2
      @_byte2
    end

    def byte3
      @_byte3
    end

    def byte4
      @_byte4
    end

    def byte5
      @_byte5
    end

    def char0
      @_char0
    end

    def char1
      @_char1
    end

    def char2
      @_char2
    end

    def char3
      @_char3
    end

    def char4
      @_char4
    end

    def char5
      @_char5
    end

    def wchar0
      @_wchar0
    end

    def wchar1
      @_wchar1
    end

    def wchar2
      @_wchar2
    end

    def wchar3
      @_wchar3
    end

    def wchar4
      @_wchar4
    end

    def wchar5
      @_wchar5
    end

    def int8b0
      @_int8b0
    end

    def int8b1
      @_int8b1
    end

    def int8b2
      @_int8b2
    end

    def int8b3
      @_int8b3
    end

    def int8b4
      @_int8b4
    end

    def int8b5
      @_int8b5
    end

    def uint8b0
      @_uint8b0
    end

    def uint8b1
      @_uint8b1
    end

    def uint8b2
      @_uint8b2
    end

    def uint8b3
      @_uint8b3
    end

    def uint8b4
      @_uint8b4
    end

    def uint8b5
      @_uint8b5
    end

    def int16b0
      @_int16b0
    end

    def int16b1
      @_int16b1
    end

    def int16b2
      @_int16b2
    end

    def int16b3
      @_int16b3
    end

    def int16b4
      @_int16b4
    end

    def int16b5
      @_int16b5
    end

    def uint16b0
      @_uint16b0
    end

    def uint16b1
      @_uint16b1
    end

    def uint16b2
      @_uint16b2
    end

    def uint16b3
      @_uint16b3
    end

    def uint16b4
      @_uint16b4
    end

    def uint16b5
      @_uint16b5
    end

    def int32b0
      @_int32b0
    end

    def int32b1
      @_int32b1
    end

    def int32b2
      @_int32b2
    end

    def int32b3
      @_int32b3
    end

    def int32b4
      @_int32b4
    end

    def int32b5
      @_int32b5
    end

    def uint32b0
      @_uint32b0
    end

    def uint32b1
      @_uint32b1
    end

    def uint32b2
      @_uint32b2
    end

    def uint32b3
      @_uint32b3
    end

    def uint32b4
      @_uint32b4
    end

    def uint32b5
      @_uint32b5
    end

    def int64b0
      @_int64b0
    end

    def int64b1
      @_int64b1
    end

    def int64b2
      @_int64b2
    end

    def int64b3
      @_int64b3
    end

    def int64b4
      @_int64b4
    end

    def int64b5
      @_int64b5
    end

    def uint64b0
      @_uint64b0
    end

    def uint64b1
      @_uint64b1
    end

    def uint64b2
      @_uint64b2
    end

    def uint64b3
      @_uint64b3
    end

    def uint64b4
      @_uint64b4
    end

    def uint64b5
      @_uint64b5
    end

    # Get the field size
    def fbe_size
      4
    end

    # Get the field body size
    def fbe_body
      4 + 4 \
        + byte0.fbe_size \
        + byte1.fbe_size \
        + byte2.fbe_size \
        + byte3.fbe_size \
        + byte4.fbe_size \
        + byte5.fbe_size \
        + char0.fbe_size \
        + char1.fbe_size \
        + char2.fbe_size \
        + char3.fbe_size \
        + char4.fbe_size \
        + char5.fbe_size \
        + wchar0.fbe_size \
        + wchar1.fbe_size \
        + wchar2.fbe_size \
        + wchar3.fbe_size \
        + wchar4.fbe_size \
        + wchar5.fbe_size \
        + int8b0.fbe_size \
        + int8b1.fbe_size \
        + int8b2.fbe_size \
        + int8b3.fbe_size \
        + int8b4.fbe_size \
        + int8b5.fbe_size \
        + uint8b0.fbe_size \
        + uint8b1.fbe_size \
        + uint8b2.fbe_size \
        + uint8b3.fbe_size \
        + uint8b4.fbe_size \
        + uint8b5.fbe_size \
        + int16b0.fbe_size \
        + int16b1.fbe_size \
        + int16b2.fbe_size \
        + int16b3.fbe_size \
        + int16b4.fbe_size \
        + int16b5.fbe_size \
        + uint16b0.fbe_size \
        + uint16b1.fbe_size \
        + uint16b2.fbe_size \
        + uint16b3.fbe_size \
        + uint16b4.fbe_size \
        + uint16b5.fbe_size \
        + int32b0.fbe_size \
        + int32b1.fbe_size \
        + int32b2.fbe_size \
        + int32b3.fbe_size \
        + int32b4.fbe_size \
        + int32b5.fbe_size \
        + uint32b0.fbe_size \
        + uint32b1.fbe_size \
        + uint32b2.fbe_size \
        + uint32b3.fbe_size \
        + uint32b4.fbe_size \
        + uint32b5.fbe_size \
        + int64b0.fbe_size \
        + int64b1.fbe_size \
        + int64b2.fbe_size \
        + int64b3.fbe_size \
        + int64b4.fbe_size \
        + int64b5.fbe_size \
        + uint64b0.fbe_size \
        + uint64b1.fbe_size \
        + uint64b2.fbe_size \
        + uint64b3.fbe_size \
        + uint64b4.fbe_size \
        + uint64b5.fbe_size \
    end

    # Get the field extra size
    def fbe_extra
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      fbe_struct_offset = read_uint32(fbe_offset)
      if (fbe_struct_offset == 0) || ((@_buffer.offset + fbe_struct_offset + 4) > @_buffer.size)
        return 0
      end

      @_buffer.shift(fbe_struct_offset)

      fbe_result = fbe_body \
        + byte0.fbe_extra \
        + byte1.fbe_extra \
        + byte2.fbe_extra \
        + byte3.fbe_extra \
        + byte4.fbe_extra \
        + byte5.fbe_extra \
        + char0.fbe_extra \
        + char1.fbe_extra \
        + char2.fbe_extra \
        + char3.fbe_extra \
        + char4.fbe_extra \
        + char5.fbe_extra \
        + wchar0.fbe_extra \
        + wchar1.fbe_extra \
        + wchar2.fbe_extra \
        + wchar3.fbe_extra \
        + wchar4.fbe_extra \
        + wchar5.fbe_extra \
        + int8b0.fbe_extra \
        + int8b1.fbe_extra \
        + int8b2.fbe_extra \
        + int8b3.fbe_extra \
        + int8b4.fbe_extra \
        + int8b5.fbe_extra \
        + uint8b0.fbe_extra \
        + uint8b1.fbe_extra \
        + uint8b2.fbe_extra \
        + uint8b3.fbe_extra \
        + uint8b4.fbe_extra \
        + uint8b5.fbe_extra \
        + int16b0.fbe_extra \
        + int16b1.fbe_extra \
        + int16b2.fbe_extra \
        + int16b3.fbe_extra \
        + int16b4.fbe_extra \
        + int16b5.fbe_extra \
        + uint16b0.fbe_extra \
        + uint16b1.fbe_extra \
        + uint16b2.fbe_extra \
        + uint16b3.fbe_extra \
        + uint16b4.fbe_extra \
        + uint16b5.fbe_extra \
        + int32b0.fbe_extra \
        + int32b1.fbe_extra \
        + int32b2.fbe_extra \
        + int32b3.fbe_extra \
        + int32b4.fbe_extra \
        + int32b5.fbe_extra \
        + uint32b0.fbe_extra \
        + uint32b1.fbe_extra \
        + uint32b2.fbe_extra \
        + uint32b3.fbe_extra \
        + uint32b4.fbe_extra \
        + uint32b5.fbe_extra \
        + int64b0.fbe_extra \
        + int64b1.fbe_extra \
        + int64b2.fbe_extra \
        + int64b3.fbe_extra \
        + int64b4.fbe_extra \
        + int64b5.fbe_extra \
        + uint64b0.fbe_extra \
        + uint64b1.fbe_extra \
        + uint64b2.fbe_extra \
        + uint64b3.fbe_extra \
        + uint64b4.fbe_extra \
        + uint64b5.fbe_extra \

      @_buffer.unshift(fbe_struct_offset)

      fbe_result
    end

    # Get the field type
    def fbe_type
      TYPE
    end

    TYPE = 1

    # Is the struct value valid?
    def valid?
      verify
    end

    # Check if the struct value is valid
    def verify(fbe_verify_type = true)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return true
      end

      fbe_struct_offset = read_uint32(fbe_offset)
      if (fbe_struct_offset == 0) || ((@_buffer.offset + fbe_struct_offset + 4 + 4) > @_buffer.size)
        return false
      end

      fbe_struct_size = read_uint32(fbe_struct_offset)
      if fbe_struct_size < (4 + 4)
        return false
      end

      fbe_struct_type = read_uint32(fbe_struct_offset + 4)
      if fbe_verify_type && (fbe_struct_type != fbe_type)
        return false
      end

      @_buffer.shift(fbe_struct_offset)
      fbe_result = verify_fields(fbe_struct_size)
      @_buffer.unshift(fbe_struct_offset)
      fbe_result
    end

    # Check if the struct fields are valid
    def verify_fields(fbe_struct_size)
      fbe_current_size = 4 + 4

      if (fbe_current_size + byte0.fbe_size) > fbe_struct_size
        return true
      end
      unless byte0.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += byte0.fbe_size

      if (fbe_current_size + byte1.fbe_size) > fbe_struct_size
        return true
      end
      unless byte1.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += byte1.fbe_size

      if (fbe_current_size + byte2.fbe_size) > fbe_struct_size
        return true
      end
      unless byte2.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += byte2.fbe_size

      if (fbe_current_size + byte3.fbe_size) > fbe_struct_size
        return true
      end
      unless byte3.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += byte3.fbe_size

      if (fbe_current_size + byte4.fbe_size) > fbe_struct_size
        return true
      end
      unless byte4.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += byte4.fbe_size

      if (fbe_current_size + byte5.fbe_size) > fbe_struct_size
        return true
      end
      unless byte5.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += byte5.fbe_size

      if (fbe_current_size + char0.fbe_size) > fbe_struct_size
        return true
      end
      unless char0.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += char0.fbe_size

      if (fbe_current_size + char1.fbe_size) > fbe_struct_size
        return true
      end
      unless char1.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += char1.fbe_size

      if (fbe_current_size + char2.fbe_size) > fbe_struct_size
        return true
      end
      unless char2.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += char2.fbe_size

      if (fbe_current_size + char3.fbe_size) > fbe_struct_size
        return true
      end
      unless char3.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += char3.fbe_size

      if (fbe_current_size + char4.fbe_size) > fbe_struct_size
        return true
      end
      unless char4.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += char4.fbe_size

      if (fbe_current_size + char5.fbe_size) > fbe_struct_size
        return true
      end
      unless char5.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += char5.fbe_size

      if (fbe_current_size + wchar0.fbe_size) > fbe_struct_size
        return true
      end
      unless wchar0.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += wchar0.fbe_size

      if (fbe_current_size + wchar1.fbe_size) > fbe_struct_size
        return true
      end
      unless wchar1.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += wchar1.fbe_size

      if (fbe_current_size + wchar2.fbe_size) > fbe_struct_size
        return true
      end
      unless wchar2.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += wchar2.fbe_size

      if (fbe_current_size + wchar3.fbe_size) > fbe_struct_size
        return true
      end
      unless wchar3.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += wchar3.fbe_size

      if (fbe_current_size + wchar4.fbe_size) > fbe_struct_size
        return true
      end
      unless wchar4.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += wchar4.fbe_size

      if (fbe_current_size + wchar5.fbe_size) > fbe_struct_size
        return true
      end
      unless wchar5.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += wchar5.fbe_size

      if (fbe_current_size + int8b0.fbe_size) > fbe_struct_size
        return true
      end
      unless int8b0.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int8b0.fbe_size

      if (fbe_current_size + int8b1.fbe_size) > fbe_struct_size
        return true
      end
      unless int8b1.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int8b1.fbe_size

      if (fbe_current_size + int8b2.fbe_size) > fbe_struct_size
        return true
      end
      unless int8b2.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int8b2.fbe_size

      if (fbe_current_size + int8b3.fbe_size) > fbe_struct_size
        return true
      end
      unless int8b3.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int8b3.fbe_size

      if (fbe_current_size + int8b4.fbe_size) > fbe_struct_size
        return true
      end
      unless int8b4.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int8b4.fbe_size

      if (fbe_current_size + int8b5.fbe_size) > fbe_struct_size
        return true
      end
      unless int8b5.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int8b5.fbe_size

      if (fbe_current_size + uint8b0.fbe_size) > fbe_struct_size
        return true
      end
      unless uint8b0.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint8b0.fbe_size

      if (fbe_current_size + uint8b1.fbe_size) > fbe_struct_size
        return true
      end
      unless uint8b1.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint8b1.fbe_size

      if (fbe_current_size + uint8b2.fbe_size) > fbe_struct_size
        return true
      end
      unless uint8b2.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint8b2.fbe_size

      if (fbe_current_size + uint8b3.fbe_size) > fbe_struct_size
        return true
      end
      unless uint8b3.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint8b3.fbe_size

      if (fbe_current_size + uint8b4.fbe_size) > fbe_struct_size
        return true
      end
      unless uint8b4.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint8b4.fbe_size

      if (fbe_current_size + uint8b5.fbe_size) > fbe_struct_size
        return true
      end
      unless uint8b5.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint8b5.fbe_size

      if (fbe_current_size + int16b0.fbe_size) > fbe_struct_size
        return true
      end
      unless int16b0.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int16b0.fbe_size

      if (fbe_current_size + int16b1.fbe_size) > fbe_struct_size
        return true
      end
      unless int16b1.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int16b1.fbe_size

      if (fbe_current_size + int16b2.fbe_size) > fbe_struct_size
        return true
      end
      unless int16b2.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int16b2.fbe_size

      if (fbe_current_size + int16b3.fbe_size) > fbe_struct_size
        return true
      end
      unless int16b3.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int16b3.fbe_size

      if (fbe_current_size + int16b4.fbe_size) > fbe_struct_size
        return true
      end
      unless int16b4.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int16b4.fbe_size

      if (fbe_current_size + int16b5.fbe_size) > fbe_struct_size
        return true
      end
      unless int16b5.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int16b5.fbe_size

      if (fbe_current_size + uint16b0.fbe_size) > fbe_struct_size
        return true
      end
      unless uint16b0.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint16b0.fbe_size

      if (fbe_current_size + uint16b1.fbe_size) > fbe_struct_size
        return true
      end
      unless uint16b1.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint16b1.fbe_size

      if (fbe_current_size + uint16b2.fbe_size) > fbe_struct_size
        return true
      end
      unless uint16b2.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint16b2.fbe_size

      if (fbe_current_size + uint16b3.fbe_size) > fbe_struct_size
        return true
      end
      unless uint16b3.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint16b3.fbe_size

      if (fbe_current_size + uint16b4.fbe_size) > fbe_struct_size
        return true
      end
      unless uint16b4.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint16b4.fbe_size

      if (fbe_current_size + uint16b5.fbe_size) > fbe_struct_size
        return true
      end
      unless uint16b5.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint16b5.fbe_size

      if (fbe_current_size + int32b0.fbe_size) > fbe_struct_size
        return true
      end
      unless int32b0.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int32b0.fbe_size

      if (fbe_current_size + int32b1.fbe_size) > fbe_struct_size
        return true
      end
      unless int32b1.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int32b1.fbe_size

      if (fbe_current_size + int32b2.fbe_size) > fbe_struct_size
        return true
      end
      unless int32b2.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int32b2.fbe_size

      if (fbe_current_size + int32b3.fbe_size) > fbe_struct_size
        return true
      end
      unless int32b3.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int32b3.fbe_size

      if (fbe_current_size + int32b4.fbe_size) > fbe_struct_size
        return true
      end
      unless int32b4.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int32b4.fbe_size

      if (fbe_current_size + int32b5.fbe_size) > fbe_struct_size
        return true
      end
      unless int32b5.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int32b5.fbe_size

      if (fbe_current_size + uint32b0.fbe_size) > fbe_struct_size
        return true
      end
      unless uint32b0.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint32b0.fbe_size

      if (fbe_current_size + uint32b1.fbe_size) > fbe_struct_size
        return true
      end
      unless uint32b1.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint32b1.fbe_size

      if (fbe_current_size + uint32b2.fbe_size) > fbe_struct_size
        return true
      end
      unless uint32b2.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint32b2.fbe_size

      if (fbe_current_size + uint32b3.fbe_size) > fbe_struct_size
        return true
      end
      unless uint32b3.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint32b3.fbe_size

      if (fbe_current_size + uint32b4.fbe_size) > fbe_struct_size
        return true
      end
      unless uint32b4.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint32b4.fbe_size

      if (fbe_current_size + uint32b5.fbe_size) > fbe_struct_size
        return true
      end
      unless uint32b5.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint32b5.fbe_size

      if (fbe_current_size + int64b0.fbe_size) > fbe_struct_size
        return true
      end
      unless int64b0.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int64b0.fbe_size

      if (fbe_current_size + int64b1.fbe_size) > fbe_struct_size
        return true
      end
      unless int64b1.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int64b1.fbe_size

      if (fbe_current_size + int64b2.fbe_size) > fbe_struct_size
        return true
      end
      unless int64b2.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int64b2.fbe_size

      if (fbe_current_size + int64b3.fbe_size) > fbe_struct_size
        return true
      end
      unless int64b3.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int64b3.fbe_size

      if (fbe_current_size + int64b4.fbe_size) > fbe_struct_size
        return true
      end
      unless int64b4.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int64b4.fbe_size

      if (fbe_current_size + int64b5.fbe_size) > fbe_struct_size
        return true
      end
      unless int64b5.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int64b5.fbe_size

      if (fbe_current_size + uint64b0.fbe_size) > fbe_struct_size
        return true
      end
      unless uint64b0.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint64b0.fbe_size

      if (fbe_current_size + uint64b1.fbe_size) > fbe_struct_size
        return true
      end
      unless uint64b1.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint64b1.fbe_size

      if (fbe_current_size + uint64b2.fbe_size) > fbe_struct_size
        return true
      end
      unless uint64b2.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint64b2.fbe_size

      if (fbe_current_size + uint64b3.fbe_size) > fbe_struct_size
        return true
      end
      unless uint64b3.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint64b3.fbe_size

      if (fbe_current_size + uint64b4.fbe_size) > fbe_struct_size
        return true
      end
      unless uint64b4.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint64b4.fbe_size

      if (fbe_current_size + uint64b5.fbe_size) > fbe_struct_size
        return true
      end
      unless uint64b5.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint64b5.fbe_size

      true
    end

    # Get the struct value (begin phase)
    def get_begin
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      fbe_struct_offset = read_uint32(fbe_offset)
      if (fbe_struct_offset == 0) || ((@_buffer.offset + fbe_struct_offset + 4 + 4) > @_buffer.size)
        return 0
      end

      fbe_struct_size = read_uint32(fbe_struct_offset)
      if fbe_struct_size < (4 + 4)
        return 0
      end

      @_buffer.shift(fbe_struct_offset)
      fbe_struct_offset
    end

    # Get the struct value (end phase)
    def get_end(fbe_begin)
      @_buffer.unshift(fbe_begin)
    end

    # Get the struct value
    def get(fbe_value = Enums.new)
      fbe_begin = get_begin
      if fbe_begin == 0
        return fbe_value
      end

      fbe_struct_size = read_uint32(0)
      get_fields(fbe_value, fbe_struct_size)
      get_end(fbe_begin)
      fbe_value
    end

    # Get the struct fields values
    def get_fields(fbe_value, fbe_struct_size)
      fbe_current_size = 4 + 4

      if (fbe_current_size + byte0.fbe_size) <= fbe_struct_size
        fbe_value.byte0 = byte0.get(EnumByte.ENUM_VALUE_0)
      else
        fbe_value.byte0 = EnumByte.ENUM_VALUE_0
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += byte0.fbe_size

      if (fbe_current_size + byte1.fbe_size) <= fbe_struct_size
        fbe_value.byte1 = byte1.get(EnumByte.ENUM_VALUE_1)
      else
        fbe_value.byte1 = EnumByte.ENUM_VALUE_1
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += byte1.fbe_size

      if (fbe_current_size + byte2.fbe_size) <= fbe_struct_size
        fbe_value.byte2 = byte2.get(EnumByte.ENUM_VALUE_2)
      else
        fbe_value.byte2 = EnumByte.ENUM_VALUE_2
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += byte2.fbe_size

      if (fbe_current_size + byte3.fbe_size) <= fbe_struct_size
        fbe_value.byte3 = byte3.get(EnumByte.ENUM_VALUE_3)
      else
        fbe_value.byte3 = EnumByte.ENUM_VALUE_3
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += byte3.fbe_size

      if (fbe_current_size + byte4.fbe_size) <= fbe_struct_size
        fbe_value.byte4 = byte4.get(EnumByte.ENUM_VALUE_4)
      else
        fbe_value.byte4 = EnumByte.ENUM_VALUE_4
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += byte4.fbe_size

      if (fbe_current_size + byte5.fbe_size) <= fbe_struct_size
        fbe_value.byte5 = byte5.get(EnumByte.ENUM_VALUE_5)
      else
        fbe_value.byte5 = EnumByte.ENUM_VALUE_5
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += byte5.fbe_size

      if (fbe_current_size + char0.fbe_size) <= fbe_struct_size
        fbe_value.char0 = char0.get(EnumChar.ENUM_VALUE_0)
      else
        fbe_value.char0 = EnumChar.ENUM_VALUE_0
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += char0.fbe_size

      if (fbe_current_size + char1.fbe_size) <= fbe_struct_size
        fbe_value.char1 = char1.get(EnumChar.ENUM_VALUE_1)
      else
        fbe_value.char1 = EnumChar.ENUM_VALUE_1
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += char1.fbe_size

      if (fbe_current_size + char2.fbe_size) <= fbe_struct_size
        fbe_value.char2 = char2.get(EnumChar.ENUM_VALUE_2)
      else
        fbe_value.char2 = EnumChar.ENUM_VALUE_2
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += char2.fbe_size

      if (fbe_current_size + char3.fbe_size) <= fbe_struct_size
        fbe_value.char3 = char3.get(EnumChar.ENUM_VALUE_3)
      else
        fbe_value.char3 = EnumChar.ENUM_VALUE_3
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += char3.fbe_size

      if (fbe_current_size + char4.fbe_size) <= fbe_struct_size
        fbe_value.char4 = char4.get(EnumChar.ENUM_VALUE_4)
      else
        fbe_value.char4 = EnumChar.ENUM_VALUE_4
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += char4.fbe_size

      if (fbe_current_size + char5.fbe_size) <= fbe_struct_size
        fbe_value.char5 = char5.get(EnumChar.ENUM_VALUE_5)
      else
        fbe_value.char5 = EnumChar.ENUM_VALUE_5
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += char5.fbe_size

      if (fbe_current_size + wchar0.fbe_size) <= fbe_struct_size
        fbe_value.wchar0 = wchar0.get(EnumWChar.ENUM_VALUE_0)
      else
        fbe_value.wchar0 = EnumWChar.ENUM_VALUE_0
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += wchar0.fbe_size

      if (fbe_current_size + wchar1.fbe_size) <= fbe_struct_size
        fbe_value.wchar1 = wchar1.get(EnumWChar.ENUM_VALUE_1)
      else
        fbe_value.wchar1 = EnumWChar.ENUM_VALUE_1
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += wchar1.fbe_size

      if (fbe_current_size + wchar2.fbe_size) <= fbe_struct_size
        fbe_value.wchar2 = wchar2.get(EnumWChar.ENUM_VALUE_2)
      else
        fbe_value.wchar2 = EnumWChar.ENUM_VALUE_2
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += wchar2.fbe_size

      if (fbe_current_size + wchar3.fbe_size) <= fbe_struct_size
        fbe_value.wchar3 = wchar3.get(EnumWChar.ENUM_VALUE_3)
      else
        fbe_value.wchar3 = EnumWChar.ENUM_VALUE_3
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += wchar3.fbe_size

      if (fbe_current_size + wchar4.fbe_size) <= fbe_struct_size
        fbe_value.wchar4 = wchar4.get(EnumWChar.ENUM_VALUE_4)
      else
        fbe_value.wchar4 = EnumWChar.ENUM_VALUE_4
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += wchar4.fbe_size

      if (fbe_current_size + wchar5.fbe_size) <= fbe_struct_size
        fbe_value.wchar5 = wchar5.get(EnumWChar.ENUM_VALUE_5)
      else
        fbe_value.wchar5 = EnumWChar.ENUM_VALUE_5
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += wchar5.fbe_size

      if (fbe_current_size + int8b0.fbe_size) <= fbe_struct_size
        fbe_value.int8b0 = int8b0.get(EnumInt8.ENUM_VALUE_0)
      else
        fbe_value.int8b0 = EnumInt8.ENUM_VALUE_0
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int8b0.fbe_size

      if (fbe_current_size + int8b1.fbe_size) <= fbe_struct_size
        fbe_value.int8b1 = int8b1.get(EnumInt8.ENUM_VALUE_1)
      else
        fbe_value.int8b1 = EnumInt8.ENUM_VALUE_1
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int8b1.fbe_size

      if (fbe_current_size + int8b2.fbe_size) <= fbe_struct_size
        fbe_value.int8b2 = int8b2.get(EnumInt8.ENUM_VALUE_2)
      else
        fbe_value.int8b2 = EnumInt8.ENUM_VALUE_2
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int8b2.fbe_size

      if (fbe_current_size + int8b3.fbe_size) <= fbe_struct_size
        fbe_value.int8b3 = int8b3.get(EnumInt8.ENUM_VALUE_3)
      else
        fbe_value.int8b3 = EnumInt8.ENUM_VALUE_3
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int8b3.fbe_size

      if (fbe_current_size + int8b4.fbe_size) <= fbe_struct_size
        fbe_value.int8b4 = int8b4.get(EnumInt8.ENUM_VALUE_4)
      else
        fbe_value.int8b4 = EnumInt8.ENUM_VALUE_4
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int8b4.fbe_size

      if (fbe_current_size + int8b5.fbe_size) <= fbe_struct_size
        fbe_value.int8b5 = int8b5.get(EnumInt8.ENUM_VALUE_5)
      else
        fbe_value.int8b5 = EnumInt8.ENUM_VALUE_5
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int8b5.fbe_size

      if (fbe_current_size + uint8b0.fbe_size) <= fbe_struct_size
        fbe_value.uint8b0 = uint8b0.get(EnumUInt8.ENUM_VALUE_0)
      else
        fbe_value.uint8b0 = EnumUInt8.ENUM_VALUE_0
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint8b0.fbe_size

      if (fbe_current_size + uint8b1.fbe_size) <= fbe_struct_size
        fbe_value.uint8b1 = uint8b1.get(EnumUInt8.ENUM_VALUE_1)
      else
        fbe_value.uint8b1 = EnumUInt8.ENUM_VALUE_1
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint8b1.fbe_size

      if (fbe_current_size + uint8b2.fbe_size) <= fbe_struct_size
        fbe_value.uint8b2 = uint8b2.get(EnumUInt8.ENUM_VALUE_2)
      else
        fbe_value.uint8b2 = EnumUInt8.ENUM_VALUE_2
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint8b2.fbe_size

      if (fbe_current_size + uint8b3.fbe_size) <= fbe_struct_size
        fbe_value.uint8b3 = uint8b3.get(EnumUInt8.ENUM_VALUE_3)
      else
        fbe_value.uint8b3 = EnumUInt8.ENUM_VALUE_3
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint8b3.fbe_size

      if (fbe_current_size + uint8b4.fbe_size) <= fbe_struct_size
        fbe_value.uint8b4 = uint8b4.get(EnumUInt8.ENUM_VALUE_4)
      else
        fbe_value.uint8b4 = EnumUInt8.ENUM_VALUE_4
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint8b4.fbe_size

      if (fbe_current_size + uint8b5.fbe_size) <= fbe_struct_size
        fbe_value.uint8b5 = uint8b5.get(EnumUInt8.ENUM_VALUE_5)
      else
        fbe_value.uint8b5 = EnumUInt8.ENUM_VALUE_5
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint8b5.fbe_size

      if (fbe_current_size + int16b0.fbe_size) <= fbe_struct_size
        fbe_value.int16b0 = int16b0.get(EnumInt16.ENUM_VALUE_0)
      else
        fbe_value.int16b0 = EnumInt16.ENUM_VALUE_0
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int16b0.fbe_size

      if (fbe_current_size + int16b1.fbe_size) <= fbe_struct_size
        fbe_value.int16b1 = int16b1.get(EnumInt16.ENUM_VALUE_1)
      else
        fbe_value.int16b1 = EnumInt16.ENUM_VALUE_1
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int16b1.fbe_size

      if (fbe_current_size + int16b2.fbe_size) <= fbe_struct_size
        fbe_value.int16b2 = int16b2.get(EnumInt16.ENUM_VALUE_2)
      else
        fbe_value.int16b2 = EnumInt16.ENUM_VALUE_2
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int16b2.fbe_size

      if (fbe_current_size + int16b3.fbe_size) <= fbe_struct_size
        fbe_value.int16b3 = int16b3.get(EnumInt16.ENUM_VALUE_3)
      else
        fbe_value.int16b3 = EnumInt16.ENUM_VALUE_3
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int16b3.fbe_size

      if (fbe_current_size + int16b4.fbe_size) <= fbe_struct_size
        fbe_value.int16b4 = int16b4.get(EnumInt16.ENUM_VALUE_4)
      else
        fbe_value.int16b4 = EnumInt16.ENUM_VALUE_4
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int16b4.fbe_size

      if (fbe_current_size + int16b5.fbe_size) <= fbe_struct_size
        fbe_value.int16b5 = int16b5.get(EnumInt16.ENUM_VALUE_5)
      else
        fbe_value.int16b5 = EnumInt16.ENUM_VALUE_5
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int16b5.fbe_size

      if (fbe_current_size + uint16b0.fbe_size) <= fbe_struct_size
        fbe_value.uint16b0 = uint16b0.get(EnumUInt16.ENUM_VALUE_0)
      else
        fbe_value.uint16b0 = EnumUInt16.ENUM_VALUE_0
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint16b0.fbe_size

      if (fbe_current_size + uint16b1.fbe_size) <= fbe_struct_size
        fbe_value.uint16b1 = uint16b1.get(EnumUInt16.ENUM_VALUE_1)
      else
        fbe_value.uint16b1 = EnumUInt16.ENUM_VALUE_1
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint16b1.fbe_size

      if (fbe_current_size + uint16b2.fbe_size) <= fbe_struct_size
        fbe_value.uint16b2 = uint16b2.get(EnumUInt16.ENUM_VALUE_2)
      else
        fbe_value.uint16b2 = EnumUInt16.ENUM_VALUE_2
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint16b2.fbe_size

      if (fbe_current_size + uint16b3.fbe_size) <= fbe_struct_size
        fbe_value.uint16b3 = uint16b3.get(EnumUInt16.ENUM_VALUE_3)
      else
        fbe_value.uint16b3 = EnumUInt16.ENUM_VALUE_3
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint16b3.fbe_size

      if (fbe_current_size + uint16b4.fbe_size) <= fbe_struct_size
        fbe_value.uint16b4 = uint16b4.get(EnumUInt16.ENUM_VALUE_4)
      else
        fbe_value.uint16b4 = EnumUInt16.ENUM_VALUE_4
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint16b4.fbe_size

      if (fbe_current_size + uint16b5.fbe_size) <= fbe_struct_size
        fbe_value.uint16b5 = uint16b5.get(EnumUInt16.ENUM_VALUE_5)
      else
        fbe_value.uint16b5 = EnumUInt16.ENUM_VALUE_5
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint16b5.fbe_size

      if (fbe_current_size + int32b0.fbe_size) <= fbe_struct_size
        fbe_value.int32b0 = int32b0.get(EnumInt32.ENUM_VALUE_0)
      else
        fbe_value.int32b0 = EnumInt32.ENUM_VALUE_0
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int32b0.fbe_size

      if (fbe_current_size + int32b1.fbe_size) <= fbe_struct_size
        fbe_value.int32b1 = int32b1.get(EnumInt32.ENUM_VALUE_1)
      else
        fbe_value.int32b1 = EnumInt32.ENUM_VALUE_1
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int32b1.fbe_size

      if (fbe_current_size + int32b2.fbe_size) <= fbe_struct_size
        fbe_value.int32b2 = int32b2.get(EnumInt32.ENUM_VALUE_2)
      else
        fbe_value.int32b2 = EnumInt32.ENUM_VALUE_2
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int32b2.fbe_size

      if (fbe_current_size + int32b3.fbe_size) <= fbe_struct_size
        fbe_value.int32b3 = int32b3.get(EnumInt32.ENUM_VALUE_3)
      else
        fbe_value.int32b3 = EnumInt32.ENUM_VALUE_3
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int32b3.fbe_size

      if (fbe_current_size + int32b4.fbe_size) <= fbe_struct_size
        fbe_value.int32b4 = int32b4.get(EnumInt32.ENUM_VALUE_4)
      else
        fbe_value.int32b4 = EnumInt32.ENUM_VALUE_4
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int32b4.fbe_size

      if (fbe_current_size + int32b5.fbe_size) <= fbe_struct_size
        fbe_value.int32b5 = int32b5.get(EnumInt32.ENUM_VALUE_5)
      else
        fbe_value.int32b5 = EnumInt32.ENUM_VALUE_5
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int32b5.fbe_size

      if (fbe_current_size + uint32b0.fbe_size) <= fbe_struct_size
        fbe_value.uint32b0 = uint32b0.get(EnumUInt32.ENUM_VALUE_0)
      else
        fbe_value.uint32b0 = EnumUInt32.ENUM_VALUE_0
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint32b0.fbe_size

      if (fbe_current_size + uint32b1.fbe_size) <= fbe_struct_size
        fbe_value.uint32b1 = uint32b1.get(EnumUInt32.ENUM_VALUE_1)
      else
        fbe_value.uint32b1 = EnumUInt32.ENUM_VALUE_1
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint32b1.fbe_size

      if (fbe_current_size + uint32b2.fbe_size) <= fbe_struct_size
        fbe_value.uint32b2 = uint32b2.get(EnumUInt32.ENUM_VALUE_2)
      else
        fbe_value.uint32b2 = EnumUInt32.ENUM_VALUE_2
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint32b2.fbe_size

      if (fbe_current_size + uint32b3.fbe_size) <= fbe_struct_size
        fbe_value.uint32b3 = uint32b3.get(EnumUInt32.ENUM_VALUE_3)
      else
        fbe_value.uint32b3 = EnumUInt32.ENUM_VALUE_3
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint32b3.fbe_size

      if (fbe_current_size + uint32b4.fbe_size) <= fbe_struct_size
        fbe_value.uint32b4 = uint32b4.get(EnumUInt32.ENUM_VALUE_4)
      else
        fbe_value.uint32b4 = EnumUInt32.ENUM_VALUE_4
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint32b4.fbe_size

      if (fbe_current_size + uint32b5.fbe_size) <= fbe_struct_size
        fbe_value.uint32b5 = uint32b5.get(EnumUInt32.ENUM_VALUE_5)
      else
        fbe_value.uint32b5 = EnumUInt32.ENUM_VALUE_5
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint32b5.fbe_size

      if (fbe_current_size + int64b0.fbe_size) <= fbe_struct_size
        fbe_value.int64b0 = int64b0.get(EnumInt64.ENUM_VALUE_0)
      else
        fbe_value.int64b0 = EnumInt64.ENUM_VALUE_0
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int64b0.fbe_size

      if (fbe_current_size + int64b1.fbe_size) <= fbe_struct_size
        fbe_value.int64b1 = int64b1.get(EnumInt64.ENUM_VALUE_1)
      else
        fbe_value.int64b1 = EnumInt64.ENUM_VALUE_1
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int64b1.fbe_size

      if (fbe_current_size + int64b2.fbe_size) <= fbe_struct_size
        fbe_value.int64b2 = int64b2.get(EnumInt64.ENUM_VALUE_2)
      else
        fbe_value.int64b2 = EnumInt64.ENUM_VALUE_2
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int64b2.fbe_size

      if (fbe_current_size + int64b3.fbe_size) <= fbe_struct_size
        fbe_value.int64b3 = int64b3.get(EnumInt64.ENUM_VALUE_3)
      else
        fbe_value.int64b3 = EnumInt64.ENUM_VALUE_3
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int64b3.fbe_size

      if (fbe_current_size + int64b4.fbe_size) <= fbe_struct_size
        fbe_value.int64b4 = int64b4.get(EnumInt64.ENUM_VALUE_4)
      else
        fbe_value.int64b4 = EnumInt64.ENUM_VALUE_4
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int64b4.fbe_size

      if (fbe_current_size + int64b5.fbe_size) <= fbe_struct_size
        fbe_value.int64b5 = int64b5.get(EnumInt64.ENUM_VALUE_5)
      else
        fbe_value.int64b5 = EnumInt64.ENUM_VALUE_5
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += int64b5.fbe_size

      if (fbe_current_size + uint64b0.fbe_size) <= fbe_struct_size
        fbe_value.uint64b0 = uint64b0.get(EnumUInt64.ENUM_VALUE_0)
      else
        fbe_value.uint64b0 = EnumUInt64.ENUM_VALUE_0
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint64b0.fbe_size

      if (fbe_current_size + uint64b1.fbe_size) <= fbe_struct_size
        fbe_value.uint64b1 = uint64b1.get(EnumUInt64.ENUM_VALUE_1)
      else
        fbe_value.uint64b1 = EnumUInt64.ENUM_VALUE_1
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint64b1.fbe_size

      if (fbe_current_size + uint64b2.fbe_size) <= fbe_struct_size
        fbe_value.uint64b2 = uint64b2.get(EnumUInt64.ENUM_VALUE_2)
      else
        fbe_value.uint64b2 = EnumUInt64.ENUM_VALUE_2
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint64b2.fbe_size

      if (fbe_current_size + uint64b3.fbe_size) <= fbe_struct_size
        fbe_value.uint64b3 = uint64b3.get(EnumUInt64.ENUM_VALUE_3)
      else
        fbe_value.uint64b3 = EnumUInt64.ENUM_VALUE_3
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint64b3.fbe_size

      if (fbe_current_size + uint64b4.fbe_size) <= fbe_struct_size
        fbe_value.uint64b4 = uint64b4.get(EnumUInt64.ENUM_VALUE_4)
      else
        fbe_value.uint64b4 = EnumUInt64.ENUM_VALUE_4
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint64b4.fbe_size

      if (fbe_current_size + uint64b5.fbe_size) <= fbe_struct_size
        fbe_value.uint64b5 = uint64b5.get(EnumUInt64.ENUM_VALUE_5)
      else
        fbe_value.uint64b5 = EnumUInt64.ENUM_VALUE_5
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uint64b5.fbe_size
    end

    # Set the struct value (begin phase)
    def set_begin
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      fbe_struct_size = fbe_body
      fbe_struct_offset = @_buffer.allocate(fbe_struct_size) - @_buffer.offset
      if (fbe_struct_offset <= 0) || ((@_buffer.offset + fbe_struct_offset + fbe_struct_size) > @_buffer.size)
        return 0
      end

      write_uint32(fbe_offset, fbe_struct_offset)
      write_uint32(fbe_struct_offset, fbe_struct_size)
      write_uint32(fbe_struct_offset + 4, fbe_type)

      @_buffer.shift(fbe_struct_offset)
      fbe_struct_offset
    end

    # Set the struct value (end phase)
    def set_end(fbe_begin)
      @_buffer.unshift(fbe_begin)
    end

    # Set the struct value
    def set(fbe_value)
      fbe_begin = set_begin
      if fbe_begin == 0
        return
      end

      set_fields(fbe_value)
      set_end(fbe_begin)
    end

    # Set the struct fields values
    def set_fields(fbe_value)
      byte0.set(fbe_value.byte0)
      byte1.set(fbe_value.byte1)
      byte2.set(fbe_value.byte2)
      byte3.set(fbe_value.byte3)
      byte4.set(fbe_value.byte4)
      byte5.set(fbe_value.byte5)
      char0.set(fbe_value.char0)
      char1.set(fbe_value.char1)
      char2.set(fbe_value.char2)
      char3.set(fbe_value.char3)
      char4.set(fbe_value.char4)
      char5.set(fbe_value.char5)
      wchar0.set(fbe_value.wchar0)
      wchar1.set(fbe_value.wchar1)
      wchar2.set(fbe_value.wchar2)
      wchar3.set(fbe_value.wchar3)
      wchar4.set(fbe_value.wchar4)
      wchar5.set(fbe_value.wchar5)
      int8b0.set(fbe_value.int8b0)
      int8b1.set(fbe_value.int8b1)
      int8b2.set(fbe_value.int8b2)
      int8b3.set(fbe_value.int8b3)
      int8b4.set(fbe_value.int8b4)
      int8b5.set(fbe_value.int8b5)
      uint8b0.set(fbe_value.uint8b0)
      uint8b1.set(fbe_value.uint8b1)
      uint8b2.set(fbe_value.uint8b2)
      uint8b3.set(fbe_value.uint8b3)
      uint8b4.set(fbe_value.uint8b4)
      uint8b5.set(fbe_value.uint8b5)
      int16b0.set(fbe_value.int16b0)
      int16b1.set(fbe_value.int16b1)
      int16b2.set(fbe_value.int16b2)
      int16b3.set(fbe_value.int16b3)
      int16b4.set(fbe_value.int16b4)
      int16b5.set(fbe_value.int16b5)
      uint16b0.set(fbe_value.uint16b0)
      uint16b1.set(fbe_value.uint16b1)
      uint16b2.set(fbe_value.uint16b2)
      uint16b3.set(fbe_value.uint16b3)
      uint16b4.set(fbe_value.uint16b4)
      uint16b5.set(fbe_value.uint16b5)
      int32b0.set(fbe_value.int32b0)
      int32b1.set(fbe_value.int32b1)
      int32b2.set(fbe_value.int32b2)
      int32b3.set(fbe_value.int32b3)
      int32b4.set(fbe_value.int32b4)
      int32b5.set(fbe_value.int32b5)
      uint32b0.set(fbe_value.uint32b0)
      uint32b1.set(fbe_value.uint32b1)
      uint32b2.set(fbe_value.uint32b2)
      uint32b3.set(fbe_value.uint32b3)
      uint32b4.set(fbe_value.uint32b4)
      uint32b5.set(fbe_value.uint32b5)
      int64b0.set(fbe_value.int64b0)
      int64b1.set(fbe_value.int64b1)
      int64b2.set(fbe_value.int64b2)
      int64b3.set(fbe_value.int64b3)
      int64b4.set(fbe_value.int64b4)
      int64b5.set(fbe_value.int64b5)
      uint64b0.set(fbe_value.uint64b0)
      uint64b1.set(fbe_value.uint64b1)
      uint64b2.set(fbe_value.uint64b2)
      uint64b3.set(fbe_value.uint64b3)
      uint64b4.set(fbe_value.uint64b4)
      uint64b5.set(fbe_value.uint64b5)
    end
  end

  # Fast Binary Encoding Enums model
  class EnumsModel < FBE::Model
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer)
      @_model = FieldModelEnums.new(self.buffer, 4)
    end

    def model
      @_model
    end

    # Get the model size
    def fbe_size
      @_model.fbe_size + @_model.fbe_extra
    end

    # Get the model type
    def fbe_type
      TYPE
    end

    TYPE = FieldModelEnums::TYPE

    # Is the struct value valid?
    def valid?
      verify
    end

    # Check if the struct value is valid
    def verify
      if (buffer.offset + @_model.fbe_offset - 4) > buffer.size
        return false
      end

      fbe_full_size = read_uint32(@_model.fbe_offset - 4)
      if fbe_full_size < @_model.fbe_size
        return false
      end

      @_model.verify
    end

    # Create a new model (begin phase)
    def create_begin
      buffer.allocate(4 + @_model.fbe_size)
    end

    # Create a new model (end phase)
    def create_end(fbe_begin)
      fbe_end = buffer.size
      fbe_full_size = fbe_end - fbe_begin
      write_uint32(@_model.fbe_offset - 4, fbe_full_size)
      fbe_full_size
    end

    # Serialize the struct value
    def serialize(value)
      fbe_begin = create_begin
      @_model.set(value)
      create_end(fbe_begin)
    end

    # Deserialize the struct value
    def deserialize(value = Enums.new)
      if (buffer.offset + @_model.fbe_offset - 4) > buffer.size
        [Enums.new, 0]
      end

      fbe_full_size = read_uint32(@_model.fbe_offset - 4)
      if fbe_full_size < @_model.fbe_size
        [Enums.new, 0]
      end

      @_model.get(value)
      [value, fbe_full_size]
    end

    # Move to the next struct value
    def next(prev)
      @_model.fbe_shift(prev)
    end
  end

  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class FinalModelEnums < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
      @_byte0 = FinalModelEnumByte.new(self.buffer, 0)
      @_byte1 = FinalModelEnumByte.new(self.buffer, 0)
      @_byte2 = FinalModelEnumByte.new(self.buffer, 0)
      @_byte3 = FinalModelEnumByte.new(self.buffer, 0)
      @_byte4 = FinalModelEnumByte.new(self.buffer, 0)
      @_byte5 = FinalModelEnumByte.new(self.buffer, 0)
      @_char0 = FinalModelEnumChar.new(self.buffer, 0)
      @_char1 = FinalModelEnumChar.new(self.buffer, 0)
      @_char2 = FinalModelEnumChar.new(self.buffer, 0)
      @_char3 = FinalModelEnumChar.new(self.buffer, 0)
      @_char4 = FinalModelEnumChar.new(self.buffer, 0)
      @_char5 = FinalModelEnumChar.new(self.buffer, 0)
      @_wchar0 = FinalModelEnumWChar.new(self.buffer, 0)
      @_wchar1 = FinalModelEnumWChar.new(self.buffer, 0)
      @_wchar2 = FinalModelEnumWChar.new(self.buffer, 0)
      @_wchar3 = FinalModelEnumWChar.new(self.buffer, 0)
      @_wchar4 = FinalModelEnumWChar.new(self.buffer, 0)
      @_wchar5 = FinalModelEnumWChar.new(self.buffer, 0)
      @_int8b0 = FinalModelEnumInt8.new(self.buffer, 0)
      @_int8b1 = FinalModelEnumInt8.new(self.buffer, 0)
      @_int8b2 = FinalModelEnumInt8.new(self.buffer, 0)
      @_int8b3 = FinalModelEnumInt8.new(self.buffer, 0)
      @_int8b4 = FinalModelEnumInt8.new(self.buffer, 0)
      @_int8b5 = FinalModelEnumInt8.new(self.buffer, 0)
      @_uint8b0 = FinalModelEnumUInt8.new(self.buffer, 0)
      @_uint8b1 = FinalModelEnumUInt8.new(self.buffer, 0)
      @_uint8b2 = FinalModelEnumUInt8.new(self.buffer, 0)
      @_uint8b3 = FinalModelEnumUInt8.new(self.buffer, 0)
      @_uint8b4 = FinalModelEnumUInt8.new(self.buffer, 0)
      @_uint8b5 = FinalModelEnumUInt8.new(self.buffer, 0)
      @_int16b0 = FinalModelEnumInt16.new(self.buffer, 0)
      @_int16b1 = FinalModelEnumInt16.new(self.buffer, 0)
      @_int16b2 = FinalModelEnumInt16.new(self.buffer, 0)
      @_int16b3 = FinalModelEnumInt16.new(self.buffer, 0)
      @_int16b4 = FinalModelEnumInt16.new(self.buffer, 0)
      @_int16b5 = FinalModelEnumInt16.new(self.buffer, 0)
      @_uint16b0 = FinalModelEnumUInt16.new(self.buffer, 0)
      @_uint16b1 = FinalModelEnumUInt16.new(self.buffer, 0)
      @_uint16b2 = FinalModelEnumUInt16.new(self.buffer, 0)
      @_uint16b3 = FinalModelEnumUInt16.new(self.buffer, 0)
      @_uint16b4 = FinalModelEnumUInt16.new(self.buffer, 0)
      @_uint16b5 = FinalModelEnumUInt16.new(self.buffer, 0)
      @_int32b0 = FinalModelEnumInt32.new(self.buffer, 0)
      @_int32b1 = FinalModelEnumInt32.new(self.buffer, 0)
      @_int32b2 = FinalModelEnumInt32.new(self.buffer, 0)
      @_int32b3 = FinalModelEnumInt32.new(self.buffer, 0)
      @_int32b4 = FinalModelEnumInt32.new(self.buffer, 0)
      @_int32b5 = FinalModelEnumInt32.new(self.buffer, 0)
      @_uint32b0 = FinalModelEnumUInt32.new(self.buffer, 0)
      @_uint32b1 = FinalModelEnumUInt32.new(self.buffer, 0)
      @_uint32b2 = FinalModelEnumUInt32.new(self.buffer, 0)
      @_uint32b3 = FinalModelEnumUInt32.new(self.buffer, 0)
      @_uint32b4 = FinalModelEnumUInt32.new(self.buffer, 0)
      @_uint32b5 = FinalModelEnumUInt32.new(self.buffer, 0)
      @_int64b0 = FinalModelEnumInt64.new(self.buffer, 0)
      @_int64b1 = FinalModelEnumInt64.new(self.buffer, 0)
      @_int64b2 = FinalModelEnumInt64.new(self.buffer, 0)
      @_int64b3 = FinalModelEnumInt64.new(self.buffer, 0)
      @_int64b4 = FinalModelEnumInt64.new(self.buffer, 0)
      @_int64b5 = FinalModelEnumInt64.new(self.buffer, 0)
      @_uint64b0 = FinalModelEnumUInt64.new(self.buffer, 0)
      @_uint64b1 = FinalModelEnumUInt64.new(self.buffer, 0)
      @_uint64b2 = FinalModelEnumUInt64.new(self.buffer, 0)
      @_uint64b3 = FinalModelEnumUInt64.new(self.buffer, 0)
      @_uint64b4 = FinalModelEnumUInt64.new(self.buffer, 0)
      @_uint64b5 = FinalModelEnumUInt64.new(self.buffer, 0)
    end

    def byte0
      @_byte0
    end

    def byte1
      @_byte1
    end

    def byte2
      @_byte2
    end

    def byte3
      @_byte3
    end

    def byte4
      @_byte4
    end

    def byte5
      @_byte5
    end

    def char0
      @_char0
    end

    def char1
      @_char1
    end

    def char2
      @_char2
    end

    def char3
      @_char3
    end

    def char4
      @_char4
    end

    def char5
      @_char5
    end

    def wchar0
      @_wchar0
    end

    def wchar1
      @_wchar1
    end

    def wchar2
      @_wchar2
    end

    def wchar3
      @_wchar3
    end

    def wchar4
      @_wchar4
    end

    def wchar5
      @_wchar5
    end

    def int8b0
      @_int8b0
    end

    def int8b1
      @_int8b1
    end

    def int8b2
      @_int8b2
    end

    def int8b3
      @_int8b3
    end

    def int8b4
      @_int8b4
    end

    def int8b5
      @_int8b5
    end

    def uint8b0
      @_uint8b0
    end

    def uint8b1
      @_uint8b1
    end

    def uint8b2
      @_uint8b2
    end

    def uint8b3
      @_uint8b3
    end

    def uint8b4
      @_uint8b4
    end

    def uint8b5
      @_uint8b5
    end

    def int16b0
      @_int16b0
    end

    def int16b1
      @_int16b1
    end

    def int16b2
      @_int16b2
    end

    def int16b3
      @_int16b3
    end

    def int16b4
      @_int16b4
    end

    def int16b5
      @_int16b5
    end

    def uint16b0
      @_uint16b0
    end

    def uint16b1
      @_uint16b1
    end

    def uint16b2
      @_uint16b2
    end

    def uint16b3
      @_uint16b3
    end

    def uint16b4
      @_uint16b4
    end

    def uint16b5
      @_uint16b5
    end

    def int32b0
      @_int32b0
    end

    def int32b1
      @_int32b1
    end

    def int32b2
      @_int32b2
    end

    def int32b3
      @_int32b3
    end

    def int32b4
      @_int32b4
    end

    def int32b5
      @_int32b5
    end

    def uint32b0
      @_uint32b0
    end

    def uint32b1
      @_uint32b1
    end

    def uint32b2
      @_uint32b2
    end

    def uint32b3
      @_uint32b3
    end

    def uint32b4
      @_uint32b4
    end

    def uint32b5
      @_uint32b5
    end

    def int64b0
      @_int64b0
    end

    def int64b1
      @_int64b1
    end

    def int64b2
      @_int64b2
    end

    def int64b3
      @_int64b3
    end

    def int64b4
      @_int64b4
    end

    def int64b5
      @_int64b5
    end

    def uint64b0
      @_uint64b0
    end

    def uint64b1
      @_uint64b1
    end

    def uint64b2
      @_uint64b2
    end

    def uint64b3
      @_uint64b3
    end

    def uint64b4
      @_uint64b4
    end

    def uint64b5
      @_uint64b5
    end

    # Get the allocation size
    def fbe_allocation_size(fbe_value)
      0 \
        + byte0.fbe_allocation_size(fbe_value.byte0) \
        + byte1.fbe_allocation_size(fbe_value.byte1) \
        + byte2.fbe_allocation_size(fbe_value.byte2) \
        + byte3.fbe_allocation_size(fbe_value.byte3) \
        + byte4.fbe_allocation_size(fbe_value.byte4) \
        + byte5.fbe_allocation_size(fbe_value.byte5) \
        + char0.fbe_allocation_size(fbe_value.char0) \
        + char1.fbe_allocation_size(fbe_value.char1) \
        + char2.fbe_allocation_size(fbe_value.char2) \
        + char3.fbe_allocation_size(fbe_value.char3) \
        + char4.fbe_allocation_size(fbe_value.char4) \
        + char5.fbe_allocation_size(fbe_value.char5) \
        + wchar0.fbe_allocation_size(fbe_value.wchar0) \
        + wchar1.fbe_allocation_size(fbe_value.wchar1) \
        + wchar2.fbe_allocation_size(fbe_value.wchar2) \
        + wchar3.fbe_allocation_size(fbe_value.wchar3) \
        + wchar4.fbe_allocation_size(fbe_value.wchar4) \
        + wchar5.fbe_allocation_size(fbe_value.wchar5) \
        + int8b0.fbe_allocation_size(fbe_value.int8b0) \
        + int8b1.fbe_allocation_size(fbe_value.int8b1) \
        + int8b2.fbe_allocation_size(fbe_value.int8b2) \
        + int8b3.fbe_allocation_size(fbe_value.int8b3) \
        + int8b4.fbe_allocation_size(fbe_value.int8b4) \
        + int8b5.fbe_allocation_size(fbe_value.int8b5) \
        + uint8b0.fbe_allocation_size(fbe_value.uint8b0) \
        + uint8b1.fbe_allocation_size(fbe_value.uint8b1) \
        + uint8b2.fbe_allocation_size(fbe_value.uint8b2) \
        + uint8b3.fbe_allocation_size(fbe_value.uint8b3) \
        + uint8b4.fbe_allocation_size(fbe_value.uint8b4) \
        + uint8b5.fbe_allocation_size(fbe_value.uint8b5) \
        + int16b0.fbe_allocation_size(fbe_value.int16b0) \
        + int16b1.fbe_allocation_size(fbe_value.int16b1) \
        + int16b2.fbe_allocation_size(fbe_value.int16b2) \
        + int16b3.fbe_allocation_size(fbe_value.int16b3) \
        + int16b4.fbe_allocation_size(fbe_value.int16b4) \
        + int16b5.fbe_allocation_size(fbe_value.int16b5) \
        + uint16b0.fbe_allocation_size(fbe_value.uint16b0) \
        + uint16b1.fbe_allocation_size(fbe_value.uint16b1) \
        + uint16b2.fbe_allocation_size(fbe_value.uint16b2) \
        + uint16b3.fbe_allocation_size(fbe_value.uint16b3) \
        + uint16b4.fbe_allocation_size(fbe_value.uint16b4) \
        + uint16b5.fbe_allocation_size(fbe_value.uint16b5) \
        + int32b0.fbe_allocation_size(fbe_value.int32b0) \
        + int32b1.fbe_allocation_size(fbe_value.int32b1) \
        + int32b2.fbe_allocation_size(fbe_value.int32b2) \
        + int32b3.fbe_allocation_size(fbe_value.int32b3) \
        + int32b4.fbe_allocation_size(fbe_value.int32b4) \
        + int32b5.fbe_allocation_size(fbe_value.int32b5) \
        + uint32b0.fbe_allocation_size(fbe_value.uint32b0) \
        + uint32b1.fbe_allocation_size(fbe_value.uint32b1) \
        + uint32b2.fbe_allocation_size(fbe_value.uint32b2) \
        + uint32b3.fbe_allocation_size(fbe_value.uint32b3) \
        + uint32b4.fbe_allocation_size(fbe_value.uint32b4) \
        + uint32b5.fbe_allocation_size(fbe_value.uint32b5) \
        + int64b0.fbe_allocation_size(fbe_value.int64b0) \
        + int64b1.fbe_allocation_size(fbe_value.int64b1) \
        + int64b2.fbe_allocation_size(fbe_value.int64b2) \
        + int64b3.fbe_allocation_size(fbe_value.int64b3) \
        + int64b4.fbe_allocation_size(fbe_value.int64b4) \
        + int64b5.fbe_allocation_size(fbe_value.int64b5) \
        + uint64b0.fbe_allocation_size(fbe_value.uint64b0) \
        + uint64b1.fbe_allocation_size(fbe_value.uint64b1) \
        + uint64b2.fbe_allocation_size(fbe_value.uint64b2) \
        + uint64b3.fbe_allocation_size(fbe_value.uint64b3) \
        + uint64b4.fbe_allocation_size(fbe_value.uint64b4) \
        + uint64b5.fbe_allocation_size(fbe_value.uint64b5) \
    end

    # Get the final type
    def fbe_type
      TYPE
    end

    TYPE = 1

    # Is the struct value valid?
    def valid?
      verify
    end

    # Check if the struct value is valid
    def verify
      @_buffer.shift(fbe_offset)
      fbe_result = verify_fields
      @_buffer.unshift(fbe_offset)
      fbe_result
    end

    # Check if the struct fields are valid
    def verify_fields
      fbe_current_offset = 0

      byte0.fbe_offset = fbe_current_offset
      fbe_field_size = byte0.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      byte1.fbe_offset = fbe_current_offset
      fbe_field_size = byte1.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      byte2.fbe_offset = fbe_current_offset
      fbe_field_size = byte2.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      byte3.fbe_offset = fbe_current_offset
      fbe_field_size = byte3.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      byte4.fbe_offset = fbe_current_offset
      fbe_field_size = byte4.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      byte5.fbe_offset = fbe_current_offset
      fbe_field_size = byte5.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      char0.fbe_offset = fbe_current_offset
      fbe_field_size = char0.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      char1.fbe_offset = fbe_current_offset
      fbe_field_size = char1.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      char2.fbe_offset = fbe_current_offset
      fbe_field_size = char2.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      char3.fbe_offset = fbe_current_offset
      fbe_field_size = char3.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      char4.fbe_offset = fbe_current_offset
      fbe_field_size = char4.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      char5.fbe_offset = fbe_current_offset
      fbe_field_size = char5.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      wchar0.fbe_offset = fbe_current_offset
      fbe_field_size = wchar0.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      wchar1.fbe_offset = fbe_current_offset
      fbe_field_size = wchar1.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      wchar2.fbe_offset = fbe_current_offset
      fbe_field_size = wchar2.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      wchar3.fbe_offset = fbe_current_offset
      fbe_field_size = wchar3.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      wchar4.fbe_offset = fbe_current_offset
      fbe_field_size = wchar4.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      wchar5.fbe_offset = fbe_current_offset
      fbe_field_size = wchar5.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int8b0.fbe_offset = fbe_current_offset
      fbe_field_size = int8b0.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int8b1.fbe_offset = fbe_current_offset
      fbe_field_size = int8b1.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int8b2.fbe_offset = fbe_current_offset
      fbe_field_size = int8b2.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int8b3.fbe_offset = fbe_current_offset
      fbe_field_size = int8b3.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int8b4.fbe_offset = fbe_current_offset
      fbe_field_size = int8b4.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int8b5.fbe_offset = fbe_current_offset
      fbe_field_size = int8b5.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint8b0.fbe_offset = fbe_current_offset
      fbe_field_size = uint8b0.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint8b1.fbe_offset = fbe_current_offset
      fbe_field_size = uint8b1.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint8b2.fbe_offset = fbe_current_offset
      fbe_field_size = uint8b2.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint8b3.fbe_offset = fbe_current_offset
      fbe_field_size = uint8b3.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint8b4.fbe_offset = fbe_current_offset
      fbe_field_size = uint8b4.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint8b5.fbe_offset = fbe_current_offset
      fbe_field_size = uint8b5.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int16b0.fbe_offset = fbe_current_offset
      fbe_field_size = int16b0.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int16b1.fbe_offset = fbe_current_offset
      fbe_field_size = int16b1.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int16b2.fbe_offset = fbe_current_offset
      fbe_field_size = int16b2.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int16b3.fbe_offset = fbe_current_offset
      fbe_field_size = int16b3.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int16b4.fbe_offset = fbe_current_offset
      fbe_field_size = int16b4.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int16b5.fbe_offset = fbe_current_offset
      fbe_field_size = int16b5.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint16b0.fbe_offset = fbe_current_offset
      fbe_field_size = uint16b0.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint16b1.fbe_offset = fbe_current_offset
      fbe_field_size = uint16b1.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint16b2.fbe_offset = fbe_current_offset
      fbe_field_size = uint16b2.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint16b3.fbe_offset = fbe_current_offset
      fbe_field_size = uint16b3.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint16b4.fbe_offset = fbe_current_offset
      fbe_field_size = uint16b4.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint16b5.fbe_offset = fbe_current_offset
      fbe_field_size = uint16b5.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int32b0.fbe_offset = fbe_current_offset
      fbe_field_size = int32b0.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int32b1.fbe_offset = fbe_current_offset
      fbe_field_size = int32b1.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int32b2.fbe_offset = fbe_current_offset
      fbe_field_size = int32b2.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int32b3.fbe_offset = fbe_current_offset
      fbe_field_size = int32b3.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int32b4.fbe_offset = fbe_current_offset
      fbe_field_size = int32b4.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int32b5.fbe_offset = fbe_current_offset
      fbe_field_size = int32b5.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint32b0.fbe_offset = fbe_current_offset
      fbe_field_size = uint32b0.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint32b1.fbe_offset = fbe_current_offset
      fbe_field_size = uint32b1.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint32b2.fbe_offset = fbe_current_offset
      fbe_field_size = uint32b2.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint32b3.fbe_offset = fbe_current_offset
      fbe_field_size = uint32b3.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint32b4.fbe_offset = fbe_current_offset
      fbe_field_size = uint32b4.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint32b5.fbe_offset = fbe_current_offset
      fbe_field_size = uint32b5.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int64b0.fbe_offset = fbe_current_offset
      fbe_field_size = int64b0.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int64b1.fbe_offset = fbe_current_offset
      fbe_field_size = int64b1.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int64b2.fbe_offset = fbe_current_offset
      fbe_field_size = int64b2.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int64b3.fbe_offset = fbe_current_offset
      fbe_field_size = int64b3.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int64b4.fbe_offset = fbe_current_offset
      fbe_field_size = int64b4.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      int64b5.fbe_offset = fbe_current_offset
      fbe_field_size = int64b5.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint64b0.fbe_offset = fbe_current_offset
      fbe_field_size = uint64b0.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint64b1.fbe_offset = fbe_current_offset
      fbe_field_size = uint64b1.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint64b2.fbe_offset = fbe_current_offset
      fbe_field_size = uint64b2.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint64b3.fbe_offset = fbe_current_offset
      fbe_field_size = uint64b3.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint64b4.fbe_offset = fbe_current_offset
      fbe_field_size = uint64b4.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      uint64b5.fbe_offset = fbe_current_offset
      fbe_field_size = uint64b5.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      # noinspection RubyUnnecessaryReturnValue
      fbe_current_offset
    end

    # Get the struct value
    def get(fbe_value = Enums.new)
      @_buffer.shift(fbe_offset)
      fbe_size = get_fields(fbe_value)
      @_buffer.unshift(fbe_offset)
      [fbe_value, fbe_size]
    end

    # Get the struct fields values
    def get_fields(fbe_value)
      fbe_current_offset = 0
      fbe_current_size = 0

      byte0.fbe_offset = fbe_current_offset
      fbe_result = byte0.get
      fbe_value.byte0 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      byte1.fbe_offset = fbe_current_offset
      fbe_result = byte1.get
      fbe_value.byte1 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      byte2.fbe_offset = fbe_current_offset
      fbe_result = byte2.get
      fbe_value.byte2 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      byte3.fbe_offset = fbe_current_offset
      fbe_result = byte3.get
      fbe_value.byte3 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      byte4.fbe_offset = fbe_current_offset
      fbe_result = byte4.get
      fbe_value.byte4 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      byte5.fbe_offset = fbe_current_offset
      fbe_result = byte5.get
      fbe_value.byte5 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      char0.fbe_offset = fbe_current_offset
      fbe_result = char0.get
      fbe_value.char0 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      char1.fbe_offset = fbe_current_offset
      fbe_result = char1.get
      fbe_value.char1 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      char2.fbe_offset = fbe_current_offset
      fbe_result = char2.get
      fbe_value.char2 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      char3.fbe_offset = fbe_current_offset
      fbe_result = char3.get
      fbe_value.char3 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      char4.fbe_offset = fbe_current_offset
      fbe_result = char4.get
      fbe_value.char4 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      char5.fbe_offset = fbe_current_offset
      fbe_result = char5.get
      fbe_value.char5 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      wchar0.fbe_offset = fbe_current_offset
      fbe_result = wchar0.get
      fbe_value.wchar0 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      wchar1.fbe_offset = fbe_current_offset
      fbe_result = wchar1.get
      fbe_value.wchar1 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      wchar2.fbe_offset = fbe_current_offset
      fbe_result = wchar2.get
      fbe_value.wchar2 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      wchar3.fbe_offset = fbe_current_offset
      fbe_result = wchar3.get
      fbe_value.wchar3 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      wchar4.fbe_offset = fbe_current_offset
      fbe_result = wchar4.get
      fbe_value.wchar4 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      wchar5.fbe_offset = fbe_current_offset
      fbe_result = wchar5.get
      fbe_value.wchar5 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int8b0.fbe_offset = fbe_current_offset
      fbe_result = int8b0.get
      fbe_value.int8b0 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int8b1.fbe_offset = fbe_current_offset
      fbe_result = int8b1.get
      fbe_value.int8b1 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int8b2.fbe_offset = fbe_current_offset
      fbe_result = int8b2.get
      fbe_value.int8b2 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int8b3.fbe_offset = fbe_current_offset
      fbe_result = int8b3.get
      fbe_value.int8b3 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int8b4.fbe_offset = fbe_current_offset
      fbe_result = int8b4.get
      fbe_value.int8b4 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int8b5.fbe_offset = fbe_current_offset
      fbe_result = int8b5.get
      fbe_value.int8b5 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint8b0.fbe_offset = fbe_current_offset
      fbe_result = uint8b0.get
      fbe_value.uint8b0 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint8b1.fbe_offset = fbe_current_offset
      fbe_result = uint8b1.get
      fbe_value.uint8b1 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint8b2.fbe_offset = fbe_current_offset
      fbe_result = uint8b2.get
      fbe_value.uint8b2 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint8b3.fbe_offset = fbe_current_offset
      fbe_result = uint8b3.get
      fbe_value.uint8b3 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint8b4.fbe_offset = fbe_current_offset
      fbe_result = uint8b4.get
      fbe_value.uint8b4 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint8b5.fbe_offset = fbe_current_offset
      fbe_result = uint8b5.get
      fbe_value.uint8b5 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int16b0.fbe_offset = fbe_current_offset
      fbe_result = int16b0.get
      fbe_value.int16b0 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int16b1.fbe_offset = fbe_current_offset
      fbe_result = int16b1.get
      fbe_value.int16b1 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int16b2.fbe_offset = fbe_current_offset
      fbe_result = int16b2.get
      fbe_value.int16b2 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int16b3.fbe_offset = fbe_current_offset
      fbe_result = int16b3.get
      fbe_value.int16b3 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int16b4.fbe_offset = fbe_current_offset
      fbe_result = int16b4.get
      fbe_value.int16b4 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int16b5.fbe_offset = fbe_current_offset
      fbe_result = int16b5.get
      fbe_value.int16b5 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint16b0.fbe_offset = fbe_current_offset
      fbe_result = uint16b0.get
      fbe_value.uint16b0 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint16b1.fbe_offset = fbe_current_offset
      fbe_result = uint16b1.get
      fbe_value.uint16b1 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint16b2.fbe_offset = fbe_current_offset
      fbe_result = uint16b2.get
      fbe_value.uint16b2 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint16b3.fbe_offset = fbe_current_offset
      fbe_result = uint16b3.get
      fbe_value.uint16b3 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint16b4.fbe_offset = fbe_current_offset
      fbe_result = uint16b4.get
      fbe_value.uint16b4 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint16b5.fbe_offset = fbe_current_offset
      fbe_result = uint16b5.get
      fbe_value.uint16b5 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int32b0.fbe_offset = fbe_current_offset
      fbe_result = int32b0.get
      fbe_value.int32b0 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int32b1.fbe_offset = fbe_current_offset
      fbe_result = int32b1.get
      fbe_value.int32b1 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int32b2.fbe_offset = fbe_current_offset
      fbe_result = int32b2.get
      fbe_value.int32b2 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int32b3.fbe_offset = fbe_current_offset
      fbe_result = int32b3.get
      fbe_value.int32b3 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int32b4.fbe_offset = fbe_current_offset
      fbe_result = int32b4.get
      fbe_value.int32b4 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int32b5.fbe_offset = fbe_current_offset
      fbe_result = int32b5.get
      fbe_value.int32b5 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint32b0.fbe_offset = fbe_current_offset
      fbe_result = uint32b0.get
      fbe_value.uint32b0 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint32b1.fbe_offset = fbe_current_offset
      fbe_result = uint32b1.get
      fbe_value.uint32b1 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint32b2.fbe_offset = fbe_current_offset
      fbe_result = uint32b2.get
      fbe_value.uint32b2 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint32b3.fbe_offset = fbe_current_offset
      fbe_result = uint32b3.get
      fbe_value.uint32b3 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint32b4.fbe_offset = fbe_current_offset
      fbe_result = uint32b4.get
      fbe_value.uint32b4 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint32b5.fbe_offset = fbe_current_offset
      fbe_result = uint32b5.get
      fbe_value.uint32b5 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int64b0.fbe_offset = fbe_current_offset
      fbe_result = int64b0.get
      fbe_value.int64b0 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int64b1.fbe_offset = fbe_current_offset
      fbe_result = int64b1.get
      fbe_value.int64b1 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int64b2.fbe_offset = fbe_current_offset
      fbe_result = int64b2.get
      fbe_value.int64b2 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int64b3.fbe_offset = fbe_current_offset
      fbe_result = int64b3.get
      fbe_value.int64b3 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int64b4.fbe_offset = fbe_current_offset
      fbe_result = int64b4.get
      fbe_value.int64b4 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      int64b5.fbe_offset = fbe_current_offset
      fbe_result = int64b5.get
      fbe_value.int64b5 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint64b0.fbe_offset = fbe_current_offset
      fbe_result = uint64b0.get
      fbe_value.uint64b0 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint64b1.fbe_offset = fbe_current_offset
      fbe_result = uint64b1.get
      fbe_value.uint64b1 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint64b2.fbe_offset = fbe_current_offset
      fbe_result = uint64b2.get
      fbe_value.uint64b2 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint64b3.fbe_offset = fbe_current_offset
      fbe_result = uint64b3.get
      fbe_value.uint64b3 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint64b4.fbe_offset = fbe_current_offset
      fbe_result = uint64b4.get
      fbe_value.uint64b4 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      uint64b5.fbe_offset = fbe_current_offset
      fbe_result = uint64b5.get
      fbe_value.uint64b5 = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      # noinspection RubyUnnecessaryReturnValue
      fbe_current_size
    end

    # Set the struct value
    def set(fbe_value)
      @_buffer.shift(fbe_offset)
      fbe_size = set_fields(fbe_value)
      @_buffer.unshift(fbe_offset)
      fbe_size
    end

    # Set the struct fields values
    def set_fields(fbe_value)
      fbe_current_offset = 0
      fbe_current_size = 0

      byte0.fbe_offset = fbe_current_offset
      fbe_field_size = byte0.set(fbe_value.byte0)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      byte1.fbe_offset = fbe_current_offset
      fbe_field_size = byte1.set(fbe_value.byte1)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      byte2.fbe_offset = fbe_current_offset
      fbe_field_size = byte2.set(fbe_value.byte2)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      byte3.fbe_offset = fbe_current_offset
      fbe_field_size = byte3.set(fbe_value.byte3)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      byte4.fbe_offset = fbe_current_offset
      fbe_field_size = byte4.set(fbe_value.byte4)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      byte5.fbe_offset = fbe_current_offset
      fbe_field_size = byte5.set(fbe_value.byte5)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      char0.fbe_offset = fbe_current_offset
      fbe_field_size = char0.set(fbe_value.char0)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      char1.fbe_offset = fbe_current_offset
      fbe_field_size = char1.set(fbe_value.char1)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      char2.fbe_offset = fbe_current_offset
      fbe_field_size = char2.set(fbe_value.char2)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      char3.fbe_offset = fbe_current_offset
      fbe_field_size = char3.set(fbe_value.char3)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      char4.fbe_offset = fbe_current_offset
      fbe_field_size = char4.set(fbe_value.char4)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      char5.fbe_offset = fbe_current_offset
      fbe_field_size = char5.set(fbe_value.char5)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      wchar0.fbe_offset = fbe_current_offset
      fbe_field_size = wchar0.set(fbe_value.wchar0)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      wchar1.fbe_offset = fbe_current_offset
      fbe_field_size = wchar1.set(fbe_value.wchar1)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      wchar2.fbe_offset = fbe_current_offset
      fbe_field_size = wchar2.set(fbe_value.wchar2)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      wchar3.fbe_offset = fbe_current_offset
      fbe_field_size = wchar3.set(fbe_value.wchar3)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      wchar4.fbe_offset = fbe_current_offset
      fbe_field_size = wchar4.set(fbe_value.wchar4)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      wchar5.fbe_offset = fbe_current_offset
      fbe_field_size = wchar5.set(fbe_value.wchar5)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int8b0.fbe_offset = fbe_current_offset
      fbe_field_size = int8b0.set(fbe_value.int8b0)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int8b1.fbe_offset = fbe_current_offset
      fbe_field_size = int8b1.set(fbe_value.int8b1)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int8b2.fbe_offset = fbe_current_offset
      fbe_field_size = int8b2.set(fbe_value.int8b2)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int8b3.fbe_offset = fbe_current_offset
      fbe_field_size = int8b3.set(fbe_value.int8b3)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int8b4.fbe_offset = fbe_current_offset
      fbe_field_size = int8b4.set(fbe_value.int8b4)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int8b5.fbe_offset = fbe_current_offset
      fbe_field_size = int8b5.set(fbe_value.int8b5)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint8b0.fbe_offset = fbe_current_offset
      fbe_field_size = uint8b0.set(fbe_value.uint8b0)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint8b1.fbe_offset = fbe_current_offset
      fbe_field_size = uint8b1.set(fbe_value.uint8b1)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint8b2.fbe_offset = fbe_current_offset
      fbe_field_size = uint8b2.set(fbe_value.uint8b2)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint8b3.fbe_offset = fbe_current_offset
      fbe_field_size = uint8b3.set(fbe_value.uint8b3)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint8b4.fbe_offset = fbe_current_offset
      fbe_field_size = uint8b4.set(fbe_value.uint8b4)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint8b5.fbe_offset = fbe_current_offset
      fbe_field_size = uint8b5.set(fbe_value.uint8b5)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int16b0.fbe_offset = fbe_current_offset
      fbe_field_size = int16b0.set(fbe_value.int16b0)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int16b1.fbe_offset = fbe_current_offset
      fbe_field_size = int16b1.set(fbe_value.int16b1)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int16b2.fbe_offset = fbe_current_offset
      fbe_field_size = int16b2.set(fbe_value.int16b2)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int16b3.fbe_offset = fbe_current_offset
      fbe_field_size = int16b3.set(fbe_value.int16b3)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int16b4.fbe_offset = fbe_current_offset
      fbe_field_size = int16b4.set(fbe_value.int16b4)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int16b5.fbe_offset = fbe_current_offset
      fbe_field_size = int16b5.set(fbe_value.int16b5)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint16b0.fbe_offset = fbe_current_offset
      fbe_field_size = uint16b0.set(fbe_value.uint16b0)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint16b1.fbe_offset = fbe_current_offset
      fbe_field_size = uint16b1.set(fbe_value.uint16b1)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint16b2.fbe_offset = fbe_current_offset
      fbe_field_size = uint16b2.set(fbe_value.uint16b2)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint16b3.fbe_offset = fbe_current_offset
      fbe_field_size = uint16b3.set(fbe_value.uint16b3)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint16b4.fbe_offset = fbe_current_offset
      fbe_field_size = uint16b4.set(fbe_value.uint16b4)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint16b5.fbe_offset = fbe_current_offset
      fbe_field_size = uint16b5.set(fbe_value.uint16b5)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int32b0.fbe_offset = fbe_current_offset
      fbe_field_size = int32b0.set(fbe_value.int32b0)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int32b1.fbe_offset = fbe_current_offset
      fbe_field_size = int32b1.set(fbe_value.int32b1)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int32b2.fbe_offset = fbe_current_offset
      fbe_field_size = int32b2.set(fbe_value.int32b2)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int32b3.fbe_offset = fbe_current_offset
      fbe_field_size = int32b3.set(fbe_value.int32b3)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int32b4.fbe_offset = fbe_current_offset
      fbe_field_size = int32b4.set(fbe_value.int32b4)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int32b5.fbe_offset = fbe_current_offset
      fbe_field_size = int32b5.set(fbe_value.int32b5)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint32b0.fbe_offset = fbe_current_offset
      fbe_field_size = uint32b0.set(fbe_value.uint32b0)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint32b1.fbe_offset = fbe_current_offset
      fbe_field_size = uint32b1.set(fbe_value.uint32b1)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint32b2.fbe_offset = fbe_current_offset
      fbe_field_size = uint32b2.set(fbe_value.uint32b2)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint32b3.fbe_offset = fbe_current_offset
      fbe_field_size = uint32b3.set(fbe_value.uint32b3)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint32b4.fbe_offset = fbe_current_offset
      fbe_field_size = uint32b4.set(fbe_value.uint32b4)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint32b5.fbe_offset = fbe_current_offset
      fbe_field_size = uint32b5.set(fbe_value.uint32b5)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int64b0.fbe_offset = fbe_current_offset
      fbe_field_size = int64b0.set(fbe_value.int64b0)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int64b1.fbe_offset = fbe_current_offset
      fbe_field_size = int64b1.set(fbe_value.int64b1)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int64b2.fbe_offset = fbe_current_offset
      fbe_field_size = int64b2.set(fbe_value.int64b2)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int64b3.fbe_offset = fbe_current_offset
      fbe_field_size = int64b3.set(fbe_value.int64b3)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int64b4.fbe_offset = fbe_current_offset
      fbe_field_size = int64b4.set(fbe_value.int64b4)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      int64b5.fbe_offset = fbe_current_offset
      fbe_field_size = int64b5.set(fbe_value.int64b5)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint64b0.fbe_offset = fbe_current_offset
      fbe_field_size = uint64b0.set(fbe_value.uint64b0)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint64b1.fbe_offset = fbe_current_offset
      fbe_field_size = uint64b1.set(fbe_value.uint64b1)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint64b2.fbe_offset = fbe_current_offset
      fbe_field_size = uint64b2.set(fbe_value.uint64b2)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint64b3.fbe_offset = fbe_current_offset
      fbe_field_size = uint64b3.set(fbe_value.uint64b3)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint64b4.fbe_offset = fbe_current_offset
      fbe_field_size = uint64b4.set(fbe_value.uint64b4)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      uint64b5.fbe_offset = fbe_current_offset
      fbe_field_size = uint64b5.set(fbe_value.uint64b5)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      # noinspection RubyUnnecessaryReturnValue
      fbe_current_size
    end
  end

  # Fast Binary Encoding Enums final model
  class EnumsFinalModel < FBE::Model
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer)
      @_model = FinalModelEnums.new(self.buffer, 8)
    end

    # Get the model type
    def fbe_type
      TYPE
    end

    TYPE = FinalModelEnums::TYPE

    # Is the struct value valid?
    def valid?
      verify
    end

    # Check if the struct value is valid
    def verify
      if (buffer.offset + @_model.fbe_offset) > buffer.size
        return false
      end

      fbe_struct_size = read_uint32(@_model.fbe_offset - 8)
      fbe_struct_type = read_uint32(@_model.fbe_offset - 4)
      if (fbe_struct_size <= 0) or (fbe_struct_type != fbe_type)
        return false
      end

      (8 + @_model.verify) == fbe_struct_size
    end

    # Serialize the struct value
    def serialize(value)
      fbe_initial_size = buffer.size

      fbe_struct_type = fbe_type
      fbe_struct_size = 8 + @_model.fbe_allocation_size(value)
      fbe_struct_offset = buffer.allocate(fbe_struct_size) - buffer.offset
      if (buffer.offset + fbe_struct_offset + fbe_struct_size) > buffer.size
        return 0
      end

      fbe_struct_size = 8 + @_model.set(value)
      buffer.resize(fbe_initial_size + fbe_struct_size)

      write_uint32(@_model.fbe_offset - 8, fbe_struct_size)
      write_uint32(@_model.fbe_offset - 4, fbe_struct_type)

      fbe_struct_size
    end

    # Deserialize the struct value
    def deserialize(value = Enums.new)
      if (buffer.offset + @_model.fbe_offset) > buffer.size
        [Enums.new, 0]
      end

      fbe_struct_size = read_uint32(@_model.fbe_offset - 8)
      fbe_struct_type = read_uint32(@_model.fbe_offset - 4)
      if (fbe_struct_size <= 0) || (fbe_struct_type != fbe_type)
        [Enums.new, 8]
      end

      fbe_result = @_model.get(value)
      [fbe_result[0], (8 + fbe_result[1])]
    end

    # Move to the next struct value
    def next(prev)
      @_model.fbe_shift(prev)
    end
  end

  # Fast Binary Encoding Enums protocol version
  class ProtocolVersion
    # Protocol major version
    MAJOR = 1
    # Protocol minor version
    MINOR = 0
  end

  # Fast Binary Encoding Enums sender
  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class Sender < FBE::Sender
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer, false)
    end

    # Sender models accessors

    # Send methods

    def send(value)
      0
    end

    protected

    # Send message handler
    def on_send(buffer, offset, size)
      raise NotImplementedError, "Enums.Sender.on_send() not implemented!"
    end
  end

  # Fast Binary Encoding Enums receiver
  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class Receiver < FBE::Receiver
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer, false)
    end

    protected

    # Receive handlers

    public

    def on_receive(type, buffer, offset, size)

      false
    end
  end

  # Fast Binary Encoding Enums proxy
  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class Proxy < FBE::Receiver
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer, false)
    end

    protected

    # Receive handlers

    public

    def on_receive(type, buffer, offset, size)

      false
    end
  end

  # Fast Binary Encoding Enums final sender
  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class FinalSender < FBE::Sender
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer, true)
    end

    # Sender models accessors

    # Send methods

    def send(value)
      0
    end

    protected

    # Send message handler
    def on_send(buffer, offset, size)
      raise NotImplementedError, "Enums.Sender.on_send() not implemented!"
    end
  end

  # Fast Binary Encoding Enums final receiver
  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class FinalReceiver < FBE::Receiver
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer, true)
    end

    protected

    # Receive handlers

    public

    def on_receive(type, buffer, offset, size)

      false
    end
  end

end

# rubocop:enable all
