#------------------------------------------------------------------------------
# Automatically generated by the Fast Binary Encoding compiler, do not modify!
# https://github.com/chronoxor/FastBinaryEncoding
# Source: osa.fbe
# FBE version: 1.10.0.0
#------------------------------------------------------------------------------

# rubocop:disable Lint/MissingCopEnableDirective
# rubocop:disable Lint/UnneededCopDisableDirective
# rubocop:disable Metrics/AbcSize
# rubocop:disable Metrics/ClassLength
# rubocop:disable Metrics/CyclomaticComplexity
# rubocop:disable Metrics/LineLength
# rubocop:disable Metrics/MethodLength
# rubocop:disable Metrics/PerceivedComplexity

require 'base64'
require 'bigdecimal'
require 'json'
require 'set'
require 'uuidtools'

require_relative 'fbe'

module Osa

  module Sex
    class Enum
      include FBE::Enum

      define :male, 0 + 0
      define :female, 0 + 1

      def initialize(value = 0)
        @value = value.is_a?(Enum) ? value.value : value
      end

      # Enum compare operators
      def ==(value) @value == value.value end
      def !=(value) @value != value.value end

      # Enum equals
      def eql?(other)
        self == other
      end

      # Enum hash code
      def hash
        @value.hash
      end

      # Get enum integer value
      def to_i
        @value
      end

      # Get enum string value
      def to_s
        if @value == Enum.male
          return 'male'
        end
        if @value == Enum.female
          return 'female'
        end
        '<unknown>'
      end

      # Get enum JSON value
      def __to_json_map__
        @value
      end
    end

    class << self
      attr_accessor :male
      attr_accessor :female
    end

    self.male = Enum.new(Enum.male)
    self.female = Enum.new(Enum.female)

    def self.new(value = 0)
      Enum.new(value)
    end

    # Get enum value from JSON
    def self.__from_json_map__(json)
      Enum.new(json)
    end
  end

  Sex.freeze

  # Fast Binary Encoding Sex field model
  class FieldModelSex < FBE::FieldModel
    def initialize(buffer, offset)
        super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      4
    end

    # Get the value
    def get(defaults = Sex.new)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      Sex.new(read_int32(fbe_offset))
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_int32(fbe_offset, value.value)
    end
  end

  # Fast Binary Encoding Sex final model
  class FinalModelSex < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      4
    end

    # Is the enum value valid?
    def valid?
      verify
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return FBE::Integer::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [Sex.new, 0]
      end

      [Sex.new(read_int32(fbe_offset)), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_int32(fbe_offset, value.value)
      fbe_size
    end
  end

  module MyFLags
    class Enum
      include FBE::Enum

      define :flag0, 0x00 + 0
      define :flag1, 0x01 + 0
      define :flag2, 0x02 + 0

      def initialize(value = 0)
        @value = value.is_a?(Enum) ? value.value : value
      end

      # Enum compare operators
      def ==(value) @value == value.value end
      def !=(value) @value != value.value end

      # Enum equals
      def eql?(other)
        self == other
      end

      # Enum hash code
      def hash
        @value.hash
      end

      # Get enum integer value
      def to_i
        @value
      end

      # Get enum string value
      def to_s
        if @value == Enum.flag0
          return 'flag0'
        end
        if @value == Enum.flag1
          return 'flag1'
        end
        if @value == Enum.flag2
          return 'flag2'
        end
        '<unknown>'
      end

      # Get enum JSON value
      def __to_json_map__
        @value
      end
    end

    class << self
      attr_accessor :flag0
      attr_accessor :flag1
      attr_accessor :flag2
    end

    self.flag0 = Enum.new(Enum.flag0)
    self.flag1 = Enum.new(Enum.flag1)
    self.flag2 = Enum.new(Enum.flag2)

    def self.new(value = 0)
      Enum.new(value)
    end

    # Get enum value from JSON
    def self.__from_json_map__(json)
      Enum.new(json)
    end
  end

  MyFLags.freeze

  # Fast Binary Encoding MyFLags field model
  class FieldModelMyFLags < FBE::FieldModel
    def initialize(buffer, offset)
        super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      4
    end

    # Get the value
    def get(defaults = MyFLags.new)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      MyFLags.new(read_int32(fbe_offset))
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_int32(fbe_offset, value.value)
    end
  end

  # Fast Binary Encoding MyFLags final model
  class FinalModelMyFLags < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      4
    end

    # Is the enum value valid?
    def valid?
      verify
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return FBE::Integer::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [MyFLags.new, 0]
      end

      [MyFLags.new(read_int32(fbe_offset)), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_int32(fbe_offset, value.value)
      fbe_size
    end
  end

  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class Extra
    include Comparable

    attr_accessor :name
    attr_accessor :detail
    attr_accessor :sex
    attr_accessor :flag

    def initialize(name = '', detail = '', sex = Sex.new, flag = MyFLags.new)
      @name = name
      @detail = detail
      @sex = sex
      @flag = flag
    end

    def initialize_copy(other)
      @name = other.name
      @detail = other.detail
      @sex = other.sex
      @flag = other.flag
    end

    # Struct shallow copy
    def copy(other)
      initialize_copy(other)
      self
    end

    # Struct deep clone
    def clone
      data = Marshal.dump(self)
      clone = Marshal.load(data)
      clone.freeze if frozen?
      clone
    end

    # Struct compare operators
    def <=>(other)
      return nil unless other.is_a?(Extra)

      # noinspection RubyUnusedLocalVariable
      result = 0
      # noinspection RubyUnnecessaryReturnValue
      result
    end

    # Struct equals
    def eql?(other)
      self == other
    end

    # Struct keys
    def key
      result = []
      # noinspection RubyUnnecessaryReturnValue
      result
    end

    # Struct hash code
    def hash
      key.hash
    end

    # Get struct string value
    def to_s
      result = ''
      result << 'Extra('
      result << 'name='
      if !@name.nil?
        result << '"' << @name.to_s << '"'
      else
        result << 'null'
      end
      result << ',detail='
      if !@detail.nil?
        result << '"' << @detail.to_s << '"'
      else
        result << 'null'
      end
      result << ',sex='
      if !@sex.nil?
        result << @sex.to_s
      else
        result << 'null'
      end
      result << ',flag='
      if !@flag.nil?
        result << @flag.to_s
      else
        result << 'null'
      end
      result << ')'
      result
    end

    # Dump the struct
    def marshal_dump
      # Serialize the struct to the FBE stream
      writer = ExtraModel.new(FBE::WriteBuffer.new)
      writer.serialize(self)
      writer.buffer
    end

    # Load the struct
    def marshal_load(data)
      # Deserialize the struct from the FBE stream
      reader = ExtraModel.new(FBE::ReadBuffer.new)
      reader.attach_buffer(data)
      initialize_copy(reader.deserialize[0])
    end

    # Get struct JSON value
    def to_json
      JSON.generate(__to_json_map__)
    end

    # Get struct JSON map (internal method)
    def __to_json_map__
      result = {}
      key = 'name'
      value = (name.nil? ? nil : name)
      result.store(key, value)
      key = 'detail'
      value = (detail.nil? ? nil : detail)
      result.store(key, value)
      key = 'sex'
      value = (sex.nil? ? nil : sex.__to_json_map__)
      result.store(key, value)
      key = 'flag'
      value = (flag.nil? ? nil : flag.__to_json_map__)
      result.store(key, value)
      result
    end

    # Get struct from JSON
    def self.from_json(json)
      __from_json_map__(JSON.parse(json))
    end

    # Get struct map from JSON (internal method)
    def self.__from_json_map__(json)
      result = Extra.new
      value = json.fetch('name', nil)
      result.name = (value.nil? ? nil : value)
      value = json.fetch('detail', nil)
      result.detail = (value.nil? ? nil : value)
      value = json.fetch('sex', nil)
      result.sex = (value.nil? ? nil : Sex.__from_json_map__(value))
      value = json.fetch('flag', nil)
      result.flag = (value.nil? ? nil : MyFLags.__from_json_map__(value))
      result
    end

    # Get the FBE type
    def fbe_type
      TYPE
    end

    TYPE = 1
  end

  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class FieldModelExtra < FBE::FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
      @_name = FBE::FieldModelString.new(self.buffer, 4 + 4)
      @_detail = FBE::FieldModelString.new(self.buffer, @_name.fbe_offset + @_name.fbe_size)
      @_sex = FieldModelSex.new(self.buffer, @_detail.fbe_offset + @_detail.fbe_size)
      @_flag = FieldModelMyFLags.new(self.buffer, @_sex.fbe_offset + @_sex.fbe_size)
    end

    def name
      @_name
    end

    def detail
      @_detail
    end

    def sex
      @_sex
    end

    def flag
      @_flag
    end

    # Get the field size
    def fbe_size
      4
    end

    # Get the field body size
    def fbe_body
      4 + 4 \
        + name.fbe_size \
        + detail.fbe_size \
        + sex.fbe_size \
        + flag.fbe_size \
    end

    # Get the field extra size
    def fbe_extra
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      fbe_struct_offset = read_uint32(fbe_offset)
      if (fbe_struct_offset == 0) || ((@_buffer.offset + fbe_struct_offset + 4) > @_buffer.size)
        return 0
      end

      @_buffer.shift(fbe_struct_offset)

      fbe_result = fbe_body \
        + name.fbe_extra \
        + detail.fbe_extra \
        + sex.fbe_extra \
        + flag.fbe_extra \

      @_buffer.unshift(fbe_struct_offset)

      fbe_result
    end

    # Get the field type
    def fbe_type
      TYPE
    end

    TYPE = 1

    # Is the struct value valid?
    def valid?
      verify
    end

    # Check if the struct value is valid
    def verify(fbe_verify_type = true)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return true
      end

      fbe_struct_offset = read_uint32(fbe_offset)
      if (fbe_struct_offset == 0) || ((@_buffer.offset + fbe_struct_offset + 4 + 4) > @_buffer.size)
        return false
      end

      fbe_struct_size = read_uint32(fbe_struct_offset)
      if fbe_struct_size < (4 + 4)
        return false
      end

      fbe_struct_type = read_uint32(fbe_struct_offset + 4)
      if fbe_verify_type && (fbe_struct_type != fbe_type)
        return false
      end

      @_buffer.shift(fbe_struct_offset)
      fbe_result = verify_fields(fbe_struct_size)
      @_buffer.unshift(fbe_struct_offset)
      fbe_result
    end

    # Check if the struct fields are valid
    def verify_fields(fbe_struct_size)
      fbe_current_size = 4 + 4

      if (fbe_current_size + name.fbe_size) > fbe_struct_size
        return true
      end
      unless name.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += name.fbe_size

      if (fbe_current_size + detail.fbe_size) > fbe_struct_size
        return true
      end
      unless detail.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += detail.fbe_size

      if (fbe_current_size + sex.fbe_size) > fbe_struct_size
        return true
      end
      unless sex.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += sex.fbe_size

      if (fbe_current_size + flag.fbe_size) > fbe_struct_size
        return true
      end
      unless flag.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += flag.fbe_size

      true
    end

    # Get the struct value (begin phase)
    def get_begin
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      fbe_struct_offset = read_uint32(fbe_offset)
      if (fbe_struct_offset == 0) || ((@_buffer.offset + fbe_struct_offset + 4 + 4) > @_buffer.size)
        return 0
      end

      fbe_struct_size = read_uint32(fbe_struct_offset)
      if fbe_struct_size < (4 + 4)
        return 0
      end

      @_buffer.shift(fbe_struct_offset)
      fbe_struct_offset
    end

    # Get the struct value (end phase)
    def get_end(fbe_begin)
      @_buffer.unshift(fbe_begin)
    end

    # Get the struct value
    def get(fbe_value = Extra.new)
      fbe_begin = get_begin
      if fbe_begin == 0
        return fbe_value
      end

      fbe_struct_size = read_uint32(0)
      get_fields(fbe_value, fbe_struct_size)
      get_end(fbe_begin)
      fbe_value
    end

    # Get the struct fields values
    def get_fields(fbe_value, fbe_struct_size)
      fbe_current_size = 4 + 4

      if (fbe_current_size + name.fbe_size) <= fbe_struct_size
        fbe_value.name = name.get
      else
        fbe_value.name = ''
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += name.fbe_size

      if (fbe_current_size + detail.fbe_size) <= fbe_struct_size
        fbe_value.detail = detail.get
      else
        fbe_value.detail = ''
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += detail.fbe_size

      if (fbe_current_size + sex.fbe_size) <= fbe_struct_size
        fbe_value.sex = sex.get
      else
        fbe_value.sex = Sex.new
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += sex.fbe_size

      if (fbe_current_size + flag.fbe_size) <= fbe_struct_size
        fbe_value.flag = flag.get
      else
        fbe_value.flag = MyFLags.new
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += flag.fbe_size
    end

    # Set the struct value (begin phase)
    def set_begin
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      fbe_struct_size = fbe_body
      fbe_struct_offset = @_buffer.allocate(fbe_struct_size) - @_buffer.offset
      if (fbe_struct_offset <= 0) || ((@_buffer.offset + fbe_struct_offset + fbe_struct_size) > @_buffer.size)
        return 0
      end

      write_uint32(fbe_offset, fbe_struct_offset)
      write_uint32(fbe_struct_offset, fbe_struct_size)
      write_uint32(fbe_struct_offset + 4, fbe_type)

      @_buffer.shift(fbe_struct_offset)
      fbe_struct_offset
    end

    # Set the struct value (end phase)
    def set_end(fbe_begin)
      @_buffer.unshift(fbe_begin)
    end

    # Set the struct value
    def set(fbe_value)
      fbe_begin = set_begin
      if fbe_begin == 0
        return
      end

      set_fields(fbe_value)
      set_end(fbe_begin)
    end

    # Set the struct fields values
    def set_fields(fbe_value)
      name.set(fbe_value.name)
      detail.set(fbe_value.detail)
      sex.set(fbe_value.sex)
      flag.set(fbe_value.flag)
    end
  end

  # Fast Binary Encoding Extra model
  class ExtraModel < FBE::Model
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer)
      @_model = FieldModelExtra.new(self.buffer, 4)
    end

    def model
      @_model
    end

    # Get the model size
    def fbe_size
      @_model.fbe_size + @_model.fbe_extra
    end

    # Get the model type
    def fbe_type
      TYPE
    end

    TYPE = FieldModelExtra::TYPE

    # Is the struct value valid?
    def valid?
      verify
    end

    # Check if the struct value is valid
    def verify
      if (buffer.offset + @_model.fbe_offset - 4) > buffer.size
        return false
      end

      fbe_full_size = read_uint32(@_model.fbe_offset - 4)
      if fbe_full_size < @_model.fbe_size
        return false
      end

      @_model.verify
    end

    # Create a new model (begin phase)
    def create_begin
      buffer.allocate(4 + @_model.fbe_size)
    end

    # Create a new model (end phase)
    def create_end(fbe_begin)
      fbe_end = buffer.size
      fbe_full_size = fbe_end - fbe_begin
      write_uint32(@_model.fbe_offset - 4, fbe_full_size)
      fbe_full_size
    end

    # Serialize the struct value
    def serialize(value)
      fbe_begin = create_begin
      @_model.set(value)
      create_end(fbe_begin)
    end

    # Deserialize the struct value
    def deserialize(value = Extra.new)
      if (buffer.offset + @_model.fbe_offset - 4) > buffer.size
        [Extra.new, 0]
      end

      fbe_full_size = read_uint32(@_model.fbe_offset - 4)
      if fbe_full_size < @_model.fbe_size
        [Extra.new, 0]
      end

      @_model.get(value)
      [value, fbe_full_size]
    end

    # Move to the next struct value
    def next(prev)
      @_model.fbe_shift(prev)
    end
  end

  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class FinalModelExtra < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
      @_name = FBE::FinalModelString.new(self.buffer, 0)
      @_detail = FBE::FinalModelString.new(self.buffer, 0)
      @_sex = FinalModelSex.new(self.buffer, 0)
      @_flag = FinalModelMyFLags.new(self.buffer, 0)
    end

    def name
      @_name
    end

    def detail
      @_detail
    end

    def sex
      @_sex
    end

    def flag
      @_flag
    end

    # Get the allocation size
    def fbe_allocation_size(fbe_value)
      0 \
        + name.fbe_allocation_size(fbe_value.name) \
        + detail.fbe_allocation_size(fbe_value.detail) \
        + sex.fbe_allocation_size(fbe_value.sex) \
        + flag.fbe_allocation_size(fbe_value.flag) \
    end

    # Get the final type
    def fbe_type
      TYPE
    end

    TYPE = 1

    # Is the struct value valid?
    def valid?
      verify
    end

    # Check if the struct value is valid
    def verify
      @_buffer.shift(fbe_offset)
      fbe_result = verify_fields
      @_buffer.unshift(fbe_offset)
      fbe_result
    end

    # Check if the struct fields are valid
    def verify_fields
      fbe_current_offset = 0

      name.fbe_offset = fbe_current_offset
      fbe_field_size = name.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      detail.fbe_offset = fbe_current_offset
      fbe_field_size = detail.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      sex.fbe_offset = fbe_current_offset
      fbe_field_size = sex.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      flag.fbe_offset = fbe_current_offset
      fbe_field_size = flag.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      # noinspection RubyUnnecessaryReturnValue
      fbe_current_offset
    end

    # Get the struct value
    def get(fbe_value = Extra.new)
      @_buffer.shift(fbe_offset)
      fbe_size = get_fields(fbe_value)
      @_buffer.unshift(fbe_offset)
      [fbe_value, fbe_size]
    end

    # Get the struct fields values
    def get_fields(fbe_value)
      fbe_current_offset = 0
      fbe_current_size = 0

      name.fbe_offset = fbe_current_offset
      fbe_result = name.get
      fbe_value.name = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      detail.fbe_offset = fbe_current_offset
      fbe_result = detail.get
      fbe_value.detail = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      sex.fbe_offset = fbe_current_offset
      fbe_result = sex.get
      fbe_value.sex = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      flag.fbe_offset = fbe_current_offset
      fbe_result = flag.get
      fbe_value.flag = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      # noinspection RubyUnnecessaryReturnValue
      fbe_current_size
    end

    # Set the struct value
    def set(fbe_value)
      @_buffer.shift(fbe_offset)
      fbe_size = set_fields(fbe_value)
      @_buffer.unshift(fbe_offset)
      fbe_size
    end

    # Set the struct fields values
    def set_fields(fbe_value)
      fbe_current_offset = 0
      fbe_current_size = 0

      name.fbe_offset = fbe_current_offset
      fbe_field_size = name.set(fbe_value.name)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      detail.fbe_offset = fbe_current_offset
      fbe_field_size = detail.set(fbe_value.detail)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      sex.fbe_offset = fbe_current_offset
      fbe_field_size = sex.set(fbe_value.sex)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      flag.fbe_offset = fbe_current_offset
      fbe_field_size = flag.set(fbe_value.flag)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      # noinspection RubyUnnecessaryReturnValue
      fbe_current_size
    end
  end

  # Fast Binary Encoding Extra final model
  class ExtraFinalModel < FBE::Model
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer)
      @_model = FinalModelExtra.new(self.buffer, 8)
    end

    # Get the model type
    def fbe_type
      TYPE
    end

    TYPE = FinalModelExtra::TYPE

    # Is the struct value valid?
    def valid?
      verify
    end

    # Check if the struct value is valid
    def verify
      if (buffer.offset + @_model.fbe_offset) > buffer.size
        return false
      end

      fbe_struct_size = read_uint32(@_model.fbe_offset - 8)
      fbe_struct_type = read_uint32(@_model.fbe_offset - 4)
      if (fbe_struct_size <= 0) or (fbe_struct_type != fbe_type)
        return false
      end

      (8 + @_model.verify) == fbe_struct_size
    end

    # Serialize the struct value
    def serialize(value)
      fbe_initial_size = buffer.size

      fbe_struct_type = fbe_type
      fbe_struct_size = 8 + @_model.fbe_allocation_size(value)
      fbe_struct_offset = buffer.allocate(fbe_struct_size) - buffer.offset
      if (buffer.offset + fbe_struct_offset + fbe_struct_size) > buffer.size
        return 0
      end

      fbe_struct_size = 8 + @_model.set(value)
      buffer.resize(fbe_initial_size + fbe_struct_size)

      write_uint32(@_model.fbe_offset - 8, fbe_struct_size)
      write_uint32(@_model.fbe_offset - 4, fbe_struct_type)

      fbe_struct_size
    end

    # Deserialize the struct value
    def deserialize(value = Extra.new)
      if (buffer.offset + @_model.fbe_offset) > buffer.size
        [Extra.new, 0]
      end

      fbe_struct_size = read_uint32(@_model.fbe_offset - 8)
      fbe_struct_type = read_uint32(@_model.fbe_offset - 4)
      if (fbe_struct_size <= 0) || (fbe_struct_type != fbe_type)
        [Extra.new, 8]
      end

      fbe_result = @_model.get(value)
      [fbe_result[0], (8 + fbe_result[1])]
    end

    # Move to the next struct value
    def next(prev)
      @_model.fbe_shift(prev)
    end
  end

  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class Simple
    include Comparable

    attr_accessor :name
    attr_accessor :depth
    attr_accessor :sa
    attr_accessor :sex

    def initialize(name = '', depth = 0, sa = Array.new(1, Extra.new), sex = Sex.new)
      @name = name
      @depth = depth
      @sa = sa
      @sex = sex
    end

    def initialize_copy(other)
      @name = other.name
      @depth = other.depth
      @sa = other.sa
      @sex = other.sex
    end

    # Struct shallow copy
    def copy(other)
      initialize_copy(other)
      self
    end

    # Struct deep clone
    def clone
      data = Marshal.dump(self)
      clone = Marshal.load(data)
      clone.freeze if frozen?
      clone
    end

    # Struct compare operators
    def <=>(other)
      return nil unless other.is_a?(Simple)

      # noinspection RubyUnusedLocalVariable
      result = 0
      # noinspection RubyUnnecessaryReturnValue
      result
    end

    # Struct equals
    def eql?(other)
      self == other
    end

    # Struct keys
    def key
      result = []
      # noinspection RubyUnnecessaryReturnValue
      result
    end

    # Struct hash code
    def hash
      key.hash
    end

    # Get struct string value
    def to_s
      result = ''
      result << 'Simple('
      result << 'name='
      if !@name.nil?
        result << '"' << @name.to_s << '"'
      else
        result << 'null'
      end
      result << ',depth='
      if !@depth.nil?
        result << @depth.to_s
      else
        result << 'null'
      end
      result << ',sa='
      if @sa.nil?
        result << '[0][]'
      else
        first = true
        result << '[' << @sa.length.to_s << ']['
        @sa.each do |item|
          if !item.nil?
            result << (first ? '' : ',')
            result << item.to_s
          else
            result << (first ? '' : ',')
            result << 'null'
          end
          first = false
        end
        result << ']'
      end
      result << ',sex='
      if !@sex.nil?
        result << @sex.to_s
      else
        result << 'null'
      end
      result << ')'
      result
    end

    # Dump the struct
    def marshal_dump
      # Serialize the struct to the FBE stream
      writer = SimpleModel.new(FBE::WriteBuffer.new)
      writer.serialize(self)
      writer.buffer
    end

    # Load the struct
    def marshal_load(data)
      # Deserialize the struct from the FBE stream
      reader = SimpleModel.new(FBE::ReadBuffer.new)
      reader.attach_buffer(data)
      initialize_copy(reader.deserialize[0])
    end

    # Get struct JSON value
    def to_json
      JSON.generate(__to_json_map__)
    end

    # Get struct JSON map (internal method)
    def __to_json_map__
      result = {}
      key = 'name'
      value = (name.nil? ? nil : name)
      result.store(key, value)
      key = 'depth'
      value = (depth.nil? ? nil : depth)
      result.store(key, value)
      key = 'sa'
      value = sa.map { |item| (item.nil? ? nil : item.__to_json_map__) }
      result.store(key, value)
      key = 'sex'
      value = (sex.nil? ? nil : sex.__to_json_map__)
      result.store(key, value)
      result
    end

    # Get struct from JSON
    def self.from_json(json)
      __from_json_map__(JSON.parse(json))
    end

    # Get struct map from JSON (internal method)
    def self.__from_json_map__(json)
      result = Simple.new
      value = json.fetch('name', nil)
      result.name = (value.nil? ? nil : value)
      value = json.fetch('depth', nil)
      result.depth = (value.nil? ? nil : value)
      value = json.fetch('sa', nil)
      result.sa = value.map { |item| (item.nil? ? nil : Extra.__from_json_map__(item)) }
      value = json.fetch('sex', nil)
      result.sex = (value.nil? ? nil : Sex.__from_json_map__(value))
      result
    end

    # Get the FBE type
    def fbe_type
      TYPE
    end

    TYPE = 2
  end

  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class FieldModelSimple < FBE::FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
      @_name = FBE::FieldModelString.new(self.buffer, 4 + 4)
      @_depth = FBE::FieldModelInt32.new(self.buffer, @_name.fbe_offset + @_name.fbe_size)
      @_sa = FBE::FieldModelArray.new(FieldModelExtra.new(self.buffer, @_depth.fbe_offset + @_depth.fbe_size), self.buffer, @_depth.fbe_offset + @_depth.fbe_size, 1)
      @_sex = FieldModelSex.new(self.buffer, @_sa.fbe_offset + @_sa.fbe_size)
    end

    def name
      @_name
    end

    def depth
      @_depth
    end

    def sa
      @_sa
    end

    def sex
      @_sex
    end

    # Get the field size
    def fbe_size
      4
    end

    # Get the field body size
    def fbe_body
      4 + 4 \
        + name.fbe_size \
        + depth.fbe_size \
        + sa.fbe_size \
        + sex.fbe_size \
    end

    # Get the field extra size
    def fbe_extra
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      fbe_struct_offset = read_uint32(fbe_offset)
      if (fbe_struct_offset == 0) || ((@_buffer.offset + fbe_struct_offset + 4) > @_buffer.size)
        return 0
      end

      @_buffer.shift(fbe_struct_offset)

      fbe_result = fbe_body \
        + name.fbe_extra \
        + depth.fbe_extra \
        + sa.fbe_extra \
        + sex.fbe_extra \

      @_buffer.unshift(fbe_struct_offset)

      fbe_result
    end

    # Get the field type
    def fbe_type
      TYPE
    end

    TYPE = 2

    # Is the struct value valid?
    def valid?
      verify
    end

    # Check if the struct value is valid
    def verify(fbe_verify_type = true)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return true
      end

      fbe_struct_offset = read_uint32(fbe_offset)
      if (fbe_struct_offset == 0) || ((@_buffer.offset + fbe_struct_offset + 4 + 4) > @_buffer.size)
        return false
      end

      fbe_struct_size = read_uint32(fbe_struct_offset)
      if fbe_struct_size < (4 + 4)
        return false
      end

      fbe_struct_type = read_uint32(fbe_struct_offset + 4)
      if fbe_verify_type && (fbe_struct_type != fbe_type)
        return false
      end

      @_buffer.shift(fbe_struct_offset)
      fbe_result = verify_fields(fbe_struct_size)
      @_buffer.unshift(fbe_struct_offset)
      fbe_result
    end

    # Check if the struct fields are valid
    def verify_fields(fbe_struct_size)
      fbe_current_size = 4 + 4

      if (fbe_current_size + name.fbe_size) > fbe_struct_size
        return true
      end
      unless name.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += name.fbe_size

      if (fbe_current_size + depth.fbe_size) > fbe_struct_size
        return true
      end
      unless depth.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += depth.fbe_size

      if (fbe_current_size + sa.fbe_size) > fbe_struct_size
        return true
      end
      unless sa.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += sa.fbe_size

      if (fbe_current_size + sex.fbe_size) > fbe_struct_size
        return true
      end
      unless sex.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += sex.fbe_size

      true
    end

    # Get the struct value (begin phase)
    def get_begin
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      fbe_struct_offset = read_uint32(fbe_offset)
      if (fbe_struct_offset == 0) || ((@_buffer.offset + fbe_struct_offset + 4 + 4) > @_buffer.size)
        return 0
      end

      fbe_struct_size = read_uint32(fbe_struct_offset)
      if fbe_struct_size < (4 + 4)
        return 0
      end

      @_buffer.shift(fbe_struct_offset)
      fbe_struct_offset
    end

    # Get the struct value (end phase)
    def get_end(fbe_begin)
      @_buffer.unshift(fbe_begin)
    end

    # Get the struct value
    def get(fbe_value = Simple.new)
      fbe_begin = get_begin
      if fbe_begin == 0
        return fbe_value
      end

      fbe_struct_size = read_uint32(0)
      get_fields(fbe_value, fbe_struct_size)
      get_end(fbe_begin)
      fbe_value
    end

    # Get the struct fields values
    def get_fields(fbe_value, fbe_struct_size)
      fbe_current_size = 4 + 4

      if (fbe_current_size + name.fbe_size) <= fbe_struct_size
        fbe_value.name = name.get
      else
        fbe_value.name = ''
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += name.fbe_size

      if (fbe_current_size + depth.fbe_size) <= fbe_struct_size
        fbe_value.depth = depth.get
      else
        fbe_value.depth = 0
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += depth.fbe_size

      if (fbe_current_size + sa.fbe_size) <= fbe_struct_size
        sa.get(fbe_value.sa)
      else
        fbe_value.sa.clear
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += sa.fbe_size

      if (fbe_current_size + sex.fbe_size) <= fbe_struct_size
        fbe_value.sex = sex.get
      else
        fbe_value.sex = Sex.new
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += sex.fbe_size
    end

    # Set the struct value (begin phase)
    def set_begin
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      fbe_struct_size = fbe_body
      fbe_struct_offset = @_buffer.allocate(fbe_struct_size) - @_buffer.offset
      if (fbe_struct_offset <= 0) || ((@_buffer.offset + fbe_struct_offset + fbe_struct_size) > @_buffer.size)
        return 0
      end

      write_uint32(fbe_offset, fbe_struct_offset)
      write_uint32(fbe_struct_offset, fbe_struct_size)
      write_uint32(fbe_struct_offset + 4, fbe_type)

      @_buffer.shift(fbe_struct_offset)
      fbe_struct_offset
    end

    # Set the struct value (end phase)
    def set_end(fbe_begin)
      @_buffer.unshift(fbe_begin)
    end

    # Set the struct value
    def set(fbe_value)
      fbe_begin = set_begin
      if fbe_begin == 0
        return
      end

      set_fields(fbe_value)
      set_end(fbe_begin)
    end

    # Set the struct fields values
    def set_fields(fbe_value)
      name.set(fbe_value.name)
      depth.set(fbe_value.depth)
      sa.set(fbe_value.sa)
      sex.set(fbe_value.sex)
    end
  end

  # Fast Binary Encoding Simple model
  class SimpleModel < FBE::Model
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer)
      @_model = FieldModelSimple.new(self.buffer, 4)
    end

    def model
      @_model
    end

    # Get the model size
    def fbe_size
      @_model.fbe_size + @_model.fbe_extra
    end

    # Get the model type
    def fbe_type
      TYPE
    end

    TYPE = FieldModelSimple::TYPE

    # Is the struct value valid?
    def valid?
      verify
    end

    # Check if the struct value is valid
    def verify
      if (buffer.offset + @_model.fbe_offset - 4) > buffer.size
        return false
      end

      fbe_full_size = read_uint32(@_model.fbe_offset - 4)
      if fbe_full_size < @_model.fbe_size
        return false
      end

      @_model.verify
    end

    # Create a new model (begin phase)
    def create_begin
      buffer.allocate(4 + @_model.fbe_size)
    end

    # Create a new model (end phase)
    def create_end(fbe_begin)
      fbe_end = buffer.size
      fbe_full_size = fbe_end - fbe_begin
      write_uint32(@_model.fbe_offset - 4, fbe_full_size)
      fbe_full_size
    end

    # Serialize the struct value
    def serialize(value)
      fbe_begin = create_begin
      @_model.set(value)
      create_end(fbe_begin)
    end

    # Deserialize the struct value
    def deserialize(value = Simple.new)
      if (buffer.offset + @_model.fbe_offset - 4) > buffer.size
        [Simple.new, 0]
      end

      fbe_full_size = read_uint32(@_model.fbe_offset - 4)
      if fbe_full_size < @_model.fbe_size
        [Simple.new, 0]
      end

      @_model.get(value)
      [value, fbe_full_size]
    end

    # Move to the next struct value
    def next(prev)
      @_model.fbe_shift(prev)
    end
  end

  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class FinalModelSimple < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
      @_name = FBE::FinalModelString.new(self.buffer, 0)
      @_depth = FBE::FinalModelInt32.new(self.buffer, 0)
      @_sa = FBE::FinalModelArray.new(FinalModelExtra.new(self.buffer, 0), self.buffer, 0, 1)
      @_sex = FinalModelSex.new(self.buffer, 0)
    end

    def name
      @_name
    end

    def depth
      @_depth
    end

    def sa
      @_sa
    end

    def sex
      @_sex
    end

    # Get the allocation size
    def fbe_allocation_size(fbe_value)
      0 \
        + name.fbe_allocation_size(fbe_value.name) \
        + depth.fbe_allocation_size(fbe_value.depth) \
        + sa.fbe_allocation_size(fbe_value.sa) \
        + sex.fbe_allocation_size(fbe_value.sex) \
    end

    # Get the final type
    def fbe_type
      TYPE
    end

    TYPE = 2

    # Is the struct value valid?
    def valid?
      verify
    end

    # Check if the struct value is valid
    def verify
      @_buffer.shift(fbe_offset)
      fbe_result = verify_fields
      @_buffer.unshift(fbe_offset)
      fbe_result
    end

    # Check if the struct fields are valid
    def verify_fields
      fbe_current_offset = 0

      name.fbe_offset = fbe_current_offset
      fbe_field_size = name.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      depth.fbe_offset = fbe_current_offset
      fbe_field_size = depth.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      sa.fbe_offset = fbe_current_offset
      fbe_field_size = sa.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      sex.fbe_offset = fbe_current_offset
      fbe_field_size = sex.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      # noinspection RubyUnnecessaryReturnValue
      fbe_current_offset
    end

    # Get the struct value
    def get(fbe_value = Simple.new)
      @_buffer.shift(fbe_offset)
      fbe_size = get_fields(fbe_value)
      @_buffer.unshift(fbe_offset)
      [fbe_value, fbe_size]
    end

    # Get the struct fields values
    def get_fields(fbe_value)
      fbe_current_offset = 0
      fbe_current_size = 0

      name.fbe_offset = fbe_current_offset
      fbe_result = name.get
      fbe_value.name = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      depth.fbe_offset = fbe_current_offset
      fbe_result = depth.get
      fbe_value.depth = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      sa.fbe_offset = fbe_current_offset
      fbe_result = sa.get(fbe_value.sa)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      sex.fbe_offset = fbe_current_offset
      fbe_result = sex.get
      fbe_value.sex = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      # noinspection RubyUnnecessaryReturnValue
      fbe_current_size
    end

    # Set the struct value
    def set(fbe_value)
      @_buffer.shift(fbe_offset)
      fbe_size = set_fields(fbe_value)
      @_buffer.unshift(fbe_offset)
      fbe_size
    end

    # Set the struct fields values
    def set_fields(fbe_value)
      fbe_current_offset = 0
      fbe_current_size = 0

      name.fbe_offset = fbe_current_offset
      fbe_field_size = name.set(fbe_value.name)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      depth.fbe_offset = fbe_current_offset
      fbe_field_size = depth.set(fbe_value.depth)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      sa.fbe_offset = fbe_current_offset
      fbe_field_size = sa.set(fbe_value.sa)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      sex.fbe_offset = fbe_current_offset
      fbe_field_size = sex.set(fbe_value.sex)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      # noinspection RubyUnnecessaryReturnValue
      fbe_current_size
    end
  end

  # Fast Binary Encoding Simple final model
  class SimpleFinalModel < FBE::Model
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer)
      @_model = FinalModelSimple.new(self.buffer, 8)
    end

    # Get the model type
    def fbe_type
      TYPE
    end

    TYPE = FinalModelSimple::TYPE

    # Is the struct value valid?
    def valid?
      verify
    end

    # Check if the struct value is valid
    def verify
      if (buffer.offset + @_model.fbe_offset) > buffer.size
        return false
      end

      fbe_struct_size = read_uint32(@_model.fbe_offset - 8)
      fbe_struct_type = read_uint32(@_model.fbe_offset - 4)
      if (fbe_struct_size <= 0) or (fbe_struct_type != fbe_type)
        return false
      end

      (8 + @_model.verify) == fbe_struct_size
    end

    # Serialize the struct value
    def serialize(value)
      fbe_initial_size = buffer.size

      fbe_struct_type = fbe_type
      fbe_struct_size = 8 + @_model.fbe_allocation_size(value)
      fbe_struct_offset = buffer.allocate(fbe_struct_size) - buffer.offset
      if (buffer.offset + fbe_struct_offset + fbe_struct_size) > buffer.size
        return 0
      end

      fbe_struct_size = 8 + @_model.set(value)
      buffer.resize(fbe_initial_size + fbe_struct_size)

      write_uint32(@_model.fbe_offset - 8, fbe_struct_size)
      write_uint32(@_model.fbe_offset - 4, fbe_struct_type)

      fbe_struct_size
    end

    # Deserialize the struct value
    def deserialize(value = Simple.new)
      if (buffer.offset + @_model.fbe_offset) > buffer.size
        [Simple.new, 0]
      end

      fbe_struct_size = read_uint32(@_model.fbe_offset - 8)
      fbe_struct_type = read_uint32(@_model.fbe_offset - 4)
      if (fbe_struct_size <= 0) || (fbe_struct_type != fbe_type)
        [Simple.new, 8]
      end

      fbe_result = @_model.get(value)
      [fbe_result[0], (8 + fbe_result[1])]
    end

    # Move to the next struct value
    def next(prev)
      @_model.fbe_shift(prev)
    end
  end

  # Fast Binary Encoding Osa protocol version
  class ProtocolVersion
    # Protocol major version
    MAJOR = 0
    # Protocol minor version
    MINOR = 0
  end

  # Fast Binary Encoding Osa sender
  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class Sender < FBE::Sender
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer, false)
    end

    # Sender models accessors

    # Send methods

    def send(value)
      0
    end

    protected

    # Send message handler
    def on_send(buffer, offset, size)
      raise NotImplementedError, "Osa.Sender.on_send() not implemented!"
    end
  end

  # Fast Binary Encoding Osa receiver
  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class Receiver < FBE::Receiver
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer, false)
    end

    protected

    # Receive handlers

    public

    def on_receive(type, buffer, offset, size)

      false
    end
  end

  # Fast Binary Encoding Osa proxy
  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class Proxy < FBE::Receiver
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer, false)
    end

    protected

    # Receive handlers

    public

    def on_receive(type, buffer, offset, size)

      false
    end
  end

  # Fast Binary Encoding Osa final sender
  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class FinalSender < FBE::Sender
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer, true)
    end

    # Sender models accessors

    # Send methods

    def send(value)
      0
    end

    protected

    # Send message handler
    def on_send(buffer, offset, size)
      raise NotImplementedError, "Osa.Sender.on_send() not implemented!"
    end
  end

  # Fast Binary Encoding Osa final receiver
  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class FinalReceiver < FBE::Receiver
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer, true)
    end

    protected

    # Receive handlers

    public

    def on_receive(type, buffer, offset, size)

      false
    end
  end

end

# rubocop:enable all
