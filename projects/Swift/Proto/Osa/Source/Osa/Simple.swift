//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: osa.fbe
// FBE version: 1.10.0.0
//------------------------------------------------------------------------------

import Foundation
import Fbe

public protocol SimpleBase {
    var name: String { get set }
    var depth: Int32 { get set }
    var sa: Array<Extra> { get set }
    var sex: Sex { get set }
}

public protocol SimpleInheritance {
    var parent: Simple { get set }
}

extension SimpleInheritance {
    public var name: String {
        get { return parent.name }
        set { parent.name = newValue }
    }
    public var depth: Int32 {
        get { return parent.depth }
        set { parent.depth = newValue }
    }
    public var sa: Array<Extra> {
        get { return parent.sa }
        set { parent.sa = newValue }
    }
    public var sex: Sex {
        get { return parent.sex }
        set { parent.sex = newValue }
    }
}

public struct Simple: SimpleBase, Comparable, Hashable, Codable {
    public var name: String = ""
    public var depth: Int32 = 0
    public var sa: Array<Extra> = Array()
    public var sex: Sex = Osa.Sex()

    public init() { }
    public init(name: String, depth: Int32, sa: Array<Extra>, sex: Sex) {

        self.name = name
        self.depth = depth
        self.sa = sa
        self.sex = sex
    }

    public init(other: Simple) {
        self.name = other.name
        self.depth = other.depth
        self.sa = other.sa
        self.sex = other.sex
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        name = try container.decode(String.self, forKey: .name)
        depth = try container.decode(Int32.self, forKey: .depth)
        sa = try container.decode(Array<Osa.Extra>.self, forKey: .sa)
        sex = try container.decode(Osa.Sex.self, forKey: .sex)
    }

    public func clone() throws -> Simple {
        // Serialize the struct to the FBE stream
        let writer = SimpleModel()
        try _ = writer.serialize(value: self)

        // Deserialize the struct from the FBE stream
        let reader = SimpleModel()
        reader.attach(buffer: writer.buffer)
        return reader.deserialize()
    }

    public static func < (lhs: Simple, rhs: Simple) -> Bool {
        return true
    }

    public static func == (lhs: Simple, rhs: Simple) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }

    public var description: String {
        var sb = String()
        sb.append("Simple(")
        sb.append("name="); sb.append("\""); sb.append(name); sb.append("\"")
        sb.append(",depth="); sb.append(depth.description)
        if true {
            var first = true
            sb.append(",sa=["); sb.append("\(sa.count)"); sb.append("][")
            for item in sa {
                sb.append(first ? "" : ","); sb.append(item.description)
                first = false
            }
            sb.append("]")
        }
        sb.append(",sex="); sb.append(sex.description)
        sb.append(")")
        return sb
    }
    private enum CodingKeys: String, CodingKey {
        case name
        case depth
        case sa
        case sex
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(name, forKey: .name)
        try container.encode(depth, forKey: .depth)
        try container.encode(sa, forKey: .sa)
        try container.encode(sex, forKey: .sex)
    }

    public func toJson() throws -> String {
        return String(data: try JSONEncoder().encode(self), encoding: .utf8)!
    }

    public static func fromJson(_ json: String) throws -> Simple {
        return try JSONDecoder().decode(Simple.self, from: json.data(using: .utf8)!)
    }
}
