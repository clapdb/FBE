//------------------------------------------------------------------------------
// <auto-generated>
//     Automatically generated by the Fast Binary Encoding compiler, do not modify!
//     https://github.com/chronoxor/FastBinaryEncoding
//     Source: osa.fbe
//     FBE version: 1.10.0.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Runtime.Serialization;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
#if UTF8JSON
using Utf8Json;
using Utf8Json.Resolvers;
#elif NEWTONSOFTJSON
using Newtonsoft.Json;
#else
using System.Text.Json;
using System.Text.Json.Serialization;
#endif

namespace osa {

#if UTF8JSON
    public class SexConverter : IJsonFormatter<Sex>
    {
        public void Serialize(ref JsonWriter writer, Sex value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteInt32(value.Value);
        }

        public Sex Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            return new Sex(reader.ReadInt32());
        }
    }

    [JsonFormatter(typeof(SexConverter))]
#elif NEWTONSOFTJSON
    public class SexConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(Sex);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((Sex)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            switch (reader.Value)
            {
                case long longValue:
                    return new Sex((int)longValue);
                case BigInteger bigValue:
                    return new Sex((int)bigValue);
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(SexConverter))]
#else
    public class SexConverter : JsonConverter<Sex>
    {
        public override void Write(Utf8JsonWriter writer, Sex value, JsonSerializerOptions options) => writer.WriteNumberValue(value.Value);
        public override Sex Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => new Sex(reader.GetInt32());
    }

    [JsonConverter(typeof(SexConverter))]
#endif
    public struct Sex : IComparable, IComparable<Sex>, IEquatable<Sex>
    {
        public int Value { get; internal set; }

        public Sex(int value) : this()
        {
            Value = value;
        }

        public Sex(Sex value) : this()
        {
            Value = value.Value;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((Sex)other).Value);
        }

        public int CompareTo(Sex other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is Sex value) && Value.Equals(value.Value);
        }

        public bool Equals(Sex other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(Sex value1, Sex value2)
        {
            return value1.Value == value2.Value;
        }

        public static bool operator!=(Sex value1, Sex value2)
        {
            return value1.Value != value2.Value;
        }

        public static Sex Default => new Sex();

        public static FBE.FieldModelValueType<Sex> CreateFieldModel(FBE.Buffer buffer, long offset) { return new osa.FBE.FieldModelSex(buffer, offset); }

        public const int _male_ = (int)0 + 0;
        public const int _female_ = (int)0 + 1;

        public static Sex male = new Sex(_male_);
        public static Sex female = new Sex(_female_);

        public override string ToString()
        {
            if (this == male) return "male";
            if (this == female) return "female";
            return "<unknown>";
        }
    }

} // namespace osa

namespace osa.FBE {

    using global::osa;

    // Fast Binary Encoding Sex field model
    public class FieldModelSex : FBE.FieldModelValueType<Sex>
    {
        public FieldModelSex(FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 4;

        // Clone the field model
        public override FBE.FieldModelValueType<Sex> Clone() { return new FieldModelSex(_buffer, _offset); }

        // Get the value
        public override void Get(out Sex value) { Get(out value, Sex.Default); }
        public override void Get(out Sex value, Sex defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = new Sex((int)ReadInt32(FBEOffset));
        }

        // Set the value
        public override void Set(Sex value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace osa.FBE

namespace osa.FBE {

    using global::osa;

    // Fast Binary Encoding Sex final model
    public class FinalModelSex : FBE.FinalModelValueType<Sex>
    {
        public FinalModelSex(FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(Sex value) { return FBESize; }

        // Get the final size
        public override long FBESize => 4;

        // Clone the final model
        public override FBE.FinalModelValueType<Sex> Clone() { return new FinalModelSex(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out Sex value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = Sex.Default;
                return 0;
            }

            value = new Sex((int)ReadInt32(FBEOffset));
            return FBESize;
        }

        // Set the value
        public override long Set(Sex value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace osa.FBE

namespace osa {

#if UTF8JSON
    public class MyFLagsConverter : IJsonFormatter<MyFLags>
    {
        public void Serialize(ref JsonWriter writer, MyFLags value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteInt32(value.Value);
        }

        public MyFLags Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            return new MyFLags(reader.ReadInt32());
        }
    }

    [JsonFormatter(typeof(MyFLagsConverter))]
#elif NEWTONSOFTJSON
    public class MyFLagsConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(MyFLags);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((MyFLags)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            switch (reader.Value)
            {
                case long longValue:
                    return new MyFLags((int)longValue);
                case BigInteger bigValue:
                    return new MyFLags((int)bigValue);
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(MyFLagsConverter))]
#else
    public class MyFLagsConverter : JsonConverter<MyFLags>
    {
        public override void Write(Utf8JsonWriter writer, MyFLags value, JsonSerializerOptions options) => writer.WriteNumberValue(value.Value);
        public override MyFLags Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => new MyFLags(reader.GetInt32());
    }

    [JsonConverter(typeof(MyFLagsConverter))]
#endif
    public struct MyFLags : IComparable, IComparable<MyFLags>, IEquatable<MyFLags>
    {
        public int Value { get; internal set; }

        public MyFLags(int value) : this()
        {
            Value = value;
        }

        public MyFLags(MyFLags value) : this()
        {
            Value = value.Value;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((MyFLags)other).Value);
        }

        public int CompareTo(MyFLags other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is MyFLags value) && Value.Equals(value.Value);
        }

        public bool Equals(MyFLags other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(MyFLags value1, MyFLags value2)
        {
            return value1.Value == value2.Value;
        }

        public static bool operator!=(MyFLags value1, MyFLags value2)
        {
            return value1.Value != value2.Value;
        }

        public static MyFLags Default => new MyFLags();

        public static FBE.FieldModelValueType<MyFLags> CreateFieldModel(FBE.Buffer buffer, long offset) { return new osa.FBE.FieldModelMyFLags(buffer, offset); }

        public const int _flag0_ = (int)0x00 + 0;
        public const int _flag1_ = (int)0x01 + 0;
        public const int _flag2_ = (int)0x02 + 0;

        public static MyFLags flag0 = new MyFLags(_flag0_);
        public static MyFLags flag1 = new MyFLags(_flag1_);
        public static MyFLags flag2 = new MyFLags(_flag2_);

        public override string ToString()
        {
            if (this == flag0) return "flag0";
            if (this == flag1) return "flag1";
            if (this == flag2) return "flag2";
            return "<unknown>";
        }
    }

} // namespace osa

namespace osa.FBE {

    using global::osa;

    // Fast Binary Encoding MyFLags field model
    public class FieldModelMyFLags : FBE.FieldModelValueType<MyFLags>
    {
        public FieldModelMyFLags(FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 4;

        // Clone the field model
        public override FBE.FieldModelValueType<MyFLags> Clone() { return new FieldModelMyFLags(_buffer, _offset); }

        // Get the value
        public override void Get(out MyFLags value) { Get(out value, MyFLags.Default); }
        public override void Get(out MyFLags value, MyFLags defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = new MyFLags((int)ReadInt32(FBEOffset));
        }

        // Set the value
        public override void Set(MyFLags value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace osa.FBE

namespace osa.FBE {

    using global::osa;

    // Fast Binary Encoding MyFLags final model
    public class FinalModelMyFLags : FBE.FinalModelValueType<MyFLags>
    {
        public FinalModelMyFLags(FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(MyFLags value) { return FBESize; }

        // Get the final size
        public override long FBESize => 4;

        // Clone the final model
        public override FBE.FinalModelValueType<MyFLags> Clone() { return new FinalModelMyFLags(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out MyFLags value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = MyFLags.Default;
                return 0;
            }

            value = new MyFLags((int)ReadInt32(FBEOffset));
            return FBESize;
        }

        // Set the value
        public override long Set(MyFLags value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace osa.FBE

namespace osa {

    public struct Extra : IComparable, IComparable<Extra>, IEquatable<Extra>
    {
        public string name;
        public string detail;
        public Sex sex;
        public MyFLags flag;

        public const long FBETypeConst = 1;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static Extra Default => new Extra
        {
            name = ""
            , detail = ""
            , sex = global::osa.Sex.Default
            , flag = global::osa.MyFLags.Default
        };

        public Extra(string name, string detail, Sex sex, MyFLags flag)
        {
            this.name = name;
            this.detail = detail;
            this.sex = sex;
            this.flag = flag;
        }

        public Extra Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new osa.FBE.ExtraModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new osa.FBE.ExtraModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            return result;
        }

        public int CompareTo(Extra other)
        {
            int result = 0;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is Extra))
                return false;
            return true;
        }

        public bool Equals(Extra other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            return hash;
        }

        public static bool operator==(Extra lhs, Extra rhs) => lhs.Equals(rhs);
        public static bool operator!=(Extra lhs, Extra rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("Extra(");
            sb.Append("name="); if (name != null) sb.Append("\"").Append(name).Append("\""); else sb.Append("null");
            sb.Append(",detail="); if (detail != null) sb.Append("\"").Append(detail).Append("\""); else sb.Append("null");
            sb.Append(",sex="); sb.Append(sex);
            sb.Append(",flag="); sb.Append(flag);
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = FBE.Json.ToJson(this);
            return json;
        }

        public static Extra FromJson(string json)
        {
            var result = FBE.Json.FromJson<Extra>(json);
            return result;
        }

        public static FBE.FieldModelValueType<Extra> CreateFieldModel(FBE.Buffer buffer, long offset) { return new osa.FBE.FieldModelExtra(buffer, offset); }
    }

} // namespace osa

namespace osa.FBE {

    using global::osa;

    // Fast Binary Encoding Extra field model
    public class FieldModelExtra : FBE.FieldModelValueType<Extra>
    {
        public readonly FBE.FieldModelReferenceType<string> name;
        public readonly FBE.FieldModelReferenceType<string> detail;
        public readonly osa.FBE.FieldModelSex sex;
        public readonly osa.FBE.FieldModelMyFLags flag;

        public FieldModelExtra(FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            name = FBE.FieldModelReferenceType<string>.CreateFieldModel(FBE.BaseTypes.STRING, buffer, 4 + 4);
            detail = FBE.FieldModelReferenceType<string>.CreateFieldModel(FBE.BaseTypes.STRING, buffer, name.FBEOffset + name.FBESize);
            sex = new osa.FBE.FieldModelSex(buffer, detail.FBEOffset + detail.FBESize);
            flag = new osa.FBE.FieldModelMyFLags(buffer, sex.FBEOffset + sex.FBESize);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + name.FBESize
                    + detail.FBESize
                    + sex.FBESize
                    + flag.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + name.FBEExtra
                    + detail.FBEExtra
                    + sex.FBEExtra
                    + flag.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 1;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override FBE.FieldModelValueType<Extra> Clone() { return new FieldModelExtra(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + name.FBESize) > fbeStructSize)
                return true;
            if (!name.Verify())
                return false;
            fbeCurrentSize += name.FBESize;

            if ((fbeCurrentSize + detail.FBESize) > fbeStructSize)
                return true;
            if (!detail.Verify())
                return false;
            fbeCurrentSize += detail.FBESize;

            if ((fbeCurrentSize + sex.FBESize) > fbeStructSize)
                return true;
            if (!sex.Verify())
                return false;
            fbeCurrentSize += sex.FBESize;

            if ((fbeCurrentSize + flag.FBESize) > fbeStructSize)
                return true;
            if (!flag.Verify())
                return false;
            fbeCurrentSize += flag.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out Extra fbeValue) { Get(out fbeValue, Extra.Default); }
        public override void Get(out Extra fbeValue, Extra defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out Extra fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = Extra.Default;

            if ((fbeCurrentSize + name.FBESize) <= fbeStructSize)
                name.Get(out fbeValue.name);
            else
                fbeValue.name = "";
            fbeCurrentSize += name.FBESize;

            if ((fbeCurrentSize + detail.FBESize) <= fbeStructSize)
                detail.Get(out fbeValue.detail);
            else
                fbeValue.detail = "";
            fbeCurrentSize += detail.FBESize;

            if ((fbeCurrentSize + sex.FBESize) <= fbeStructSize)
                sex.Get(out fbeValue.sex);
            else
                fbeValue.sex = global::osa.Sex.Default;
            fbeCurrentSize += sex.FBESize;

            if ((fbeCurrentSize + flag.FBESize) <= fbeStructSize)
                flag.Get(out fbeValue.flag);
            else
                fbeValue.flag = global::osa.MyFLags.Default;
            fbeCurrentSize += flag.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(Extra fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(Extra fbeValue)
        {
            name.Set(fbeValue.name);
            detail.Set(fbeValue.detail);
            sex.Set(fbeValue.sex);
            flag.Set(fbeValue.flag);
        }
    }

} // namespace osa.FBE

namespace osa.FBE {

    using global::osa;

    // Fast Binary Encoding Extra model
    public class ExtraModel : FBE.Model
    {
        public readonly FieldModelExtra model;

        public ExtraModel() { model = new FieldModelExtra(Buffer, 4); }
        public ExtraModel(FBE.Buffer buffer) : base(buffer) { model = new FieldModelExtra(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelExtra.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(Extra value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out Extra value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = Extra.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = Extra.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace osa.FBE

namespace osa.FBE {

    using global::osa;

    // Fast Binary Encoding Extra final model
    public class FinalModelExtra : FBE.FinalModelValueType<Extra>
    {
        public readonly FBE.FinalModelReferenceType<string> name;
        public readonly FBE.FinalModelReferenceType<string> detail;
        public readonly osa.FBE.FinalModelSex sex;
        public readonly osa.FBE.FinalModelMyFLags flag;

        public FinalModelExtra(FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            name = FBE.FinalModelReferenceType<string>.CreateFinalModel(FBE.BaseTypes.STRING, buffer, 0);
            detail = FBE.FinalModelReferenceType<string>.CreateFinalModel(FBE.BaseTypes.STRING, buffer, 0);
            sex = new osa.FBE.FinalModelSex(buffer, 0);
            flag = new osa.FBE.FinalModelMyFLags(buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(Extra fbeValue)
        {
            long fbeResult = 0
                + name.FBEAllocationSize(fbeValue.name)
                + detail.FBEAllocationSize(fbeValue.detail)
                + sex.FBEAllocationSize(fbeValue.sex)
                + flag.FBEAllocationSize(fbeValue.flag)
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 1;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override FBE.FinalModelValueType<Extra> Clone() { return new FinalModelExtra(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            name.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = name.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            detail.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = detail.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            sex.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = sex.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            flag.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = flag.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out Extra fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out Extra fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = Extra.Default;

            name.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = name.Get(out fbeValue.name);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            detail.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = detail.Get(out fbeValue.detail);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            sex.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = sex.Get(out fbeValue.sex);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            flag.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = flag.Get(out fbeValue.flag);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(Extra fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(Extra fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            name.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = name.Set(fbeValue.name);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            detail.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = detail.Set(fbeValue.detail);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            sex.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = sex.Set(fbeValue.sex);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            flag.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = flag.Set(fbeValue.flag);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace osa.FBE

namespace osa.FBE {

    using global::osa;

    // Fast Binary Encoding Extra final model
    public class ExtraFinalModel : FBE.Model
    {
        private readonly FinalModelExtra _model;

        public ExtraFinalModel() { _model = new FinalModelExtra(Buffer, 8); }
        public ExtraFinalModel(FBE.Buffer buffer) : base(buffer) { _model = new FinalModelExtra(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelExtra.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(Extra value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out Extra value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = Extra.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = Extra.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace osa.FBE

namespace osa {

    public struct Simple : IComparable, IComparable<Simple>, IEquatable<Simple>
    {
        public string name;
        public int depth;
        public Extra[] sa;
        public Sex sex;

        public const long FBETypeConst = 2;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static Simple Default => new Simple
        {
            name = ""
            , depth = (int)0
            , sa = new Extra[1]
            , sex = global::osa.Sex.Default
        };

        public Simple(string name, int depth, Extra[] sa, Sex sex)
        {
            this.name = name;
            this.depth = depth;
            this.sa = sa;
            this.sex = sex;
        }

        public Simple Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new osa.FBE.SimpleModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new osa.FBE.SimpleModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            return result;
        }

        public int CompareTo(Simple other)
        {
            int result = 0;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is Simple))
                return false;
            return true;
        }

        public bool Equals(Simple other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            return hash;
        }

        public static bool operator==(Simple lhs, Simple rhs) => lhs.Equals(rhs);
        public static bool operator!=(Simple lhs, Simple rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("Simple(");
            sb.Append("name="); if (name != null) sb.Append("\"").Append(name).Append("\""); else sb.Append("null");
            sb.Append(",depth="); sb.Append(depth);
            if (sa != null)
            {
                bool first = true;
                sb.Append(",sa=[").Append(sa.Length).Append("][");
                foreach (var item in sa)
                {
                    sb.Append(first ? "" : ",").Append(item);
                    first = false;
                }
                sb.Append("]");
            }
            else
            {
                sb.Append(",sa=[0][]");
            }
            sb.Append(",sex="); sb.Append(sex);
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = FBE.Json.ToJson(this);
            return json;
        }

        public static Simple FromJson(string json)
        {
            var result = FBE.Json.FromJson<Simple>(json);
            return result;
        }

        public static FBE.FieldModelValueType<Simple> CreateFieldModel(FBE.Buffer buffer, long offset) { return new osa.FBE.FieldModelSimple(buffer, offset); }
    }

} // namespace osa

namespace osa.FBE {

    using global::osa;

    // Fast Binary Encoding Simple field model
    public class FieldModelSimple : FBE.FieldModelValueType<Simple>
    {
        public readonly FBE.FieldModelReferenceType<string> name;
        public readonly FBE.FieldModelValueType<int> depth;
        public readonly FBE.FieldModelArrayValueType<Extra, osa.FBE.FieldModelExtra> sa;
        public readonly osa.FBE.FieldModelSex sex;

        public FieldModelSimple(FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            name = FBE.FieldModelReferenceType<string>.CreateFieldModel(FBE.BaseTypes.STRING, buffer, 4 + 4);
            depth = FBE.FieldModelValueType<int>.CreateFieldModel(FBE.BaseTypes.INT32, buffer, name.FBEOffset + name.FBESize);
            sa = new FBE.FieldModelArrayValueType<Extra, osa.FBE.FieldModelExtra>(new osa.FBE.FieldModelExtra(buffer, depth.FBEOffset + depth.FBESize), buffer, depth.FBEOffset + depth.FBESize, 1);
            sex = new osa.FBE.FieldModelSex(buffer, sa.FBEOffset + sa.FBESize);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + name.FBESize
                    + depth.FBESize
                    + sa.FBESize
                    + sex.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + name.FBEExtra
                    + depth.FBEExtra
                    + sa.FBEExtra
                    + sex.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 2;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override FBE.FieldModelValueType<Simple> Clone() { return new FieldModelSimple(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + name.FBESize) > fbeStructSize)
                return true;
            if (!name.Verify())
                return false;
            fbeCurrentSize += name.FBESize;

            if ((fbeCurrentSize + depth.FBESize) > fbeStructSize)
                return true;
            if (!depth.Verify())
                return false;
            fbeCurrentSize += depth.FBESize;

            if ((fbeCurrentSize + sa.FBESize) > fbeStructSize)
                return true;
            if (!sa.Verify())
                return false;
            fbeCurrentSize += sa.FBESize;

            if ((fbeCurrentSize + sex.FBESize) > fbeStructSize)
                return true;
            if (!sex.Verify())
                return false;
            fbeCurrentSize += sex.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out Simple fbeValue) { Get(out fbeValue, Simple.Default); }
        public override void Get(out Simple fbeValue, Simple defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out Simple fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = Simple.Default;

            if ((fbeCurrentSize + name.FBESize) <= fbeStructSize)
                name.Get(out fbeValue.name);
            else
                fbeValue.name = "";
            fbeCurrentSize += name.FBESize;

            if ((fbeCurrentSize + depth.FBESize) <= fbeStructSize)
                depth.Get(out fbeValue.depth);
            else
                fbeValue.depth = (int)0;
            fbeCurrentSize += depth.FBESize;

            if ((fbeCurrentSize + sa.FBESize) <= fbeStructSize)
                sa.Get(ref fbeValue.sa);
            else
                fbeValue.sa = new Extra[1];
            fbeCurrentSize += sa.FBESize;

            if ((fbeCurrentSize + sex.FBESize) <= fbeStructSize)
                sex.Get(out fbeValue.sex);
            else
                fbeValue.sex = global::osa.Sex.Default;
            fbeCurrentSize += sex.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(Simple fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(Simple fbeValue)
        {
            name.Set(fbeValue.name);
            depth.Set(fbeValue.depth);
            sa.Set(fbeValue.sa);
            sex.Set(fbeValue.sex);
        }
    }

} // namespace osa.FBE

namespace osa.FBE {

    using global::osa;

    // Fast Binary Encoding Simple model
    public class SimpleModel : FBE.Model
    {
        public readonly FieldModelSimple model;

        public SimpleModel() { model = new FieldModelSimple(Buffer, 4); }
        public SimpleModel(FBE.Buffer buffer) : base(buffer) { model = new FieldModelSimple(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelSimple.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(Simple value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out Simple value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = Simple.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = Simple.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace osa.FBE

namespace osa.FBE {

    using global::osa;

    // Fast Binary Encoding Simple final model
    public class FinalModelSimple : FBE.FinalModelValueType<Simple>
    {
        public readonly FBE.FinalModelReferenceType<string> name;
        public readonly FBE.FinalModelValueType<int> depth;
        public readonly FBE.FinalModelArrayValueType<Extra, osa.FBE.FinalModelExtra> sa;
        public readonly osa.FBE.FinalModelSex sex;

        public FinalModelSimple(FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            name = FBE.FinalModelReferenceType<string>.CreateFinalModel(FBE.BaseTypes.STRING, buffer, 0);
            depth = FBE.FinalModelValueType<int>.CreateFinalModel(FBE.BaseTypes.INT32, buffer, 0);
            sa = new FBE.FinalModelArrayValueType<Extra, osa.FBE.FinalModelExtra>(new osa.FBE.FinalModelExtra(buffer, 0), buffer, 0, 1);
            sex = new osa.FBE.FinalModelSex(buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(Simple fbeValue)
        {
            long fbeResult = 0
                + name.FBEAllocationSize(fbeValue.name)
                + depth.FBEAllocationSize(fbeValue.depth)
                + sa.FBEAllocationSize(fbeValue.sa)
                + sex.FBEAllocationSize(fbeValue.sex)
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 2;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override FBE.FinalModelValueType<Simple> Clone() { return new FinalModelSimple(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            name.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = name.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            depth.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = depth.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            sa.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = sa.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            sex.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = sex.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out Simple fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out Simple fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = Simple.Default;

            name.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = name.Get(out fbeValue.name);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            depth.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = depth.Get(out fbeValue.depth);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            sa.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = sa.Get(out fbeValue.sa);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            sex.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = sex.Get(out fbeValue.sex);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(Simple fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(Simple fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            name.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = name.Set(fbeValue.name);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            depth.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = depth.Set(fbeValue.depth);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            sa.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = sa.Set(fbeValue.sa);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            sex.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = sex.Set(fbeValue.sex);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace osa.FBE

namespace osa.FBE {

    using global::osa;

    // Fast Binary Encoding Simple final model
    public class SimpleFinalModel : FBE.Model
    {
        private readonly FinalModelSimple _model;

        public SimpleFinalModel() { _model = new FinalModelSimple(Buffer, 8); }
        public SimpleFinalModel(FBE.Buffer buffer) : base(buffer) { _model = new FinalModelSimple(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelSimple.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(Simple value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out Simple value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = Simple.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = Simple.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace osa.FBE

namespace osa.FBE {

    // Fast Binary Encoding osa protocol version
    public static class ProtocolVersion
    {
        // Protocol major version
        public const int Major = 0;
        // Protocol minor version
        public const int Minor = 0;
    }

} // namespace osa.FBE

namespace osa.FBE {

    // Fast Binary Encoding osa sender listener interface
    public interface ISenderListener : FBE.ISenderListener
    {
    }

    // Fast Binary Encoding osa sender
    public class Sender : FBE.Sender, ISenderListener
    {
        // Sender models accessors

        public Sender() : base(false)
        {
        }
        public Sender(FBE.Buffer buffer) : base(buffer, false)
        {
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(ISenderListener listener, object obj)
        {
            switch (obj)
            {
                default: break;
            }

            return 0;
        }

    }

} // namespace osa.FBE

namespace osa.FBE {

    // Fast Binary Encoding osa receiver listener interface
    public interface IReceiverListener : FBE.IReceiverListener
    {
        // Receive handlers
    }

    // Fast Binary Encoding osa receiver
    public class Receiver : FBE.Receiver, IReceiverListener
    {
        // Receiver values accessors

        // Receiver models accessors

        public Receiver() : base(false)
        {
        }
        public Receiver(FBE.Buffer buffer) : base(buffer, false)
        {
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IReceiverListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                default: break;
            }

            return false;
        }
    }

} // namespace osa.FBE

namespace osa.FBE {

    // Fast Binary Encoding osa proxy listener interface
    public interface IProxyListener : FBE.IReceiverListener
    {
        // Proxy handlers
    }

    // Fast Binary Encoding osa proxy
    public class Proxy : FBE.Receiver, IProxyListener
    {
        // Proxy models accessors

        public Proxy() : base(false)
        {
        }
        public Proxy(FBE.Buffer buffer) : base(buffer, false)
        {
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IProxyListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                default: break;
            }

            return false;
        }
    }

} // namespace osa.FBE

namespace osa.FBE {

    // Fast Binary Encoding osa client listener interface
    public interface IClientListener : FBE.IClientListener, ISenderListener, IReceiverListener
    {
    }

    // Fast Binary Encoding osa client
    public class Client : FBE.Client, IClientListener
    {
        // Client sender models accessors

        // Client receiver values accessors

        // Client receiver models accessors

        public Client() : base(false)
        {
        }
        public Client(FBE.Buffer sendBuffer, FBE.Buffer receiveBuffer) : base(sendBuffer, receiveBuffer, false)
        {
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(IClientListener listener, object obj)
        {
            switch (obj)
            {
                default: break;
            }

            return 0;
        }


        // Reset client requests
        internal override void ResetRequests()
        {
            base.ResetRequests();
        }

        // Watchdog client requests for timeouts
        internal override void WatchdogRequests(DateTime utc)
        {
            base.WatchdogRequests(utc);
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IClientListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                default: break;
            }

            return false;
        }

    }

} // namespace osa.FBE

namespace osa.FBE {

    // Fast Binary Encoding osa final sender listener interface
    public interface IFinalSenderListener : FBE.ISenderListener
    {
    }

    // Fast Binary Encoding osa final sender
    public class FinalSender : FBE.Sender, IFinalSenderListener
    {
        // Sender models accessors

        public FinalSender() : base(true)
        {
        }
        public FinalSender(FBE.Buffer buffer) : base(buffer, true)
        {
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(IFinalSenderListener listener, object obj)
        {
            switch (obj)
            {
                default: break;
            }

            return 0;
        }

    }

} // namespace osa.FBE

namespace osa.FBE {

    // Fast Binary Encoding osa final receiver listener interface
    public interface IFinalReceiverListener : FBE.IReceiverListener
    {
        // Receive handlers
    }

    // Fast Binary Encoding osa final receiver
    public class FinalReceiver : FBE.Receiver, IFinalReceiverListener
    {
        // Receiver values accessors

        // Receiver models accessors

        public FinalReceiver() : base(true)
        {
        }
        public FinalReceiver(FBE.Buffer buffer) : base(buffer, true)
        {
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IFinalReceiverListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                default: break;
            }

            return false;
        }
    }

} // namespace osa.FBE

namespace osa.FBE {

    // Fast Binary Encoding osa final client listener interface
    public interface IFinalClientListener : FBE.IClientListener, IFinalSenderListener, IFinalReceiverListener
    {
    }

    // Fast Binary Encoding osa final client
    public class FinalClient : FBE.Client, IFinalClientListener
    {
        // Client sender models accessors

        // Client receiver values accessors

        // Client receiver models accessors

        public FinalClient() : base(true)
        {
        }
        public FinalClient(FBE.Buffer sendBuffer, FBE.Buffer receiveBuffer) : base(sendBuffer, receiveBuffer, true)
        {
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(IFinalClientListener listener, object obj)
        {
            switch (obj)
            {
                default: break;
            }

            return 0;
        }


        // Reset client requests
        internal override void ResetRequests()
        {
            base.ResetRequests();
        }

        // Watchdog client requests for timeouts
        internal override void WatchdogRequests(DateTime utc)
        {
            base.WatchdogRequests(utc);
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IFinalClientListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                default: break;
            }

            return false;
        }

    }

} // namespace osa.FBE
