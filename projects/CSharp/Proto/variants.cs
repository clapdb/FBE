//------------------------------------------------------------------------------
// <auto-generated>
//     Automatically generated by the Fast Binary Encoding compiler, do not modify!
//     https://github.com/chronoxor/FastBinaryEncoding
//     Source: variants.fbe
//     FBE version: 1.10.0.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Runtime.Serialization;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
#if UTF8JSON
using Utf8Json;
using Utf8Json.Resolvers;
#elif NEWTONSOFTJSON
using Newtonsoft.Json;
#else
using System.Text.Json;
using System.Text.Json.Serialization;
#endif

namespace variants {

    public struct Simple : IComparable, IComparable<Simple>, IEquatable<Simple>
    {
        public string name;

        public const long FBETypeConst = 1;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static Simple Default => new Simple
        {
            name = ""
        };

        public Simple(string name)
        {
            this.name = name;
        }

        public Simple Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new variants.FBE.SimpleModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new variants.FBE.SimpleModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            return result;
        }

        public int CompareTo(Simple other)
        {
            int result = 0;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is Simple))
                return false;
            return true;
        }

        public bool Equals(Simple other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            return hash;
        }

        public static bool operator==(Simple lhs, Simple rhs) => lhs.Equals(rhs);
        public static bool operator!=(Simple lhs, Simple rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("Simple(");
            sb.Append("name="); if (name != null) sb.Append("\"").Append(name).Append("\""); else sb.Append("null");
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = FBE.Json.ToJson(this);
            return json;
        }

        public static Simple FromJson(string json)
        {
            var result = FBE.Json.FromJson<Simple>(json);
            return result;
        }

        public static FBE.FieldModelValueType<Simple> CreateFieldModel(FBE.Buffer buffer, long offset) { return new variants.FBE.FieldModelSimple(buffer, offset); }
    }

} // namespace variants

namespace variants.FBE {

    using global::variants;

    // Fast Binary Encoding Simple field model
    public class FieldModelSimple : FBE.FieldModelValueType<Simple>
    {
        public readonly FBE.FieldModelReferenceType<string> name;

        public FieldModelSimple(FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            name = FBE.FieldModelReferenceType<string>.CreateFieldModel(FBE.BaseTypes.STRING, buffer, 4 + 4);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + name.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + name.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 1;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override FBE.FieldModelValueType<Simple> Clone() { return new FieldModelSimple(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + name.FBESize) > fbeStructSize)
                return true;
            if (!name.Verify())
                return false;
            fbeCurrentSize += name.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out Simple fbeValue) { Get(out fbeValue, Simple.Default); }
        public override void Get(out Simple fbeValue, Simple defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out Simple fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = Simple.Default;

            if ((fbeCurrentSize + name.FBESize) <= fbeStructSize)
                name.Get(out fbeValue.name);
            else
                fbeValue.name = "";
            fbeCurrentSize += name.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(Simple fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(Simple fbeValue)
        {
            name.Set(fbeValue.name);
        }
    }

} // namespace variants.FBE

namespace variants.FBE {

    using global::variants;

    // Fast Binary Encoding Simple model
    public class SimpleModel : FBE.Model
    {
        public readonly FieldModelSimple model;

        public SimpleModel() { model = new FieldModelSimple(Buffer, 4); }
        public SimpleModel(FBE.Buffer buffer) : base(buffer) { model = new FieldModelSimple(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelSimple.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(Simple value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out Simple value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = Simple.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = Simple.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace variants.FBE

namespace variants.FBE {

    using global::variants;

    // Fast Binary Encoding Simple final model
    public class FinalModelSimple : FBE.FinalModelValueType<Simple>
    {
        public readonly FBE.FinalModelReferenceType<string> name;

        public FinalModelSimple(FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            name = FBE.FinalModelReferenceType<string>.CreateFinalModel(FBE.BaseTypes.STRING, buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(Simple fbeValue)
        {
            long fbeResult = 0
                + name.FBEAllocationSize(fbeValue.name)
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 1;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override FBE.FinalModelValueType<Simple> Clone() { return new FinalModelSimple(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            name.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = name.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out Simple fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out Simple fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = Simple.Default;

            name.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = name.Get(out fbeValue.name);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(Simple fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(Simple fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            name.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = name.Set(fbeValue.name);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace variants.FBE

namespace variants.FBE {

    using global::variants;

    // Fast Binary Encoding Simple final model
    public class SimpleFinalModel : FBE.Model
    {
        private readonly FinalModelSimple _model;

        public SimpleFinalModel() { _model = new FinalModelSimple(Buffer, 8); }
        public SimpleFinalModel(FBE.Buffer buffer) : base(buffer) { _model = new FinalModelSimple(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelSimple.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(Simple value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out Simple value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = Simple.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = Simple.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace variants.FBE

namespace variants {

    public struct Value : IComparable, IComparable<Value>, IEquatable<Value>
    {
        public V v;

        public const long FBETypeConst = 2;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static Value Default => new Value
        {
            v = global::variants.V.Default
        };

        public Value(V v)
        {
            this.v = v;
        }

        public Value Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new variants.FBE.ValueModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new variants.FBE.ValueModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            return result;
        }

        public int CompareTo(Value other)
        {
            int result = 0;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is Value))
                return false;
            return true;
        }

        public bool Equals(Value other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            return hash;
        }

        public static bool operator==(Value lhs, Value rhs) => lhs.Equals(rhs);
        public static bool operator!=(Value lhs, Value rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("Value(");
            sb.Append("v="); sb.Append(v);
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = FBE.Json.ToJson(this);
            return json;
        }

        public static Value FromJson(string json)
        {
            var result = FBE.Json.FromJson<Value>(json);
            return result;
        }

        public static FBE.FieldModelValueType<Value> CreateFieldModel(FBE.Buffer buffer, long offset) { return new variants.FBE.FieldModelValue(buffer, offset); }
    }

} // namespace variants

namespace variants.FBE {

    using global::variants;

    // Fast Binary Encoding Value field model
    public class FieldModelValue : FBE.FieldModelValueType<Value>
    {
        public readonly variants.FBE.FieldModelV v;

        public FieldModelValue(FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            v = new variants.FBE.FieldModelV(buffer, 4 + 4);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + v.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + v.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 2;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override FBE.FieldModelValueType<Value> Clone() { return new FieldModelValue(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + v.FBESize) > fbeStructSize)
                return true;
            if (!v.Verify())
                return false;
            fbeCurrentSize += v.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out Value fbeValue) { Get(out fbeValue, Value.Default); }
        public override void Get(out Value fbeValue, Value defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out Value fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = Value.Default;

            if ((fbeCurrentSize + v.FBESize) <= fbeStructSize)
                v.Get(out fbeValue.v);
            else
                fbeValue.v = global::variants.V.Default;
            fbeCurrentSize += v.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(Value fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(Value fbeValue)
        {
            v.Set(fbeValue.v);
        }
    }

} // namespace variants.FBE

namespace variants.FBE {

    using global::variants;

    // Fast Binary Encoding Value model
    public class ValueModel : FBE.Model
    {
        public readonly FieldModelValue model;

        public ValueModel() { model = new FieldModelValue(Buffer, 4); }
        public ValueModel(FBE.Buffer buffer) : base(buffer) { model = new FieldModelValue(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelValue.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(Value value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out Value value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = Value.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = Value.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace variants.FBE

namespace variants.FBE {

    using global::variants;

    // Fast Binary Encoding Value final model
    public class FinalModelValue : FBE.FinalModelValueType<Value>
    {
        public readonly variants.FBE.FinalModelV v;

        public FinalModelValue(FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            v = new variants.FBE.FinalModelV(buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(Value fbeValue)
        {
            long fbeResult = 0
                + v.FBEAllocationSize(fbeValue.v)
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 2;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override FBE.FinalModelValueType<Value> Clone() { return new FinalModelValue(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            v.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = v.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out Value fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out Value fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = Value.Default;

            v.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = v.Get(out fbeValue.v);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(Value fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(Value fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            v.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = v.Set(fbeValue.v);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace variants.FBE

namespace variants.FBE {

    using global::variants;

    // Fast Binary Encoding Value final model
    public class ValueFinalModel : FBE.Model
    {
        private readonly FinalModelValue _model;

        public ValueFinalModel() { _model = new FinalModelValue(Buffer, 8); }
        public ValueFinalModel(FBE.Buffer buffer) : base(buffer) { _model = new FinalModelValue(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelValue.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(Value value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out Value value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = Value.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = Value.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace variants.FBE

namespace variants.FBE {

    // Fast Binary Encoding variants protocol version
    public static class ProtocolVersion
    {
        // Protocol major version
        public const int Major = 0;
        // Protocol minor version
        public const int Minor = 0;
    }

} // namespace variants.FBE

namespace variants.FBE {

    // Fast Binary Encoding variants sender listener interface
    public interface ISenderListener : FBE.ISenderListener
    {
    }

    // Fast Binary Encoding variants sender
    public class Sender : FBE.Sender, ISenderListener
    {
        // Sender models accessors

        public Sender() : base(false)
        {
        }
        public Sender(FBE.Buffer buffer) : base(buffer, false)
        {
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(ISenderListener listener, object obj)
        {
            switch (obj)
            {
                default: break;
            }

            return 0;
        }

    }

} // namespace variants.FBE

namespace variants.FBE {

    // Fast Binary Encoding variants receiver listener interface
    public interface IReceiverListener : FBE.IReceiverListener
    {
        // Receive handlers
    }

    // Fast Binary Encoding variants receiver
    public class Receiver : FBE.Receiver, IReceiverListener
    {
        // Receiver values accessors

        // Receiver models accessors

        public Receiver() : base(false)
        {
        }
        public Receiver(FBE.Buffer buffer) : base(buffer, false)
        {
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IReceiverListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                default: break;
            }

            return false;
        }
    }

} // namespace variants.FBE

namespace variants.FBE {

    // Fast Binary Encoding variants proxy listener interface
    public interface IProxyListener : FBE.IReceiverListener
    {
        // Proxy handlers
    }

    // Fast Binary Encoding variants proxy
    public class Proxy : FBE.Receiver, IProxyListener
    {
        // Proxy models accessors

        public Proxy() : base(false)
        {
        }
        public Proxy(FBE.Buffer buffer) : base(buffer, false)
        {
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IProxyListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                default: break;
            }

            return false;
        }
    }

} // namespace variants.FBE

namespace variants.FBE {

    // Fast Binary Encoding variants client listener interface
    public interface IClientListener : FBE.IClientListener, ISenderListener, IReceiverListener
    {
    }

    // Fast Binary Encoding variants client
    public class Client : FBE.Client, IClientListener
    {
        // Client sender models accessors

        // Client receiver values accessors

        // Client receiver models accessors

        public Client() : base(false)
        {
        }
        public Client(FBE.Buffer sendBuffer, FBE.Buffer receiveBuffer) : base(sendBuffer, receiveBuffer, false)
        {
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(IClientListener listener, object obj)
        {
            switch (obj)
            {
                default: break;
            }

            return 0;
        }


        // Reset client requests
        internal override void ResetRequests()
        {
            base.ResetRequests();
        }

        // Watchdog client requests for timeouts
        internal override void WatchdogRequests(DateTime utc)
        {
            base.WatchdogRequests(utc);
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IClientListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                default: break;
            }

            return false;
        }

    }

} // namespace variants.FBE

namespace variants.FBE {

    // Fast Binary Encoding variants final sender listener interface
    public interface IFinalSenderListener : FBE.ISenderListener
    {
    }

    // Fast Binary Encoding variants final sender
    public class FinalSender : FBE.Sender, IFinalSenderListener
    {
        // Sender models accessors

        public FinalSender() : base(true)
        {
        }
        public FinalSender(FBE.Buffer buffer) : base(buffer, true)
        {
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(IFinalSenderListener listener, object obj)
        {
            switch (obj)
            {
                default: break;
            }

            return 0;
        }

    }

} // namespace variants.FBE

namespace variants.FBE {

    // Fast Binary Encoding variants final receiver listener interface
    public interface IFinalReceiverListener : FBE.IReceiverListener
    {
        // Receive handlers
    }

    // Fast Binary Encoding variants final receiver
    public class FinalReceiver : FBE.Receiver, IFinalReceiverListener
    {
        // Receiver values accessors

        // Receiver models accessors

        public FinalReceiver() : base(true)
        {
        }
        public FinalReceiver(FBE.Buffer buffer) : base(buffer, true)
        {
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IFinalReceiverListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                default: break;
            }

            return false;
        }
    }

} // namespace variants.FBE

namespace variants.FBE {

    // Fast Binary Encoding variants final client listener interface
    public interface IFinalClientListener : FBE.IClientListener, IFinalSenderListener, IFinalReceiverListener
    {
    }

    // Fast Binary Encoding variants final client
    public class FinalClient : FBE.Client, IFinalClientListener
    {
        // Client sender models accessors

        // Client receiver values accessors

        // Client receiver models accessors

        public FinalClient() : base(true)
        {
        }
        public FinalClient(FBE.Buffer sendBuffer, FBE.Buffer receiveBuffer) : base(sendBuffer, receiveBuffer, true)
        {
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(IFinalClientListener listener, object obj)
        {
            switch (obj)
            {
                default: break;
            }

            return 0;
        }


        // Reset client requests
        internal override void ResetRequests()
        {
            base.ResetRequests();
        }

        // Watchdog client requests for timeouts
        internal override void WatchdogRequests(DateTime utc)
        {
            base.WatchdogRequests(utc);
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IFinalClientListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                default: break;
            }

            return false;
        }

    }

} // namespace variants.FBE
