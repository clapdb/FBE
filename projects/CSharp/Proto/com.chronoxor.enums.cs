//------------------------------------------------------------------------------
// <auto-generated>
//     Automatically generated by the Fast Binary Encoding compiler, do not modify!
//     https://github.com/chronoxor/FastBinaryEncoding
//     Source: enums.fbe
//     FBE version: 1.10.0.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Runtime.Serialization;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
#if UTF8JSON
using Utf8Json;
using Utf8Json.Resolvers;
#elif NEWTONSOFTJSON
using Newtonsoft.Json;
#else
using System.Text.Json;
using System.Text.Json.Serialization;
#endif

namespace com.chronoxor.enums {

#if UTF8JSON
    public class EnumByteConverter : IJsonFormatter<EnumByte>
    {
        public void Serialize(ref JsonWriter writer, EnumByte value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteByte(value.Value);
        }

        public EnumByte Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            return new EnumByte(reader.ReadByte());
        }
    }

    [JsonFormatter(typeof(EnumByteConverter))]
#elif NEWTONSOFTJSON
    public class EnumByteConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(EnumByte);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((EnumByte)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            switch (reader.Value)
            {
                case long longValue:
                    return new EnumByte((byte)longValue);
                case BigInteger bigValue:
                    return new EnumByte((byte)bigValue);
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(EnumByteConverter))]
#else
    public class EnumByteConverter : JsonConverter<EnumByte>
    {
        public override void Write(Utf8JsonWriter writer, EnumByte value, JsonSerializerOptions options) => writer.WriteNumberValue(value.Value);
        public override EnumByte Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => new EnumByte(reader.GetByte());
    }

    [JsonConverter(typeof(EnumByteConverter))]
#endif
    public struct EnumByte : IComparable, IComparable<EnumByte>, IEquatable<EnumByte>
    {
        public byte Value { get; internal set; }

        public EnumByte(byte value) : this()
        {
            Value = value;
        }

        public EnumByte(EnumByte value) : this()
        {
            Value = value.Value;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((EnumByte)other).Value);
        }

        public int CompareTo(EnumByte other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is EnumByte value) && Value.Equals(value.Value);
        }

        public bool Equals(EnumByte other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(EnumByte value1, EnumByte value2)
        {
            return value1.Value == value2.Value;
        }

        public static bool operator!=(EnumByte value1, EnumByte value2)
        {
            return value1.Value != value2.Value;
        }

        public static EnumByte Default => new EnumByte();

        public static com.chronoxor.FBE.FieldModelValueType<EnumByte> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new enums.FBE.FieldModelEnumByte(buffer, offset); }

        public const byte _ENUM_VALUE_0_ = (byte)0U + 0;
        public const byte _ENUM_VALUE_1_ = (byte)0U + 0;
        public const byte _ENUM_VALUE_2_ = (byte)0U + 1;
        public const byte _ENUM_VALUE_3_ = (byte)254U + 0;
        public const byte _ENUM_VALUE_4_ = (byte)254U + 1;
        public const byte _ENUM_VALUE_5_ = _ENUM_VALUE_3_;

        public static EnumByte ENUM_VALUE_0 = new EnumByte(_ENUM_VALUE_0_);
        public static EnumByte ENUM_VALUE_1 = new EnumByte(_ENUM_VALUE_1_);
        public static EnumByte ENUM_VALUE_2 = new EnumByte(_ENUM_VALUE_2_);
        public static EnumByte ENUM_VALUE_3 = new EnumByte(_ENUM_VALUE_3_);
        public static EnumByte ENUM_VALUE_4 = new EnumByte(_ENUM_VALUE_4_);
        public static EnumByte ENUM_VALUE_5 = new EnumByte(_ENUM_VALUE_5_);

        public override string ToString()
        {
            if (this == ENUM_VALUE_0) return "ENUM_VALUE_0";
            if (this == ENUM_VALUE_1) return "ENUM_VALUE_1";
            if (this == ENUM_VALUE_2) return "ENUM_VALUE_2";
            if (this == ENUM_VALUE_3) return "ENUM_VALUE_3";
            if (this == ENUM_VALUE_4) return "ENUM_VALUE_4";
            if (this == ENUM_VALUE_5) return "ENUM_VALUE_5";
            return "<unknown>";
        }
    }

} // namespace com.chronoxor.enums

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding EnumByte field model
    public class FieldModelEnumByte : com.chronoxor.FBE.FieldModelValueType<EnumByte>
    {
        public FieldModelEnumByte(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 1;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<EnumByte> Clone() { return new FieldModelEnumByte(_buffer, _offset); }

        // Get the value
        public override void Get(out EnumByte value) { Get(out value, EnumByte.Default); }
        public override void Get(out EnumByte value, EnumByte defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = new EnumByte((byte)ReadByte(FBEOffset));
        }

        // Set the value
        public override void Set(EnumByte value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding EnumByte final model
    public class FinalModelEnumByte : com.chronoxor.FBE.FinalModelValueType<EnumByte>
    {
        public FinalModelEnumByte(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(EnumByte value) { return FBESize; }

        // Get the final size
        public override long FBESize => 1;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<EnumByte> Clone() { return new FinalModelEnumByte(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out EnumByte value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = EnumByte.Default;
                return 0;
            }

            value = new EnumByte((byte)ReadByte(FBEOffset));
            return FBESize;
        }

        // Set the value
        public override long Set(EnumByte value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums {

#if UTF8JSON
    public class EnumCharConverter : IJsonFormatter<EnumChar>
    {
        public void Serialize(ref JsonWriter writer, EnumChar value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteByte(value.Value);
        }

        public EnumChar Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            return new EnumChar(reader.ReadByte());
        }
    }

    [JsonFormatter(typeof(EnumCharConverter))]
#elif NEWTONSOFTJSON
    public class EnumCharConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(EnumChar);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((EnumChar)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            switch (reader.Value)
            {
                case long longValue:
                    return new EnumChar((byte)longValue);
                case BigInteger bigValue:
                    return new EnumChar((byte)bigValue);
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(EnumCharConverter))]
#else
    public class EnumCharConverter : JsonConverter<EnumChar>
    {
        public override void Write(Utf8JsonWriter writer, EnumChar value, JsonSerializerOptions options) => writer.WriteNumberValue(value.Value);
        public override EnumChar Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => new EnumChar(reader.GetByte());
    }

    [JsonConverter(typeof(EnumCharConverter))]
#endif
    public struct EnumChar : IComparable, IComparable<EnumChar>, IEquatable<EnumChar>
    {
        public byte Value { get; internal set; }

        public EnumChar(byte value) : this()
        {
            Value = value;
        }

        public EnumChar(EnumChar value) : this()
        {
            Value = value.Value;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((EnumChar)other).Value);
        }

        public int CompareTo(EnumChar other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is EnumChar value) && Value.Equals(value.Value);
        }

        public bool Equals(EnumChar other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(EnumChar value1, EnumChar value2)
        {
            return value1.Value == value2.Value;
        }

        public static bool operator!=(EnumChar value1, EnumChar value2)
        {
            return value1.Value != value2.Value;
        }

        public static EnumChar Default => new EnumChar();

        public static com.chronoxor.FBE.FieldModelValueType<EnumChar> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new enums.FBE.FieldModelEnumChar(buffer, offset); }

        public const byte _ENUM_VALUE_0_ = (byte)0 + 0;
        public const byte _ENUM_VALUE_1_ = (byte)'1' + 0;
        public const byte _ENUM_VALUE_2_ = (byte)'1' + 1;
        public const byte _ENUM_VALUE_3_ = (byte)'3' + 0;
        public const byte _ENUM_VALUE_4_ = (byte)'3' + 1;
        public const byte _ENUM_VALUE_5_ = _ENUM_VALUE_3_;

        public static EnumChar ENUM_VALUE_0 = new EnumChar(_ENUM_VALUE_0_);
        public static EnumChar ENUM_VALUE_1 = new EnumChar(_ENUM_VALUE_1_);
        public static EnumChar ENUM_VALUE_2 = new EnumChar(_ENUM_VALUE_2_);
        public static EnumChar ENUM_VALUE_3 = new EnumChar(_ENUM_VALUE_3_);
        public static EnumChar ENUM_VALUE_4 = new EnumChar(_ENUM_VALUE_4_);
        public static EnumChar ENUM_VALUE_5 = new EnumChar(_ENUM_VALUE_5_);

        public override string ToString()
        {
            if (this == ENUM_VALUE_0) return "ENUM_VALUE_0";
            if (this == ENUM_VALUE_1) return "ENUM_VALUE_1";
            if (this == ENUM_VALUE_2) return "ENUM_VALUE_2";
            if (this == ENUM_VALUE_3) return "ENUM_VALUE_3";
            if (this == ENUM_VALUE_4) return "ENUM_VALUE_4";
            if (this == ENUM_VALUE_5) return "ENUM_VALUE_5";
            return "<unknown>";
        }
    }

} // namespace com.chronoxor.enums

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding EnumChar field model
    public class FieldModelEnumChar : com.chronoxor.FBE.FieldModelValueType<EnumChar>
    {
        public FieldModelEnumChar(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 1;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<EnumChar> Clone() { return new FieldModelEnumChar(_buffer, _offset); }

        // Get the value
        public override void Get(out EnumChar value) { Get(out value, EnumChar.Default); }
        public override void Get(out EnumChar value, EnumChar defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = new EnumChar((byte)ReadUInt8(FBEOffset));
        }

        // Set the value
        public override void Set(EnumChar value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding EnumChar final model
    public class FinalModelEnumChar : com.chronoxor.FBE.FinalModelValueType<EnumChar>
    {
        public FinalModelEnumChar(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(EnumChar value) { return FBESize; }

        // Get the final size
        public override long FBESize => 1;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<EnumChar> Clone() { return new FinalModelEnumChar(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out EnumChar value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = EnumChar.Default;
                return 0;
            }

            value = new EnumChar((byte)ReadUInt8(FBEOffset));
            return FBESize;
        }

        // Set the value
        public override long Set(EnumChar value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums {

#if UTF8JSON
    public class EnumWCharConverter : IJsonFormatter<EnumWChar>
    {
        public void Serialize(ref JsonWriter writer, EnumWChar value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteUInt16(value.Value);
        }

        public EnumWChar Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            return new EnumWChar(reader.ReadUInt16());
        }
    }

    [JsonFormatter(typeof(EnumWCharConverter))]
#elif NEWTONSOFTJSON
    public class EnumWCharConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(EnumWChar);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((EnumWChar)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            switch (reader.Value)
            {
                case long longValue:
                    return new EnumWChar((ushort)longValue);
                case BigInteger bigValue:
                    return new EnumWChar((ushort)bigValue);
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(EnumWCharConverter))]
#else
    public class EnumWCharConverter : JsonConverter<EnumWChar>
    {
        public override void Write(Utf8JsonWriter writer, EnumWChar value, JsonSerializerOptions options) => writer.WriteNumberValue(value.Value);
        public override EnumWChar Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => new EnumWChar(reader.GetUInt16());
    }

    [JsonConverter(typeof(EnumWCharConverter))]
#endif
    public struct EnumWChar : IComparable, IComparable<EnumWChar>, IEquatable<EnumWChar>
    {
        public ushort Value { get; internal set; }

        public EnumWChar(ushort value) : this()
        {
            Value = value;
        }

        public EnumWChar(EnumWChar value) : this()
        {
            Value = value.Value;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((EnumWChar)other).Value);
        }

        public int CompareTo(EnumWChar other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is EnumWChar value) && Value.Equals(value.Value);
        }

        public bool Equals(EnumWChar other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(EnumWChar value1, EnumWChar value2)
        {
            return value1.Value == value2.Value;
        }

        public static bool operator!=(EnumWChar value1, EnumWChar value2)
        {
            return value1.Value != value2.Value;
        }

        public static EnumWChar Default => new EnumWChar();

        public static com.chronoxor.FBE.FieldModelValueType<EnumWChar> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new enums.FBE.FieldModelEnumWChar(buffer, offset); }

        public const ushort _ENUM_VALUE_0_ = (ushort)0 + 0;
        public const ushort _ENUM_VALUE_1_ = (ushort)0x0444 + 0;
        public const ushort _ENUM_VALUE_2_ = (ushort)0x0444 + 1;
        public const ushort _ENUM_VALUE_3_ = (ushort)0x0555 + 0;
        public const ushort _ENUM_VALUE_4_ = (ushort)0x0555 + 1;
        public const ushort _ENUM_VALUE_5_ = _ENUM_VALUE_3_;

        public static EnumWChar ENUM_VALUE_0 = new EnumWChar(_ENUM_VALUE_0_);
        public static EnumWChar ENUM_VALUE_1 = new EnumWChar(_ENUM_VALUE_1_);
        public static EnumWChar ENUM_VALUE_2 = new EnumWChar(_ENUM_VALUE_2_);
        public static EnumWChar ENUM_VALUE_3 = new EnumWChar(_ENUM_VALUE_3_);
        public static EnumWChar ENUM_VALUE_4 = new EnumWChar(_ENUM_VALUE_4_);
        public static EnumWChar ENUM_VALUE_5 = new EnumWChar(_ENUM_VALUE_5_);

        public override string ToString()
        {
            if (this == ENUM_VALUE_0) return "ENUM_VALUE_0";
            if (this == ENUM_VALUE_1) return "ENUM_VALUE_1";
            if (this == ENUM_VALUE_2) return "ENUM_VALUE_2";
            if (this == ENUM_VALUE_3) return "ENUM_VALUE_3";
            if (this == ENUM_VALUE_4) return "ENUM_VALUE_4";
            if (this == ENUM_VALUE_5) return "ENUM_VALUE_5";
            return "<unknown>";
        }
    }

} // namespace com.chronoxor.enums

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding EnumWChar field model
    public class FieldModelEnumWChar : com.chronoxor.FBE.FieldModelValueType<EnumWChar>
    {
        public FieldModelEnumWChar(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 4;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<EnumWChar> Clone() { return new FieldModelEnumWChar(_buffer, _offset); }

        // Get the value
        public override void Get(out EnumWChar value) { Get(out value, EnumWChar.Default); }
        public override void Get(out EnumWChar value, EnumWChar defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = new EnumWChar((ushort)ReadUInt32(FBEOffset));
        }

        // Set the value
        public override void Set(EnumWChar value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding EnumWChar final model
    public class FinalModelEnumWChar : com.chronoxor.FBE.FinalModelValueType<EnumWChar>
    {
        public FinalModelEnumWChar(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(EnumWChar value) { return FBESize; }

        // Get the final size
        public override long FBESize => 4;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<EnumWChar> Clone() { return new FinalModelEnumWChar(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out EnumWChar value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = EnumWChar.Default;
                return 0;
            }

            value = new EnumWChar((ushort)ReadUInt32(FBEOffset));
            return FBESize;
        }

        // Set the value
        public override long Set(EnumWChar value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums {

#if UTF8JSON
    public class EnumInt8Converter : IJsonFormatter<EnumInt8>
    {
        public void Serialize(ref JsonWriter writer, EnumInt8 value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteSByte(value.Value);
        }

        public EnumInt8 Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            return new EnumInt8(reader.ReadSByte());
        }
    }

    [JsonFormatter(typeof(EnumInt8Converter))]
#elif NEWTONSOFTJSON
    public class EnumInt8Converter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(EnumInt8);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((EnumInt8)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            switch (reader.Value)
            {
                case long longValue:
                    return new EnumInt8((sbyte)longValue);
                case BigInteger bigValue:
                    return new EnumInt8((sbyte)bigValue);
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(EnumInt8Converter))]
#else
    public class EnumInt8Converter : JsonConverter<EnumInt8>
    {
        public override void Write(Utf8JsonWriter writer, EnumInt8 value, JsonSerializerOptions options) => writer.WriteNumberValue(value.Value);
        public override EnumInt8 Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => new EnumInt8(reader.GetSByte());
    }

    [JsonConverter(typeof(EnumInt8Converter))]
#endif
    public struct EnumInt8 : IComparable, IComparable<EnumInt8>, IEquatable<EnumInt8>
    {
        public sbyte Value { get; internal set; }

        public EnumInt8(sbyte value) : this()
        {
            Value = value;
        }

        public EnumInt8(EnumInt8 value) : this()
        {
            Value = value.Value;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((EnumInt8)other).Value);
        }

        public int CompareTo(EnumInt8 other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is EnumInt8 value) && Value.Equals(value.Value);
        }

        public bool Equals(EnumInt8 other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(EnumInt8 value1, EnumInt8 value2)
        {
            return value1.Value == value2.Value;
        }

        public static bool operator!=(EnumInt8 value1, EnumInt8 value2)
        {
            return value1.Value != value2.Value;
        }

        public static EnumInt8 Default => new EnumInt8();

        public static com.chronoxor.FBE.FieldModelValueType<EnumInt8> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new enums.FBE.FieldModelEnumInt8(buffer, offset); }

        public const sbyte _ENUM_VALUE_0_ = (sbyte)0 + 0;
        public const sbyte _ENUM_VALUE_1_ = (sbyte)-128 + 0;
        public const sbyte _ENUM_VALUE_2_ = (sbyte)-128 + 1;
        public const sbyte _ENUM_VALUE_3_ = (sbyte)126 + 0;
        public const sbyte _ENUM_VALUE_4_ = (sbyte)126 + 1;
        public const sbyte _ENUM_VALUE_5_ = _ENUM_VALUE_3_;

        public static EnumInt8 ENUM_VALUE_0 = new EnumInt8(_ENUM_VALUE_0_);
        public static EnumInt8 ENUM_VALUE_1 = new EnumInt8(_ENUM_VALUE_1_);
        public static EnumInt8 ENUM_VALUE_2 = new EnumInt8(_ENUM_VALUE_2_);
        public static EnumInt8 ENUM_VALUE_3 = new EnumInt8(_ENUM_VALUE_3_);
        public static EnumInt8 ENUM_VALUE_4 = new EnumInt8(_ENUM_VALUE_4_);
        public static EnumInt8 ENUM_VALUE_5 = new EnumInt8(_ENUM_VALUE_5_);

        public override string ToString()
        {
            if (this == ENUM_VALUE_0) return "ENUM_VALUE_0";
            if (this == ENUM_VALUE_1) return "ENUM_VALUE_1";
            if (this == ENUM_VALUE_2) return "ENUM_VALUE_2";
            if (this == ENUM_VALUE_3) return "ENUM_VALUE_3";
            if (this == ENUM_VALUE_4) return "ENUM_VALUE_4";
            if (this == ENUM_VALUE_5) return "ENUM_VALUE_5";
            return "<unknown>";
        }
    }

} // namespace com.chronoxor.enums

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding EnumInt8 field model
    public class FieldModelEnumInt8 : com.chronoxor.FBE.FieldModelValueType<EnumInt8>
    {
        public FieldModelEnumInt8(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 1;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<EnumInt8> Clone() { return new FieldModelEnumInt8(_buffer, _offset); }

        // Get the value
        public override void Get(out EnumInt8 value) { Get(out value, EnumInt8.Default); }
        public override void Get(out EnumInt8 value, EnumInt8 defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = new EnumInt8((sbyte)ReadInt8(FBEOffset));
        }

        // Set the value
        public override void Set(EnumInt8 value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding EnumInt8 final model
    public class FinalModelEnumInt8 : com.chronoxor.FBE.FinalModelValueType<EnumInt8>
    {
        public FinalModelEnumInt8(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(EnumInt8 value) { return FBESize; }

        // Get the final size
        public override long FBESize => 1;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<EnumInt8> Clone() { return new FinalModelEnumInt8(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out EnumInt8 value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = EnumInt8.Default;
                return 0;
            }

            value = new EnumInt8((sbyte)ReadInt8(FBEOffset));
            return FBESize;
        }

        // Set the value
        public override long Set(EnumInt8 value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums {

#if UTF8JSON
    public class EnumUInt8Converter : IJsonFormatter<EnumUInt8>
    {
        public void Serialize(ref JsonWriter writer, EnumUInt8 value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteByte(value.Value);
        }

        public EnumUInt8 Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            return new EnumUInt8(reader.ReadByte());
        }
    }

    [JsonFormatter(typeof(EnumUInt8Converter))]
#elif NEWTONSOFTJSON
    public class EnumUInt8Converter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(EnumUInt8);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((EnumUInt8)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            switch (reader.Value)
            {
                case long longValue:
                    return new EnumUInt8((byte)longValue);
                case BigInteger bigValue:
                    return new EnumUInt8((byte)bigValue);
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(EnumUInt8Converter))]
#else
    public class EnumUInt8Converter : JsonConverter<EnumUInt8>
    {
        public override void Write(Utf8JsonWriter writer, EnumUInt8 value, JsonSerializerOptions options) => writer.WriteNumberValue(value.Value);
        public override EnumUInt8 Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => new EnumUInt8(reader.GetByte());
    }

    [JsonConverter(typeof(EnumUInt8Converter))]
#endif
    public struct EnumUInt8 : IComparable, IComparable<EnumUInt8>, IEquatable<EnumUInt8>
    {
        public byte Value { get; internal set; }

        public EnumUInt8(byte value) : this()
        {
            Value = value;
        }

        public EnumUInt8(EnumUInt8 value) : this()
        {
            Value = value.Value;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((EnumUInt8)other).Value);
        }

        public int CompareTo(EnumUInt8 other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is EnumUInt8 value) && Value.Equals(value.Value);
        }

        public bool Equals(EnumUInt8 other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(EnumUInt8 value1, EnumUInt8 value2)
        {
            return value1.Value == value2.Value;
        }

        public static bool operator!=(EnumUInt8 value1, EnumUInt8 value2)
        {
            return value1.Value != value2.Value;
        }

        public static EnumUInt8 Default => new EnumUInt8();

        public static com.chronoxor.FBE.FieldModelValueType<EnumUInt8> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new enums.FBE.FieldModelEnumUInt8(buffer, offset); }

        public const byte _ENUM_VALUE_0_ = (byte)0U + 0;
        public const byte _ENUM_VALUE_1_ = (byte)0U + 0;
        public const byte _ENUM_VALUE_2_ = (byte)0U + 1;
        public const byte _ENUM_VALUE_3_ = (byte)254U + 0;
        public const byte _ENUM_VALUE_4_ = (byte)254U + 1;
        public const byte _ENUM_VALUE_5_ = _ENUM_VALUE_3_;

        public static EnumUInt8 ENUM_VALUE_0 = new EnumUInt8(_ENUM_VALUE_0_);
        public static EnumUInt8 ENUM_VALUE_1 = new EnumUInt8(_ENUM_VALUE_1_);
        public static EnumUInt8 ENUM_VALUE_2 = new EnumUInt8(_ENUM_VALUE_2_);
        public static EnumUInt8 ENUM_VALUE_3 = new EnumUInt8(_ENUM_VALUE_3_);
        public static EnumUInt8 ENUM_VALUE_4 = new EnumUInt8(_ENUM_VALUE_4_);
        public static EnumUInt8 ENUM_VALUE_5 = new EnumUInt8(_ENUM_VALUE_5_);

        public override string ToString()
        {
            if (this == ENUM_VALUE_0) return "ENUM_VALUE_0";
            if (this == ENUM_VALUE_1) return "ENUM_VALUE_1";
            if (this == ENUM_VALUE_2) return "ENUM_VALUE_2";
            if (this == ENUM_VALUE_3) return "ENUM_VALUE_3";
            if (this == ENUM_VALUE_4) return "ENUM_VALUE_4";
            if (this == ENUM_VALUE_5) return "ENUM_VALUE_5";
            return "<unknown>";
        }
    }

} // namespace com.chronoxor.enums

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding EnumUInt8 field model
    public class FieldModelEnumUInt8 : com.chronoxor.FBE.FieldModelValueType<EnumUInt8>
    {
        public FieldModelEnumUInt8(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 1;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<EnumUInt8> Clone() { return new FieldModelEnumUInt8(_buffer, _offset); }

        // Get the value
        public override void Get(out EnumUInt8 value) { Get(out value, EnumUInt8.Default); }
        public override void Get(out EnumUInt8 value, EnumUInt8 defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = new EnumUInt8((byte)ReadUInt8(FBEOffset));
        }

        // Set the value
        public override void Set(EnumUInt8 value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding EnumUInt8 final model
    public class FinalModelEnumUInt8 : com.chronoxor.FBE.FinalModelValueType<EnumUInt8>
    {
        public FinalModelEnumUInt8(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(EnumUInt8 value) { return FBESize; }

        // Get the final size
        public override long FBESize => 1;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<EnumUInt8> Clone() { return new FinalModelEnumUInt8(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out EnumUInt8 value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = EnumUInt8.Default;
                return 0;
            }

            value = new EnumUInt8((byte)ReadUInt8(FBEOffset));
            return FBESize;
        }

        // Set the value
        public override long Set(EnumUInt8 value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums {

#if UTF8JSON
    public class EnumInt16Converter : IJsonFormatter<EnumInt16>
    {
        public void Serialize(ref JsonWriter writer, EnumInt16 value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteInt16(value.Value);
        }

        public EnumInt16 Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            return new EnumInt16(reader.ReadInt16());
        }
    }

    [JsonFormatter(typeof(EnumInt16Converter))]
#elif NEWTONSOFTJSON
    public class EnumInt16Converter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(EnumInt16);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((EnumInt16)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            switch (reader.Value)
            {
                case long longValue:
                    return new EnumInt16((short)longValue);
                case BigInteger bigValue:
                    return new EnumInt16((short)bigValue);
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(EnumInt16Converter))]
#else
    public class EnumInt16Converter : JsonConverter<EnumInt16>
    {
        public override void Write(Utf8JsonWriter writer, EnumInt16 value, JsonSerializerOptions options) => writer.WriteNumberValue(value.Value);
        public override EnumInt16 Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => new EnumInt16(reader.GetInt16());
    }

    [JsonConverter(typeof(EnumInt16Converter))]
#endif
    public struct EnumInt16 : IComparable, IComparable<EnumInt16>, IEquatable<EnumInt16>
    {
        public short Value { get; internal set; }

        public EnumInt16(short value) : this()
        {
            Value = value;
        }

        public EnumInt16(EnumInt16 value) : this()
        {
            Value = value.Value;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((EnumInt16)other).Value);
        }

        public int CompareTo(EnumInt16 other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is EnumInt16 value) && Value.Equals(value.Value);
        }

        public bool Equals(EnumInt16 other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(EnumInt16 value1, EnumInt16 value2)
        {
            return value1.Value == value2.Value;
        }

        public static bool operator!=(EnumInt16 value1, EnumInt16 value2)
        {
            return value1.Value != value2.Value;
        }

        public static EnumInt16 Default => new EnumInt16();

        public static com.chronoxor.FBE.FieldModelValueType<EnumInt16> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new enums.FBE.FieldModelEnumInt16(buffer, offset); }

        public const short _ENUM_VALUE_0_ = (short)0 + 0;
        public const short _ENUM_VALUE_1_ = (short)-32768 + 0;
        public const short _ENUM_VALUE_2_ = (short)-32768 + 1;
        public const short _ENUM_VALUE_3_ = (short)32766 + 0;
        public const short _ENUM_VALUE_4_ = (short)32766 + 1;
        public const short _ENUM_VALUE_5_ = _ENUM_VALUE_3_;

        public static EnumInt16 ENUM_VALUE_0 = new EnumInt16(_ENUM_VALUE_0_);
        public static EnumInt16 ENUM_VALUE_1 = new EnumInt16(_ENUM_VALUE_1_);
        public static EnumInt16 ENUM_VALUE_2 = new EnumInt16(_ENUM_VALUE_2_);
        public static EnumInt16 ENUM_VALUE_3 = new EnumInt16(_ENUM_VALUE_3_);
        public static EnumInt16 ENUM_VALUE_4 = new EnumInt16(_ENUM_VALUE_4_);
        public static EnumInt16 ENUM_VALUE_5 = new EnumInt16(_ENUM_VALUE_5_);

        public override string ToString()
        {
            if (this == ENUM_VALUE_0) return "ENUM_VALUE_0";
            if (this == ENUM_VALUE_1) return "ENUM_VALUE_1";
            if (this == ENUM_VALUE_2) return "ENUM_VALUE_2";
            if (this == ENUM_VALUE_3) return "ENUM_VALUE_3";
            if (this == ENUM_VALUE_4) return "ENUM_VALUE_4";
            if (this == ENUM_VALUE_5) return "ENUM_VALUE_5";
            return "<unknown>";
        }
    }

} // namespace com.chronoxor.enums

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding EnumInt16 field model
    public class FieldModelEnumInt16 : com.chronoxor.FBE.FieldModelValueType<EnumInt16>
    {
        public FieldModelEnumInt16(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 2;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<EnumInt16> Clone() { return new FieldModelEnumInt16(_buffer, _offset); }

        // Get the value
        public override void Get(out EnumInt16 value) { Get(out value, EnumInt16.Default); }
        public override void Get(out EnumInt16 value, EnumInt16 defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = new EnumInt16((short)ReadInt16(FBEOffset));
        }

        // Set the value
        public override void Set(EnumInt16 value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding EnumInt16 final model
    public class FinalModelEnumInt16 : com.chronoxor.FBE.FinalModelValueType<EnumInt16>
    {
        public FinalModelEnumInt16(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(EnumInt16 value) { return FBESize; }

        // Get the final size
        public override long FBESize => 2;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<EnumInt16> Clone() { return new FinalModelEnumInt16(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out EnumInt16 value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = EnumInt16.Default;
                return 0;
            }

            value = new EnumInt16((short)ReadInt16(FBEOffset));
            return FBESize;
        }

        // Set the value
        public override long Set(EnumInt16 value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums {

#if UTF8JSON
    public class EnumUInt16Converter : IJsonFormatter<EnumUInt16>
    {
        public void Serialize(ref JsonWriter writer, EnumUInt16 value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteUInt16(value.Value);
        }

        public EnumUInt16 Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            return new EnumUInt16(reader.ReadUInt16());
        }
    }

    [JsonFormatter(typeof(EnumUInt16Converter))]
#elif NEWTONSOFTJSON
    public class EnumUInt16Converter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(EnumUInt16);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((EnumUInt16)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            switch (reader.Value)
            {
                case long longValue:
                    return new EnumUInt16((ushort)longValue);
                case BigInteger bigValue:
                    return new EnumUInt16((ushort)bigValue);
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(EnumUInt16Converter))]
#else
    public class EnumUInt16Converter : JsonConverter<EnumUInt16>
    {
        public override void Write(Utf8JsonWriter writer, EnumUInt16 value, JsonSerializerOptions options) => writer.WriteNumberValue(value.Value);
        public override EnumUInt16 Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => new EnumUInt16(reader.GetUInt16());
    }

    [JsonConverter(typeof(EnumUInt16Converter))]
#endif
    public struct EnumUInt16 : IComparable, IComparable<EnumUInt16>, IEquatable<EnumUInt16>
    {
        public ushort Value { get; internal set; }

        public EnumUInt16(ushort value) : this()
        {
            Value = value;
        }

        public EnumUInt16(EnumUInt16 value) : this()
        {
            Value = value.Value;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((EnumUInt16)other).Value);
        }

        public int CompareTo(EnumUInt16 other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is EnumUInt16 value) && Value.Equals(value.Value);
        }

        public bool Equals(EnumUInt16 other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(EnumUInt16 value1, EnumUInt16 value2)
        {
            return value1.Value == value2.Value;
        }

        public static bool operator!=(EnumUInt16 value1, EnumUInt16 value2)
        {
            return value1.Value != value2.Value;
        }

        public static EnumUInt16 Default => new EnumUInt16();

        public static com.chronoxor.FBE.FieldModelValueType<EnumUInt16> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new enums.FBE.FieldModelEnumUInt16(buffer, offset); }

        public const ushort _ENUM_VALUE_0_ = (ushort)0U + 0;
        public const ushort _ENUM_VALUE_1_ = (ushort)0U + 0;
        public const ushort _ENUM_VALUE_2_ = (ushort)0U + 1;
        public const ushort _ENUM_VALUE_3_ = (ushort)65534U + 0;
        public const ushort _ENUM_VALUE_4_ = (ushort)65534U + 1;
        public const ushort _ENUM_VALUE_5_ = _ENUM_VALUE_3_;

        public static EnumUInt16 ENUM_VALUE_0 = new EnumUInt16(_ENUM_VALUE_0_);
        public static EnumUInt16 ENUM_VALUE_1 = new EnumUInt16(_ENUM_VALUE_1_);
        public static EnumUInt16 ENUM_VALUE_2 = new EnumUInt16(_ENUM_VALUE_2_);
        public static EnumUInt16 ENUM_VALUE_3 = new EnumUInt16(_ENUM_VALUE_3_);
        public static EnumUInt16 ENUM_VALUE_4 = new EnumUInt16(_ENUM_VALUE_4_);
        public static EnumUInt16 ENUM_VALUE_5 = new EnumUInt16(_ENUM_VALUE_5_);

        public override string ToString()
        {
            if (this == ENUM_VALUE_0) return "ENUM_VALUE_0";
            if (this == ENUM_VALUE_1) return "ENUM_VALUE_1";
            if (this == ENUM_VALUE_2) return "ENUM_VALUE_2";
            if (this == ENUM_VALUE_3) return "ENUM_VALUE_3";
            if (this == ENUM_VALUE_4) return "ENUM_VALUE_4";
            if (this == ENUM_VALUE_5) return "ENUM_VALUE_5";
            return "<unknown>";
        }
    }

} // namespace com.chronoxor.enums

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding EnumUInt16 field model
    public class FieldModelEnumUInt16 : com.chronoxor.FBE.FieldModelValueType<EnumUInt16>
    {
        public FieldModelEnumUInt16(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 2;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<EnumUInt16> Clone() { return new FieldModelEnumUInt16(_buffer, _offset); }

        // Get the value
        public override void Get(out EnumUInt16 value) { Get(out value, EnumUInt16.Default); }
        public override void Get(out EnumUInt16 value, EnumUInt16 defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = new EnumUInt16((ushort)ReadUInt16(FBEOffset));
        }

        // Set the value
        public override void Set(EnumUInt16 value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding EnumUInt16 final model
    public class FinalModelEnumUInt16 : com.chronoxor.FBE.FinalModelValueType<EnumUInt16>
    {
        public FinalModelEnumUInt16(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(EnumUInt16 value) { return FBESize; }

        // Get the final size
        public override long FBESize => 2;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<EnumUInt16> Clone() { return new FinalModelEnumUInt16(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out EnumUInt16 value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = EnumUInt16.Default;
                return 0;
            }

            value = new EnumUInt16((ushort)ReadUInt16(FBEOffset));
            return FBESize;
        }

        // Set the value
        public override long Set(EnumUInt16 value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums {

#if UTF8JSON
    public class EnumInt32Converter : IJsonFormatter<EnumInt32>
    {
        public void Serialize(ref JsonWriter writer, EnumInt32 value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteInt32(value.Value);
        }

        public EnumInt32 Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            return new EnumInt32(reader.ReadInt32());
        }
    }

    [JsonFormatter(typeof(EnumInt32Converter))]
#elif NEWTONSOFTJSON
    public class EnumInt32Converter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(EnumInt32);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((EnumInt32)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            switch (reader.Value)
            {
                case long longValue:
                    return new EnumInt32((int)longValue);
                case BigInteger bigValue:
                    return new EnumInt32((int)bigValue);
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(EnumInt32Converter))]
#else
    public class EnumInt32Converter : JsonConverter<EnumInt32>
    {
        public override void Write(Utf8JsonWriter writer, EnumInt32 value, JsonSerializerOptions options) => writer.WriteNumberValue(value.Value);
        public override EnumInt32 Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => new EnumInt32(reader.GetInt32());
    }

    [JsonConverter(typeof(EnumInt32Converter))]
#endif
    public struct EnumInt32 : IComparable, IComparable<EnumInt32>, IEquatable<EnumInt32>
    {
        public int Value { get; internal set; }

        public EnumInt32(int value) : this()
        {
            Value = value;
        }

        public EnumInt32(EnumInt32 value) : this()
        {
            Value = value.Value;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((EnumInt32)other).Value);
        }

        public int CompareTo(EnumInt32 other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is EnumInt32 value) && Value.Equals(value.Value);
        }

        public bool Equals(EnumInt32 other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(EnumInt32 value1, EnumInt32 value2)
        {
            return value1.Value == value2.Value;
        }

        public static bool operator!=(EnumInt32 value1, EnumInt32 value2)
        {
            return value1.Value != value2.Value;
        }

        public static EnumInt32 Default => new EnumInt32();

        public static com.chronoxor.FBE.FieldModelValueType<EnumInt32> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new enums.FBE.FieldModelEnumInt32(buffer, offset); }

        public const int _ENUM_VALUE_0_ = (int)0 + 0;
        public const int _ENUM_VALUE_1_ = (int)-2147483648 + 0;
        public const int _ENUM_VALUE_2_ = (int)-2147483648 + 1;
        public const int _ENUM_VALUE_3_ = (int)2147483646 + 0;
        public const int _ENUM_VALUE_4_ = (int)2147483646 + 1;
        public const int _ENUM_VALUE_5_ = _ENUM_VALUE_3_;

        public static EnumInt32 ENUM_VALUE_0 = new EnumInt32(_ENUM_VALUE_0_);
        public static EnumInt32 ENUM_VALUE_1 = new EnumInt32(_ENUM_VALUE_1_);
        public static EnumInt32 ENUM_VALUE_2 = new EnumInt32(_ENUM_VALUE_2_);
        public static EnumInt32 ENUM_VALUE_3 = new EnumInt32(_ENUM_VALUE_3_);
        public static EnumInt32 ENUM_VALUE_4 = new EnumInt32(_ENUM_VALUE_4_);
        public static EnumInt32 ENUM_VALUE_5 = new EnumInt32(_ENUM_VALUE_5_);

        public override string ToString()
        {
            if (this == ENUM_VALUE_0) return "ENUM_VALUE_0";
            if (this == ENUM_VALUE_1) return "ENUM_VALUE_1";
            if (this == ENUM_VALUE_2) return "ENUM_VALUE_2";
            if (this == ENUM_VALUE_3) return "ENUM_VALUE_3";
            if (this == ENUM_VALUE_4) return "ENUM_VALUE_4";
            if (this == ENUM_VALUE_5) return "ENUM_VALUE_5";
            return "<unknown>";
        }
    }

} // namespace com.chronoxor.enums

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding EnumInt32 field model
    public class FieldModelEnumInt32 : com.chronoxor.FBE.FieldModelValueType<EnumInt32>
    {
        public FieldModelEnumInt32(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 4;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<EnumInt32> Clone() { return new FieldModelEnumInt32(_buffer, _offset); }

        // Get the value
        public override void Get(out EnumInt32 value) { Get(out value, EnumInt32.Default); }
        public override void Get(out EnumInt32 value, EnumInt32 defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = new EnumInt32((int)ReadInt32(FBEOffset));
        }

        // Set the value
        public override void Set(EnumInt32 value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding EnumInt32 final model
    public class FinalModelEnumInt32 : com.chronoxor.FBE.FinalModelValueType<EnumInt32>
    {
        public FinalModelEnumInt32(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(EnumInt32 value) { return FBESize; }

        // Get the final size
        public override long FBESize => 4;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<EnumInt32> Clone() { return new FinalModelEnumInt32(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out EnumInt32 value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = EnumInt32.Default;
                return 0;
            }

            value = new EnumInt32((int)ReadInt32(FBEOffset));
            return FBESize;
        }

        // Set the value
        public override long Set(EnumInt32 value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums {

#if UTF8JSON
    public class EnumUInt32Converter : IJsonFormatter<EnumUInt32>
    {
        public void Serialize(ref JsonWriter writer, EnumUInt32 value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteUInt32(value.Value);
        }

        public EnumUInt32 Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            return new EnumUInt32(reader.ReadUInt32());
        }
    }

    [JsonFormatter(typeof(EnumUInt32Converter))]
#elif NEWTONSOFTJSON
    public class EnumUInt32Converter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(EnumUInt32);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((EnumUInt32)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            switch (reader.Value)
            {
                case long longValue:
                    return new EnumUInt32((uint)longValue);
                case BigInteger bigValue:
                    return new EnumUInt32((uint)bigValue);
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(EnumUInt32Converter))]
#else
    public class EnumUInt32Converter : JsonConverter<EnumUInt32>
    {
        public override void Write(Utf8JsonWriter writer, EnumUInt32 value, JsonSerializerOptions options) => writer.WriteNumberValue(value.Value);
        public override EnumUInt32 Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => new EnumUInt32(reader.GetUInt32());
    }

    [JsonConverter(typeof(EnumUInt32Converter))]
#endif
    public struct EnumUInt32 : IComparable, IComparable<EnumUInt32>, IEquatable<EnumUInt32>
    {
        public uint Value { get; internal set; }

        public EnumUInt32(uint value) : this()
        {
            Value = value;
        }

        public EnumUInt32(EnumUInt32 value) : this()
        {
            Value = value.Value;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((EnumUInt32)other).Value);
        }

        public int CompareTo(EnumUInt32 other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is EnumUInt32 value) && Value.Equals(value.Value);
        }

        public bool Equals(EnumUInt32 other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(EnumUInt32 value1, EnumUInt32 value2)
        {
            return value1.Value == value2.Value;
        }

        public static bool operator!=(EnumUInt32 value1, EnumUInt32 value2)
        {
            return value1.Value != value2.Value;
        }

        public static EnumUInt32 Default => new EnumUInt32();

        public static com.chronoxor.FBE.FieldModelValueType<EnumUInt32> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new enums.FBE.FieldModelEnumUInt32(buffer, offset); }

        public const uint _ENUM_VALUE_0_ = (uint)0U + 0;
        public const uint _ENUM_VALUE_1_ = (uint)0U + 0;
        public const uint _ENUM_VALUE_2_ = (uint)0U + 1;
        public const uint _ENUM_VALUE_3_ = (uint)0xFFFFFFFEU + 0;
        public const uint _ENUM_VALUE_4_ = (uint)0xFFFFFFFEU + 1;
        public const uint _ENUM_VALUE_5_ = _ENUM_VALUE_3_;

        public static EnumUInt32 ENUM_VALUE_0 = new EnumUInt32(_ENUM_VALUE_0_);
        public static EnumUInt32 ENUM_VALUE_1 = new EnumUInt32(_ENUM_VALUE_1_);
        public static EnumUInt32 ENUM_VALUE_2 = new EnumUInt32(_ENUM_VALUE_2_);
        public static EnumUInt32 ENUM_VALUE_3 = new EnumUInt32(_ENUM_VALUE_3_);
        public static EnumUInt32 ENUM_VALUE_4 = new EnumUInt32(_ENUM_VALUE_4_);
        public static EnumUInt32 ENUM_VALUE_5 = new EnumUInt32(_ENUM_VALUE_5_);

        public override string ToString()
        {
            if (this == ENUM_VALUE_0) return "ENUM_VALUE_0";
            if (this == ENUM_VALUE_1) return "ENUM_VALUE_1";
            if (this == ENUM_VALUE_2) return "ENUM_VALUE_2";
            if (this == ENUM_VALUE_3) return "ENUM_VALUE_3";
            if (this == ENUM_VALUE_4) return "ENUM_VALUE_4";
            if (this == ENUM_VALUE_5) return "ENUM_VALUE_5";
            return "<unknown>";
        }
    }

} // namespace com.chronoxor.enums

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding EnumUInt32 field model
    public class FieldModelEnumUInt32 : com.chronoxor.FBE.FieldModelValueType<EnumUInt32>
    {
        public FieldModelEnumUInt32(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 4;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<EnumUInt32> Clone() { return new FieldModelEnumUInt32(_buffer, _offset); }

        // Get the value
        public override void Get(out EnumUInt32 value) { Get(out value, EnumUInt32.Default); }
        public override void Get(out EnumUInt32 value, EnumUInt32 defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = new EnumUInt32((uint)ReadUInt32(FBEOffset));
        }

        // Set the value
        public override void Set(EnumUInt32 value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding EnumUInt32 final model
    public class FinalModelEnumUInt32 : com.chronoxor.FBE.FinalModelValueType<EnumUInt32>
    {
        public FinalModelEnumUInt32(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(EnumUInt32 value) { return FBESize; }

        // Get the final size
        public override long FBESize => 4;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<EnumUInt32> Clone() { return new FinalModelEnumUInt32(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out EnumUInt32 value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = EnumUInt32.Default;
                return 0;
            }

            value = new EnumUInt32((uint)ReadUInt32(FBEOffset));
            return FBESize;
        }

        // Set the value
        public override long Set(EnumUInt32 value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums {

#if UTF8JSON
    public class EnumInt64Converter : IJsonFormatter<EnumInt64>
    {
        public void Serialize(ref JsonWriter writer, EnumInt64 value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteInt64(value.Value);
        }

        public EnumInt64 Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            return new EnumInt64(reader.ReadInt64());
        }
    }

    [JsonFormatter(typeof(EnumInt64Converter))]
#elif NEWTONSOFTJSON
    public class EnumInt64Converter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(EnumInt64);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((EnumInt64)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            switch (reader.Value)
            {
                case long longValue:
                    return new EnumInt64((long)longValue);
                case BigInteger bigValue:
                    return new EnumInt64((long)bigValue);
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(EnumInt64Converter))]
#else
    public class EnumInt64Converter : JsonConverter<EnumInt64>
    {
        public override void Write(Utf8JsonWriter writer, EnumInt64 value, JsonSerializerOptions options) => writer.WriteNumberValue(value.Value);
        public override EnumInt64 Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => new EnumInt64(reader.GetInt64());
    }

    [JsonConverter(typeof(EnumInt64Converter))]
#endif
    public struct EnumInt64 : IComparable, IComparable<EnumInt64>, IEquatable<EnumInt64>
    {
        public long Value { get; internal set; }

        public EnumInt64(long value) : this()
        {
            Value = value;
        }

        public EnumInt64(EnumInt64 value) : this()
        {
            Value = value.Value;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((EnumInt64)other).Value);
        }

        public int CompareTo(EnumInt64 other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is EnumInt64 value) && Value.Equals(value.Value);
        }

        public bool Equals(EnumInt64 other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(EnumInt64 value1, EnumInt64 value2)
        {
            return value1.Value == value2.Value;
        }

        public static bool operator!=(EnumInt64 value1, EnumInt64 value2)
        {
            return value1.Value != value2.Value;
        }

        public static EnumInt64 Default => new EnumInt64();

        public static com.chronoxor.FBE.FieldModelValueType<EnumInt64> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new enums.FBE.FieldModelEnumInt64(buffer, offset); }

        public const long _ENUM_VALUE_0_ = (long)0L + 0;
        public const long _ENUM_VALUE_1_ = (long)-9223372036854775807L + 0;
        public const long _ENUM_VALUE_2_ = (long)-9223372036854775807L + 1;
        public const long _ENUM_VALUE_3_ = (long)9223372036854775806L + 0;
        public const long _ENUM_VALUE_4_ = (long)9223372036854775806L + 1;
        public const long _ENUM_VALUE_5_ = _ENUM_VALUE_3_;

        public static EnumInt64 ENUM_VALUE_0 = new EnumInt64(_ENUM_VALUE_0_);
        public static EnumInt64 ENUM_VALUE_1 = new EnumInt64(_ENUM_VALUE_1_);
        public static EnumInt64 ENUM_VALUE_2 = new EnumInt64(_ENUM_VALUE_2_);
        public static EnumInt64 ENUM_VALUE_3 = new EnumInt64(_ENUM_VALUE_3_);
        public static EnumInt64 ENUM_VALUE_4 = new EnumInt64(_ENUM_VALUE_4_);
        public static EnumInt64 ENUM_VALUE_5 = new EnumInt64(_ENUM_VALUE_5_);

        public override string ToString()
        {
            if (this == ENUM_VALUE_0) return "ENUM_VALUE_0";
            if (this == ENUM_VALUE_1) return "ENUM_VALUE_1";
            if (this == ENUM_VALUE_2) return "ENUM_VALUE_2";
            if (this == ENUM_VALUE_3) return "ENUM_VALUE_3";
            if (this == ENUM_VALUE_4) return "ENUM_VALUE_4";
            if (this == ENUM_VALUE_5) return "ENUM_VALUE_5";
            return "<unknown>";
        }
    }

} // namespace com.chronoxor.enums

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding EnumInt64 field model
    public class FieldModelEnumInt64 : com.chronoxor.FBE.FieldModelValueType<EnumInt64>
    {
        public FieldModelEnumInt64(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 8;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<EnumInt64> Clone() { return new FieldModelEnumInt64(_buffer, _offset); }

        // Get the value
        public override void Get(out EnumInt64 value) { Get(out value, EnumInt64.Default); }
        public override void Get(out EnumInt64 value, EnumInt64 defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = new EnumInt64((long)ReadInt64(FBEOffset));
        }

        // Set the value
        public override void Set(EnumInt64 value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding EnumInt64 final model
    public class FinalModelEnumInt64 : com.chronoxor.FBE.FinalModelValueType<EnumInt64>
    {
        public FinalModelEnumInt64(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(EnumInt64 value) { return FBESize; }

        // Get the final size
        public override long FBESize => 8;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<EnumInt64> Clone() { return new FinalModelEnumInt64(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out EnumInt64 value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = EnumInt64.Default;
                return 0;
            }

            value = new EnumInt64((long)ReadInt64(FBEOffset));
            return FBESize;
        }

        // Set the value
        public override long Set(EnumInt64 value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums {

#if UTF8JSON
    public class EnumUInt64Converter : IJsonFormatter<EnumUInt64>
    {
        public void Serialize(ref JsonWriter writer, EnumUInt64 value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteUInt64(value.Value);
        }

        public EnumUInt64 Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            return new EnumUInt64(reader.ReadUInt64());
        }
    }

    [JsonFormatter(typeof(EnumUInt64Converter))]
#elif NEWTONSOFTJSON
    public class EnumUInt64Converter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(EnumUInt64);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((EnumUInt64)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            switch (reader.Value)
            {
                case long longValue:
                    return new EnumUInt64((ulong)longValue);
                case BigInteger bigValue:
                    return new EnumUInt64((ulong)bigValue);
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(EnumUInt64Converter))]
#else
    public class EnumUInt64Converter : JsonConverter<EnumUInt64>
    {
        public override void Write(Utf8JsonWriter writer, EnumUInt64 value, JsonSerializerOptions options) => writer.WriteNumberValue(value.Value);
        public override EnumUInt64 Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => new EnumUInt64(reader.GetUInt64());
    }

    [JsonConverter(typeof(EnumUInt64Converter))]
#endif
    public struct EnumUInt64 : IComparable, IComparable<EnumUInt64>, IEquatable<EnumUInt64>
    {
        public ulong Value { get; internal set; }

        public EnumUInt64(ulong value) : this()
        {
            Value = value;
        }

        public EnumUInt64(EnumUInt64 value) : this()
        {
            Value = value.Value;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((EnumUInt64)other).Value);
        }

        public int CompareTo(EnumUInt64 other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is EnumUInt64 value) && Value.Equals(value.Value);
        }

        public bool Equals(EnumUInt64 other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(EnumUInt64 value1, EnumUInt64 value2)
        {
            return value1.Value == value2.Value;
        }

        public static bool operator!=(EnumUInt64 value1, EnumUInt64 value2)
        {
            return value1.Value != value2.Value;
        }

        public static EnumUInt64 Default => new EnumUInt64();

        public static com.chronoxor.FBE.FieldModelValueType<EnumUInt64> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new enums.FBE.FieldModelEnumUInt64(buffer, offset); }

        public const ulong _ENUM_VALUE_0_ = (ulong)0UL + 0;
        public const ulong _ENUM_VALUE_1_ = (ulong)0UL + 0;
        public const ulong _ENUM_VALUE_2_ = (ulong)0UL + 1;
        public const ulong _ENUM_VALUE_3_ = (ulong)0xFFFFFFFFFFFFFFFEUL + 0;
        public const ulong _ENUM_VALUE_4_ = (ulong)0xFFFFFFFFFFFFFFFEUL + 1;
        public const ulong _ENUM_VALUE_5_ = _ENUM_VALUE_3_;

        public static EnumUInt64 ENUM_VALUE_0 = new EnumUInt64(_ENUM_VALUE_0_);
        public static EnumUInt64 ENUM_VALUE_1 = new EnumUInt64(_ENUM_VALUE_1_);
        public static EnumUInt64 ENUM_VALUE_2 = new EnumUInt64(_ENUM_VALUE_2_);
        public static EnumUInt64 ENUM_VALUE_3 = new EnumUInt64(_ENUM_VALUE_3_);
        public static EnumUInt64 ENUM_VALUE_4 = new EnumUInt64(_ENUM_VALUE_4_);
        public static EnumUInt64 ENUM_VALUE_5 = new EnumUInt64(_ENUM_VALUE_5_);

        public override string ToString()
        {
            if (this == ENUM_VALUE_0) return "ENUM_VALUE_0";
            if (this == ENUM_VALUE_1) return "ENUM_VALUE_1";
            if (this == ENUM_VALUE_2) return "ENUM_VALUE_2";
            if (this == ENUM_VALUE_3) return "ENUM_VALUE_3";
            if (this == ENUM_VALUE_4) return "ENUM_VALUE_4";
            if (this == ENUM_VALUE_5) return "ENUM_VALUE_5";
            return "<unknown>";
        }
    }

} // namespace com.chronoxor.enums

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding EnumUInt64 field model
    public class FieldModelEnumUInt64 : com.chronoxor.FBE.FieldModelValueType<EnumUInt64>
    {
        public FieldModelEnumUInt64(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 8;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<EnumUInt64> Clone() { return new FieldModelEnumUInt64(_buffer, _offset); }

        // Get the value
        public override void Get(out EnumUInt64 value) { Get(out value, EnumUInt64.Default); }
        public override void Get(out EnumUInt64 value, EnumUInt64 defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = new EnumUInt64((ulong)ReadUInt64(FBEOffset));
        }

        // Set the value
        public override void Set(EnumUInt64 value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding EnumUInt64 final model
    public class FinalModelEnumUInt64 : com.chronoxor.FBE.FinalModelValueType<EnumUInt64>
    {
        public FinalModelEnumUInt64(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(EnumUInt64 value) { return FBESize; }

        // Get the final size
        public override long FBESize => 8;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<EnumUInt64> Clone() { return new FinalModelEnumUInt64(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out EnumUInt64 value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = EnumUInt64.Default;
                return 0;
            }

            value = new EnumUInt64((ulong)ReadUInt64(FBEOffset));
            return FBESize;
        }

        // Set the value
        public override long Set(EnumUInt64 value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums {

    public struct Enums : IComparable, IComparable<Enums>, IEquatable<Enums>
    {
        public EnumByte byte0;
        public EnumByte byte1;
        public EnumByte byte2;
        public EnumByte byte3;
        public EnumByte byte4;
        public EnumByte byte5;
        public EnumChar char0;
        public EnumChar char1;
        public EnumChar char2;
        public EnumChar char3;
        public EnumChar char4;
        public EnumChar char5;
        public EnumWChar wchar0;
        public EnumWChar wchar1;
        public EnumWChar wchar2;
        public EnumWChar wchar3;
        public EnumWChar wchar4;
        public EnumWChar wchar5;
        public EnumInt8 int8b0;
        public EnumInt8 int8b1;
        public EnumInt8 int8b2;
        public EnumInt8 int8b3;
        public EnumInt8 int8b4;
        public EnumInt8 int8b5;
        public EnumUInt8 uint8b0;
        public EnumUInt8 uint8b1;
        public EnumUInt8 uint8b2;
        public EnumUInt8 uint8b3;
        public EnumUInt8 uint8b4;
        public EnumUInt8 uint8b5;
        public EnumInt16 int16b0;
        public EnumInt16 int16b1;
        public EnumInt16 int16b2;
        public EnumInt16 int16b3;
        public EnumInt16 int16b4;
        public EnumInt16 int16b5;
        public EnumUInt16 uint16b0;
        public EnumUInt16 uint16b1;
        public EnumUInt16 uint16b2;
        public EnumUInt16 uint16b3;
        public EnumUInt16 uint16b4;
        public EnumUInt16 uint16b5;
        public EnumInt32 int32b0;
        public EnumInt32 int32b1;
        public EnumInt32 int32b2;
        public EnumInt32 int32b3;
        public EnumInt32 int32b4;
        public EnumInt32 int32b5;
        public EnumUInt32 uint32b0;
        public EnumUInt32 uint32b1;
        public EnumUInt32 uint32b2;
        public EnumUInt32 uint32b3;
        public EnumUInt32 uint32b4;
        public EnumUInt32 uint32b5;
        public EnumInt64 int64b0;
        public EnumInt64 int64b1;
        public EnumInt64 int64b2;
        public EnumInt64 int64b3;
        public EnumInt64 int64b4;
        public EnumInt64 int64b5;
        public EnumUInt64 uint64b0;
        public EnumUInt64 uint64b1;
        public EnumUInt64 uint64b2;
        public EnumUInt64 uint64b3;
        public EnumUInt64 uint64b4;
        public EnumUInt64 uint64b5;

        public const long FBETypeConst = 1;
        #if UTF8JSON
        [IgnoreDataMember]
        #else
        [JsonIgnore]
        #endif
        public long FBEType => FBETypeConst;

        public static Enums Default => new Enums
        {
            byte0 = global::com.chronoxor.enums.EnumByte.ENUM_VALUE_0
            , byte1 = global::com.chronoxor.enums.EnumByte.ENUM_VALUE_1
            , byte2 = global::com.chronoxor.enums.EnumByte.ENUM_VALUE_2
            , byte3 = global::com.chronoxor.enums.EnumByte.ENUM_VALUE_3
            , byte4 = global::com.chronoxor.enums.EnumByte.ENUM_VALUE_4
            , byte5 = global::com.chronoxor.enums.EnumByte.ENUM_VALUE_5
            , char0 = global::com.chronoxor.enums.EnumChar.ENUM_VALUE_0
            , char1 = global::com.chronoxor.enums.EnumChar.ENUM_VALUE_1
            , char2 = global::com.chronoxor.enums.EnumChar.ENUM_VALUE_2
            , char3 = global::com.chronoxor.enums.EnumChar.ENUM_VALUE_3
            , char4 = global::com.chronoxor.enums.EnumChar.ENUM_VALUE_4
            , char5 = global::com.chronoxor.enums.EnumChar.ENUM_VALUE_5
            , wchar0 = global::com.chronoxor.enums.EnumWChar.ENUM_VALUE_0
            , wchar1 = global::com.chronoxor.enums.EnumWChar.ENUM_VALUE_1
            , wchar2 = global::com.chronoxor.enums.EnumWChar.ENUM_VALUE_2
            , wchar3 = global::com.chronoxor.enums.EnumWChar.ENUM_VALUE_3
            , wchar4 = global::com.chronoxor.enums.EnumWChar.ENUM_VALUE_4
            , wchar5 = global::com.chronoxor.enums.EnumWChar.ENUM_VALUE_5
            , int8b0 = global::com.chronoxor.enums.EnumInt8.ENUM_VALUE_0
            , int8b1 = global::com.chronoxor.enums.EnumInt8.ENUM_VALUE_1
            , int8b2 = global::com.chronoxor.enums.EnumInt8.ENUM_VALUE_2
            , int8b3 = global::com.chronoxor.enums.EnumInt8.ENUM_VALUE_3
            , int8b4 = global::com.chronoxor.enums.EnumInt8.ENUM_VALUE_4
            , int8b5 = global::com.chronoxor.enums.EnumInt8.ENUM_VALUE_5
            , uint8b0 = global::com.chronoxor.enums.EnumUInt8.ENUM_VALUE_0
            , uint8b1 = global::com.chronoxor.enums.EnumUInt8.ENUM_VALUE_1
            , uint8b2 = global::com.chronoxor.enums.EnumUInt8.ENUM_VALUE_2
            , uint8b3 = global::com.chronoxor.enums.EnumUInt8.ENUM_VALUE_3
            , uint8b4 = global::com.chronoxor.enums.EnumUInt8.ENUM_VALUE_4
            , uint8b5 = global::com.chronoxor.enums.EnumUInt8.ENUM_VALUE_5
            , int16b0 = global::com.chronoxor.enums.EnumInt16.ENUM_VALUE_0
            , int16b1 = global::com.chronoxor.enums.EnumInt16.ENUM_VALUE_1
            , int16b2 = global::com.chronoxor.enums.EnumInt16.ENUM_VALUE_2
            , int16b3 = global::com.chronoxor.enums.EnumInt16.ENUM_VALUE_3
            , int16b4 = global::com.chronoxor.enums.EnumInt16.ENUM_VALUE_4
            , int16b5 = global::com.chronoxor.enums.EnumInt16.ENUM_VALUE_5
            , uint16b0 = global::com.chronoxor.enums.EnumUInt16.ENUM_VALUE_0
            , uint16b1 = global::com.chronoxor.enums.EnumUInt16.ENUM_VALUE_1
            , uint16b2 = global::com.chronoxor.enums.EnumUInt16.ENUM_VALUE_2
            , uint16b3 = global::com.chronoxor.enums.EnumUInt16.ENUM_VALUE_3
            , uint16b4 = global::com.chronoxor.enums.EnumUInt16.ENUM_VALUE_4
            , uint16b5 = global::com.chronoxor.enums.EnumUInt16.ENUM_VALUE_5
            , int32b0 = global::com.chronoxor.enums.EnumInt32.ENUM_VALUE_0
            , int32b1 = global::com.chronoxor.enums.EnumInt32.ENUM_VALUE_1
            , int32b2 = global::com.chronoxor.enums.EnumInt32.ENUM_VALUE_2
            , int32b3 = global::com.chronoxor.enums.EnumInt32.ENUM_VALUE_3
            , int32b4 = global::com.chronoxor.enums.EnumInt32.ENUM_VALUE_4
            , int32b5 = global::com.chronoxor.enums.EnumInt32.ENUM_VALUE_5
            , uint32b0 = global::com.chronoxor.enums.EnumUInt32.ENUM_VALUE_0
            , uint32b1 = global::com.chronoxor.enums.EnumUInt32.ENUM_VALUE_1
            , uint32b2 = global::com.chronoxor.enums.EnumUInt32.ENUM_VALUE_2
            , uint32b3 = global::com.chronoxor.enums.EnumUInt32.ENUM_VALUE_3
            , uint32b4 = global::com.chronoxor.enums.EnumUInt32.ENUM_VALUE_4
            , uint32b5 = global::com.chronoxor.enums.EnumUInt32.ENUM_VALUE_5
            , int64b0 = global::com.chronoxor.enums.EnumInt64.ENUM_VALUE_0
            , int64b1 = global::com.chronoxor.enums.EnumInt64.ENUM_VALUE_1
            , int64b2 = global::com.chronoxor.enums.EnumInt64.ENUM_VALUE_2
            , int64b3 = global::com.chronoxor.enums.EnumInt64.ENUM_VALUE_3
            , int64b4 = global::com.chronoxor.enums.EnumInt64.ENUM_VALUE_4
            , int64b5 = global::com.chronoxor.enums.EnumInt64.ENUM_VALUE_5
            , uint64b0 = global::com.chronoxor.enums.EnumUInt64.ENUM_VALUE_0
            , uint64b1 = global::com.chronoxor.enums.EnumUInt64.ENUM_VALUE_1
            , uint64b2 = global::com.chronoxor.enums.EnumUInt64.ENUM_VALUE_2
            , uint64b3 = global::com.chronoxor.enums.EnumUInt64.ENUM_VALUE_3
            , uint64b4 = global::com.chronoxor.enums.EnumUInt64.ENUM_VALUE_4
            , uint64b5 = global::com.chronoxor.enums.EnumUInt64.ENUM_VALUE_5
        };

        public Enums(EnumByte byte0, EnumByte byte1, EnumByte byte2, EnumByte byte3, EnumByte byte4, EnumByte byte5, EnumChar char0, EnumChar char1, EnumChar char2, EnumChar char3, EnumChar char4, EnumChar char5, EnumWChar wchar0, EnumWChar wchar1, EnumWChar wchar2, EnumWChar wchar3, EnumWChar wchar4, EnumWChar wchar5, EnumInt8 int8b0, EnumInt8 int8b1, EnumInt8 int8b2, EnumInt8 int8b3, EnumInt8 int8b4, EnumInt8 int8b5, EnumUInt8 uint8b0, EnumUInt8 uint8b1, EnumUInt8 uint8b2, EnumUInt8 uint8b3, EnumUInt8 uint8b4, EnumUInt8 uint8b5, EnumInt16 int16b0, EnumInt16 int16b1, EnumInt16 int16b2, EnumInt16 int16b3, EnumInt16 int16b4, EnumInt16 int16b5, EnumUInt16 uint16b0, EnumUInt16 uint16b1, EnumUInt16 uint16b2, EnumUInt16 uint16b3, EnumUInt16 uint16b4, EnumUInt16 uint16b5, EnumInt32 int32b0, EnumInt32 int32b1, EnumInt32 int32b2, EnumInt32 int32b3, EnumInt32 int32b4, EnumInt32 int32b5, EnumUInt32 uint32b0, EnumUInt32 uint32b1, EnumUInt32 uint32b2, EnumUInt32 uint32b3, EnumUInt32 uint32b4, EnumUInt32 uint32b5, EnumInt64 int64b0, EnumInt64 int64b1, EnumInt64 int64b2, EnumInt64 int64b3, EnumInt64 int64b4, EnumInt64 int64b5, EnumUInt64 uint64b0, EnumUInt64 uint64b1, EnumUInt64 uint64b2, EnumUInt64 uint64b3, EnumUInt64 uint64b4, EnumUInt64 uint64b5)
        {
            this.byte0 = byte0;
            this.byte1 = byte1;
            this.byte2 = byte2;
            this.byte3 = byte3;
            this.byte4 = byte4;
            this.byte5 = byte5;
            this.char0 = char0;
            this.char1 = char1;
            this.char2 = char2;
            this.char3 = char3;
            this.char4 = char4;
            this.char5 = char5;
            this.wchar0 = wchar0;
            this.wchar1 = wchar1;
            this.wchar2 = wchar2;
            this.wchar3 = wchar3;
            this.wchar4 = wchar4;
            this.wchar5 = wchar5;
            this.int8b0 = int8b0;
            this.int8b1 = int8b1;
            this.int8b2 = int8b2;
            this.int8b3 = int8b3;
            this.int8b4 = int8b4;
            this.int8b5 = int8b5;
            this.uint8b0 = uint8b0;
            this.uint8b1 = uint8b1;
            this.uint8b2 = uint8b2;
            this.uint8b3 = uint8b3;
            this.uint8b4 = uint8b4;
            this.uint8b5 = uint8b5;
            this.int16b0 = int16b0;
            this.int16b1 = int16b1;
            this.int16b2 = int16b2;
            this.int16b3 = int16b3;
            this.int16b4 = int16b4;
            this.int16b5 = int16b5;
            this.uint16b0 = uint16b0;
            this.uint16b1 = uint16b1;
            this.uint16b2 = uint16b2;
            this.uint16b3 = uint16b3;
            this.uint16b4 = uint16b4;
            this.uint16b5 = uint16b5;
            this.int32b0 = int32b0;
            this.int32b1 = int32b1;
            this.int32b2 = int32b2;
            this.int32b3 = int32b3;
            this.int32b4 = int32b4;
            this.int32b5 = int32b5;
            this.uint32b0 = uint32b0;
            this.uint32b1 = uint32b1;
            this.uint32b2 = uint32b2;
            this.uint32b3 = uint32b3;
            this.uint32b4 = uint32b4;
            this.uint32b5 = uint32b5;
            this.int64b0 = int64b0;
            this.int64b1 = int64b1;
            this.int64b2 = int64b2;
            this.int64b3 = int64b3;
            this.int64b4 = int64b4;
            this.int64b5 = int64b5;
            this.uint64b0 = uint64b0;
            this.uint64b1 = uint64b1;
            this.uint64b2 = uint64b2;
            this.uint64b3 = uint64b3;
            this.uint64b4 = uint64b4;
            this.uint64b5 = uint64b5;
        }

        public Enums Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.chronoxor.enums.FBE.EnumsModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.chronoxor.enums.FBE.EnumsModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            return result;
        }

        public int CompareTo(Enums other)
        {
            int result = 0;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is Enums))
                return false;
            return true;
        }

        public bool Equals(Enums other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            return hash;
        }

        public static bool operator==(Enums lhs, Enums rhs) => lhs.Equals(rhs);
        public static bool operator!=(Enums lhs, Enums rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("Enums(");
            sb.Append("byte0="); sb.Append(byte0);
            sb.Append(",byte1="); sb.Append(byte1);
            sb.Append(",byte2="); sb.Append(byte2);
            sb.Append(",byte3="); sb.Append(byte3);
            sb.Append(",byte4="); sb.Append(byte4);
            sb.Append(",byte5="); sb.Append(byte5);
            sb.Append(",char0="); sb.Append(char0);
            sb.Append(",char1="); sb.Append(char1);
            sb.Append(",char2="); sb.Append(char2);
            sb.Append(",char3="); sb.Append(char3);
            sb.Append(",char4="); sb.Append(char4);
            sb.Append(",char5="); sb.Append(char5);
            sb.Append(",wchar0="); sb.Append(wchar0);
            sb.Append(",wchar1="); sb.Append(wchar1);
            sb.Append(",wchar2="); sb.Append(wchar2);
            sb.Append(",wchar3="); sb.Append(wchar3);
            sb.Append(",wchar4="); sb.Append(wchar4);
            sb.Append(",wchar5="); sb.Append(wchar5);
            sb.Append(",int8b0="); sb.Append(int8b0);
            sb.Append(",int8b1="); sb.Append(int8b1);
            sb.Append(",int8b2="); sb.Append(int8b2);
            sb.Append(",int8b3="); sb.Append(int8b3);
            sb.Append(",int8b4="); sb.Append(int8b4);
            sb.Append(",int8b5="); sb.Append(int8b5);
            sb.Append(",uint8b0="); sb.Append(uint8b0);
            sb.Append(",uint8b1="); sb.Append(uint8b1);
            sb.Append(",uint8b2="); sb.Append(uint8b2);
            sb.Append(",uint8b3="); sb.Append(uint8b3);
            sb.Append(",uint8b4="); sb.Append(uint8b4);
            sb.Append(",uint8b5="); sb.Append(uint8b5);
            sb.Append(",int16b0="); sb.Append(int16b0);
            sb.Append(",int16b1="); sb.Append(int16b1);
            sb.Append(",int16b2="); sb.Append(int16b2);
            sb.Append(",int16b3="); sb.Append(int16b3);
            sb.Append(",int16b4="); sb.Append(int16b4);
            sb.Append(",int16b5="); sb.Append(int16b5);
            sb.Append(",uint16b0="); sb.Append(uint16b0);
            sb.Append(",uint16b1="); sb.Append(uint16b1);
            sb.Append(",uint16b2="); sb.Append(uint16b2);
            sb.Append(",uint16b3="); sb.Append(uint16b3);
            sb.Append(",uint16b4="); sb.Append(uint16b4);
            sb.Append(",uint16b5="); sb.Append(uint16b5);
            sb.Append(",int32b0="); sb.Append(int32b0);
            sb.Append(",int32b1="); sb.Append(int32b1);
            sb.Append(",int32b2="); sb.Append(int32b2);
            sb.Append(",int32b3="); sb.Append(int32b3);
            sb.Append(",int32b4="); sb.Append(int32b4);
            sb.Append(",int32b5="); sb.Append(int32b5);
            sb.Append(",uint32b0="); sb.Append(uint32b0);
            sb.Append(",uint32b1="); sb.Append(uint32b1);
            sb.Append(",uint32b2="); sb.Append(uint32b2);
            sb.Append(",uint32b3="); sb.Append(uint32b3);
            sb.Append(",uint32b4="); sb.Append(uint32b4);
            sb.Append(",uint32b5="); sb.Append(uint32b5);
            sb.Append(",int64b0="); sb.Append(int64b0);
            sb.Append(",int64b1="); sb.Append(int64b1);
            sb.Append(",int64b2="); sb.Append(int64b2);
            sb.Append(",int64b3="); sb.Append(int64b3);
            sb.Append(",int64b4="); sb.Append(int64b4);
            sb.Append(",int64b5="); sb.Append(int64b5);
            sb.Append(",uint64b0="); sb.Append(uint64b0);
            sb.Append(",uint64b1="); sb.Append(uint64b1);
            sb.Append(",uint64b2="); sb.Append(uint64b2);
            sb.Append(",uint64b3="); sb.Append(uint64b3);
            sb.Append(",uint64b4="); sb.Append(uint64b4);
            sb.Append(",uint64b5="); sb.Append(uint64b5);
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson()
        {
            var json = com.chronoxor.FBE.Json.ToJson(this);
            return json;
        }

        public static Enums FromJson(string json)
        {
            var result = com.chronoxor.FBE.Json.FromJson<Enums>(json);
            return result;
        }

        public static com.chronoxor.FBE.FieldModelValueType<Enums> CreateFieldModel(com.chronoxor.FBE.Buffer buffer, long offset) { return new enums.FBE.FieldModelEnums(buffer, offset); }
    }

} // namespace com.chronoxor.enums

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding Enums field model
    public class FieldModelEnums : com.chronoxor.FBE.FieldModelValueType<Enums>
    {
        public readonly com.chronoxor.enums.FBE.FieldModelEnumByte byte0;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumByte byte1;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumByte byte2;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumByte byte3;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumByte byte4;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumByte byte5;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumChar char0;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumChar char1;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumChar char2;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumChar char3;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumChar char4;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumChar char5;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumWChar wchar0;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumWChar wchar1;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumWChar wchar2;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumWChar wchar3;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumWChar wchar4;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumWChar wchar5;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt8 int8b0;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt8 int8b1;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt8 int8b2;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt8 int8b3;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt8 int8b4;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt8 int8b5;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt8 uint8b0;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt8 uint8b1;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt8 uint8b2;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt8 uint8b3;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt8 uint8b4;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt8 uint8b5;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt16 int16b0;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt16 int16b1;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt16 int16b2;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt16 int16b3;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt16 int16b4;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt16 int16b5;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt16 uint16b0;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt16 uint16b1;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt16 uint16b2;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt16 uint16b3;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt16 uint16b4;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt16 uint16b5;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt32 int32b0;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt32 int32b1;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt32 int32b2;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt32 int32b3;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt32 int32b4;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt32 int32b5;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt32 uint32b0;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt32 uint32b1;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt32 uint32b2;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt32 uint32b3;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt32 uint32b4;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt32 uint32b5;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt64 int64b0;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt64 int64b1;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt64 int64b2;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt64 int64b3;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt64 int64b4;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumInt64 int64b5;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt64 uint64b0;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt64 uint64b1;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt64 uint64b2;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt64 uint64b3;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt64 uint64b4;
        public readonly com.chronoxor.enums.FBE.FieldModelEnumUInt64 uint64b5;

        public FieldModelEnums(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            byte0 = new com.chronoxor.enums.FBE.FieldModelEnumByte(buffer, 4 + 4);
            byte1 = new com.chronoxor.enums.FBE.FieldModelEnumByte(buffer, byte0.FBEOffset + byte0.FBESize);
            byte2 = new com.chronoxor.enums.FBE.FieldModelEnumByte(buffer, byte1.FBEOffset + byte1.FBESize);
            byte3 = new com.chronoxor.enums.FBE.FieldModelEnumByte(buffer, byte2.FBEOffset + byte2.FBESize);
            byte4 = new com.chronoxor.enums.FBE.FieldModelEnumByte(buffer, byte3.FBEOffset + byte3.FBESize);
            byte5 = new com.chronoxor.enums.FBE.FieldModelEnumByte(buffer, byte4.FBEOffset + byte4.FBESize);
            char0 = new com.chronoxor.enums.FBE.FieldModelEnumChar(buffer, byte5.FBEOffset + byte5.FBESize);
            char1 = new com.chronoxor.enums.FBE.FieldModelEnumChar(buffer, char0.FBEOffset + char0.FBESize);
            char2 = new com.chronoxor.enums.FBE.FieldModelEnumChar(buffer, char1.FBEOffset + char1.FBESize);
            char3 = new com.chronoxor.enums.FBE.FieldModelEnumChar(buffer, char2.FBEOffset + char2.FBESize);
            char4 = new com.chronoxor.enums.FBE.FieldModelEnumChar(buffer, char3.FBEOffset + char3.FBESize);
            char5 = new com.chronoxor.enums.FBE.FieldModelEnumChar(buffer, char4.FBEOffset + char4.FBESize);
            wchar0 = new com.chronoxor.enums.FBE.FieldModelEnumWChar(buffer, char5.FBEOffset + char5.FBESize);
            wchar1 = new com.chronoxor.enums.FBE.FieldModelEnumWChar(buffer, wchar0.FBEOffset + wchar0.FBESize);
            wchar2 = new com.chronoxor.enums.FBE.FieldModelEnumWChar(buffer, wchar1.FBEOffset + wchar1.FBESize);
            wchar3 = new com.chronoxor.enums.FBE.FieldModelEnumWChar(buffer, wchar2.FBEOffset + wchar2.FBESize);
            wchar4 = new com.chronoxor.enums.FBE.FieldModelEnumWChar(buffer, wchar3.FBEOffset + wchar3.FBESize);
            wchar5 = new com.chronoxor.enums.FBE.FieldModelEnumWChar(buffer, wchar4.FBEOffset + wchar4.FBESize);
            int8b0 = new com.chronoxor.enums.FBE.FieldModelEnumInt8(buffer, wchar5.FBEOffset + wchar5.FBESize);
            int8b1 = new com.chronoxor.enums.FBE.FieldModelEnumInt8(buffer, int8b0.FBEOffset + int8b0.FBESize);
            int8b2 = new com.chronoxor.enums.FBE.FieldModelEnumInt8(buffer, int8b1.FBEOffset + int8b1.FBESize);
            int8b3 = new com.chronoxor.enums.FBE.FieldModelEnumInt8(buffer, int8b2.FBEOffset + int8b2.FBESize);
            int8b4 = new com.chronoxor.enums.FBE.FieldModelEnumInt8(buffer, int8b3.FBEOffset + int8b3.FBESize);
            int8b5 = new com.chronoxor.enums.FBE.FieldModelEnumInt8(buffer, int8b4.FBEOffset + int8b4.FBESize);
            uint8b0 = new com.chronoxor.enums.FBE.FieldModelEnumUInt8(buffer, int8b5.FBEOffset + int8b5.FBESize);
            uint8b1 = new com.chronoxor.enums.FBE.FieldModelEnumUInt8(buffer, uint8b0.FBEOffset + uint8b0.FBESize);
            uint8b2 = new com.chronoxor.enums.FBE.FieldModelEnumUInt8(buffer, uint8b1.FBEOffset + uint8b1.FBESize);
            uint8b3 = new com.chronoxor.enums.FBE.FieldModelEnumUInt8(buffer, uint8b2.FBEOffset + uint8b2.FBESize);
            uint8b4 = new com.chronoxor.enums.FBE.FieldModelEnumUInt8(buffer, uint8b3.FBEOffset + uint8b3.FBESize);
            uint8b5 = new com.chronoxor.enums.FBE.FieldModelEnumUInt8(buffer, uint8b4.FBEOffset + uint8b4.FBESize);
            int16b0 = new com.chronoxor.enums.FBE.FieldModelEnumInt16(buffer, uint8b5.FBEOffset + uint8b5.FBESize);
            int16b1 = new com.chronoxor.enums.FBE.FieldModelEnumInt16(buffer, int16b0.FBEOffset + int16b0.FBESize);
            int16b2 = new com.chronoxor.enums.FBE.FieldModelEnumInt16(buffer, int16b1.FBEOffset + int16b1.FBESize);
            int16b3 = new com.chronoxor.enums.FBE.FieldModelEnumInt16(buffer, int16b2.FBEOffset + int16b2.FBESize);
            int16b4 = new com.chronoxor.enums.FBE.FieldModelEnumInt16(buffer, int16b3.FBEOffset + int16b3.FBESize);
            int16b5 = new com.chronoxor.enums.FBE.FieldModelEnumInt16(buffer, int16b4.FBEOffset + int16b4.FBESize);
            uint16b0 = new com.chronoxor.enums.FBE.FieldModelEnumUInt16(buffer, int16b5.FBEOffset + int16b5.FBESize);
            uint16b1 = new com.chronoxor.enums.FBE.FieldModelEnumUInt16(buffer, uint16b0.FBEOffset + uint16b0.FBESize);
            uint16b2 = new com.chronoxor.enums.FBE.FieldModelEnumUInt16(buffer, uint16b1.FBEOffset + uint16b1.FBESize);
            uint16b3 = new com.chronoxor.enums.FBE.FieldModelEnumUInt16(buffer, uint16b2.FBEOffset + uint16b2.FBESize);
            uint16b4 = new com.chronoxor.enums.FBE.FieldModelEnumUInt16(buffer, uint16b3.FBEOffset + uint16b3.FBESize);
            uint16b5 = new com.chronoxor.enums.FBE.FieldModelEnumUInt16(buffer, uint16b4.FBEOffset + uint16b4.FBESize);
            int32b0 = new com.chronoxor.enums.FBE.FieldModelEnumInt32(buffer, uint16b5.FBEOffset + uint16b5.FBESize);
            int32b1 = new com.chronoxor.enums.FBE.FieldModelEnumInt32(buffer, int32b0.FBEOffset + int32b0.FBESize);
            int32b2 = new com.chronoxor.enums.FBE.FieldModelEnumInt32(buffer, int32b1.FBEOffset + int32b1.FBESize);
            int32b3 = new com.chronoxor.enums.FBE.FieldModelEnumInt32(buffer, int32b2.FBEOffset + int32b2.FBESize);
            int32b4 = new com.chronoxor.enums.FBE.FieldModelEnumInt32(buffer, int32b3.FBEOffset + int32b3.FBESize);
            int32b5 = new com.chronoxor.enums.FBE.FieldModelEnumInt32(buffer, int32b4.FBEOffset + int32b4.FBESize);
            uint32b0 = new com.chronoxor.enums.FBE.FieldModelEnumUInt32(buffer, int32b5.FBEOffset + int32b5.FBESize);
            uint32b1 = new com.chronoxor.enums.FBE.FieldModelEnumUInt32(buffer, uint32b0.FBEOffset + uint32b0.FBESize);
            uint32b2 = new com.chronoxor.enums.FBE.FieldModelEnumUInt32(buffer, uint32b1.FBEOffset + uint32b1.FBESize);
            uint32b3 = new com.chronoxor.enums.FBE.FieldModelEnumUInt32(buffer, uint32b2.FBEOffset + uint32b2.FBESize);
            uint32b4 = new com.chronoxor.enums.FBE.FieldModelEnumUInt32(buffer, uint32b3.FBEOffset + uint32b3.FBESize);
            uint32b5 = new com.chronoxor.enums.FBE.FieldModelEnumUInt32(buffer, uint32b4.FBEOffset + uint32b4.FBESize);
            int64b0 = new com.chronoxor.enums.FBE.FieldModelEnumInt64(buffer, uint32b5.FBEOffset + uint32b5.FBESize);
            int64b1 = new com.chronoxor.enums.FBE.FieldModelEnumInt64(buffer, int64b0.FBEOffset + int64b0.FBESize);
            int64b2 = new com.chronoxor.enums.FBE.FieldModelEnumInt64(buffer, int64b1.FBEOffset + int64b1.FBESize);
            int64b3 = new com.chronoxor.enums.FBE.FieldModelEnumInt64(buffer, int64b2.FBEOffset + int64b2.FBESize);
            int64b4 = new com.chronoxor.enums.FBE.FieldModelEnumInt64(buffer, int64b3.FBEOffset + int64b3.FBESize);
            int64b5 = new com.chronoxor.enums.FBE.FieldModelEnumInt64(buffer, int64b4.FBEOffset + int64b4.FBESize);
            uint64b0 = new com.chronoxor.enums.FBE.FieldModelEnumUInt64(buffer, int64b5.FBEOffset + int64b5.FBESize);
            uint64b1 = new com.chronoxor.enums.FBE.FieldModelEnumUInt64(buffer, uint64b0.FBEOffset + uint64b0.FBESize);
            uint64b2 = new com.chronoxor.enums.FBE.FieldModelEnumUInt64(buffer, uint64b1.FBEOffset + uint64b1.FBESize);
            uint64b3 = new com.chronoxor.enums.FBE.FieldModelEnumUInt64(buffer, uint64b2.FBEOffset + uint64b2.FBESize);
            uint64b4 = new com.chronoxor.enums.FBE.FieldModelEnumUInt64(buffer, uint64b3.FBEOffset + uint64b3.FBESize);
            uint64b5 = new com.chronoxor.enums.FBE.FieldModelEnumUInt64(buffer, uint64b4.FBEOffset + uint64b4.FBESize);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + byte0.FBESize
                    + byte1.FBESize
                    + byte2.FBESize
                    + byte3.FBESize
                    + byte4.FBESize
                    + byte5.FBESize
                    + char0.FBESize
                    + char1.FBESize
                    + char2.FBESize
                    + char3.FBESize
                    + char4.FBESize
                    + char5.FBESize
                    + wchar0.FBESize
                    + wchar1.FBESize
                    + wchar2.FBESize
                    + wchar3.FBESize
                    + wchar4.FBESize
                    + wchar5.FBESize
                    + int8b0.FBESize
                    + int8b1.FBESize
                    + int8b2.FBESize
                    + int8b3.FBESize
                    + int8b4.FBESize
                    + int8b5.FBESize
                    + uint8b0.FBESize
                    + uint8b1.FBESize
                    + uint8b2.FBESize
                    + uint8b3.FBESize
                    + uint8b4.FBESize
                    + uint8b5.FBESize
                    + int16b0.FBESize
                    + int16b1.FBESize
                    + int16b2.FBESize
                    + int16b3.FBESize
                    + int16b4.FBESize
                    + int16b5.FBESize
                    + uint16b0.FBESize
                    + uint16b1.FBESize
                    + uint16b2.FBESize
                    + uint16b3.FBESize
                    + uint16b4.FBESize
                    + uint16b5.FBESize
                    + int32b0.FBESize
                    + int32b1.FBESize
                    + int32b2.FBESize
                    + int32b3.FBESize
                    + int32b4.FBESize
                    + int32b5.FBESize
                    + uint32b0.FBESize
                    + uint32b1.FBESize
                    + uint32b2.FBESize
                    + uint32b3.FBESize
                    + uint32b4.FBESize
                    + uint32b5.FBESize
                    + int64b0.FBESize
                    + int64b1.FBESize
                    + int64b2.FBESize
                    + int64b3.FBESize
                    + int64b4.FBESize
                    + int64b5.FBESize
                    + uint64b0.FBESize
                    + uint64b1.FBESize
                    + uint64b2.FBESize
                    + uint64b3.FBESize
                    + uint64b4.FBESize
                    + uint64b5.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + byte0.FBEExtra
                    + byte1.FBEExtra
                    + byte2.FBEExtra
                    + byte3.FBEExtra
                    + byte4.FBEExtra
                    + byte5.FBEExtra
                    + char0.FBEExtra
                    + char1.FBEExtra
                    + char2.FBEExtra
                    + char3.FBEExtra
                    + char4.FBEExtra
                    + char5.FBEExtra
                    + wchar0.FBEExtra
                    + wchar1.FBEExtra
                    + wchar2.FBEExtra
                    + wchar3.FBEExtra
                    + wchar4.FBEExtra
                    + wchar5.FBEExtra
                    + int8b0.FBEExtra
                    + int8b1.FBEExtra
                    + int8b2.FBEExtra
                    + int8b3.FBEExtra
                    + int8b4.FBEExtra
                    + int8b5.FBEExtra
                    + uint8b0.FBEExtra
                    + uint8b1.FBEExtra
                    + uint8b2.FBEExtra
                    + uint8b3.FBEExtra
                    + uint8b4.FBEExtra
                    + uint8b5.FBEExtra
                    + int16b0.FBEExtra
                    + int16b1.FBEExtra
                    + int16b2.FBEExtra
                    + int16b3.FBEExtra
                    + int16b4.FBEExtra
                    + int16b5.FBEExtra
                    + uint16b0.FBEExtra
                    + uint16b1.FBEExtra
                    + uint16b2.FBEExtra
                    + uint16b3.FBEExtra
                    + uint16b4.FBEExtra
                    + uint16b5.FBEExtra
                    + int32b0.FBEExtra
                    + int32b1.FBEExtra
                    + int32b2.FBEExtra
                    + int32b3.FBEExtra
                    + int32b4.FBEExtra
                    + int32b5.FBEExtra
                    + uint32b0.FBEExtra
                    + uint32b1.FBEExtra
                    + uint32b2.FBEExtra
                    + uint32b3.FBEExtra
                    + uint32b4.FBEExtra
                    + uint32b5.FBEExtra
                    + int64b0.FBEExtra
                    + int64b1.FBEExtra
                    + int64b2.FBEExtra
                    + int64b3.FBEExtra
                    + int64b4.FBEExtra
                    + int64b5.FBEExtra
                    + uint64b0.FBEExtra
                    + uint64b1.FBEExtra
                    + uint64b2.FBEExtra
                    + uint64b3.FBEExtra
                    + uint64b4.FBEExtra
                    + uint64b5.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 1;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.chronoxor.FBE.FieldModelValueType<Enums> Clone() { return new FieldModelEnums(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + byte0.FBESize) > fbeStructSize)
                return true;
            if (!byte0.Verify())
                return false;
            fbeCurrentSize += byte0.FBESize;

            if ((fbeCurrentSize + byte1.FBESize) > fbeStructSize)
                return true;
            if (!byte1.Verify())
                return false;
            fbeCurrentSize += byte1.FBESize;

            if ((fbeCurrentSize + byte2.FBESize) > fbeStructSize)
                return true;
            if (!byte2.Verify())
                return false;
            fbeCurrentSize += byte2.FBESize;

            if ((fbeCurrentSize + byte3.FBESize) > fbeStructSize)
                return true;
            if (!byte3.Verify())
                return false;
            fbeCurrentSize += byte3.FBESize;

            if ((fbeCurrentSize + byte4.FBESize) > fbeStructSize)
                return true;
            if (!byte4.Verify())
                return false;
            fbeCurrentSize += byte4.FBESize;

            if ((fbeCurrentSize + byte5.FBESize) > fbeStructSize)
                return true;
            if (!byte5.Verify())
                return false;
            fbeCurrentSize += byte5.FBESize;

            if ((fbeCurrentSize + char0.FBESize) > fbeStructSize)
                return true;
            if (!char0.Verify())
                return false;
            fbeCurrentSize += char0.FBESize;

            if ((fbeCurrentSize + char1.FBESize) > fbeStructSize)
                return true;
            if (!char1.Verify())
                return false;
            fbeCurrentSize += char1.FBESize;

            if ((fbeCurrentSize + char2.FBESize) > fbeStructSize)
                return true;
            if (!char2.Verify())
                return false;
            fbeCurrentSize += char2.FBESize;

            if ((fbeCurrentSize + char3.FBESize) > fbeStructSize)
                return true;
            if (!char3.Verify())
                return false;
            fbeCurrentSize += char3.FBESize;

            if ((fbeCurrentSize + char4.FBESize) > fbeStructSize)
                return true;
            if (!char4.Verify())
                return false;
            fbeCurrentSize += char4.FBESize;

            if ((fbeCurrentSize + char5.FBESize) > fbeStructSize)
                return true;
            if (!char5.Verify())
                return false;
            fbeCurrentSize += char5.FBESize;

            if ((fbeCurrentSize + wchar0.FBESize) > fbeStructSize)
                return true;
            if (!wchar0.Verify())
                return false;
            fbeCurrentSize += wchar0.FBESize;

            if ((fbeCurrentSize + wchar1.FBESize) > fbeStructSize)
                return true;
            if (!wchar1.Verify())
                return false;
            fbeCurrentSize += wchar1.FBESize;

            if ((fbeCurrentSize + wchar2.FBESize) > fbeStructSize)
                return true;
            if (!wchar2.Verify())
                return false;
            fbeCurrentSize += wchar2.FBESize;

            if ((fbeCurrentSize + wchar3.FBESize) > fbeStructSize)
                return true;
            if (!wchar3.Verify())
                return false;
            fbeCurrentSize += wchar3.FBESize;

            if ((fbeCurrentSize + wchar4.FBESize) > fbeStructSize)
                return true;
            if (!wchar4.Verify())
                return false;
            fbeCurrentSize += wchar4.FBESize;

            if ((fbeCurrentSize + wchar5.FBESize) > fbeStructSize)
                return true;
            if (!wchar5.Verify())
                return false;
            fbeCurrentSize += wchar5.FBESize;

            if ((fbeCurrentSize + int8b0.FBESize) > fbeStructSize)
                return true;
            if (!int8b0.Verify())
                return false;
            fbeCurrentSize += int8b0.FBESize;

            if ((fbeCurrentSize + int8b1.FBESize) > fbeStructSize)
                return true;
            if (!int8b1.Verify())
                return false;
            fbeCurrentSize += int8b1.FBESize;

            if ((fbeCurrentSize + int8b2.FBESize) > fbeStructSize)
                return true;
            if (!int8b2.Verify())
                return false;
            fbeCurrentSize += int8b2.FBESize;

            if ((fbeCurrentSize + int8b3.FBESize) > fbeStructSize)
                return true;
            if (!int8b3.Verify())
                return false;
            fbeCurrentSize += int8b3.FBESize;

            if ((fbeCurrentSize + int8b4.FBESize) > fbeStructSize)
                return true;
            if (!int8b4.Verify())
                return false;
            fbeCurrentSize += int8b4.FBESize;

            if ((fbeCurrentSize + int8b5.FBESize) > fbeStructSize)
                return true;
            if (!int8b5.Verify())
                return false;
            fbeCurrentSize += int8b5.FBESize;

            if ((fbeCurrentSize + uint8b0.FBESize) > fbeStructSize)
                return true;
            if (!uint8b0.Verify())
                return false;
            fbeCurrentSize += uint8b0.FBESize;

            if ((fbeCurrentSize + uint8b1.FBESize) > fbeStructSize)
                return true;
            if (!uint8b1.Verify())
                return false;
            fbeCurrentSize += uint8b1.FBESize;

            if ((fbeCurrentSize + uint8b2.FBESize) > fbeStructSize)
                return true;
            if (!uint8b2.Verify())
                return false;
            fbeCurrentSize += uint8b2.FBESize;

            if ((fbeCurrentSize + uint8b3.FBESize) > fbeStructSize)
                return true;
            if (!uint8b3.Verify())
                return false;
            fbeCurrentSize += uint8b3.FBESize;

            if ((fbeCurrentSize + uint8b4.FBESize) > fbeStructSize)
                return true;
            if (!uint8b4.Verify())
                return false;
            fbeCurrentSize += uint8b4.FBESize;

            if ((fbeCurrentSize + uint8b5.FBESize) > fbeStructSize)
                return true;
            if (!uint8b5.Verify())
                return false;
            fbeCurrentSize += uint8b5.FBESize;

            if ((fbeCurrentSize + int16b0.FBESize) > fbeStructSize)
                return true;
            if (!int16b0.Verify())
                return false;
            fbeCurrentSize += int16b0.FBESize;

            if ((fbeCurrentSize + int16b1.FBESize) > fbeStructSize)
                return true;
            if (!int16b1.Verify())
                return false;
            fbeCurrentSize += int16b1.FBESize;

            if ((fbeCurrentSize + int16b2.FBESize) > fbeStructSize)
                return true;
            if (!int16b2.Verify())
                return false;
            fbeCurrentSize += int16b2.FBESize;

            if ((fbeCurrentSize + int16b3.FBESize) > fbeStructSize)
                return true;
            if (!int16b3.Verify())
                return false;
            fbeCurrentSize += int16b3.FBESize;

            if ((fbeCurrentSize + int16b4.FBESize) > fbeStructSize)
                return true;
            if (!int16b4.Verify())
                return false;
            fbeCurrentSize += int16b4.FBESize;

            if ((fbeCurrentSize + int16b5.FBESize) > fbeStructSize)
                return true;
            if (!int16b5.Verify())
                return false;
            fbeCurrentSize += int16b5.FBESize;

            if ((fbeCurrentSize + uint16b0.FBESize) > fbeStructSize)
                return true;
            if (!uint16b0.Verify())
                return false;
            fbeCurrentSize += uint16b0.FBESize;

            if ((fbeCurrentSize + uint16b1.FBESize) > fbeStructSize)
                return true;
            if (!uint16b1.Verify())
                return false;
            fbeCurrentSize += uint16b1.FBESize;

            if ((fbeCurrentSize + uint16b2.FBESize) > fbeStructSize)
                return true;
            if (!uint16b2.Verify())
                return false;
            fbeCurrentSize += uint16b2.FBESize;

            if ((fbeCurrentSize + uint16b3.FBESize) > fbeStructSize)
                return true;
            if (!uint16b3.Verify())
                return false;
            fbeCurrentSize += uint16b3.FBESize;

            if ((fbeCurrentSize + uint16b4.FBESize) > fbeStructSize)
                return true;
            if (!uint16b4.Verify())
                return false;
            fbeCurrentSize += uint16b4.FBESize;

            if ((fbeCurrentSize + uint16b5.FBESize) > fbeStructSize)
                return true;
            if (!uint16b5.Verify())
                return false;
            fbeCurrentSize += uint16b5.FBESize;

            if ((fbeCurrentSize + int32b0.FBESize) > fbeStructSize)
                return true;
            if (!int32b0.Verify())
                return false;
            fbeCurrentSize += int32b0.FBESize;

            if ((fbeCurrentSize + int32b1.FBESize) > fbeStructSize)
                return true;
            if (!int32b1.Verify())
                return false;
            fbeCurrentSize += int32b1.FBESize;

            if ((fbeCurrentSize + int32b2.FBESize) > fbeStructSize)
                return true;
            if (!int32b2.Verify())
                return false;
            fbeCurrentSize += int32b2.FBESize;

            if ((fbeCurrentSize + int32b3.FBESize) > fbeStructSize)
                return true;
            if (!int32b3.Verify())
                return false;
            fbeCurrentSize += int32b3.FBESize;

            if ((fbeCurrentSize + int32b4.FBESize) > fbeStructSize)
                return true;
            if (!int32b4.Verify())
                return false;
            fbeCurrentSize += int32b4.FBESize;

            if ((fbeCurrentSize + int32b5.FBESize) > fbeStructSize)
                return true;
            if (!int32b5.Verify())
                return false;
            fbeCurrentSize += int32b5.FBESize;

            if ((fbeCurrentSize + uint32b0.FBESize) > fbeStructSize)
                return true;
            if (!uint32b0.Verify())
                return false;
            fbeCurrentSize += uint32b0.FBESize;

            if ((fbeCurrentSize + uint32b1.FBESize) > fbeStructSize)
                return true;
            if (!uint32b1.Verify())
                return false;
            fbeCurrentSize += uint32b1.FBESize;

            if ((fbeCurrentSize + uint32b2.FBESize) > fbeStructSize)
                return true;
            if (!uint32b2.Verify())
                return false;
            fbeCurrentSize += uint32b2.FBESize;

            if ((fbeCurrentSize + uint32b3.FBESize) > fbeStructSize)
                return true;
            if (!uint32b3.Verify())
                return false;
            fbeCurrentSize += uint32b3.FBESize;

            if ((fbeCurrentSize + uint32b4.FBESize) > fbeStructSize)
                return true;
            if (!uint32b4.Verify())
                return false;
            fbeCurrentSize += uint32b4.FBESize;

            if ((fbeCurrentSize + uint32b5.FBESize) > fbeStructSize)
                return true;
            if (!uint32b5.Verify())
                return false;
            fbeCurrentSize += uint32b5.FBESize;

            if ((fbeCurrentSize + int64b0.FBESize) > fbeStructSize)
                return true;
            if (!int64b0.Verify())
                return false;
            fbeCurrentSize += int64b0.FBESize;

            if ((fbeCurrentSize + int64b1.FBESize) > fbeStructSize)
                return true;
            if (!int64b1.Verify())
                return false;
            fbeCurrentSize += int64b1.FBESize;

            if ((fbeCurrentSize + int64b2.FBESize) > fbeStructSize)
                return true;
            if (!int64b2.Verify())
                return false;
            fbeCurrentSize += int64b2.FBESize;

            if ((fbeCurrentSize + int64b3.FBESize) > fbeStructSize)
                return true;
            if (!int64b3.Verify())
                return false;
            fbeCurrentSize += int64b3.FBESize;

            if ((fbeCurrentSize + int64b4.FBESize) > fbeStructSize)
                return true;
            if (!int64b4.Verify())
                return false;
            fbeCurrentSize += int64b4.FBESize;

            if ((fbeCurrentSize + int64b5.FBESize) > fbeStructSize)
                return true;
            if (!int64b5.Verify())
                return false;
            fbeCurrentSize += int64b5.FBESize;

            if ((fbeCurrentSize + uint64b0.FBESize) > fbeStructSize)
                return true;
            if (!uint64b0.Verify())
                return false;
            fbeCurrentSize += uint64b0.FBESize;

            if ((fbeCurrentSize + uint64b1.FBESize) > fbeStructSize)
                return true;
            if (!uint64b1.Verify())
                return false;
            fbeCurrentSize += uint64b1.FBESize;

            if ((fbeCurrentSize + uint64b2.FBESize) > fbeStructSize)
                return true;
            if (!uint64b2.Verify())
                return false;
            fbeCurrentSize += uint64b2.FBESize;

            if ((fbeCurrentSize + uint64b3.FBESize) > fbeStructSize)
                return true;
            if (!uint64b3.Verify())
                return false;
            fbeCurrentSize += uint64b3.FBESize;

            if ((fbeCurrentSize + uint64b4.FBESize) > fbeStructSize)
                return true;
            if (!uint64b4.Verify())
                return false;
            fbeCurrentSize += uint64b4.FBESize;

            if ((fbeCurrentSize + uint64b5.FBESize) > fbeStructSize)
                return true;
            if (!uint64b5.Verify())
                return false;
            fbeCurrentSize += uint64b5.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out Enums fbeValue) { Get(out fbeValue, Enums.Default); }
        public override void Get(out Enums fbeValue, Enums defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out Enums fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = Enums.Default;

            if ((fbeCurrentSize + byte0.FBESize) <= fbeStructSize)
                byte0.Get(out fbeValue.byte0, global::com.chronoxor.enums.EnumByte.ENUM_VALUE_0);
            else
                fbeValue.byte0 = global::com.chronoxor.enums.EnumByte.ENUM_VALUE_0;
            fbeCurrentSize += byte0.FBESize;

            if ((fbeCurrentSize + byte1.FBESize) <= fbeStructSize)
                byte1.Get(out fbeValue.byte1, global::com.chronoxor.enums.EnumByte.ENUM_VALUE_1);
            else
                fbeValue.byte1 = global::com.chronoxor.enums.EnumByte.ENUM_VALUE_1;
            fbeCurrentSize += byte1.FBESize;

            if ((fbeCurrentSize + byte2.FBESize) <= fbeStructSize)
                byte2.Get(out fbeValue.byte2, global::com.chronoxor.enums.EnumByte.ENUM_VALUE_2);
            else
                fbeValue.byte2 = global::com.chronoxor.enums.EnumByte.ENUM_VALUE_2;
            fbeCurrentSize += byte2.FBESize;

            if ((fbeCurrentSize + byte3.FBESize) <= fbeStructSize)
                byte3.Get(out fbeValue.byte3, global::com.chronoxor.enums.EnumByte.ENUM_VALUE_3);
            else
                fbeValue.byte3 = global::com.chronoxor.enums.EnumByte.ENUM_VALUE_3;
            fbeCurrentSize += byte3.FBESize;

            if ((fbeCurrentSize + byte4.FBESize) <= fbeStructSize)
                byte4.Get(out fbeValue.byte4, global::com.chronoxor.enums.EnumByte.ENUM_VALUE_4);
            else
                fbeValue.byte4 = global::com.chronoxor.enums.EnumByte.ENUM_VALUE_4;
            fbeCurrentSize += byte4.FBESize;

            if ((fbeCurrentSize + byte5.FBESize) <= fbeStructSize)
                byte5.Get(out fbeValue.byte5, global::com.chronoxor.enums.EnumByte.ENUM_VALUE_5);
            else
                fbeValue.byte5 = global::com.chronoxor.enums.EnumByte.ENUM_VALUE_5;
            fbeCurrentSize += byte5.FBESize;

            if ((fbeCurrentSize + char0.FBESize) <= fbeStructSize)
                char0.Get(out fbeValue.char0, global::com.chronoxor.enums.EnumChar.ENUM_VALUE_0);
            else
                fbeValue.char0 = global::com.chronoxor.enums.EnumChar.ENUM_VALUE_0;
            fbeCurrentSize += char0.FBESize;

            if ((fbeCurrentSize + char1.FBESize) <= fbeStructSize)
                char1.Get(out fbeValue.char1, global::com.chronoxor.enums.EnumChar.ENUM_VALUE_1);
            else
                fbeValue.char1 = global::com.chronoxor.enums.EnumChar.ENUM_VALUE_1;
            fbeCurrentSize += char1.FBESize;

            if ((fbeCurrentSize + char2.FBESize) <= fbeStructSize)
                char2.Get(out fbeValue.char2, global::com.chronoxor.enums.EnumChar.ENUM_VALUE_2);
            else
                fbeValue.char2 = global::com.chronoxor.enums.EnumChar.ENUM_VALUE_2;
            fbeCurrentSize += char2.FBESize;

            if ((fbeCurrentSize + char3.FBESize) <= fbeStructSize)
                char3.Get(out fbeValue.char3, global::com.chronoxor.enums.EnumChar.ENUM_VALUE_3);
            else
                fbeValue.char3 = global::com.chronoxor.enums.EnumChar.ENUM_VALUE_3;
            fbeCurrentSize += char3.FBESize;

            if ((fbeCurrentSize + char4.FBESize) <= fbeStructSize)
                char4.Get(out fbeValue.char4, global::com.chronoxor.enums.EnumChar.ENUM_VALUE_4);
            else
                fbeValue.char4 = global::com.chronoxor.enums.EnumChar.ENUM_VALUE_4;
            fbeCurrentSize += char4.FBESize;

            if ((fbeCurrentSize + char5.FBESize) <= fbeStructSize)
                char5.Get(out fbeValue.char5, global::com.chronoxor.enums.EnumChar.ENUM_VALUE_5);
            else
                fbeValue.char5 = global::com.chronoxor.enums.EnumChar.ENUM_VALUE_5;
            fbeCurrentSize += char5.FBESize;

            if ((fbeCurrentSize + wchar0.FBESize) <= fbeStructSize)
                wchar0.Get(out fbeValue.wchar0, global::com.chronoxor.enums.EnumWChar.ENUM_VALUE_0);
            else
                fbeValue.wchar0 = global::com.chronoxor.enums.EnumWChar.ENUM_VALUE_0;
            fbeCurrentSize += wchar0.FBESize;

            if ((fbeCurrentSize + wchar1.FBESize) <= fbeStructSize)
                wchar1.Get(out fbeValue.wchar1, global::com.chronoxor.enums.EnumWChar.ENUM_VALUE_1);
            else
                fbeValue.wchar1 = global::com.chronoxor.enums.EnumWChar.ENUM_VALUE_1;
            fbeCurrentSize += wchar1.FBESize;

            if ((fbeCurrentSize + wchar2.FBESize) <= fbeStructSize)
                wchar2.Get(out fbeValue.wchar2, global::com.chronoxor.enums.EnumWChar.ENUM_VALUE_2);
            else
                fbeValue.wchar2 = global::com.chronoxor.enums.EnumWChar.ENUM_VALUE_2;
            fbeCurrentSize += wchar2.FBESize;

            if ((fbeCurrentSize + wchar3.FBESize) <= fbeStructSize)
                wchar3.Get(out fbeValue.wchar3, global::com.chronoxor.enums.EnumWChar.ENUM_VALUE_3);
            else
                fbeValue.wchar3 = global::com.chronoxor.enums.EnumWChar.ENUM_VALUE_3;
            fbeCurrentSize += wchar3.FBESize;

            if ((fbeCurrentSize + wchar4.FBESize) <= fbeStructSize)
                wchar4.Get(out fbeValue.wchar4, global::com.chronoxor.enums.EnumWChar.ENUM_VALUE_4);
            else
                fbeValue.wchar4 = global::com.chronoxor.enums.EnumWChar.ENUM_VALUE_4;
            fbeCurrentSize += wchar4.FBESize;

            if ((fbeCurrentSize + wchar5.FBESize) <= fbeStructSize)
                wchar5.Get(out fbeValue.wchar5, global::com.chronoxor.enums.EnumWChar.ENUM_VALUE_5);
            else
                fbeValue.wchar5 = global::com.chronoxor.enums.EnumWChar.ENUM_VALUE_5;
            fbeCurrentSize += wchar5.FBESize;

            if ((fbeCurrentSize + int8b0.FBESize) <= fbeStructSize)
                int8b0.Get(out fbeValue.int8b0, global::com.chronoxor.enums.EnumInt8.ENUM_VALUE_0);
            else
                fbeValue.int8b0 = global::com.chronoxor.enums.EnumInt8.ENUM_VALUE_0;
            fbeCurrentSize += int8b0.FBESize;

            if ((fbeCurrentSize + int8b1.FBESize) <= fbeStructSize)
                int8b1.Get(out fbeValue.int8b1, global::com.chronoxor.enums.EnumInt8.ENUM_VALUE_1);
            else
                fbeValue.int8b1 = global::com.chronoxor.enums.EnumInt8.ENUM_VALUE_1;
            fbeCurrentSize += int8b1.FBESize;

            if ((fbeCurrentSize + int8b2.FBESize) <= fbeStructSize)
                int8b2.Get(out fbeValue.int8b2, global::com.chronoxor.enums.EnumInt8.ENUM_VALUE_2);
            else
                fbeValue.int8b2 = global::com.chronoxor.enums.EnumInt8.ENUM_VALUE_2;
            fbeCurrentSize += int8b2.FBESize;

            if ((fbeCurrentSize + int8b3.FBESize) <= fbeStructSize)
                int8b3.Get(out fbeValue.int8b3, global::com.chronoxor.enums.EnumInt8.ENUM_VALUE_3);
            else
                fbeValue.int8b3 = global::com.chronoxor.enums.EnumInt8.ENUM_VALUE_3;
            fbeCurrentSize += int8b3.FBESize;

            if ((fbeCurrentSize + int8b4.FBESize) <= fbeStructSize)
                int8b4.Get(out fbeValue.int8b4, global::com.chronoxor.enums.EnumInt8.ENUM_VALUE_4);
            else
                fbeValue.int8b4 = global::com.chronoxor.enums.EnumInt8.ENUM_VALUE_4;
            fbeCurrentSize += int8b4.FBESize;

            if ((fbeCurrentSize + int8b5.FBESize) <= fbeStructSize)
                int8b5.Get(out fbeValue.int8b5, global::com.chronoxor.enums.EnumInt8.ENUM_VALUE_5);
            else
                fbeValue.int8b5 = global::com.chronoxor.enums.EnumInt8.ENUM_VALUE_5;
            fbeCurrentSize += int8b5.FBESize;

            if ((fbeCurrentSize + uint8b0.FBESize) <= fbeStructSize)
                uint8b0.Get(out fbeValue.uint8b0, global::com.chronoxor.enums.EnumUInt8.ENUM_VALUE_0);
            else
                fbeValue.uint8b0 = global::com.chronoxor.enums.EnumUInt8.ENUM_VALUE_0;
            fbeCurrentSize += uint8b0.FBESize;

            if ((fbeCurrentSize + uint8b1.FBESize) <= fbeStructSize)
                uint8b1.Get(out fbeValue.uint8b1, global::com.chronoxor.enums.EnumUInt8.ENUM_VALUE_1);
            else
                fbeValue.uint8b1 = global::com.chronoxor.enums.EnumUInt8.ENUM_VALUE_1;
            fbeCurrentSize += uint8b1.FBESize;

            if ((fbeCurrentSize + uint8b2.FBESize) <= fbeStructSize)
                uint8b2.Get(out fbeValue.uint8b2, global::com.chronoxor.enums.EnumUInt8.ENUM_VALUE_2);
            else
                fbeValue.uint8b2 = global::com.chronoxor.enums.EnumUInt8.ENUM_VALUE_2;
            fbeCurrentSize += uint8b2.FBESize;

            if ((fbeCurrentSize + uint8b3.FBESize) <= fbeStructSize)
                uint8b3.Get(out fbeValue.uint8b3, global::com.chronoxor.enums.EnumUInt8.ENUM_VALUE_3);
            else
                fbeValue.uint8b3 = global::com.chronoxor.enums.EnumUInt8.ENUM_VALUE_3;
            fbeCurrentSize += uint8b3.FBESize;

            if ((fbeCurrentSize + uint8b4.FBESize) <= fbeStructSize)
                uint8b4.Get(out fbeValue.uint8b4, global::com.chronoxor.enums.EnumUInt8.ENUM_VALUE_4);
            else
                fbeValue.uint8b4 = global::com.chronoxor.enums.EnumUInt8.ENUM_VALUE_4;
            fbeCurrentSize += uint8b4.FBESize;

            if ((fbeCurrentSize + uint8b5.FBESize) <= fbeStructSize)
                uint8b5.Get(out fbeValue.uint8b5, global::com.chronoxor.enums.EnumUInt8.ENUM_VALUE_5);
            else
                fbeValue.uint8b5 = global::com.chronoxor.enums.EnumUInt8.ENUM_VALUE_5;
            fbeCurrentSize += uint8b5.FBESize;

            if ((fbeCurrentSize + int16b0.FBESize) <= fbeStructSize)
                int16b0.Get(out fbeValue.int16b0, global::com.chronoxor.enums.EnumInt16.ENUM_VALUE_0);
            else
                fbeValue.int16b0 = global::com.chronoxor.enums.EnumInt16.ENUM_VALUE_0;
            fbeCurrentSize += int16b0.FBESize;

            if ((fbeCurrentSize + int16b1.FBESize) <= fbeStructSize)
                int16b1.Get(out fbeValue.int16b1, global::com.chronoxor.enums.EnumInt16.ENUM_VALUE_1);
            else
                fbeValue.int16b1 = global::com.chronoxor.enums.EnumInt16.ENUM_VALUE_1;
            fbeCurrentSize += int16b1.FBESize;

            if ((fbeCurrentSize + int16b2.FBESize) <= fbeStructSize)
                int16b2.Get(out fbeValue.int16b2, global::com.chronoxor.enums.EnumInt16.ENUM_VALUE_2);
            else
                fbeValue.int16b2 = global::com.chronoxor.enums.EnumInt16.ENUM_VALUE_2;
            fbeCurrentSize += int16b2.FBESize;

            if ((fbeCurrentSize + int16b3.FBESize) <= fbeStructSize)
                int16b3.Get(out fbeValue.int16b3, global::com.chronoxor.enums.EnumInt16.ENUM_VALUE_3);
            else
                fbeValue.int16b3 = global::com.chronoxor.enums.EnumInt16.ENUM_VALUE_3;
            fbeCurrentSize += int16b3.FBESize;

            if ((fbeCurrentSize + int16b4.FBESize) <= fbeStructSize)
                int16b4.Get(out fbeValue.int16b4, global::com.chronoxor.enums.EnumInt16.ENUM_VALUE_4);
            else
                fbeValue.int16b4 = global::com.chronoxor.enums.EnumInt16.ENUM_VALUE_4;
            fbeCurrentSize += int16b4.FBESize;

            if ((fbeCurrentSize + int16b5.FBESize) <= fbeStructSize)
                int16b5.Get(out fbeValue.int16b5, global::com.chronoxor.enums.EnumInt16.ENUM_VALUE_5);
            else
                fbeValue.int16b5 = global::com.chronoxor.enums.EnumInt16.ENUM_VALUE_5;
            fbeCurrentSize += int16b5.FBESize;

            if ((fbeCurrentSize + uint16b0.FBESize) <= fbeStructSize)
                uint16b0.Get(out fbeValue.uint16b0, global::com.chronoxor.enums.EnumUInt16.ENUM_VALUE_0);
            else
                fbeValue.uint16b0 = global::com.chronoxor.enums.EnumUInt16.ENUM_VALUE_0;
            fbeCurrentSize += uint16b0.FBESize;

            if ((fbeCurrentSize + uint16b1.FBESize) <= fbeStructSize)
                uint16b1.Get(out fbeValue.uint16b1, global::com.chronoxor.enums.EnumUInt16.ENUM_VALUE_1);
            else
                fbeValue.uint16b1 = global::com.chronoxor.enums.EnumUInt16.ENUM_VALUE_1;
            fbeCurrentSize += uint16b1.FBESize;

            if ((fbeCurrentSize + uint16b2.FBESize) <= fbeStructSize)
                uint16b2.Get(out fbeValue.uint16b2, global::com.chronoxor.enums.EnumUInt16.ENUM_VALUE_2);
            else
                fbeValue.uint16b2 = global::com.chronoxor.enums.EnumUInt16.ENUM_VALUE_2;
            fbeCurrentSize += uint16b2.FBESize;

            if ((fbeCurrentSize + uint16b3.FBESize) <= fbeStructSize)
                uint16b3.Get(out fbeValue.uint16b3, global::com.chronoxor.enums.EnumUInt16.ENUM_VALUE_3);
            else
                fbeValue.uint16b3 = global::com.chronoxor.enums.EnumUInt16.ENUM_VALUE_3;
            fbeCurrentSize += uint16b3.FBESize;

            if ((fbeCurrentSize + uint16b4.FBESize) <= fbeStructSize)
                uint16b4.Get(out fbeValue.uint16b4, global::com.chronoxor.enums.EnumUInt16.ENUM_VALUE_4);
            else
                fbeValue.uint16b4 = global::com.chronoxor.enums.EnumUInt16.ENUM_VALUE_4;
            fbeCurrentSize += uint16b4.FBESize;

            if ((fbeCurrentSize + uint16b5.FBESize) <= fbeStructSize)
                uint16b5.Get(out fbeValue.uint16b5, global::com.chronoxor.enums.EnumUInt16.ENUM_VALUE_5);
            else
                fbeValue.uint16b5 = global::com.chronoxor.enums.EnumUInt16.ENUM_VALUE_5;
            fbeCurrentSize += uint16b5.FBESize;

            if ((fbeCurrentSize + int32b0.FBESize) <= fbeStructSize)
                int32b0.Get(out fbeValue.int32b0, global::com.chronoxor.enums.EnumInt32.ENUM_VALUE_0);
            else
                fbeValue.int32b0 = global::com.chronoxor.enums.EnumInt32.ENUM_VALUE_0;
            fbeCurrentSize += int32b0.FBESize;

            if ((fbeCurrentSize + int32b1.FBESize) <= fbeStructSize)
                int32b1.Get(out fbeValue.int32b1, global::com.chronoxor.enums.EnumInt32.ENUM_VALUE_1);
            else
                fbeValue.int32b1 = global::com.chronoxor.enums.EnumInt32.ENUM_VALUE_1;
            fbeCurrentSize += int32b1.FBESize;

            if ((fbeCurrentSize + int32b2.FBESize) <= fbeStructSize)
                int32b2.Get(out fbeValue.int32b2, global::com.chronoxor.enums.EnumInt32.ENUM_VALUE_2);
            else
                fbeValue.int32b2 = global::com.chronoxor.enums.EnumInt32.ENUM_VALUE_2;
            fbeCurrentSize += int32b2.FBESize;

            if ((fbeCurrentSize + int32b3.FBESize) <= fbeStructSize)
                int32b3.Get(out fbeValue.int32b3, global::com.chronoxor.enums.EnumInt32.ENUM_VALUE_3);
            else
                fbeValue.int32b3 = global::com.chronoxor.enums.EnumInt32.ENUM_VALUE_3;
            fbeCurrentSize += int32b3.FBESize;

            if ((fbeCurrentSize + int32b4.FBESize) <= fbeStructSize)
                int32b4.Get(out fbeValue.int32b4, global::com.chronoxor.enums.EnumInt32.ENUM_VALUE_4);
            else
                fbeValue.int32b4 = global::com.chronoxor.enums.EnumInt32.ENUM_VALUE_4;
            fbeCurrentSize += int32b4.FBESize;

            if ((fbeCurrentSize + int32b5.FBESize) <= fbeStructSize)
                int32b5.Get(out fbeValue.int32b5, global::com.chronoxor.enums.EnumInt32.ENUM_VALUE_5);
            else
                fbeValue.int32b5 = global::com.chronoxor.enums.EnumInt32.ENUM_VALUE_5;
            fbeCurrentSize += int32b5.FBESize;

            if ((fbeCurrentSize + uint32b0.FBESize) <= fbeStructSize)
                uint32b0.Get(out fbeValue.uint32b0, global::com.chronoxor.enums.EnumUInt32.ENUM_VALUE_0);
            else
                fbeValue.uint32b0 = global::com.chronoxor.enums.EnumUInt32.ENUM_VALUE_0;
            fbeCurrentSize += uint32b0.FBESize;

            if ((fbeCurrentSize + uint32b1.FBESize) <= fbeStructSize)
                uint32b1.Get(out fbeValue.uint32b1, global::com.chronoxor.enums.EnumUInt32.ENUM_VALUE_1);
            else
                fbeValue.uint32b1 = global::com.chronoxor.enums.EnumUInt32.ENUM_VALUE_1;
            fbeCurrentSize += uint32b1.FBESize;

            if ((fbeCurrentSize + uint32b2.FBESize) <= fbeStructSize)
                uint32b2.Get(out fbeValue.uint32b2, global::com.chronoxor.enums.EnumUInt32.ENUM_VALUE_2);
            else
                fbeValue.uint32b2 = global::com.chronoxor.enums.EnumUInt32.ENUM_VALUE_2;
            fbeCurrentSize += uint32b2.FBESize;

            if ((fbeCurrentSize + uint32b3.FBESize) <= fbeStructSize)
                uint32b3.Get(out fbeValue.uint32b3, global::com.chronoxor.enums.EnumUInt32.ENUM_VALUE_3);
            else
                fbeValue.uint32b3 = global::com.chronoxor.enums.EnumUInt32.ENUM_VALUE_3;
            fbeCurrentSize += uint32b3.FBESize;

            if ((fbeCurrentSize + uint32b4.FBESize) <= fbeStructSize)
                uint32b4.Get(out fbeValue.uint32b4, global::com.chronoxor.enums.EnumUInt32.ENUM_VALUE_4);
            else
                fbeValue.uint32b4 = global::com.chronoxor.enums.EnumUInt32.ENUM_VALUE_4;
            fbeCurrentSize += uint32b4.FBESize;

            if ((fbeCurrentSize + uint32b5.FBESize) <= fbeStructSize)
                uint32b5.Get(out fbeValue.uint32b5, global::com.chronoxor.enums.EnumUInt32.ENUM_VALUE_5);
            else
                fbeValue.uint32b5 = global::com.chronoxor.enums.EnumUInt32.ENUM_VALUE_5;
            fbeCurrentSize += uint32b5.FBESize;

            if ((fbeCurrentSize + int64b0.FBESize) <= fbeStructSize)
                int64b0.Get(out fbeValue.int64b0, global::com.chronoxor.enums.EnumInt64.ENUM_VALUE_0);
            else
                fbeValue.int64b0 = global::com.chronoxor.enums.EnumInt64.ENUM_VALUE_0;
            fbeCurrentSize += int64b0.FBESize;

            if ((fbeCurrentSize + int64b1.FBESize) <= fbeStructSize)
                int64b1.Get(out fbeValue.int64b1, global::com.chronoxor.enums.EnumInt64.ENUM_VALUE_1);
            else
                fbeValue.int64b1 = global::com.chronoxor.enums.EnumInt64.ENUM_VALUE_1;
            fbeCurrentSize += int64b1.FBESize;

            if ((fbeCurrentSize + int64b2.FBESize) <= fbeStructSize)
                int64b2.Get(out fbeValue.int64b2, global::com.chronoxor.enums.EnumInt64.ENUM_VALUE_2);
            else
                fbeValue.int64b2 = global::com.chronoxor.enums.EnumInt64.ENUM_VALUE_2;
            fbeCurrentSize += int64b2.FBESize;

            if ((fbeCurrentSize + int64b3.FBESize) <= fbeStructSize)
                int64b3.Get(out fbeValue.int64b3, global::com.chronoxor.enums.EnumInt64.ENUM_VALUE_3);
            else
                fbeValue.int64b3 = global::com.chronoxor.enums.EnumInt64.ENUM_VALUE_3;
            fbeCurrentSize += int64b3.FBESize;

            if ((fbeCurrentSize + int64b4.FBESize) <= fbeStructSize)
                int64b4.Get(out fbeValue.int64b4, global::com.chronoxor.enums.EnumInt64.ENUM_VALUE_4);
            else
                fbeValue.int64b4 = global::com.chronoxor.enums.EnumInt64.ENUM_VALUE_4;
            fbeCurrentSize += int64b4.FBESize;

            if ((fbeCurrentSize + int64b5.FBESize) <= fbeStructSize)
                int64b5.Get(out fbeValue.int64b5, global::com.chronoxor.enums.EnumInt64.ENUM_VALUE_5);
            else
                fbeValue.int64b5 = global::com.chronoxor.enums.EnumInt64.ENUM_VALUE_5;
            fbeCurrentSize += int64b5.FBESize;

            if ((fbeCurrentSize + uint64b0.FBESize) <= fbeStructSize)
                uint64b0.Get(out fbeValue.uint64b0, global::com.chronoxor.enums.EnumUInt64.ENUM_VALUE_0);
            else
                fbeValue.uint64b0 = global::com.chronoxor.enums.EnumUInt64.ENUM_VALUE_0;
            fbeCurrentSize += uint64b0.FBESize;

            if ((fbeCurrentSize + uint64b1.FBESize) <= fbeStructSize)
                uint64b1.Get(out fbeValue.uint64b1, global::com.chronoxor.enums.EnumUInt64.ENUM_VALUE_1);
            else
                fbeValue.uint64b1 = global::com.chronoxor.enums.EnumUInt64.ENUM_VALUE_1;
            fbeCurrentSize += uint64b1.FBESize;

            if ((fbeCurrentSize + uint64b2.FBESize) <= fbeStructSize)
                uint64b2.Get(out fbeValue.uint64b2, global::com.chronoxor.enums.EnumUInt64.ENUM_VALUE_2);
            else
                fbeValue.uint64b2 = global::com.chronoxor.enums.EnumUInt64.ENUM_VALUE_2;
            fbeCurrentSize += uint64b2.FBESize;

            if ((fbeCurrentSize + uint64b3.FBESize) <= fbeStructSize)
                uint64b3.Get(out fbeValue.uint64b3, global::com.chronoxor.enums.EnumUInt64.ENUM_VALUE_3);
            else
                fbeValue.uint64b3 = global::com.chronoxor.enums.EnumUInt64.ENUM_VALUE_3;
            fbeCurrentSize += uint64b3.FBESize;

            if ((fbeCurrentSize + uint64b4.FBESize) <= fbeStructSize)
                uint64b4.Get(out fbeValue.uint64b4, global::com.chronoxor.enums.EnumUInt64.ENUM_VALUE_4);
            else
                fbeValue.uint64b4 = global::com.chronoxor.enums.EnumUInt64.ENUM_VALUE_4;
            fbeCurrentSize += uint64b4.FBESize;

            if ((fbeCurrentSize + uint64b5.FBESize) <= fbeStructSize)
                uint64b5.Get(out fbeValue.uint64b5, global::com.chronoxor.enums.EnumUInt64.ENUM_VALUE_5);
            else
                fbeValue.uint64b5 = global::com.chronoxor.enums.EnumUInt64.ENUM_VALUE_5;
            fbeCurrentSize += uint64b5.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(Enums fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(Enums fbeValue)
        {
            byte0.Set(fbeValue.byte0);
            byte1.Set(fbeValue.byte1);
            byte2.Set(fbeValue.byte2);
            byte3.Set(fbeValue.byte3);
            byte4.Set(fbeValue.byte4);
            byte5.Set(fbeValue.byte5);
            char0.Set(fbeValue.char0);
            char1.Set(fbeValue.char1);
            char2.Set(fbeValue.char2);
            char3.Set(fbeValue.char3);
            char4.Set(fbeValue.char4);
            char5.Set(fbeValue.char5);
            wchar0.Set(fbeValue.wchar0);
            wchar1.Set(fbeValue.wchar1);
            wchar2.Set(fbeValue.wchar2);
            wchar3.Set(fbeValue.wchar3);
            wchar4.Set(fbeValue.wchar4);
            wchar5.Set(fbeValue.wchar5);
            int8b0.Set(fbeValue.int8b0);
            int8b1.Set(fbeValue.int8b1);
            int8b2.Set(fbeValue.int8b2);
            int8b3.Set(fbeValue.int8b3);
            int8b4.Set(fbeValue.int8b4);
            int8b5.Set(fbeValue.int8b5);
            uint8b0.Set(fbeValue.uint8b0);
            uint8b1.Set(fbeValue.uint8b1);
            uint8b2.Set(fbeValue.uint8b2);
            uint8b3.Set(fbeValue.uint8b3);
            uint8b4.Set(fbeValue.uint8b4);
            uint8b5.Set(fbeValue.uint8b5);
            int16b0.Set(fbeValue.int16b0);
            int16b1.Set(fbeValue.int16b1);
            int16b2.Set(fbeValue.int16b2);
            int16b3.Set(fbeValue.int16b3);
            int16b4.Set(fbeValue.int16b4);
            int16b5.Set(fbeValue.int16b5);
            uint16b0.Set(fbeValue.uint16b0);
            uint16b1.Set(fbeValue.uint16b1);
            uint16b2.Set(fbeValue.uint16b2);
            uint16b3.Set(fbeValue.uint16b3);
            uint16b4.Set(fbeValue.uint16b4);
            uint16b5.Set(fbeValue.uint16b5);
            int32b0.Set(fbeValue.int32b0);
            int32b1.Set(fbeValue.int32b1);
            int32b2.Set(fbeValue.int32b2);
            int32b3.Set(fbeValue.int32b3);
            int32b4.Set(fbeValue.int32b4);
            int32b5.Set(fbeValue.int32b5);
            uint32b0.Set(fbeValue.uint32b0);
            uint32b1.Set(fbeValue.uint32b1);
            uint32b2.Set(fbeValue.uint32b2);
            uint32b3.Set(fbeValue.uint32b3);
            uint32b4.Set(fbeValue.uint32b4);
            uint32b5.Set(fbeValue.uint32b5);
            int64b0.Set(fbeValue.int64b0);
            int64b1.Set(fbeValue.int64b1);
            int64b2.Set(fbeValue.int64b2);
            int64b3.Set(fbeValue.int64b3);
            int64b4.Set(fbeValue.int64b4);
            int64b5.Set(fbeValue.int64b5);
            uint64b0.Set(fbeValue.uint64b0);
            uint64b1.Set(fbeValue.uint64b1);
            uint64b2.Set(fbeValue.uint64b2);
            uint64b3.Set(fbeValue.uint64b3);
            uint64b4.Set(fbeValue.uint64b4);
            uint64b5.Set(fbeValue.uint64b5);
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding Enums model
    public class EnumsModel : com.chronoxor.FBE.Model
    {
        public readonly FieldModelEnums model;

        public EnumsModel() { model = new FieldModelEnums(Buffer, 4); }
        public EnumsModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { model = new FieldModelEnums(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelEnums.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(Enums value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out Enums value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = Enums.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = Enums.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding Enums final model
    public class FinalModelEnums : com.chronoxor.FBE.FinalModelValueType<Enums>
    {
        public readonly com.chronoxor.enums.FBE.FinalModelEnumByte byte0;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumByte byte1;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumByte byte2;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumByte byte3;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumByte byte4;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumByte byte5;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumChar char0;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumChar char1;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumChar char2;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumChar char3;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumChar char4;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumChar char5;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumWChar wchar0;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumWChar wchar1;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumWChar wchar2;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumWChar wchar3;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumWChar wchar4;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumWChar wchar5;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt8 int8b0;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt8 int8b1;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt8 int8b2;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt8 int8b3;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt8 int8b4;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt8 int8b5;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt8 uint8b0;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt8 uint8b1;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt8 uint8b2;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt8 uint8b3;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt8 uint8b4;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt8 uint8b5;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt16 int16b0;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt16 int16b1;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt16 int16b2;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt16 int16b3;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt16 int16b4;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt16 int16b5;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt16 uint16b0;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt16 uint16b1;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt16 uint16b2;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt16 uint16b3;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt16 uint16b4;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt16 uint16b5;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt32 int32b0;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt32 int32b1;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt32 int32b2;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt32 int32b3;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt32 int32b4;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt32 int32b5;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt32 uint32b0;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt32 uint32b1;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt32 uint32b2;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt32 uint32b3;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt32 uint32b4;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt32 uint32b5;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt64 int64b0;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt64 int64b1;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt64 int64b2;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt64 int64b3;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt64 int64b4;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumInt64 int64b5;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt64 uint64b0;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt64 uint64b1;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt64 uint64b2;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt64 uint64b3;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt64 uint64b4;
        public readonly com.chronoxor.enums.FBE.FinalModelEnumUInt64 uint64b5;

        public FinalModelEnums(com.chronoxor.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            byte0 = new com.chronoxor.enums.FBE.FinalModelEnumByte(buffer, 0);
            byte1 = new com.chronoxor.enums.FBE.FinalModelEnumByte(buffer, 0);
            byte2 = new com.chronoxor.enums.FBE.FinalModelEnumByte(buffer, 0);
            byte3 = new com.chronoxor.enums.FBE.FinalModelEnumByte(buffer, 0);
            byte4 = new com.chronoxor.enums.FBE.FinalModelEnumByte(buffer, 0);
            byte5 = new com.chronoxor.enums.FBE.FinalModelEnumByte(buffer, 0);
            char0 = new com.chronoxor.enums.FBE.FinalModelEnumChar(buffer, 0);
            char1 = new com.chronoxor.enums.FBE.FinalModelEnumChar(buffer, 0);
            char2 = new com.chronoxor.enums.FBE.FinalModelEnumChar(buffer, 0);
            char3 = new com.chronoxor.enums.FBE.FinalModelEnumChar(buffer, 0);
            char4 = new com.chronoxor.enums.FBE.FinalModelEnumChar(buffer, 0);
            char5 = new com.chronoxor.enums.FBE.FinalModelEnumChar(buffer, 0);
            wchar0 = new com.chronoxor.enums.FBE.FinalModelEnumWChar(buffer, 0);
            wchar1 = new com.chronoxor.enums.FBE.FinalModelEnumWChar(buffer, 0);
            wchar2 = new com.chronoxor.enums.FBE.FinalModelEnumWChar(buffer, 0);
            wchar3 = new com.chronoxor.enums.FBE.FinalModelEnumWChar(buffer, 0);
            wchar4 = new com.chronoxor.enums.FBE.FinalModelEnumWChar(buffer, 0);
            wchar5 = new com.chronoxor.enums.FBE.FinalModelEnumWChar(buffer, 0);
            int8b0 = new com.chronoxor.enums.FBE.FinalModelEnumInt8(buffer, 0);
            int8b1 = new com.chronoxor.enums.FBE.FinalModelEnumInt8(buffer, 0);
            int8b2 = new com.chronoxor.enums.FBE.FinalModelEnumInt8(buffer, 0);
            int8b3 = new com.chronoxor.enums.FBE.FinalModelEnumInt8(buffer, 0);
            int8b4 = new com.chronoxor.enums.FBE.FinalModelEnumInt8(buffer, 0);
            int8b5 = new com.chronoxor.enums.FBE.FinalModelEnumInt8(buffer, 0);
            uint8b0 = new com.chronoxor.enums.FBE.FinalModelEnumUInt8(buffer, 0);
            uint8b1 = new com.chronoxor.enums.FBE.FinalModelEnumUInt8(buffer, 0);
            uint8b2 = new com.chronoxor.enums.FBE.FinalModelEnumUInt8(buffer, 0);
            uint8b3 = new com.chronoxor.enums.FBE.FinalModelEnumUInt8(buffer, 0);
            uint8b4 = new com.chronoxor.enums.FBE.FinalModelEnumUInt8(buffer, 0);
            uint8b5 = new com.chronoxor.enums.FBE.FinalModelEnumUInt8(buffer, 0);
            int16b0 = new com.chronoxor.enums.FBE.FinalModelEnumInt16(buffer, 0);
            int16b1 = new com.chronoxor.enums.FBE.FinalModelEnumInt16(buffer, 0);
            int16b2 = new com.chronoxor.enums.FBE.FinalModelEnumInt16(buffer, 0);
            int16b3 = new com.chronoxor.enums.FBE.FinalModelEnumInt16(buffer, 0);
            int16b4 = new com.chronoxor.enums.FBE.FinalModelEnumInt16(buffer, 0);
            int16b5 = new com.chronoxor.enums.FBE.FinalModelEnumInt16(buffer, 0);
            uint16b0 = new com.chronoxor.enums.FBE.FinalModelEnumUInt16(buffer, 0);
            uint16b1 = new com.chronoxor.enums.FBE.FinalModelEnumUInt16(buffer, 0);
            uint16b2 = new com.chronoxor.enums.FBE.FinalModelEnumUInt16(buffer, 0);
            uint16b3 = new com.chronoxor.enums.FBE.FinalModelEnumUInt16(buffer, 0);
            uint16b4 = new com.chronoxor.enums.FBE.FinalModelEnumUInt16(buffer, 0);
            uint16b5 = new com.chronoxor.enums.FBE.FinalModelEnumUInt16(buffer, 0);
            int32b0 = new com.chronoxor.enums.FBE.FinalModelEnumInt32(buffer, 0);
            int32b1 = new com.chronoxor.enums.FBE.FinalModelEnumInt32(buffer, 0);
            int32b2 = new com.chronoxor.enums.FBE.FinalModelEnumInt32(buffer, 0);
            int32b3 = new com.chronoxor.enums.FBE.FinalModelEnumInt32(buffer, 0);
            int32b4 = new com.chronoxor.enums.FBE.FinalModelEnumInt32(buffer, 0);
            int32b5 = new com.chronoxor.enums.FBE.FinalModelEnumInt32(buffer, 0);
            uint32b0 = new com.chronoxor.enums.FBE.FinalModelEnumUInt32(buffer, 0);
            uint32b1 = new com.chronoxor.enums.FBE.FinalModelEnumUInt32(buffer, 0);
            uint32b2 = new com.chronoxor.enums.FBE.FinalModelEnumUInt32(buffer, 0);
            uint32b3 = new com.chronoxor.enums.FBE.FinalModelEnumUInt32(buffer, 0);
            uint32b4 = new com.chronoxor.enums.FBE.FinalModelEnumUInt32(buffer, 0);
            uint32b5 = new com.chronoxor.enums.FBE.FinalModelEnumUInt32(buffer, 0);
            int64b0 = new com.chronoxor.enums.FBE.FinalModelEnumInt64(buffer, 0);
            int64b1 = new com.chronoxor.enums.FBE.FinalModelEnumInt64(buffer, 0);
            int64b2 = new com.chronoxor.enums.FBE.FinalModelEnumInt64(buffer, 0);
            int64b3 = new com.chronoxor.enums.FBE.FinalModelEnumInt64(buffer, 0);
            int64b4 = new com.chronoxor.enums.FBE.FinalModelEnumInt64(buffer, 0);
            int64b5 = new com.chronoxor.enums.FBE.FinalModelEnumInt64(buffer, 0);
            uint64b0 = new com.chronoxor.enums.FBE.FinalModelEnumUInt64(buffer, 0);
            uint64b1 = new com.chronoxor.enums.FBE.FinalModelEnumUInt64(buffer, 0);
            uint64b2 = new com.chronoxor.enums.FBE.FinalModelEnumUInt64(buffer, 0);
            uint64b3 = new com.chronoxor.enums.FBE.FinalModelEnumUInt64(buffer, 0);
            uint64b4 = new com.chronoxor.enums.FBE.FinalModelEnumUInt64(buffer, 0);
            uint64b5 = new com.chronoxor.enums.FBE.FinalModelEnumUInt64(buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(Enums fbeValue)
        {
            long fbeResult = 0
                + byte0.FBEAllocationSize(fbeValue.byte0)
                + byte1.FBEAllocationSize(fbeValue.byte1)
                + byte2.FBEAllocationSize(fbeValue.byte2)
                + byte3.FBEAllocationSize(fbeValue.byte3)
                + byte4.FBEAllocationSize(fbeValue.byte4)
                + byte5.FBEAllocationSize(fbeValue.byte5)
                + char0.FBEAllocationSize(fbeValue.char0)
                + char1.FBEAllocationSize(fbeValue.char1)
                + char2.FBEAllocationSize(fbeValue.char2)
                + char3.FBEAllocationSize(fbeValue.char3)
                + char4.FBEAllocationSize(fbeValue.char4)
                + char5.FBEAllocationSize(fbeValue.char5)
                + wchar0.FBEAllocationSize(fbeValue.wchar0)
                + wchar1.FBEAllocationSize(fbeValue.wchar1)
                + wchar2.FBEAllocationSize(fbeValue.wchar2)
                + wchar3.FBEAllocationSize(fbeValue.wchar3)
                + wchar4.FBEAllocationSize(fbeValue.wchar4)
                + wchar5.FBEAllocationSize(fbeValue.wchar5)
                + int8b0.FBEAllocationSize(fbeValue.int8b0)
                + int8b1.FBEAllocationSize(fbeValue.int8b1)
                + int8b2.FBEAllocationSize(fbeValue.int8b2)
                + int8b3.FBEAllocationSize(fbeValue.int8b3)
                + int8b4.FBEAllocationSize(fbeValue.int8b4)
                + int8b5.FBEAllocationSize(fbeValue.int8b5)
                + uint8b0.FBEAllocationSize(fbeValue.uint8b0)
                + uint8b1.FBEAllocationSize(fbeValue.uint8b1)
                + uint8b2.FBEAllocationSize(fbeValue.uint8b2)
                + uint8b3.FBEAllocationSize(fbeValue.uint8b3)
                + uint8b4.FBEAllocationSize(fbeValue.uint8b4)
                + uint8b5.FBEAllocationSize(fbeValue.uint8b5)
                + int16b0.FBEAllocationSize(fbeValue.int16b0)
                + int16b1.FBEAllocationSize(fbeValue.int16b1)
                + int16b2.FBEAllocationSize(fbeValue.int16b2)
                + int16b3.FBEAllocationSize(fbeValue.int16b3)
                + int16b4.FBEAllocationSize(fbeValue.int16b4)
                + int16b5.FBEAllocationSize(fbeValue.int16b5)
                + uint16b0.FBEAllocationSize(fbeValue.uint16b0)
                + uint16b1.FBEAllocationSize(fbeValue.uint16b1)
                + uint16b2.FBEAllocationSize(fbeValue.uint16b2)
                + uint16b3.FBEAllocationSize(fbeValue.uint16b3)
                + uint16b4.FBEAllocationSize(fbeValue.uint16b4)
                + uint16b5.FBEAllocationSize(fbeValue.uint16b5)
                + int32b0.FBEAllocationSize(fbeValue.int32b0)
                + int32b1.FBEAllocationSize(fbeValue.int32b1)
                + int32b2.FBEAllocationSize(fbeValue.int32b2)
                + int32b3.FBEAllocationSize(fbeValue.int32b3)
                + int32b4.FBEAllocationSize(fbeValue.int32b4)
                + int32b5.FBEAllocationSize(fbeValue.int32b5)
                + uint32b0.FBEAllocationSize(fbeValue.uint32b0)
                + uint32b1.FBEAllocationSize(fbeValue.uint32b1)
                + uint32b2.FBEAllocationSize(fbeValue.uint32b2)
                + uint32b3.FBEAllocationSize(fbeValue.uint32b3)
                + uint32b4.FBEAllocationSize(fbeValue.uint32b4)
                + uint32b5.FBEAllocationSize(fbeValue.uint32b5)
                + int64b0.FBEAllocationSize(fbeValue.int64b0)
                + int64b1.FBEAllocationSize(fbeValue.int64b1)
                + int64b2.FBEAllocationSize(fbeValue.int64b2)
                + int64b3.FBEAllocationSize(fbeValue.int64b3)
                + int64b4.FBEAllocationSize(fbeValue.int64b4)
                + int64b5.FBEAllocationSize(fbeValue.int64b5)
                + uint64b0.FBEAllocationSize(fbeValue.uint64b0)
                + uint64b1.FBEAllocationSize(fbeValue.uint64b1)
                + uint64b2.FBEAllocationSize(fbeValue.uint64b2)
                + uint64b3.FBEAllocationSize(fbeValue.uint64b3)
                + uint64b4.FBEAllocationSize(fbeValue.uint64b4)
                + uint64b5.FBEAllocationSize(fbeValue.uint64b5)
                ;
            return fbeResult;
        }

        // Get the final type
        public const long FBETypeConst = 1;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override com.chronoxor.FBE.FinalModelValueType<Enums> Clone() { return new FinalModelEnums(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            byte0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = byte0.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            byte1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = byte1.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            byte2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = byte2.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            byte3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = byte3.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            byte4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = byte4.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            byte5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = byte5.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            char0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = char0.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            char1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = char1.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            char2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = char2.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            char3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = char3.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            char4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = char4.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            char5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = char5.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            wchar0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wchar0.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            wchar1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wchar1.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            wchar2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wchar2.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            wchar3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wchar3.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            wchar4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wchar4.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            wchar5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wchar5.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int8b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int8b0.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int8b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int8b1.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int8b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int8b2.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int8b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int8b3.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int8b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int8b4.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int8b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int8b5.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint8b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint8b0.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint8b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint8b1.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint8b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint8b2.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint8b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint8b3.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint8b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint8b4.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint8b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint8b5.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int16b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int16b0.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int16b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int16b1.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int16b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int16b2.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int16b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int16b3.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int16b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int16b4.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int16b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int16b5.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint16b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint16b0.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint16b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint16b1.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint16b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint16b2.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint16b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint16b3.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint16b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint16b4.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint16b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint16b5.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int32b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int32b0.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int32b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int32b1.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int32b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int32b2.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int32b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int32b3.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int32b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int32b4.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int32b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int32b5.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint32b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint32b0.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint32b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint32b1.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint32b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint32b2.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint32b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint32b3.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint32b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint32b4.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint32b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint32b5.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int64b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int64b0.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int64b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int64b1.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int64b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int64b2.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int64b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int64b3.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int64b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int64b4.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            int64b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int64b5.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint64b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint64b0.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint64b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint64b1.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint64b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint64b2.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint64b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint64b3.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint64b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint64b4.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            uint64b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint64b5.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out Enums fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out Enums fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = Enums.Default;

            byte0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = byte0.Get(out fbeValue.byte0);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            byte1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = byte1.Get(out fbeValue.byte1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            byte2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = byte2.Get(out fbeValue.byte2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            byte3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = byte3.Get(out fbeValue.byte3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            byte4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = byte4.Get(out fbeValue.byte4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            byte5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = byte5.Get(out fbeValue.byte5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            char0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = char0.Get(out fbeValue.char0);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            char1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = char1.Get(out fbeValue.char1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            char2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = char2.Get(out fbeValue.char2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            char3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = char3.Get(out fbeValue.char3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            char4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = char4.Get(out fbeValue.char4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            char5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = char5.Get(out fbeValue.char5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            wchar0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wchar0.Get(out fbeValue.wchar0);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            wchar1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wchar1.Get(out fbeValue.wchar1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            wchar2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wchar2.Get(out fbeValue.wchar2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            wchar3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wchar3.Get(out fbeValue.wchar3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            wchar4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wchar4.Get(out fbeValue.wchar4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            wchar5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wchar5.Get(out fbeValue.wchar5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int8b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int8b0.Get(out fbeValue.int8b0);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int8b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int8b1.Get(out fbeValue.int8b1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int8b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int8b2.Get(out fbeValue.int8b2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int8b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int8b3.Get(out fbeValue.int8b3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int8b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int8b4.Get(out fbeValue.int8b4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int8b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int8b5.Get(out fbeValue.int8b5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint8b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint8b0.Get(out fbeValue.uint8b0);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint8b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint8b1.Get(out fbeValue.uint8b1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint8b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint8b2.Get(out fbeValue.uint8b2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint8b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint8b3.Get(out fbeValue.uint8b3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint8b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint8b4.Get(out fbeValue.uint8b4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint8b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint8b5.Get(out fbeValue.uint8b5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int16b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int16b0.Get(out fbeValue.int16b0);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int16b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int16b1.Get(out fbeValue.int16b1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int16b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int16b2.Get(out fbeValue.int16b2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int16b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int16b3.Get(out fbeValue.int16b3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int16b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int16b4.Get(out fbeValue.int16b4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int16b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int16b5.Get(out fbeValue.int16b5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint16b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint16b0.Get(out fbeValue.uint16b0);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint16b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint16b1.Get(out fbeValue.uint16b1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint16b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint16b2.Get(out fbeValue.uint16b2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint16b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint16b3.Get(out fbeValue.uint16b3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint16b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint16b4.Get(out fbeValue.uint16b4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint16b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint16b5.Get(out fbeValue.uint16b5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int32b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int32b0.Get(out fbeValue.int32b0);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int32b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int32b1.Get(out fbeValue.int32b1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int32b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int32b2.Get(out fbeValue.int32b2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int32b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int32b3.Get(out fbeValue.int32b3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int32b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int32b4.Get(out fbeValue.int32b4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int32b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int32b5.Get(out fbeValue.int32b5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint32b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint32b0.Get(out fbeValue.uint32b0);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint32b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint32b1.Get(out fbeValue.uint32b1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint32b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint32b2.Get(out fbeValue.uint32b2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint32b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint32b3.Get(out fbeValue.uint32b3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint32b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint32b4.Get(out fbeValue.uint32b4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint32b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint32b5.Get(out fbeValue.uint32b5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int64b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int64b0.Get(out fbeValue.int64b0);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int64b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int64b1.Get(out fbeValue.int64b1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int64b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int64b2.Get(out fbeValue.int64b2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int64b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int64b3.Get(out fbeValue.int64b3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int64b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int64b4.Get(out fbeValue.int64b4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int64b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int64b5.Get(out fbeValue.int64b5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint64b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint64b0.Get(out fbeValue.uint64b0);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint64b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint64b1.Get(out fbeValue.uint64b1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint64b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint64b2.Get(out fbeValue.uint64b2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint64b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint64b3.Get(out fbeValue.uint64b3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint64b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint64b4.Get(out fbeValue.uint64b4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint64b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint64b5.Get(out fbeValue.uint64b5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(Enums fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(Enums fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            byte0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = byte0.Set(fbeValue.byte0);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            byte1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = byte1.Set(fbeValue.byte1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            byte2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = byte2.Set(fbeValue.byte2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            byte3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = byte3.Set(fbeValue.byte3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            byte4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = byte4.Set(fbeValue.byte4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            byte5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = byte5.Set(fbeValue.byte5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            char0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = char0.Set(fbeValue.char0);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            char1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = char1.Set(fbeValue.char1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            char2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = char2.Set(fbeValue.char2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            char3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = char3.Set(fbeValue.char3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            char4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = char4.Set(fbeValue.char4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            char5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = char5.Set(fbeValue.char5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            wchar0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wchar0.Set(fbeValue.wchar0);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            wchar1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wchar1.Set(fbeValue.wchar1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            wchar2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wchar2.Set(fbeValue.wchar2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            wchar3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wchar3.Set(fbeValue.wchar3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            wchar4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wchar4.Set(fbeValue.wchar4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            wchar5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wchar5.Set(fbeValue.wchar5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int8b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int8b0.Set(fbeValue.int8b0);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int8b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int8b1.Set(fbeValue.int8b1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int8b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int8b2.Set(fbeValue.int8b2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int8b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int8b3.Set(fbeValue.int8b3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int8b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int8b4.Set(fbeValue.int8b4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int8b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int8b5.Set(fbeValue.int8b5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint8b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint8b0.Set(fbeValue.uint8b0);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint8b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint8b1.Set(fbeValue.uint8b1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint8b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint8b2.Set(fbeValue.uint8b2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint8b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint8b3.Set(fbeValue.uint8b3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint8b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint8b4.Set(fbeValue.uint8b4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint8b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint8b5.Set(fbeValue.uint8b5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int16b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int16b0.Set(fbeValue.int16b0);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int16b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int16b1.Set(fbeValue.int16b1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int16b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int16b2.Set(fbeValue.int16b2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int16b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int16b3.Set(fbeValue.int16b3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int16b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int16b4.Set(fbeValue.int16b4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int16b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int16b5.Set(fbeValue.int16b5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint16b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint16b0.Set(fbeValue.uint16b0);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint16b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint16b1.Set(fbeValue.uint16b1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint16b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint16b2.Set(fbeValue.uint16b2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint16b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint16b3.Set(fbeValue.uint16b3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint16b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint16b4.Set(fbeValue.uint16b4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint16b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint16b5.Set(fbeValue.uint16b5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int32b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int32b0.Set(fbeValue.int32b0);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int32b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int32b1.Set(fbeValue.int32b1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int32b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int32b2.Set(fbeValue.int32b2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int32b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int32b3.Set(fbeValue.int32b3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int32b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int32b4.Set(fbeValue.int32b4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int32b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int32b5.Set(fbeValue.int32b5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint32b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint32b0.Set(fbeValue.uint32b0);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint32b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint32b1.Set(fbeValue.uint32b1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint32b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint32b2.Set(fbeValue.uint32b2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint32b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint32b3.Set(fbeValue.uint32b3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint32b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint32b4.Set(fbeValue.uint32b4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint32b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint32b5.Set(fbeValue.uint32b5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int64b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int64b0.Set(fbeValue.int64b0);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int64b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int64b1.Set(fbeValue.int64b1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int64b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int64b2.Set(fbeValue.int64b2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int64b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int64b3.Set(fbeValue.int64b3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int64b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int64b4.Set(fbeValue.int64b4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            int64b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = int64b5.Set(fbeValue.int64b5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint64b0.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint64b0.Set(fbeValue.uint64b0);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint64b1.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint64b1.Set(fbeValue.uint64b1);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint64b2.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint64b2.Set(fbeValue.uint64b2);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint64b3.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint64b3.Set(fbeValue.uint64b3);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint64b4.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint64b4.Set(fbeValue.uint64b4);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            uint64b5.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uint64b5.Set(fbeValue.uint64b5);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums.FBE {

    using global::com.chronoxor.enums;

    // Fast Binary Encoding Enums final model
    public class EnumsFinalModel : com.chronoxor.FBE.Model
    {
        private readonly FinalModelEnums _model;

        public EnumsFinalModel() { _model = new FinalModelEnums(Buffer, 8); }
        public EnumsFinalModel(com.chronoxor.FBE.Buffer buffer) : base(buffer) { _model = new FinalModelEnums(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelEnums.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(Enums value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out Enums value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = Enums.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = Enums.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums.FBE {

    // Fast Binary Encoding com.chronoxor.enums protocol version
    public static class ProtocolVersion
    {
        // Protocol major version
        public const int Major = 1;
        // Protocol minor version
        public const int Minor = 0;
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums.FBE {

    // Fast Binary Encoding com.chronoxor.enums sender listener interface
    public interface ISenderListener : com.chronoxor.FBE.ISenderListener
    {
    }

    // Fast Binary Encoding com.chronoxor.enums sender
    public class Sender : com.chronoxor.FBE.Sender, ISenderListener
    {
        // Sender models accessors

        public Sender() : base(false)
        {
        }
        public Sender(com.chronoxor.FBE.Buffer buffer) : base(buffer, false)
        {
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(ISenderListener listener, object obj)
        {
            switch (obj)
            {
                default: break;
            }

            return 0;
        }

    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums.FBE {

    // Fast Binary Encoding com.chronoxor.enums receiver listener interface
    public interface IReceiverListener : com.chronoxor.FBE.IReceiverListener
    {
        // Receive handlers
    }

    // Fast Binary Encoding com.chronoxor.enums receiver
    public class Receiver : com.chronoxor.FBE.Receiver, IReceiverListener
    {
        // Receiver values accessors

        // Receiver models accessors

        public Receiver() : base(false)
        {
        }
        public Receiver(com.chronoxor.FBE.Buffer buffer) : base(buffer, false)
        {
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IReceiverListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                default: break;
            }

            return false;
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums.FBE {

    // Fast Binary Encoding com.chronoxor.enums proxy listener interface
    public interface IProxyListener : com.chronoxor.FBE.IReceiverListener
    {
        // Proxy handlers
    }

    // Fast Binary Encoding com.chronoxor.enums proxy
    public class Proxy : com.chronoxor.FBE.Receiver, IProxyListener
    {
        // Proxy models accessors

        public Proxy() : base(false)
        {
        }
        public Proxy(com.chronoxor.FBE.Buffer buffer) : base(buffer, false)
        {
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IProxyListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                default: break;
            }

            return false;
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums.FBE {

    // Fast Binary Encoding com.chronoxor.enums client listener interface
    public interface IClientListener : com.chronoxor.FBE.IClientListener, ISenderListener, IReceiverListener
    {
    }

    // Fast Binary Encoding com.chronoxor.enums client
    public class Client : com.chronoxor.FBE.Client, IClientListener
    {
        // Client sender models accessors

        // Client receiver values accessors

        // Client receiver models accessors

        public Client() : base(false)
        {
        }
        public Client(com.chronoxor.FBE.Buffer sendBuffer, com.chronoxor.FBE.Buffer receiveBuffer) : base(sendBuffer, receiveBuffer, false)
        {
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(IClientListener listener, object obj)
        {
            switch (obj)
            {
                default: break;
            }

            return 0;
        }


        // Reset client requests
        internal override void ResetRequests()
        {
            base.ResetRequests();
        }

        // Watchdog client requests for timeouts
        internal override void WatchdogRequests(DateTime utc)
        {
            base.WatchdogRequests(utc);
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IClientListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                default: break;
            }

            return false;
        }

    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums.FBE {

    // Fast Binary Encoding com.chronoxor.enums final sender listener interface
    public interface IFinalSenderListener : com.chronoxor.FBE.ISenderListener
    {
    }

    // Fast Binary Encoding com.chronoxor.enums final sender
    public class FinalSender : com.chronoxor.FBE.Sender, IFinalSenderListener
    {
        // Sender models accessors

        public FinalSender() : base(true)
        {
        }
        public FinalSender(com.chronoxor.FBE.Buffer buffer) : base(buffer, true)
        {
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(IFinalSenderListener listener, object obj)
        {
            switch (obj)
            {
                default: break;
            }

            return 0;
        }

    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums.FBE {

    // Fast Binary Encoding com.chronoxor.enums final receiver listener interface
    public interface IFinalReceiverListener : com.chronoxor.FBE.IReceiverListener
    {
        // Receive handlers
    }

    // Fast Binary Encoding com.chronoxor.enums final receiver
    public class FinalReceiver : com.chronoxor.FBE.Receiver, IFinalReceiverListener
    {
        // Receiver values accessors

        // Receiver models accessors

        public FinalReceiver() : base(true)
        {
        }
        public FinalReceiver(com.chronoxor.FBE.Buffer buffer) : base(buffer, true)
        {
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IFinalReceiverListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                default: break;
            }

            return false;
        }
    }

} // namespace com.chronoxor.enums.FBE

namespace com.chronoxor.enums.FBE {

    // Fast Binary Encoding com.chronoxor.enums final client listener interface
    public interface IFinalClientListener : com.chronoxor.FBE.IClientListener, IFinalSenderListener, IFinalReceiverListener
    {
    }

    // Fast Binary Encoding com.chronoxor.enums final client
    public class FinalClient : com.chronoxor.FBE.Client, IFinalClientListener
    {
        // Client sender models accessors

        // Client receiver values accessors

        // Client receiver models accessors

        public FinalClient() : base(true)
        {
        }
        public FinalClient(com.chronoxor.FBE.Buffer sendBuffer, com.chronoxor.FBE.Buffer receiveBuffer) : base(sendBuffer, receiveBuffer, true)
        {
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(IFinalClientListener listener, object obj)
        {
            switch (obj)
            {
                default: break;
            }

            return 0;
        }


        // Reset client requests
        internal override void ResetRequests()
        {
            base.ResetRequests();
        }

        // Watchdog client requests for timeouts
        internal override void WatchdogRequests(DateTime utc)
        {
            base.WatchdogRequests(utc);
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IFinalClientListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                default: break;
            }

            return false;
        }

    }

} // namespace com.chronoxor.enums.FBE
