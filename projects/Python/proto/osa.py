#------------------------------------------------------------------------------
# Automatically generated by the Fast Binary Encoding compiler, do not modify!
# https://github.com/chronoxor/FastBinaryEncoding
# Source: osa.fbe
# FBE version: 1.10.0.0
#------------------------------------------------------------------------------

import base64
import decimal
import enum
import functools
import json
import sys
import uuid

import fbe


class Sex(enum.IntEnum, metaclass=fbe.DefaultEnumMeta):
    male = int(0) + 0
    female = int(0) + 1
    unknown = ~0

    __slots__ = ()

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        if self.value == Sex.male:
            return "male"
        if self.value == Sex.female:
            return "female"
        return "<unknown>"

    @classmethod
    def _missing_(cls, value):
        return Sex.unknown

    @staticmethod
    def __from_json__(value):
        if value is None:
            return None
        return Sex(value)


# Fast Binary Encoding Sex field model
class FieldModelSex(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the value
    def get(self, defaults=None):
        if defaults is None:
            defaults = Sex()

        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return defaults

        return Sex(self.read_int32(self.fbe_offset))

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        self.write_int32(self.fbe_offset, value)


# Fast Binary Encoding Sex final model
class FinalModelSex(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    # noinspection PyUnusedLocal
    def fbe_allocation_size(self, value):
        return self.fbe_size

    # Get the final size
    @property
    def fbe_size(self):
        return 4

    # Check if the value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return sys.maxsize

        return self.fbe_size

    # Get the value
    def get(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return Sex(), 0

        return Sex(self.read_int32(self.fbe_offset)), self.fbe_size

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        self.write_int32(self.fbe_offset, value)
        return self.fbe_size


class MyFLags(enum.IntEnum, metaclass=fbe.DefaultEnumMeta):
    flag0 = int(0x00) + 0
    flag1 = int(0x01) + 0
    flag2 = int(0x02) + 0
    unknown = ~0

    __slots__ = ()

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        if self.value == MyFLags.flag0:
            return "flag0"
        if self.value == MyFLags.flag1:
            return "flag1"
        if self.value == MyFLags.flag2:
            return "flag2"
        return "<unknown>"

    @classmethod
    def _missing_(cls, value):
        return MyFLags.unknown

    @staticmethod
    def __from_json__(value):
        if value is None:
            return None
        return MyFLags(value)


# Fast Binary Encoding MyFLags field model
class FieldModelMyFLags(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the value
    def get(self, defaults=None):
        if defaults is None:
            defaults = MyFLags()

        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return defaults

        return MyFLags(self.read_int32(self.fbe_offset))

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        self.write_int32(self.fbe_offset, value)


# Fast Binary Encoding MyFLags final model
class FinalModelMyFLags(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    # noinspection PyUnusedLocal
    def fbe_allocation_size(self, value):
        return self.fbe_size

    # Get the final size
    @property
    def fbe_size(self):
        return 4

    # Check if the value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return sys.maxsize

        return self.fbe_size

    # Get the value
    def get(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return MyFLags(), 0

        return MyFLags(self.read_int32(self.fbe_offset)), self.fbe_size

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        self.write_int32(self.fbe_offset, value)
        return self.fbe_size


@functools.total_ordering
class Extra(object):
    __slots__ = "name", "detail", "sex", "flag", 

    def __init__(self, name="", detail="", sex=None, flag=None):
        if sex is None:
            sex = Sex()
        if flag is None:
            flag = MyFLags()
        self.name = name
        self.detail = detail
        self.sex = sex
        self.flag = flag

    # Struct shallow copy
    def copy(self, other):
        self.name = other.name
        self.detail = other.detail
        self.sex = other.sex
        self.flag = other.flag
        return self

    # Struct deep clone
    def clone(self):
        # Serialize the struct to the FBE stream
        writer = ExtraModel(fbe.WriteBuffer())
        writer.serialize(self)

        # Deserialize the struct from the FBE stream
        reader = ExtraModel(fbe.ReadBuffer())
        reader.attach_buffer(writer.buffer)
        return reader.deserialize()[0]

    def __eq__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return True

    def __lt__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return False

    @property
    def __key__(self):
        return ()

    def __hash__(self):
        return hash(self.__key__)

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        sb = list()
        sb.append("Extra(")
        sb.append("name=")
        if self.name is not None:
            sb.append("\"" + str(self.name) + "\"")
        else:
            sb.append("null")
        sb.append(",detail=")
        if self.detail is not None:
            sb.append("\"" + str(self.detail) + "\"")
        else:
            sb.append("null")
        sb.append(",sex=")
        sb.append(str(self.sex))
        sb.append(",flag=")
        sb.append(str(self.flag))
        sb.append(")")
        return "".join(sb)

    # Get struct JSON value
    def to_json(self):
        return json.dumps(self.__to_json__(), cls=fbe.JSONEncoder, separators=(',', ':'))

    def __to_json__(self):
        result = dict()
        result.update(dict(
            name=self.name, 
            detail=self.detail, 
            sex=self.sex, 
            flag=self.flag, 
        ))
        return result

    # Create struct from JSON value
    @staticmethod
    def from_json(document):
        return Extra.__from_json__(json.loads(document))

    @staticmethod
    def __from_json__(fields):
        if fields is None:
            return None
        return Extra(
            None if "name" not in fields else fields["name"],
            None if "detail" not in fields else fields["detail"],
            None if "sex" not in fields else Sex.__from_json__(fields["sex"]),
            None if "flag" not in fields else MyFLags.__from_json__(fields["flag"]),
        )

    # Get the FBE type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 1


class FieldModelExtra(fbe.FieldModel):
    __slots__ = "_name", "_detail", "_sex", "_flag", 

    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)
        self._name = fbe.FieldModelString(buffer, 4 + 4)
        self._detail = fbe.FieldModelString(buffer, self._name.fbe_offset + self._name.fbe_size)
        self._sex = FieldModelSex(buffer, self._detail.fbe_offset + self._detail.fbe_size)
        self._flag = FieldModelMyFLags(buffer, self._sex.fbe_offset + self._sex.fbe_size)

    @property
    def name(self):
        return self._name

    @property
    def detail(self):
        return self._detail

    @property
    def sex(self):
        return self._sex

    @property
    def flag(self):
        return self._flag

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the field body size
    @property
    def fbe_body(self):
        fbe_result = 4 + 4 \
            + self.name.fbe_size \
            + self.detail.fbe_size \
            + self.sex.fbe_size \
            + self.flag.fbe_size \

        return fbe_result

    # Get the field extra size
    @property
    def fbe_extra(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4) > self._buffer.size):
            return 0

        self._buffer.shift(fbe_struct_offset)

        fbe_result = self.fbe_body \
            + self.name.fbe_extra \
            + self.detail.fbe_extra \
            + self.sex.fbe_extra \
            + self.flag.fbe_extra \

        self._buffer.unshift(fbe_struct_offset)

        return fbe_result

    # Get the field type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 1

    # Check if the struct value is valid
    def verify(self, fbe_verify_type=True):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return True

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return False

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        if fbe_struct_size < (4 + 4):
            return False

        fbe_struct_type = self.read_uint32(fbe_struct_offset + 4)
        if fbe_verify_type and (fbe_struct_type != self.fbe_type):
            return False

        self._buffer.shift(fbe_struct_offset)
        fbe_result = self.verify_fields(fbe_struct_size)
        self._buffer.unshift(fbe_struct_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self, fbe_struct_size):
        fbe_current_size = 4 + 4

        if (fbe_current_size + self.name.fbe_size) > fbe_struct_size:
            return True
        if not self.name.verify():
            return False
        fbe_current_size += self.name.fbe_size

        if (fbe_current_size + self.detail.fbe_size) > fbe_struct_size:
            return True
        if not self.detail.verify():
            return False
        fbe_current_size += self.detail.fbe_size

        if (fbe_current_size + self.sex.fbe_size) > fbe_struct_size:
            return True
        if not self.sex.verify():
            return False
        fbe_current_size += self.sex.fbe_size

        if (fbe_current_size + self.flag.fbe_size) > fbe_struct_size:
            return True
        if not self.flag.verify():
            return False
        fbe_current_size += self.flag.fbe_size

        return True

    # Get the struct value (begin phase)
    def get_begin(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + 4 + 4) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return 0

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        assert (fbe_struct_size >= (4 + 4)), "Model is broken!"
        if fbe_struct_size < (4 + 4):
            return 0

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Get the struct value (end phase)
    def get_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = Extra()

        fbe_begin = self.get_begin()
        if fbe_begin == 0:
            return fbe_value

        fbe_struct_size = self.read_uint32(0)
        self.get_fields(fbe_value, fbe_struct_size)
        self.get_end(fbe_begin)
        return fbe_value

    # Get the struct fields values
    def get_fields(self, fbe_value, fbe_struct_size):
        fbe_current_size = 4 + 4

        if (fbe_current_size + self.name.fbe_size) <= fbe_struct_size:
            fbe_value.name = self.name.get()
        else:
            fbe_value.name = ""
        fbe_current_size += self.name.fbe_size

        if (fbe_current_size + self.detail.fbe_size) <= fbe_struct_size:
            fbe_value.detail = self.detail.get()
        else:
            fbe_value.detail = ""
        fbe_current_size += self.detail.fbe_size

        if (fbe_current_size + self.sex.fbe_size) <= fbe_struct_size:
            fbe_value.sex = self.sex.get()
        else:
            fbe_value.sex = Sex()
        fbe_current_size += self.sex.fbe_size

        if (fbe_current_size + self.flag.fbe_size) <= fbe_struct_size:
            fbe_value.flag = self.flag.get()
        else:
            fbe_value.flag = MyFLags()
        fbe_current_size += self.flag.fbe_size

    # Set the struct value (begin phase)
    def set_begin(self):
        assert (self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size, "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_size = self.fbe_body
        fbe_struct_offset = self._buffer.allocate(fbe_struct_size) - self._buffer.offset
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset <= 0) or ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) > self._buffer.size):
            return 0

        self.write_uint32(self.fbe_offset, fbe_struct_offset)
        self.write_uint32(fbe_struct_offset, fbe_struct_size)
        self.write_uint32(fbe_struct_offset + 4, self.fbe_type)

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Set the struct value (end phase)
    def set_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Set the struct value
    def set(self, fbe_value):
        fbe_begin = self.set_begin()
        if fbe_begin == 0:
            return

        self.set_fields(fbe_value)
        self.set_end(fbe_begin)

    # Set the struct fields values
    def set_fields(self, fbe_value):
        self.name.set(fbe_value.name)
        self.detail.set(fbe_value.detail)
        self.sex.set(fbe_value.sex)
        self.flag.set(fbe_value.flag)


# Fast Binary Encoding Extra model
class ExtraModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FieldModelExtra(self.buffer, 4)

    @property
    def model(self):
        return self._model

    # Get the model size
    @property
    def fbe_size(self):
        return self._model.fbe_size + self._model.fbe_extra

    # Get the model type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = FieldModelExtra.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            return False

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        if fbe_full_size < self._model.fbe_size:
            return False

        return self._model.verify()

    # Create a new model (begin phase)
    def create_begin(self):
        fbe_begin = self.buffer.allocate(4 + self._model.fbe_size)
        return fbe_begin

    # Create a new model (end phase)
    def create_end(self, fbe_begin):
        fbe_end = self.buffer.size
        fbe_full_size = fbe_end - fbe_begin
        self.write_uint32(self._model.fbe_offset - 4, fbe_full_size)
        return fbe_full_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_begin = self.create_begin()
        self._model.set(value)
        fbe_full_size = self.create_end(fbe_begin)
        return fbe_full_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = Extra()

        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            value = Extra()
            return value, 0

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        assert (fbe_full_size >= self._model.fbe_size), "Model is broken!"
        if fbe_full_size < self._model.fbe_size:
            value = Extra()
            return value, 0

        self._model.get(value)
        return value, fbe_full_size

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


class FinalModelExtra(fbe.FinalModel):
    __slots__ = "_name", "_detail", "_sex", "_flag", 

    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)
        self._name = fbe.FinalModelString(buffer, 0)
        self._detail = fbe.FinalModelString(buffer, 0)
        self._sex = FinalModelSex(buffer, 0)
        self._flag = FinalModelMyFLags(buffer, 0)

    @property
    def name(self):
        return self._name

    @property
    def detail(self):
        return self._detail

    @property
    def sex(self):
        return self._sex

    @property
    def flag(self):
        return self._flag

    # Get the allocation size
    def fbe_allocation_size(self, fbe_value):
        fbe_result = 0 \
            + self.name.fbe_allocation_size(fbe_value.name) \
            + self.detail.fbe_allocation_size(fbe_value.detail) \
            + self.sex.fbe_allocation_size(fbe_value.sex) \
            + self.flag.fbe_allocation_size(fbe_value.flag) \

        return fbe_result

    # Get the final type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 1

    # Check if the struct value is valid
    def verify(self):
        self._buffer.shift(self.fbe_offset)
        fbe_result = self.verify_fields()
        self._buffer.unshift(self.fbe_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self):
        fbe_current_offset = 0

        self.name.fbe_offset = fbe_current_offset
        fbe_field_size = self.name.verify()
        if fbe_field_size == sys.maxsize:
            return sys.maxsize
        fbe_current_offset += fbe_field_size

        self.detail.fbe_offset = fbe_current_offset
        fbe_field_size = self.detail.verify()
        if fbe_field_size == sys.maxsize:
            return sys.maxsize
        fbe_current_offset += fbe_field_size

        self.sex.fbe_offset = fbe_current_offset
        fbe_field_size = self.sex.verify()
        if fbe_field_size == sys.maxsize:
            return sys.maxsize
        fbe_current_offset += fbe_field_size

        self.flag.fbe_offset = fbe_current_offset
        fbe_field_size = self.flag.verify()
        if fbe_field_size == sys.maxsize:
            return sys.maxsize
        fbe_current_offset += fbe_field_size

        return fbe_current_offset

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = Extra()

        self._buffer.shift(self.fbe_offset)
        fbe_size = self.get_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_value, fbe_size

    # Get the struct fields values
    def get_fields(self, fbe_value):
        fbe_current_offset = 0
        fbe_current_size = 0

        self.name.fbe_offset = fbe_current_offset
        fbe_result = self.name.get()
        fbe_value.name = fbe_result[0]
        fbe_current_offset += fbe_result[1]
        fbe_current_size += fbe_result[1]

        self.detail.fbe_offset = fbe_current_offset
        fbe_result = self.detail.get()
        fbe_value.detail = fbe_result[0]
        fbe_current_offset += fbe_result[1]
        fbe_current_size += fbe_result[1]

        self.sex.fbe_offset = fbe_current_offset
        fbe_result = self.sex.get()
        fbe_value.sex = fbe_result[0]
        fbe_current_offset += fbe_result[1]
        fbe_current_size += fbe_result[1]

        self.flag.fbe_offset = fbe_current_offset
        fbe_result = self.flag.get()
        fbe_value.flag = fbe_result[0]
        fbe_current_offset += fbe_result[1]
        fbe_current_size += fbe_result[1]

        return fbe_current_size

    # Set the struct value
    def set(self, fbe_value):
        self._buffer.shift(self.fbe_offset)
        fbe_size = self.set_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_size

    # Set the struct fields values
    def set_fields(self, fbe_value):
        fbe_current_offset = 0
        fbe_current_size = 0

        self.name.fbe_offset = fbe_current_offset
        fbe_field_size = self.name.set(fbe_value.name)
        fbe_current_offset += fbe_field_size
        fbe_current_size += fbe_field_size

        self.detail.fbe_offset = fbe_current_offset
        fbe_field_size = self.detail.set(fbe_value.detail)
        fbe_current_offset += fbe_field_size
        fbe_current_size += fbe_field_size

        self.sex.fbe_offset = fbe_current_offset
        fbe_field_size = self.sex.set(fbe_value.sex)
        fbe_current_offset += fbe_field_size
        fbe_current_size += fbe_field_size

        self.flag.fbe_offset = fbe_current_offset
        fbe_field_size = self.flag.set(fbe_value.flag)
        fbe_current_offset += fbe_field_size
        fbe_current_size += fbe_field_size

        return fbe_current_size


# Fast Binary Encoding Extra final model
class ExtraFinalModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FinalModelExtra(self.buffer, 8)

    # Get the model type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = FinalModelExtra.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return False

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return False

        return (8 + self._model.verify()) == fbe_struct_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_initial_size = self.buffer.size

        fbe_struct_type = self.fbe_type
        fbe_struct_size = 8 + self._model.fbe_allocation_size(value)
        fbe_struct_offset = self.buffer.allocate(fbe_struct_size) - self.buffer.offset
        assert ((self.buffer.offset + fbe_struct_offset + fbe_struct_size) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + fbe_struct_offset + fbe_struct_size) > self.buffer.size:
            return 0

        fbe_struct_size = 8 + self._model.set(value)
        self.buffer.resize(fbe_initial_size + fbe_struct_size)

        self.write_uint32(self._model.fbe_offset - 8, fbe_struct_size)
        self.write_uint32(self._model.fbe_offset - 4, fbe_struct_type)

        return fbe_struct_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = Extra()

        assert ((self.buffer.offset + self._model.fbe_offset) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return Extra(), 0

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        assert ((fbe_struct_size > 0) and (fbe_struct_type == self.fbe_type)), "Model is broken!"
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return Extra(), 8

        fbe_result = self._model.get(value)
        return fbe_result[0], (8 + fbe_result[1])

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


@functools.total_ordering
class Simple(object):
    __slots__ = "name", "depth", "sa", "sex", 

    def __init__(self, name="", depth=0, sa=None, sex=None):
        if sa is None:
            sa = [Extra()]*1
        if sex is None:
            sex = Sex()
        self.name = name
        self.depth = depth
        self.sa = sa
        self.sex = sex

    # Struct shallow copy
    def copy(self, other):
        self.name = other.name
        self.depth = other.depth
        self.sa = other.sa
        self.sex = other.sex
        return self

    # Struct deep clone
    def clone(self):
        # Serialize the struct to the FBE stream
        writer = SimpleModel(fbe.WriteBuffer())
        writer.serialize(self)

        # Deserialize the struct from the FBE stream
        reader = SimpleModel(fbe.ReadBuffer())
        reader.attach_buffer(writer.buffer)
        return reader.deserialize()[0]

    def __eq__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return True

    def __lt__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return False

    @property
    def __key__(self):
        return ()

    def __hash__(self):
        return hash(self.__key__)

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        sb = list()
        sb.append("Simple(")
        sb.append("name=")
        if self.name is not None:
            sb.append("\"" + str(self.name) + "\"")
        else:
            sb.append("null")
        sb.append(",depth=")
        sb.append(str(self.depth))
        sb.append(",sa=")
        if self.sa is not None:
            first = True
            sb.append("[" + str(len(self.sa)) + "][")
            for item in self.sa:
                sb.append("" if first else ",")
                sb.append(str(item))
                first = False
            sb.append("]")
        else:
            sb.append("[0][]")
        sb.append(",sex=")
        sb.append(str(self.sex))
        sb.append(")")
        return "".join(sb)

    # Get struct JSON value
    def to_json(self):
        return json.dumps(self.__to_json__(), cls=fbe.JSONEncoder, separators=(',', ':'))

    def __to_json__(self):
        result = dict()
        result.update(dict(
            name=self.name, 
            depth=self.depth, 
            sa=self.sa, 
            sex=self.sex, 
        ))
        return result

    # Create struct from JSON value
    @staticmethod
    def from_json(document):
        return Simple.__from_json__(json.loads(document))

    @staticmethod
    def __from_json__(fields):
        if fields is None:
            return None
        return Simple(
            None if "name" not in fields else fields["name"],
            None if "depth" not in fields else fields["depth"],
            None if "sa" not in fields else [Extra.__from_json__(value) for value in fields["sa"]],
            None if "sex" not in fields else Sex.__from_json__(fields["sex"]),
        )

    # Get the FBE type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 2


class FieldModelSimple(fbe.FieldModel):
    __slots__ = "_name", "_depth", "_sa", "_sex", 

    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)
        self._name = fbe.FieldModelString(buffer, 4 + 4)
        self._depth = fbe.FieldModelInt32(buffer, self._name.fbe_offset + self._name.fbe_size)
        self._sa = fbe.FieldModelArray(FieldModelExtra(buffer, self._depth.fbe_offset + self._depth.fbe_size), buffer, self._depth.fbe_offset + self._depth.fbe_size, 1)
        self._sex = FieldModelSex(buffer, self._sa.fbe_offset + self._sa.fbe_size)

    @property
    def name(self):
        return self._name

    @property
    def depth(self):
        return self._depth

    @property
    def sa(self):
        return self._sa

    @property
    def sex(self):
        return self._sex

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the field body size
    @property
    def fbe_body(self):
        fbe_result = 4 + 4 \
            + self.name.fbe_size \
            + self.depth.fbe_size \
            + self.sa.fbe_size \
            + self.sex.fbe_size \

        return fbe_result

    # Get the field extra size
    @property
    def fbe_extra(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4) > self._buffer.size):
            return 0

        self._buffer.shift(fbe_struct_offset)

        fbe_result = self.fbe_body \
            + self.name.fbe_extra \
            + self.depth.fbe_extra \
            + self.sa.fbe_extra \
            + self.sex.fbe_extra \

        self._buffer.unshift(fbe_struct_offset)

        return fbe_result

    # Get the field type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 2

    # Check if the struct value is valid
    def verify(self, fbe_verify_type=True):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return True

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return False

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        if fbe_struct_size < (4 + 4):
            return False

        fbe_struct_type = self.read_uint32(fbe_struct_offset + 4)
        if fbe_verify_type and (fbe_struct_type != self.fbe_type):
            return False

        self._buffer.shift(fbe_struct_offset)
        fbe_result = self.verify_fields(fbe_struct_size)
        self._buffer.unshift(fbe_struct_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self, fbe_struct_size):
        fbe_current_size = 4 + 4

        if (fbe_current_size + self.name.fbe_size) > fbe_struct_size:
            return True
        if not self.name.verify():
            return False
        fbe_current_size += self.name.fbe_size

        if (fbe_current_size + self.depth.fbe_size) > fbe_struct_size:
            return True
        if not self.depth.verify():
            return False
        fbe_current_size += self.depth.fbe_size

        if (fbe_current_size + self.sa.fbe_size) > fbe_struct_size:
            return True
        if not self.sa.verify():
            return False
        fbe_current_size += self.sa.fbe_size

        if (fbe_current_size + self.sex.fbe_size) > fbe_struct_size:
            return True
        if not self.sex.verify():
            return False
        fbe_current_size += self.sex.fbe_size

        return True

    # Get the struct value (begin phase)
    def get_begin(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + 4 + 4) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return 0

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        assert (fbe_struct_size >= (4 + 4)), "Model is broken!"
        if fbe_struct_size < (4 + 4):
            return 0

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Get the struct value (end phase)
    def get_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = Simple()

        fbe_begin = self.get_begin()
        if fbe_begin == 0:
            return fbe_value

        fbe_struct_size = self.read_uint32(0)
        self.get_fields(fbe_value, fbe_struct_size)
        self.get_end(fbe_begin)
        return fbe_value

    # Get the struct fields values
    def get_fields(self, fbe_value, fbe_struct_size):
        fbe_current_size = 4 + 4

        if (fbe_current_size + self.name.fbe_size) <= fbe_struct_size:
            fbe_value.name = self.name.get()
        else:
            fbe_value.name = ""
        fbe_current_size += self.name.fbe_size

        if (fbe_current_size + self.depth.fbe_size) <= fbe_struct_size:
            fbe_value.depth = self.depth.get()
        else:
            fbe_value.depth = 0
        fbe_current_size += self.depth.fbe_size

        if (fbe_current_size + self.sa.fbe_size) <= fbe_struct_size:
            self.sa.get(fbe_value.sa)
        else:
            fbe_value.sa.clear()
        fbe_current_size += self.sa.fbe_size

        if (fbe_current_size + self.sex.fbe_size) <= fbe_struct_size:
            fbe_value.sex = self.sex.get()
        else:
            fbe_value.sex = Sex()
        fbe_current_size += self.sex.fbe_size

    # Set the struct value (begin phase)
    def set_begin(self):
        assert (self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size, "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_size = self.fbe_body
        fbe_struct_offset = self._buffer.allocate(fbe_struct_size) - self._buffer.offset
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset <= 0) or ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) > self._buffer.size):
            return 0

        self.write_uint32(self.fbe_offset, fbe_struct_offset)
        self.write_uint32(fbe_struct_offset, fbe_struct_size)
        self.write_uint32(fbe_struct_offset + 4, self.fbe_type)

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Set the struct value (end phase)
    def set_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Set the struct value
    def set(self, fbe_value):
        fbe_begin = self.set_begin()
        if fbe_begin == 0:
            return

        self.set_fields(fbe_value)
        self.set_end(fbe_begin)

    # Set the struct fields values
    def set_fields(self, fbe_value):
        self.name.set(fbe_value.name)
        self.depth.set(fbe_value.depth)
        self.sa.set(fbe_value.sa)
        self.sex.set(fbe_value.sex)


# Fast Binary Encoding Simple model
class SimpleModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FieldModelSimple(self.buffer, 4)

    @property
    def model(self):
        return self._model

    # Get the model size
    @property
    def fbe_size(self):
        return self._model.fbe_size + self._model.fbe_extra

    # Get the model type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = FieldModelSimple.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            return False

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        if fbe_full_size < self._model.fbe_size:
            return False

        return self._model.verify()

    # Create a new model (begin phase)
    def create_begin(self):
        fbe_begin = self.buffer.allocate(4 + self._model.fbe_size)
        return fbe_begin

    # Create a new model (end phase)
    def create_end(self, fbe_begin):
        fbe_end = self.buffer.size
        fbe_full_size = fbe_end - fbe_begin
        self.write_uint32(self._model.fbe_offset - 4, fbe_full_size)
        return fbe_full_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_begin = self.create_begin()
        self._model.set(value)
        fbe_full_size = self.create_end(fbe_begin)
        return fbe_full_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = Simple()

        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            value = Simple()
            return value, 0

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        assert (fbe_full_size >= self._model.fbe_size), "Model is broken!"
        if fbe_full_size < self._model.fbe_size:
            value = Simple()
            return value, 0

        self._model.get(value)
        return value, fbe_full_size

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


class FinalModelSimple(fbe.FinalModel):
    __slots__ = "_name", "_depth", "_sa", "_sex", 

    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)
        self._name = fbe.FinalModelString(buffer, 0)
        self._depth = fbe.FinalModelInt32(buffer, 0)
        self._sa = fbe.FinalModelArray(FinalModelExtra(buffer, 0), buffer, 0, 1)
        self._sex = FinalModelSex(buffer, 0)

    @property
    def name(self):
        return self._name

    @property
    def depth(self):
        return self._depth

    @property
    def sa(self):
        return self._sa

    @property
    def sex(self):
        return self._sex

    # Get the allocation size
    def fbe_allocation_size(self, fbe_value):
        fbe_result = 0 \
            + self.name.fbe_allocation_size(fbe_value.name) \
            + self.depth.fbe_allocation_size(fbe_value.depth) \
            + self.sa.fbe_allocation_size(fbe_value.sa) \
            + self.sex.fbe_allocation_size(fbe_value.sex) \

        return fbe_result

    # Get the final type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 2

    # Check if the struct value is valid
    def verify(self):
        self._buffer.shift(self.fbe_offset)
        fbe_result = self.verify_fields()
        self._buffer.unshift(self.fbe_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self):
        fbe_current_offset = 0

        self.name.fbe_offset = fbe_current_offset
        fbe_field_size = self.name.verify()
        if fbe_field_size == sys.maxsize:
            return sys.maxsize
        fbe_current_offset += fbe_field_size

        self.depth.fbe_offset = fbe_current_offset
        fbe_field_size = self.depth.verify()
        if fbe_field_size == sys.maxsize:
            return sys.maxsize
        fbe_current_offset += fbe_field_size

        self.sa.fbe_offset = fbe_current_offset
        fbe_field_size = self.sa.verify()
        if fbe_field_size == sys.maxsize:
            return sys.maxsize
        fbe_current_offset += fbe_field_size

        self.sex.fbe_offset = fbe_current_offset
        fbe_field_size = self.sex.verify()
        if fbe_field_size == sys.maxsize:
            return sys.maxsize
        fbe_current_offset += fbe_field_size

        return fbe_current_offset

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = Simple()

        self._buffer.shift(self.fbe_offset)
        fbe_size = self.get_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_value, fbe_size

    # Get the struct fields values
    def get_fields(self, fbe_value):
        fbe_current_offset = 0
        fbe_current_size = 0

        self.name.fbe_offset = fbe_current_offset
        fbe_result = self.name.get()
        fbe_value.name = fbe_result[0]
        fbe_current_offset += fbe_result[1]
        fbe_current_size += fbe_result[1]

        self.depth.fbe_offset = fbe_current_offset
        fbe_result = self.depth.get()
        fbe_value.depth = fbe_result[0]
        fbe_current_offset += fbe_result[1]
        fbe_current_size += fbe_result[1]

        self.sa.fbe_offset = fbe_current_offset
        fbe_result = self.sa.get(fbe_value.sa)
        fbe_current_offset += fbe_result[1]
        fbe_current_size += fbe_result[1]

        self.sex.fbe_offset = fbe_current_offset
        fbe_result = self.sex.get()
        fbe_value.sex = fbe_result[0]
        fbe_current_offset += fbe_result[1]
        fbe_current_size += fbe_result[1]

        return fbe_current_size

    # Set the struct value
    def set(self, fbe_value):
        self._buffer.shift(self.fbe_offset)
        fbe_size = self.set_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_size

    # Set the struct fields values
    def set_fields(self, fbe_value):
        fbe_current_offset = 0
        fbe_current_size = 0

        self.name.fbe_offset = fbe_current_offset
        fbe_field_size = self.name.set(fbe_value.name)
        fbe_current_offset += fbe_field_size
        fbe_current_size += fbe_field_size

        self.depth.fbe_offset = fbe_current_offset
        fbe_field_size = self.depth.set(fbe_value.depth)
        fbe_current_offset += fbe_field_size
        fbe_current_size += fbe_field_size

        self.sa.fbe_offset = fbe_current_offset
        fbe_field_size = self.sa.set(fbe_value.sa)
        fbe_current_offset += fbe_field_size
        fbe_current_size += fbe_field_size

        self.sex.fbe_offset = fbe_current_offset
        fbe_field_size = self.sex.set(fbe_value.sex)
        fbe_current_offset += fbe_field_size
        fbe_current_size += fbe_field_size

        return fbe_current_size


# Fast Binary Encoding Simple final model
class SimpleFinalModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FinalModelSimple(self.buffer, 8)

    # Get the model type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = FinalModelSimple.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return False

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return False

        return (8 + self._model.verify()) == fbe_struct_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_initial_size = self.buffer.size

        fbe_struct_type = self.fbe_type
        fbe_struct_size = 8 + self._model.fbe_allocation_size(value)
        fbe_struct_offset = self.buffer.allocate(fbe_struct_size) - self.buffer.offset
        assert ((self.buffer.offset + fbe_struct_offset + fbe_struct_size) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + fbe_struct_offset + fbe_struct_size) > self.buffer.size:
            return 0

        fbe_struct_size = 8 + self._model.set(value)
        self.buffer.resize(fbe_initial_size + fbe_struct_size)

        self.write_uint32(self._model.fbe_offset - 8, fbe_struct_size)
        self.write_uint32(self._model.fbe_offset - 4, fbe_struct_type)

        return fbe_struct_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = Simple()

        assert ((self.buffer.offset + self._model.fbe_offset) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return Simple(), 0

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        assert ((fbe_struct_size > 0) and (fbe_struct_type == self.fbe_type)), "Model is broken!"
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return Simple(), 8

        fbe_result = self._model.get(value)
        return fbe_result[0], (8 + fbe_result[1])

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


# Fast Binary Encoding osa protocol version
class ProtocolVersion(object):
    # Protocol major version
    Major = 0
    # Protocol minor version
    Minor = 0


# Fast Binary Encoding osa sender
class Sender(fbe.Sender):
    def __init__(self, buffer=None):
        super().__init__(buffer, False)

    # Sender models accessors

    # Send methods

    def send(self, value):
        return 0

    # Send message handler
    def on_send(self, buffer, offset, size):
        raise NotImplementedError("osa.Sender.on_send() not implemented!")


# Fast Binary Encoding osa receiver
class Receiver(fbe.Receiver):
    def __init__(self, buffer=None):
        super().__init__(buffer, False)

    # Receive handlers

    def on_receive(self, type, buffer, offset, size):

        return False


# Fast Binary Encoding osa proxy
class Proxy(fbe.Receiver):
    def __init__(self, buffer=None):
        super().__init__(buffer, False)

    # Receive handlers

    def on_receive(self, type, buffer, offset, size):

        return False


# Fast Binary Encoding osa final sender
class FinalSender(fbe.Sender):
    def __init__(self, buffer=None):
        super().__init__(buffer, True)

    # Sender models accessors

    # Send methods

    def send(self, value):
        return 0

    # Send message handler
    def on_send(self, buffer, offset, size):
        raise NotImplementedError("osa.Sender.on_send() not implemented!")


# Fast Binary Encoding osa final receiver
class FinalReceiver(fbe.Receiver):
    def __init__(self, buffer=None):
        super().__init__(buffer, True)

    # Receive handlers

    def on_receive(self, type, buffer, offset, size):

        return False
