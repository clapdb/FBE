//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: osa.fbe
// FBE version: 1.10.0.0
//------------------------------------------------------------------------------

/* eslint-disable prefer-const,no-loss-of-precision */
'use strict'

const util = require('util')

const big = require('./big')
const int64 = require('./int64')
const uuid = require('./uuid')

const Big = big.Big // eslint-disable-line
const Int64 = int64.Int64 // eslint-disable-line
const UInt64 = int64.UInt64 // eslint-disable-line
const UUID = uuid.UUID // eslint-disable-line

const fbe = require('./fbe')

/**
 * Sex enum
 */
class Sex {
  /**
   * Initialize enum with a given value
   * @param {Sex|number|Int64|UInt64=} value Enum value, defaults is 0
   * @constructor
   */
  constructor (value = 0) {
    if (value instanceof Sex) {
      this.value = value.value
    } else {
      this.value = value
    }
  }

  /**
   * Is this enum equal to other one?
   * @this {!Sex}
   * @param {!Sex} other Other enum
   * @returns {boolean} Equal result
   */
  eq (other) {
    if (!(other instanceof Sex)) {
      throw new TypeError('Instance of Sex is required!')
    }
    return this.value === other.value
  }

  /**
   * Get enum value
   * @this {!Sex}
   * @returns {!number|!Int64|!UInt64} Enum value
   */
  valueOf () {
    return this.value
  }

  /**
   * Convert enum to string
   * @this {!Sex}
   * @returns {!string} Enum value string
   */
  toString () {
    if (this.value === Sex.male.value) {
      return 'male'
    }
    if (this.value === Sex.female.value) {
      return 'female'
    }
    return '<unknown>'
  }

  /**
   * Inspect enum
   * @this {!Sex}
   * @returns {!string} Enum value string
   */
  [util.inspect.custom] () {
    return this.toString()
  }

  /**
   * Convert enum to JSON
   * @this {!Sex}
   * @returns {!number} Enum value for JSON
   */
  toJSON () {
    return this.value
  }

  /**
   * Create enum from object value
   * @param {!number} other Object value
   * @returns {!Sex} Created enum
   */
  static fromObject (other) {
    return new Sex(other)
  }
}

// noinspection PointlessArithmeticExpressionJS
Sex.male = new Sex(0 + 0)
// noinspection PointlessArithmeticExpressionJS
Sex.female = new Sex(0 + 1)

exports.Sex = Sex

/**
 * Fast Binary Encoding Sex field model
 */
class FieldModelSex extends fbe.FieldModel {
  /**
   * Get the field size
   * @this {!FieldModelSex}
   * @returns {!number} Field size
   */
  get fbeSize () {
    return 4
  }

  /**
   * Get the value
   * @this {!FieldModelSex}
   * @param {Sex=} defaults Default value, defaults is new Sex()
   * @returns {!Sex} Result value
   */
  get (defaults = new Sex()) {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return defaults
    }

    return new Sex(this.readInt32(this.fbeOffset))
  }

  /**
   * Set the value
   * @this {!FieldModelSex}
   * @param {!Sex} value Value
   */
  set (value) {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return
    }

    this.writeInt32(this.fbeOffset, value.value)
  }
}

exports.FieldModelSex = FieldModelSex

/**
 * Fast Binary Encoding Sex final model
 */
class FinalModelSex extends fbe.FinalModel {
  /**
   * Get the allocation size
   * @this {!FinalModelSex}
   * @param {!Sex} value Value
   * @returns {!number} Allocation size
   */
  fbeAllocationSize (value) {
    return this.fbeSize
  }

  /**
   * Get the final size
   * @this {!FieldModelSex}
   * @returns {!number} Final size
   */
  get fbeSize () {
    return 4
  }

  /**
   * Check if the value is valid
   * @this {!FinalModelSex}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verify () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return Number.MAX_SAFE_INTEGER
    }

    return this.fbeSize
  }

  /**
   * Get the value
   * @this {!FieldModelSex}
   * @returns {!object} Result value and its size
   */
  get () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return { value: new Sex(), size: 0 }
    }

    return { value: new Sex(this.readInt32(this.fbeOffset)), size: this.fbeSize }
  }

  /**
   * Set the value
   * @this {!FieldModelSex}
   * @param {!Sex} value Value
   * @returns {!number} Final model size
   */
  set (value) {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    this.writeInt32(this.fbeOffset, value.value)
    return this.fbeSize
  }
}

exports.FinalModelSex = FinalModelSex

/**
 * MyFLags enum
 */
class MyFLags {
  /**
   * Initialize enum with a given value
   * @param {MyFLags|number|Int64|UInt64=} value Enum value, defaults is 0
   * @constructor
   */
  constructor (value = 0) {
    if (value instanceof MyFLags) {
      this.value = value.value
    } else {
      this.value = value
    }
  }

  /**
   * Is this enum equal to other one?
   * @this {!MyFLags}
   * @param {!MyFLags} other Other enum
   * @returns {boolean} Equal result
   */
  eq (other) {
    if (!(other instanceof MyFLags)) {
      throw new TypeError('Instance of MyFLags is required!')
    }
    return this.value === other.value
  }

  /**
   * Get enum value
   * @this {!MyFLags}
   * @returns {!number|!Int64|!UInt64} Enum value
   */
  valueOf () {
    return this.value
  }

  /**
   * Convert enum to string
   * @this {!MyFLags}
   * @returns {!string} Enum value string
   */
  toString () {
    if (this.value === MyFLags.flag0.value) {
      return 'flag0'
    }
    if (this.value === MyFLags.flag1.value) {
      return 'flag1'
    }
    if (this.value === MyFLags.flag2.value) {
      return 'flag2'
    }
    return '<unknown>'
  }

  /**
   * Inspect enum
   * @this {!MyFLags}
   * @returns {!string} Enum value string
   */
  [util.inspect.custom] () {
    return this.toString()
  }

  /**
   * Convert enum to JSON
   * @this {!MyFLags}
   * @returns {!number} Enum value for JSON
   */
  toJSON () {
    return this.value
  }

  /**
   * Create enum from object value
   * @param {!number} other Object value
   * @returns {!MyFLags} Created enum
   */
  static fromObject (other) {
    return new MyFLags(other)
  }
}

// noinspection PointlessArithmeticExpressionJS
MyFLags.flag0 = new MyFLags(0x00 + 0)
// noinspection PointlessArithmeticExpressionJS
MyFLags.flag1 = new MyFLags(0x01 + 0)
// noinspection PointlessArithmeticExpressionJS
MyFLags.flag2 = new MyFLags(0x02 + 0)

exports.MyFLags = MyFLags

/**
 * Fast Binary Encoding MyFLags field model
 */
class FieldModelMyFLags extends fbe.FieldModel {
  /**
   * Get the field size
   * @this {!FieldModelMyFLags}
   * @returns {!number} Field size
   */
  get fbeSize () {
    return 4
  }

  /**
   * Get the value
   * @this {!FieldModelMyFLags}
   * @param {MyFLags=} defaults Default value, defaults is new MyFLags()
   * @returns {!MyFLags} Result value
   */
  get (defaults = new MyFLags()) {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return defaults
    }

    return new MyFLags(this.readInt32(this.fbeOffset))
  }

  /**
   * Set the value
   * @this {!FieldModelMyFLags}
   * @param {!MyFLags} value Value
   */
  set (value) {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return
    }

    this.writeInt32(this.fbeOffset, value.value)
  }
}

exports.FieldModelMyFLags = FieldModelMyFLags

/**
 * Fast Binary Encoding MyFLags final model
 */
class FinalModelMyFLags extends fbe.FinalModel {
  /**
   * Get the allocation size
   * @this {!FinalModelMyFLags}
   * @param {!MyFLags} value Value
   * @returns {!number} Allocation size
   */
  fbeAllocationSize (value) {
    return this.fbeSize
  }

  /**
   * Get the final size
   * @this {!FieldModelMyFLags}
   * @returns {!number} Final size
   */
  get fbeSize () {
    return 4
  }

  /**
   * Check if the value is valid
   * @this {!FinalModelMyFLags}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verify () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return Number.MAX_SAFE_INTEGER
    }

    return this.fbeSize
  }

  /**
   * Get the value
   * @this {!FieldModelMyFLags}
   * @returns {!object} Result value and its size
   */
  get () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return { value: new MyFLags(), size: 0 }
    }

    return { value: new MyFLags(this.readInt32(this.fbeOffset)), size: this.fbeSize }
  }

  /**
   * Set the value
   * @this {!FieldModelMyFLags}
   * @param {!MyFLags} value Value
   * @returns {!number} Final model size
   */
  set (value) {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    this.writeInt32(this.fbeOffset, value.value)
    return this.fbeSize
  }
}

exports.FinalModelMyFLags = FinalModelMyFLags

/**
 * Extra struct
 */
class Extra {
  /**
   * Initialize struct
   * @param {!string=} name
   * @param {!string=} detail
   * @param {!Sex=} sex
   * @param {!MyFLags=} flag
   * @constructor
   */
  constructor (argname = '', argdetail = '', argsex = new Sex(), argflag = new MyFLags()) {
    this.name = argname
    this.detail = argdetail
    this.sex = argsex
    this.flag = argflag
  }

  /**
   * Copy struct (shallow copy)
   * @this {!Extra}
   * @param {!Extra} other Other struct
   * @returns {!Extra} This struct
   */
  copy (other) {
    if (other.name != null) {
      this.name = other.name
    } else {
      this.name = undefined
    }
    if (other.detail != null) {
      this.detail = other.detail
    } else {
      this.detail = undefined
    }
    if (other.sex != null) {
      this.sex = Sex.fromObject(other.sex)
    } else {
      this.sex = undefined
    }
    if (other.flag != null) {
      this.flag = MyFLags.fromObject(other.flag)
    } else {
      this.flag = undefined
    }
    return this
  }

  /**
   * Clone struct (deep clone)
   * @this {!Extra}
   * @returns {!Extra} Cloned struct
   */
  clone () {
    // Serialize the struct to the FBE stream
    let writer = new ExtraModel(new fbe.WriteBuffer())
    writer.serialize(this)

    // Deserialize the struct from the FBE stream
    let reader = new ExtraModel(new fbe.ReadBuffer())
    reader.attachBuffer(writer.buffer)
    return reader.deserialize().value
  }

  /**
   * Is this struct equal to other one?
   * @this {!Extra}
   * @param {!Extra} other Other struct
   * @returns {boolean} Equal result
   */
  eq (other) {
    if (!(other instanceof Extra)) {
      throw new TypeError('Instance of Extra is required!')
    }
    return true
  }

  /**
   * Convert struct to string
   * @this {!Extra}
   * @returns {!string} Struct value string
   */
  toString () {
    let result = ''
    result += 'Extra('
    result += 'name='
    if (this.name != null) {
      result += '"' + this.name.toString() + '"'
    } else {
      result += 'null'
    }
    result += ',detail='
    if (this.detail != null) {
      result += '"' + this.detail.toString() + '"'
    } else {
      result += 'null'
    }
    result += ',sex='
    result += this.sex.toString()
    result += ',flag='
    result += this.flag.toString()
    result += ')'
    return result
  }

  /**
   * Inspect struct
   * @this {!Extra}
   * @returns {!string} Struct value string
   */
  [util.inspect.custom] () {
    return this.toString()
  }

  /**
   * Convert struct to JSON
   * @this {!Extra}
   * @returns {!object} Struct value for JSON
   */
  toJSON () {
    return {
      name: ((this.name != null) ? this.name : null),
      detail: ((this.detail != null) ? this.detail : null),
      sex: ((this.sex != null) ? this.sex : null),
      flag: ((this.flag != null) ? this.flag : null)
    }
  }

  /**
   * Convert JSON to struct
   * @param {!string} json JSON string
   * @returns {!object} Struct value for JSON
   */
  static fromJSON (json) {
    return Extra.fromObject(JSON.parse(json))
  }

  /**
   * Create struct from object value
   * @param {!Extra} other Object value
   * @returns {!Extra} Created struct
   */
  static fromObject (other) {
    return new Extra().copy(other)
  }

  /**
   * Get the FBE type
   * @this {!Extra}
   * @returns {!number} FBE type
   */
  get fbeType () {
    return Extra.fbeType
  }

  /**
   * Get the FBE type (static)
   * @this {!Extra}
   * @returns {!number} FBE type
   */
  static get fbeType () {
    return 1
  }
}

exports.Extra = Extra

/**
 * Fast Binary Encoding Extra field model
 */
class FieldModelExtra extends fbe.FieldModel {
  /**
   * Initialize field model with the given buffer and offset
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Buffer
   * @param {!number} offset Offset
   * @constructor
   */
  constructor (buffer, offset) {
    super(buffer, offset)
    this._name = new fbe.FieldModelString(buffer, 4 + 4)
    this._detail = new fbe.FieldModelString(buffer, this._name.fbeOffset + this._name.fbeSize)
    this._sex = new FieldModelSex(buffer, this._detail.fbeOffset + this._detail.fbeSize)
    this._flag = new FieldModelMyFLags(buffer, this._sex.fbeOffset + this._sex.fbeSize)
  }

  /**
   * Get the name field model
   * @this {!FieldModelExtra}
   * @returns {!fbe.FieldModelString} name field model
   */
  get name () {
    return this._name
  }

  /**
   * Get the detail field model
   * @this {!FieldModelExtra}
   * @returns {!fbe.FieldModelString} detail field model
   */
  get detail () {
    return this._detail
  }

  /**
   * Get the sex field model
   * @this {!FieldModelExtra}
   * @returns {!FieldModelSex} sex field model
   */
  get sex () {
    return this._sex
  }

  /**
   * Get the flag field model
   * @this {!FieldModelExtra}
   * @returns {!FieldModelMyFLags} flag field model
   */
  get flag () {
    return this._flag
  }

  /**
   * Get the field size
   * @this {!FieldModelExtra}
   * @returns {!number} Field size
   */
  get fbeSize () {
    return 4
  }

  /**
   * Get the field body size
   * @this {!FieldModelExtra}
   * @returns {!number} Field body size
   */
  get fbeBody () {
    return 4 + 4 + this.name.fbeSize + this.detail.fbeSize + this.sex.fbeSize + this.flag.fbeSize
  }

  /**
   * Get the field extra size
   * @this {!FieldModelExtra}
   * @returns {!number} Field extra size
   */
  get fbeExtra () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4) > this._buffer.size)) {
      return 0
    }

    this._buffer.shift(fbeStructOffset)

    let fbeResult = this.fbeBody + this.name.fbeExtra + this.detail.fbeExtra + this.sex.fbeExtra + this.flag.fbeExtra

    this._buffer.unshift(fbeStructOffset)

    return fbeResult
  }

  /**
   * Get the field type
   * @this {!FieldModelExtra}
   * @returns {!number} Field type
   */
  get fbeType () {
    return FieldModelExtra.fbeType
  }

  /**
   * Get the field type (static)
   * @this {!FieldModelExtra}
   * @returns {!number} Field type
   */
  static get fbeType () {
    return 1
  }

  /**
   * Check if the struct value is valid
   * @this {!FieldModelExtra}
   * @param {!boolean} fbeVerifyType Verify model type flag, defaults is true
   * @returns {!boolean} Field model valid state
   */
  verify (fbeVerifyType = true) {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return true
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4 + 4) > this._buffer.size)) {
      return false
    }

    let fbeStructSize = this.readUInt32(fbeStructOffset)
    if (fbeStructSize < (4 + 4)) {
      return false
    }

    let fbeStructType = this.readUInt32(fbeStructOffset + 4)
    if (fbeVerifyType && (fbeStructType !== this.fbeType)) {
      return false
    }

    this._buffer.shift(fbeStructOffset)
    let fbeResult = this.verifyFields(fbeStructSize)
    this._buffer.unshift(fbeStructOffset)
    return fbeResult
  }

  /**
   * Check if the struct fields are valid
   * @this {!FieldModelExtra}
   * @param {!number} fbeStructSize FBE struct size
   * @returns {!boolean} Field model valid state
   */
  verifyFields (fbeStructSize) {
    let fbeCurrentSize = 4 + 4

    if ((fbeCurrentSize + this.name.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.name.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.name.fbeSize

    if ((fbeCurrentSize + this.detail.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.detail.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.detail.fbeSize

    if ((fbeCurrentSize + this.sex.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.sex.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.sex.fbeSize

    if ((fbeCurrentSize + this.flag.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.flag.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.flag.fbeSize

    return true
  }

  /**
   * Get the struct value (begin phase)
   * @this {!FieldModelExtra}
   * @returns {!number} Field model begin offset
   */
  getBegin () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    console.assert((fbeStructOffset > 0) && ((this._buffer.offset + fbeStructOffset + 4 + 4) <= this._buffer.size), 'Model is broken!')
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4 + 4) > this._buffer.size)) {
      return 0
    }

    let fbeStructSize = this.readUInt32(fbeStructOffset)
    console.assert((fbeStructSize >= (4 + 4)), 'Model is broken!')
    if (fbeStructSize < (4 + 4)) {
      return 0
    }

    this._buffer.shift(fbeStructOffset)
    return fbeStructOffset
  }

  /**
   * Get the struct value (end phase)
   * @this {!FieldModelExtra}
   * @param {!number} fbeBegin Field model begin offset
   */
  getEnd (fbeBegin) {
    this._buffer.unshift(fbeBegin)
  }

  /**
   * Get the struct value
   * @this {!FieldModelExtra}
   * @param {!Extra} fbeValue Default value, defaults is new Extra()
   * @returns {!Extra} Extra value
   */
  get (fbeValue = new Extra()) {
    let fbeBegin = this.getBegin()
    if (fbeBegin === 0) {
      return fbeValue
    }

    let fbeStructSize = this.readUInt32(0)
    this.getFields(fbeValue, fbeStructSize)
    this.getEnd(fbeBegin)
    return fbeValue
  }

  /**
   * Get the struct fields values
   * @this {!FieldModelExtra}
   * @param {!Extra} fbeValue Extra value
   * @param {!number} fbeStructSize Struct size
   */
  getFields (fbeValue, fbeStructSize) {
    let fbeCurrentSize = 4 + 4

    if ((fbeCurrentSize + this.name.fbeSize) <= fbeStructSize) {
      fbeValue.name = this.name.get()
    } else {
      fbeValue.name = ''
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.name.fbeSize

    if ((fbeCurrentSize + this.detail.fbeSize) <= fbeStructSize) {
      fbeValue.detail = this.detail.get()
    } else {
      fbeValue.detail = ''
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.detail.fbeSize

    if ((fbeCurrentSize + this.sex.fbeSize) <= fbeStructSize) {
      fbeValue.sex = this.sex.get()
    } else {
      fbeValue.sex = new Sex()
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.sex.fbeSize

    if ((fbeCurrentSize + this.flag.fbeSize) <= fbeStructSize) {
      fbeValue.flag = this.flag.get()
    } else {
      fbeValue.flag = new MyFLags()
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.flag.fbeSize
  }

  /**
   * Set the struct value (begin phase)
   * @this {!FieldModelExtra}
   * @returns {!number} Field model begin offset
   */
  setBegin () {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructSize = this.fbeBody
    let fbeStructOffset = this._buffer.allocate(fbeStructSize) - this._buffer.offset
    console.assert((fbeStructOffset > 0) && ((this._buffer.offset + fbeStructOffset + fbeStructSize) <= this._buffer.size), 'Model is broken!')
    if ((fbeStructOffset <= 0) || ((this._buffer.offset + fbeStructOffset + fbeStructSize) > this._buffer.size)) {
      return 0
    }

    this.writeUInt32(this.fbeOffset, fbeStructOffset)
    this.writeUInt32(fbeStructOffset, fbeStructSize)
    this.writeUInt32(fbeStructOffset + 4, this.fbeType)

    this._buffer.shift(fbeStructOffset)
    return fbeStructOffset
  }

  /**
   * Set the struct value (end phase)
   * @this {!FieldModelExtra}
   * @param {!number} fbeBegin Field model begin offset
   */
  setEnd (fbeBegin) {
    this._buffer.unshift(fbeBegin)
  }

  /**
   * Set the struct value
   * @this {!FieldModelExtra}
   * @param {!Extra} fbeValue Extra value
   */
  set (fbeValue) {
    let fbeBegin = this.setBegin()
    if (fbeBegin === 0) {
      return
    }

    this.setFields(fbeValue)
    this.setEnd(fbeBegin)
  }

  /**
   * Set the struct fields values
   * @this {!FieldModelExtra}
   * @param {Extra} fbeValue Extra value
   */
  setFields (fbeValue) {
    this.name.set(fbeValue.name)
    this.detail.set(fbeValue.detail)
    this.sex.set(fbeValue.sex)
    this.flag.set(fbeValue.flag)
  }
}

exports.FieldModelExtra = FieldModelExtra

/**
 * Fast Binary Encoding Extra model
 */
class ExtraModel extends fbe.Model {
  /**
   * Initialize model with the given buffer
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Read/Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer)
    this._model = new FieldModelExtra(this.buffer, 4)
  }

  /**
   * Get the Extra model
   * @this {!ExtraModel}
   * @returns {!FieldModelExtra} model Extra model
   */
  get model () {
    return this._model
  }

  /**
   * Get the model size
   * @this {!ExtraModel}
   * @returns {!number} Model size
   */
  get fbeSize () {
    return this.model.fbeSize + this.model.fbeExtra
  }

  /**
   * Get the model type
   * @this {!ExtraModel}
   * @returns {!number} Model type
   */
  get fbeType () {
    return ExtraModel.fbeType
  }

  /**
   * Get the model type (static)
   * @this {!ExtraModel}
   * @returns {!number} Model type
   */
  static get fbeType () {
    return FieldModelExtra.fbeType
  }

  /**
   * Check if the struct value is valid
   * @this {!ExtraModel}
   * @returns {!boolean} Model valid state
   */
  verify () {
    if ((this.buffer.offset + this.model.fbeOffset - 4) > this.buffer.size) {
      return false
    }

    let fbeFullSize = this.readUInt32(this.model.fbeOffset - 4)
    if (fbeFullSize < this.model.fbeSize) {
      return false
    }

    return this.model.verify()
  }

  /**
   * Create a new model (begin phase)
   * @this {!ExtraModel}
   * @returns {!number} Model begin offset
   */
  createBegin () {
    return this.buffer.allocate(4 + this.model.fbeSize)
  }

  /**
   * Create a new model (end phase)
   * @this {!ExtraModel}
   * @param {!number} fbeBegin Model begin offset
   */
  createEnd (fbeBegin) {
    let fbeEnd = this.buffer.size
    let fbeFullSize = fbeEnd - fbeBegin
    this.writeUInt32(this.model.fbeOffset - 4, fbeFullSize)
    return fbeFullSize
  }

  /**
   * Serialize the struct value
   * @this {!ExtraModel}
   * @param {!Extra} value Extra value
   * @return {!number} Model begin offset
   */
  serialize (value) {
    let fbeBegin = this.createBegin()
    this.model.set(value)
    return this.createEnd(fbeBegin)
  }

  /**
   * Deserialize the struct value
   * @this {!ExtraModel}
   * @param {!Extra} value Extra value, defaults is new Extra()
   * @return {!object} Deserialized Extra value and its size
   */
  deserialize (value = new Extra()) {
    if ((this.buffer.offset + this.model.fbeOffset - 4) > this.buffer.size) {
      return { value: new Extra(), size: 0 }
    }

    let fbeFullSize = this.readUInt32(this.model.fbeOffset - 4)
    console.assert((fbeFullSize >= this.model.fbeSize), 'Model is broken!')
    if (fbeFullSize < this.model.fbeSize) {
      return { value: new Extra(), size: 0 }
    }

    this.model.get(value)
    return { value: value, size: fbeFullSize }
  }

  /**
   * Move to the next struct value
   * @this {!ExtraModel}
   * @param {!number} prev Previous Extra model size
   */
  next (prev) {
    this.model.fbeShift(prev)
  }
}

exports.ExtraModel = ExtraModel

/**
 * Fast Binary Encoding Extra final model
 */
class FinalModelExtra extends fbe.FinalModel {
  /**
   * Initialize final model with the given buffer and offset
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Buffer
   * @param {!number} offset Offset
   * @constructor
   */
  constructor (buffer, offset) {
    super(buffer, offset)
    this._name = new fbe.FinalModelString(buffer, 0)
    this._detail = new fbe.FinalModelString(buffer, 0)
    this._sex = new FinalModelSex(buffer, 0)
    this._flag = new FinalModelMyFLags(buffer, 0)
  }

  /**
   * Get the name final model
   * @this {!FinalModelExtra}
   * @returns {!fbe.FinalModelString} name final model
   */
  get name () {
    return this._name
  }

  /**
   * Get the detail final model
   * @this {!FinalModelExtra}
   * @returns {!fbe.FinalModelString} detail final model
   */
  get detail () {
    return this._detail
  }

  /**
   * Get the sex final model
   * @this {!FinalModelExtra}
   * @returns {!FinalModelSex} sex final model
   */
  get sex () {
    return this._sex
  }

  /**
   * Get the flag final model
   * @this {!FinalModelExtra}
   * @returns {!FinalModelMyFLags} flag final model
   */
  get flag () {
    return this._flag
  }

  /**
   * Get the allocation size
   * @this {!FinalModelExtra}
   * @param {!Extra} fbeValue Extra value
   * @returns {!number} Allocation size
   */
  fbeAllocationSize (fbeValue) {
    return 0 + this.name.fbeAllocationSize(fbeValue.name) + this.detail.fbeAllocationSize(fbeValue.detail) + this.sex.fbeAllocationSize(fbeValue.sex) + this.flag.fbeAllocationSize(fbeValue.flag)
  }

  /**
   * Get the final type
   * @this {!FinalModelExtra}
   * @returns {!number} Final type
   */
  get fbeType () {
    return FinalModelExtra.fbeType
  }

  /**
   * Get the final type (static)
   * @this {!FinalModelExtra}
   * @returns {!number} Final type
   */
  static get fbeType () {
    return 1
  }

  /**
   * Check if the struct value is valid
   * @this {!FinalModelExtra}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verify () {
    this._buffer.shift(this.fbeOffset)
    let fbeResult = this.verifyFields()
    this._buffer.unshift(this.fbeOffset)
    return fbeResult
  }

  /**
   * Check if the struct fields are valid
   * @this {!FinalModelExtra}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verifyFields () {
    let fbeCurrentOffset = 0
    let fbeFieldSize

    this.name.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.name.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.detail.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.detail.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.sex.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.sex.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.flag.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.flag.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    return fbeCurrentOffset
  }

  /**
   * Get the struct value
   * @this {!FinalModelExtra}
   * @param {!Extra} fbeValue Extra value, defaults is new Extra()
   * @returns {!object} Result struct value and its size
   */
  get (fbeValue = new Extra()) {
    this._buffer.shift(this.fbeOffset)
    let fbeSize = this.getFields(fbeValue)
    this._buffer.unshift(this.fbeOffset)
    return { value: fbeValue, size: fbeSize }
  }

  /**
   * Get the struct fields values
   * @this {!FinalModelExtra}
   * @param {!Extra} fbeValue Extra value
   * @returns {!number} Struct size
   */
  getFields (fbeValue) {
    let fbeCurrentOffset = 0
    let fbeCurrentSize = 0
    let fbeResult

    this.name.fbeOffset = fbeCurrentOffset
    fbeResult = this.name.get()
    fbeValue.name = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.detail.fbeOffset = fbeCurrentOffset
    fbeResult = this.detail.get()
    fbeValue.detail = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.sex.fbeOffset = fbeCurrentOffset
    fbeResult = this.sex.get()
    fbeValue.sex = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.flag.fbeOffset = fbeCurrentOffset
    fbeResult = this.flag.get()
    fbeValue.flag = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    return fbeCurrentSize
  }

  /**
   * Set the struct value
   * @this {!FinalModelExtra}
   * @param {!Extra} fbeValue Extra value
   * @returns {!number} Final model size
   */
  set (fbeValue) {
    this._buffer.shift(this.fbeOffset)
    let fbeSize = this.setFields(fbeValue)
    this._buffer.unshift(this.fbeOffset)
    return fbeSize
  }

  /**
   * Set the struct fields values
   * @this {!FinalModelExtra}
   * @param {Extra} fbeValue Extra value
   * @returns {!number} Final model size
   */
  setFields (fbeValue) {
    let fbeCurrentOffset = 0
    let fbeCurrentSize = 0
    let fbeFieldSize

    this.name.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.name.set(fbeValue.name)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.detail.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.detail.set(fbeValue.detail)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.sex.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.sex.set(fbeValue.sex)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.flag.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.flag.set(fbeValue.flag)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    return fbeCurrentSize
  }
}

exports.FinalModelExtra = FinalModelExtra

/**
 * Fast Binary Encoding Extra final model
 */
class ExtraFinalModel extends fbe.Model {
  /**
   * Initialize final model with the given buffer
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Read/Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer)
    this._model = new FinalModelExtra(this.buffer, 8)
  }

  /**
   * Get the model type
   * @this {!ExtraFinalModel}
   * @returns {!number} Model type
   */
  get fbeType () {
    return ExtraFinalModel.fbeType
  }

  /**
   * Get the model type (static)
   * @this {!ExtraFinalModel}
   * @returns {!number} Model type
   */
  static get fbeType () {
    return FinalModelExtra.fbeType
  }

  /**
   * Check if the struct value is valid
   * @this {!ExtraFinalModel}
   * @returns {!boolean} Model valid state
   */
  verify () {
    if ((this.buffer.offset + this._model.fbeOffset) > this.buffer.size) {
      return false
    }

    let fbeStructSize = this.readUInt32(this._model.fbeOffset - 8)
    let fbeStructType = this.readUInt32(this._model.fbeOffset - 4)
    if ((fbeStructSize <= 0) || (fbeStructType !== this.fbeType)) {
      return false
    }

    return ((8 + this._model.verify()) === fbeStructSize)
  }

  /**
   * Serialize the struct value
   * @this {!ExtraFinalModel}
   * @param {!Extra} value Extra value
   * @return {!number} Struct size
   */
  serialize (value) {
    let fbeInitialSize = this.buffer.size

    let fbeStructType = this.fbeType
    let fbeStructSize = 8 + this._model.fbeAllocationSize(value)
    let fbeStructOffset = this.buffer.allocate(fbeStructSize) - this.buffer.offset
    console.assert(((this.buffer.offset + fbeStructOffset + fbeStructSize) <= this.buffer.size), 'Model is broken!')
    if ((this.buffer.offset + fbeStructOffset + fbeStructSize) > this.buffer.size) {
      return 0
    }

    fbeStructSize = 8 + this._model.set(value)
    this.buffer.resize(fbeInitialSize + fbeStructSize)

    this.writeUInt32(this._model.fbeOffset - 8, fbeStructSize)
    this.writeUInt32(this._model.fbeOffset - 4, fbeStructType)

    return fbeStructSize
  }

  /**
   * Deserialize the struct value
   * @this {!ExtraFinalModel}
   * @param {!Extra} value Extra value, defaults is new Extra()
   * @return {!object} Deserialized Extra value and its size
   */
  deserialize (value = new Extra()) {
    console.assert(((this.buffer.offset + this._model.fbeOffset) <= this.buffer.size), 'Model is broken!')
    if ((this.buffer.offset + this._model.fbeOffset) > this.buffer.size) {
      return { value: new Extra(), size: 0 }
    }

    let fbeStructSize = this.readUInt32(this._model.fbeOffset - 8)
    let fbeStructType = this.readUInt32(this._model.fbeOffset - 4)
    console.assert(((fbeStructSize > 0) && (fbeStructType === this.fbeType)), 'Model is broken!')
    if ((fbeStructSize <= 0) || (fbeStructType !== this.fbeType)) {
      return { value: new Extra(), size: 8 }
    }

    let fbeResult = this._model.get(value)
    return { value: fbeResult.value, size: (8 + fbeResult.size) }
  }

  /**
   * Move to the next struct value
   * @this {!ExtraFinalModel}
   * @param {!number} prev Previous Extra model size
   */
  next (prev) {
    this._model.fbeShift(prev)
  }
}

exports.ExtraFinalModel = ExtraFinalModel

/**
 * Simple struct
 */
class Simple {
  /**
   * Initialize struct
   * @param {!string=} name
   * @param {!number=} depth
   * @param {!Array=} sa
   * @param {!Sex=} sex
   * @constructor
   */
  constructor (argname = '', argdepth = 0, argsa = [], argsex = new Sex()) {
    this.name = argname
    this.depth = argdepth
    this.sa = argsa
    this.sex = argsex
  }

  /**
   * Copy struct (shallow copy)
   * @this {!Simple}
   * @param {!Simple} other Other struct
   * @returns {!Simple} This struct
   */
  copy (other) {
    if (other.name != null) {
      this.name = other.name
    } else {
      this.name = undefined
    }
    if (other.depth != null) {
      this.depth = other.depth
    } else {
      this.depth = undefined
    }
    if (other.sa != null) {
      this.sa = []
      for (let item of other.sa) {
        if (item != null) {
          let tempItem
          tempItem = Extra.fromObject(item)
          this.sa.push(tempItem)
        } else {
          this.sa.push(undefined)
        }
      }
    } else {
      this.sa = undefined
    }
    if (other.sex != null) {
      this.sex = Sex.fromObject(other.sex)
    } else {
      this.sex = undefined
    }
    return this
  }

  /**
   * Clone struct (deep clone)
   * @this {!Simple}
   * @returns {!Simple} Cloned struct
   */
  clone () {
    // Serialize the struct to the FBE stream
    let writer = new SimpleModel(new fbe.WriteBuffer())
    writer.serialize(this)

    // Deserialize the struct from the FBE stream
    let reader = new SimpleModel(new fbe.ReadBuffer())
    reader.attachBuffer(writer.buffer)
    return reader.deserialize().value
  }

  /**
   * Is this struct equal to other one?
   * @this {!Simple}
   * @param {!Simple} other Other struct
   * @returns {boolean} Equal result
   */
  eq (other) {
    if (!(other instanceof Simple)) {
      throw new TypeError('Instance of Simple is required!')
    }
    return true
  }

  /**
   * Convert struct to string
   * @this {!Simple}
   * @returns {!string} Struct value string
   */
  toString () {
    let result = ''
    result += 'Simple('
    result += 'name='
    if (this.name != null) {
      result += '"' + this.name.toString() + '"'
    } else {
      result += 'null'
    }
    result += ',depth='
    result += this.depth.toString()
    result += ',sa='
    if (this.sa != null) {
      let first = true
      result += '[' + this.sa.length + ']['
      for (let item of this.sa) {
        result += first ? '' : ','
        result += item.toString()
        first = false
      }
      result += ']'
    } else {
      result += '[0][]'
    }
    result += ',sex='
    result += this.sex.toString()
    result += ')'
    return result
  }

  /**
   * Inspect struct
   * @this {!Simple}
   * @returns {!string} Struct value string
   */
  [util.inspect.custom] () {
    return this.toString()
  }

  /**
   * Convert struct to JSON
   * @this {!Simple}
   * @returns {!object} Struct value for JSON
   */
  toJSON () {
    return {
      name: ((this.name != null) ? this.name : null),
      depth: ((this.depth != null) ? this.depth : null),
      sa: ((this.sa != null) ? Array.from(this.sa, item => ((item != null) ? item : null)) : null),
      sex: ((this.sex != null) ? this.sex : null)
    }
  }

  /**
   * Convert JSON to struct
   * @param {!string} json JSON string
   * @returns {!object} Struct value for JSON
   */
  static fromJSON (json) {
    return Simple.fromObject(JSON.parse(json))
  }

  /**
   * Create struct from object value
   * @param {!Simple} other Object value
   * @returns {!Simple} Created struct
   */
  static fromObject (other) {
    return new Simple().copy(other)
  }

  /**
   * Get the FBE type
   * @this {!Simple}
   * @returns {!number} FBE type
   */
  get fbeType () {
    return Simple.fbeType
  }

  /**
   * Get the FBE type (static)
   * @this {!Simple}
   * @returns {!number} FBE type
   */
  static get fbeType () {
    return 2
  }
}

exports.Simple = Simple

/**
 * Fast Binary Encoding Simple field model
 */
class FieldModelSimple extends fbe.FieldModel {
  /**
   * Initialize field model with the given buffer and offset
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Buffer
   * @param {!number} offset Offset
   * @constructor
   */
  constructor (buffer, offset) {
    super(buffer, offset)
    this._name = new fbe.FieldModelString(buffer, 4 + 4)
    this._depth = new fbe.FieldModelInt32(buffer, this._name.fbeOffset + this._name.fbeSize)
    this._sa = new fbe.FieldModelArray(new FieldModelExtra(buffer, this._depth.fbeOffset + this._depth.fbeSize), buffer, this._depth.fbeOffset + this._depth.fbeSize, 1)
    this._sex = new FieldModelSex(buffer, this._sa.fbeOffset + this._sa.fbeSize)
  }

  /**
   * Get the name field model
   * @this {!FieldModelSimple}
   * @returns {!fbe.FieldModelString} name field model
   */
  get name () {
    return this._name
  }

  /**
   * Get the depth field model
   * @this {!FieldModelSimple}
   * @returns {!fbe.FieldModelInt32} depth field model
   */
  get depth () {
    return this._depth
  }

  /**
   * Get the sa field model
   * @this {!FieldModelSimple}
   * @returns {!fbe.FieldModelArray} sa field model
   */
  get sa () {
    return this._sa
  }

  /**
   * Get the sex field model
   * @this {!FieldModelSimple}
   * @returns {!FieldModelSex} sex field model
   */
  get sex () {
    return this._sex
  }

  /**
   * Get the field size
   * @this {!FieldModelSimple}
   * @returns {!number} Field size
   */
  get fbeSize () {
    return 4
  }

  /**
   * Get the field body size
   * @this {!FieldModelSimple}
   * @returns {!number} Field body size
   */
  get fbeBody () {
    return 4 + 4 + this.name.fbeSize + this.depth.fbeSize + this.sa.fbeSize + this.sex.fbeSize
  }

  /**
   * Get the field extra size
   * @this {!FieldModelSimple}
   * @returns {!number} Field extra size
   */
  get fbeExtra () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4) > this._buffer.size)) {
      return 0
    }

    this._buffer.shift(fbeStructOffset)

    let fbeResult = this.fbeBody + this.name.fbeExtra + this.depth.fbeExtra + this.sa.fbeExtra + this.sex.fbeExtra

    this._buffer.unshift(fbeStructOffset)

    return fbeResult
  }

  /**
   * Get the field type
   * @this {!FieldModelSimple}
   * @returns {!number} Field type
   */
  get fbeType () {
    return FieldModelSimple.fbeType
  }

  /**
   * Get the field type (static)
   * @this {!FieldModelSimple}
   * @returns {!number} Field type
   */
  static get fbeType () {
    return 2
  }

  /**
   * Check if the struct value is valid
   * @this {!FieldModelSimple}
   * @param {!boolean} fbeVerifyType Verify model type flag, defaults is true
   * @returns {!boolean} Field model valid state
   */
  verify (fbeVerifyType = true) {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return true
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4 + 4) > this._buffer.size)) {
      return false
    }

    let fbeStructSize = this.readUInt32(fbeStructOffset)
    if (fbeStructSize < (4 + 4)) {
      return false
    }

    let fbeStructType = this.readUInt32(fbeStructOffset + 4)
    if (fbeVerifyType && (fbeStructType !== this.fbeType)) {
      return false
    }

    this._buffer.shift(fbeStructOffset)
    let fbeResult = this.verifyFields(fbeStructSize)
    this._buffer.unshift(fbeStructOffset)
    return fbeResult
  }

  /**
   * Check if the struct fields are valid
   * @this {!FieldModelSimple}
   * @param {!number} fbeStructSize FBE struct size
   * @returns {!boolean} Field model valid state
   */
  verifyFields (fbeStructSize) {
    let fbeCurrentSize = 4 + 4

    if ((fbeCurrentSize + this.name.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.name.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.name.fbeSize

    if ((fbeCurrentSize + this.depth.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.depth.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.depth.fbeSize

    if ((fbeCurrentSize + this.sa.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.sa.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.sa.fbeSize

    if ((fbeCurrentSize + this.sex.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.sex.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.sex.fbeSize

    return true
  }

  /**
   * Get the struct value (begin phase)
   * @this {!FieldModelSimple}
   * @returns {!number} Field model begin offset
   */
  getBegin () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    console.assert((fbeStructOffset > 0) && ((this._buffer.offset + fbeStructOffset + 4 + 4) <= this._buffer.size), 'Model is broken!')
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4 + 4) > this._buffer.size)) {
      return 0
    }

    let fbeStructSize = this.readUInt32(fbeStructOffset)
    console.assert((fbeStructSize >= (4 + 4)), 'Model is broken!')
    if (fbeStructSize < (4 + 4)) {
      return 0
    }

    this._buffer.shift(fbeStructOffset)
    return fbeStructOffset
  }

  /**
   * Get the struct value (end phase)
   * @this {!FieldModelSimple}
   * @param {!number} fbeBegin Field model begin offset
   */
  getEnd (fbeBegin) {
    this._buffer.unshift(fbeBegin)
  }

  /**
   * Get the struct value
   * @this {!FieldModelSimple}
   * @param {!Simple} fbeValue Default value, defaults is new Simple()
   * @returns {!Simple} Simple value
   */
  get (fbeValue = new Simple()) {
    let fbeBegin = this.getBegin()
    if (fbeBegin === 0) {
      return fbeValue
    }

    let fbeStructSize = this.readUInt32(0)
    this.getFields(fbeValue, fbeStructSize)
    this.getEnd(fbeBegin)
    return fbeValue
  }

  /**
   * Get the struct fields values
   * @this {!FieldModelSimple}
   * @param {!Simple} fbeValue Simple value
   * @param {!number} fbeStructSize Struct size
   */
  getFields (fbeValue, fbeStructSize) {
    let fbeCurrentSize = 4 + 4

    if ((fbeCurrentSize + this.name.fbeSize) <= fbeStructSize) {
      fbeValue.name = this.name.get()
    } else {
      fbeValue.name = ''
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.name.fbeSize

    if ((fbeCurrentSize + this.depth.fbeSize) <= fbeStructSize) {
      fbeValue.depth = this.depth.get()
    } else {
      fbeValue.depth = 0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.depth.fbeSize

    if ((fbeCurrentSize + this.sa.fbeSize) <= fbeStructSize) {
      this.sa.get(fbeValue.sa)
    } else {
      fbeValue.sa.length = 0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.sa.fbeSize

    if ((fbeCurrentSize + this.sex.fbeSize) <= fbeStructSize) {
      fbeValue.sex = this.sex.get()
    } else {
      fbeValue.sex = new Sex()
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.sex.fbeSize
  }

  /**
   * Set the struct value (begin phase)
   * @this {!FieldModelSimple}
   * @returns {!number} Field model begin offset
   */
  setBegin () {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructSize = this.fbeBody
    let fbeStructOffset = this._buffer.allocate(fbeStructSize) - this._buffer.offset
    console.assert((fbeStructOffset > 0) && ((this._buffer.offset + fbeStructOffset + fbeStructSize) <= this._buffer.size), 'Model is broken!')
    if ((fbeStructOffset <= 0) || ((this._buffer.offset + fbeStructOffset + fbeStructSize) > this._buffer.size)) {
      return 0
    }

    this.writeUInt32(this.fbeOffset, fbeStructOffset)
    this.writeUInt32(fbeStructOffset, fbeStructSize)
    this.writeUInt32(fbeStructOffset + 4, this.fbeType)

    this._buffer.shift(fbeStructOffset)
    return fbeStructOffset
  }

  /**
   * Set the struct value (end phase)
   * @this {!FieldModelSimple}
   * @param {!number} fbeBegin Field model begin offset
   */
  setEnd (fbeBegin) {
    this._buffer.unshift(fbeBegin)
  }

  /**
   * Set the struct value
   * @this {!FieldModelSimple}
   * @param {!Simple} fbeValue Simple value
   */
  set (fbeValue) {
    let fbeBegin = this.setBegin()
    if (fbeBegin === 0) {
      return
    }

    this.setFields(fbeValue)
    this.setEnd(fbeBegin)
  }

  /**
   * Set the struct fields values
   * @this {!FieldModelSimple}
   * @param {Simple} fbeValue Simple value
   */
  setFields (fbeValue) {
    this.name.set(fbeValue.name)
    this.depth.set(fbeValue.depth)
    this.sa.set(fbeValue.sa)
    this.sex.set(fbeValue.sex)
  }
}

exports.FieldModelSimple = FieldModelSimple

/**
 * Fast Binary Encoding Simple model
 */
class SimpleModel extends fbe.Model {
  /**
   * Initialize model with the given buffer
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Read/Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer)
    this._model = new FieldModelSimple(this.buffer, 4)
  }

  /**
   * Get the Simple model
   * @this {!SimpleModel}
   * @returns {!FieldModelSimple} model Simple model
   */
  get model () {
    return this._model
  }

  /**
   * Get the model size
   * @this {!SimpleModel}
   * @returns {!number} Model size
   */
  get fbeSize () {
    return this.model.fbeSize + this.model.fbeExtra
  }

  /**
   * Get the model type
   * @this {!SimpleModel}
   * @returns {!number} Model type
   */
  get fbeType () {
    return SimpleModel.fbeType
  }

  /**
   * Get the model type (static)
   * @this {!SimpleModel}
   * @returns {!number} Model type
   */
  static get fbeType () {
    return FieldModelSimple.fbeType
  }

  /**
   * Check if the struct value is valid
   * @this {!SimpleModel}
   * @returns {!boolean} Model valid state
   */
  verify () {
    if ((this.buffer.offset + this.model.fbeOffset - 4) > this.buffer.size) {
      return false
    }

    let fbeFullSize = this.readUInt32(this.model.fbeOffset - 4)
    if (fbeFullSize < this.model.fbeSize) {
      return false
    }

    return this.model.verify()
  }

  /**
   * Create a new model (begin phase)
   * @this {!SimpleModel}
   * @returns {!number} Model begin offset
   */
  createBegin () {
    return this.buffer.allocate(4 + this.model.fbeSize)
  }

  /**
   * Create a new model (end phase)
   * @this {!SimpleModel}
   * @param {!number} fbeBegin Model begin offset
   */
  createEnd (fbeBegin) {
    let fbeEnd = this.buffer.size
    let fbeFullSize = fbeEnd - fbeBegin
    this.writeUInt32(this.model.fbeOffset - 4, fbeFullSize)
    return fbeFullSize
  }

  /**
   * Serialize the struct value
   * @this {!SimpleModel}
   * @param {!Simple} value Simple value
   * @return {!number} Model begin offset
   */
  serialize (value) {
    let fbeBegin = this.createBegin()
    this.model.set(value)
    return this.createEnd(fbeBegin)
  }

  /**
   * Deserialize the struct value
   * @this {!SimpleModel}
   * @param {!Simple} value Simple value, defaults is new Simple()
   * @return {!object} Deserialized Simple value and its size
   */
  deserialize (value = new Simple()) {
    if ((this.buffer.offset + this.model.fbeOffset - 4) > this.buffer.size) {
      return { value: new Simple(), size: 0 }
    }

    let fbeFullSize = this.readUInt32(this.model.fbeOffset - 4)
    console.assert((fbeFullSize >= this.model.fbeSize), 'Model is broken!')
    if (fbeFullSize < this.model.fbeSize) {
      return { value: new Simple(), size: 0 }
    }

    this.model.get(value)
    return { value: value, size: fbeFullSize }
  }

  /**
   * Move to the next struct value
   * @this {!SimpleModel}
   * @param {!number} prev Previous Simple model size
   */
  next (prev) {
    this.model.fbeShift(prev)
  }
}

exports.SimpleModel = SimpleModel

/**
 * Fast Binary Encoding Simple final model
 */
class FinalModelSimple extends fbe.FinalModel {
  /**
   * Initialize final model with the given buffer and offset
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Buffer
   * @param {!number} offset Offset
   * @constructor
   */
  constructor (buffer, offset) {
    super(buffer, offset)
    this._name = new fbe.FinalModelString(buffer, 0)
    this._depth = new fbe.FinalModelInt32(buffer, 0)
    this._sa = new fbe.FinalModelArray(new FinalModelExtra(buffer, 0), buffer, 0, 1)
    this._sex = new FinalModelSex(buffer, 0)
  }

  /**
   * Get the name final model
   * @this {!FinalModelSimple}
   * @returns {!fbe.FinalModelString} name final model
   */
  get name () {
    return this._name
  }

  /**
   * Get the depth final model
   * @this {!FinalModelSimple}
   * @returns {!fbe.FinalModelInt32} depth final model
   */
  get depth () {
    return this._depth
  }

  /**
   * Get the sa final model
   * @this {!FinalModelSimple}
   * @returns {!fbe.FinalModelArray} sa final model
   */
  get sa () {
    return this._sa
  }

  /**
   * Get the sex final model
   * @this {!FinalModelSimple}
   * @returns {!FinalModelSex} sex final model
   */
  get sex () {
    return this._sex
  }

  /**
   * Get the allocation size
   * @this {!FinalModelSimple}
   * @param {!Simple} fbeValue Simple value
   * @returns {!number} Allocation size
   */
  fbeAllocationSize (fbeValue) {
    return 0 + this.name.fbeAllocationSize(fbeValue.name) + this.depth.fbeAllocationSize(fbeValue.depth) + this.sa.fbeAllocationSize(fbeValue.sa) + this.sex.fbeAllocationSize(fbeValue.sex)
  }

  /**
   * Get the final type
   * @this {!FinalModelSimple}
   * @returns {!number} Final type
   */
  get fbeType () {
    return FinalModelSimple.fbeType
  }

  /**
   * Get the final type (static)
   * @this {!FinalModelSimple}
   * @returns {!number} Final type
   */
  static get fbeType () {
    return 2
  }

  /**
   * Check if the struct value is valid
   * @this {!FinalModelSimple}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verify () {
    this._buffer.shift(this.fbeOffset)
    let fbeResult = this.verifyFields()
    this._buffer.unshift(this.fbeOffset)
    return fbeResult
  }

  /**
   * Check if the struct fields are valid
   * @this {!FinalModelSimple}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verifyFields () {
    let fbeCurrentOffset = 0
    let fbeFieldSize

    this.name.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.name.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.depth.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.depth.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.sa.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.sa.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.sex.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.sex.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    return fbeCurrentOffset
  }

  /**
   * Get the struct value
   * @this {!FinalModelSimple}
   * @param {!Simple} fbeValue Simple value, defaults is new Simple()
   * @returns {!object} Result struct value and its size
   */
  get (fbeValue = new Simple()) {
    this._buffer.shift(this.fbeOffset)
    let fbeSize = this.getFields(fbeValue)
    this._buffer.unshift(this.fbeOffset)
    return { value: fbeValue, size: fbeSize }
  }

  /**
   * Get the struct fields values
   * @this {!FinalModelSimple}
   * @param {!Simple} fbeValue Simple value
   * @returns {!number} Struct size
   */
  getFields (fbeValue) {
    let fbeCurrentOffset = 0
    let fbeCurrentSize = 0
    let fbeResult

    this.name.fbeOffset = fbeCurrentOffset
    fbeResult = this.name.get()
    fbeValue.name = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.depth.fbeOffset = fbeCurrentOffset
    fbeResult = this.depth.get()
    fbeValue.depth = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.sa.fbeOffset = fbeCurrentOffset
    fbeResult = this.sa.get(fbeValue.sa)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.sex.fbeOffset = fbeCurrentOffset
    fbeResult = this.sex.get()
    fbeValue.sex = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    return fbeCurrentSize
  }

  /**
   * Set the struct value
   * @this {!FinalModelSimple}
   * @param {!Simple} fbeValue Simple value
   * @returns {!number} Final model size
   */
  set (fbeValue) {
    this._buffer.shift(this.fbeOffset)
    let fbeSize = this.setFields(fbeValue)
    this._buffer.unshift(this.fbeOffset)
    return fbeSize
  }

  /**
   * Set the struct fields values
   * @this {!FinalModelSimple}
   * @param {Simple} fbeValue Simple value
   * @returns {!number} Final model size
   */
  setFields (fbeValue) {
    let fbeCurrentOffset = 0
    let fbeCurrentSize = 0
    let fbeFieldSize

    this.name.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.name.set(fbeValue.name)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.depth.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.depth.set(fbeValue.depth)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.sa.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.sa.set(fbeValue.sa)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.sex.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.sex.set(fbeValue.sex)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    return fbeCurrentSize
  }
}

exports.FinalModelSimple = FinalModelSimple

/**
 * Fast Binary Encoding Simple final model
 */
class SimpleFinalModel extends fbe.Model {
  /**
   * Initialize final model with the given buffer
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Read/Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer)
    this._model = new FinalModelSimple(this.buffer, 8)
  }

  /**
   * Get the model type
   * @this {!SimpleFinalModel}
   * @returns {!number} Model type
   */
  get fbeType () {
    return SimpleFinalModel.fbeType
  }

  /**
   * Get the model type (static)
   * @this {!SimpleFinalModel}
   * @returns {!number} Model type
   */
  static get fbeType () {
    return FinalModelSimple.fbeType
  }

  /**
   * Check if the struct value is valid
   * @this {!SimpleFinalModel}
   * @returns {!boolean} Model valid state
   */
  verify () {
    if ((this.buffer.offset + this._model.fbeOffset) > this.buffer.size) {
      return false
    }

    let fbeStructSize = this.readUInt32(this._model.fbeOffset - 8)
    let fbeStructType = this.readUInt32(this._model.fbeOffset - 4)
    if ((fbeStructSize <= 0) || (fbeStructType !== this.fbeType)) {
      return false
    }

    return ((8 + this._model.verify()) === fbeStructSize)
  }

  /**
   * Serialize the struct value
   * @this {!SimpleFinalModel}
   * @param {!Simple} value Simple value
   * @return {!number} Struct size
   */
  serialize (value) {
    let fbeInitialSize = this.buffer.size

    let fbeStructType = this.fbeType
    let fbeStructSize = 8 + this._model.fbeAllocationSize(value)
    let fbeStructOffset = this.buffer.allocate(fbeStructSize) - this.buffer.offset
    console.assert(((this.buffer.offset + fbeStructOffset + fbeStructSize) <= this.buffer.size), 'Model is broken!')
    if ((this.buffer.offset + fbeStructOffset + fbeStructSize) > this.buffer.size) {
      return 0
    }

    fbeStructSize = 8 + this._model.set(value)
    this.buffer.resize(fbeInitialSize + fbeStructSize)

    this.writeUInt32(this._model.fbeOffset - 8, fbeStructSize)
    this.writeUInt32(this._model.fbeOffset - 4, fbeStructType)

    return fbeStructSize
  }

  /**
   * Deserialize the struct value
   * @this {!SimpleFinalModel}
   * @param {!Simple} value Simple value, defaults is new Simple()
   * @return {!object} Deserialized Simple value and its size
   */
  deserialize (value = new Simple()) {
    console.assert(((this.buffer.offset + this._model.fbeOffset) <= this.buffer.size), 'Model is broken!')
    if ((this.buffer.offset + this._model.fbeOffset) > this.buffer.size) {
      return { value: new Simple(), size: 0 }
    }

    let fbeStructSize = this.readUInt32(this._model.fbeOffset - 8)
    let fbeStructType = this.readUInt32(this._model.fbeOffset - 4)
    console.assert(((fbeStructSize > 0) && (fbeStructType === this.fbeType)), 'Model is broken!')
    if ((fbeStructSize <= 0) || (fbeStructType !== this.fbeType)) {
      return { value: new Simple(), size: 8 }
    }

    let fbeResult = this._model.get(value)
    return { value: fbeResult.value, size: (8 + fbeResult.size) }
  }

  /**
   * Move to the next struct value
   * @this {!SimpleFinalModel}
   * @param {!number} prev Previous Simple model size
   */
  next (prev) {
    this._model.fbeShift(prev)
  }
}

exports.SimpleFinalModel = SimpleFinalModel

// Protocol major version
const ProtocolVersionMajor = 0
// Protocol minor version
const ProtocolVersionMinor = 0

exports.ProtocolVersionMajor = ProtocolVersionMajor
exports.ProtocolVersionMinor = ProtocolVersionMinor

/**
 * Fast Binary Encoding osa sender
 */
class Sender extends fbe.Sender {
  /**
   * Initialize osa sender with the given buffer
   * @param {!fbe.WriteBuffer} buffer Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer, false)
    this.onSendHandler = this.onSend
    this.onSendLogHandler = this.onSendLog
  }

  // Sender models accessors

  // Send methods

  /**
   * Send value
   * @this {!Sender}
   * @param {!object} value Value to send
   * @returns {!number} Sent bytes
   */
  send (value) {
    return 0
  }

  /**
   * Send message handler
   * @this {!Sender}
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   */
  onSend (buffer, offset, size) {
    console.assert(true, 'osa.Sender.onSend() not implemented!')
    debugger // eslint-disable-line
    return 0
  }

  /**
   * Setup send message handler
   * @this {!Sender}
   * @param {!function} handler Send message handler
   */
  set onSendHandler (handler) { // eslint-disable-line
    this.onSend = handler
  }

  /**
   * Setup send log message handler
   * @this {!Sender}
   * @param {!function} handler Send log message handler
   */
  set onSendLogHandler (handler) { // eslint-disable-line
    this.onSendLog = handler
  }
}

exports.Sender = Sender

/**
 * Fast Binary Encoding osa receiver
 */
class Receiver extends fbe.Receiver {
  /**
   * Initialize osa receiver with the given buffer
   * @param {!fbe.WriteBuffer} buffer Write buffer, defaults is new WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer, false)
    this.onReceiveLogHandler = this.onReceiveLog
  }

  // Receive handlers

  /**
   * osa receive message handler
   * @this {!Receiver}
   * @param {!number} type Message type
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   * @returns {!boolean} Success flag
   */
  onReceive (type, buffer, offset, size) {
    switch (type) {
      default: break
    }
    return false
  }

  /**
   * Setup receive log message handler
   * @this {!Receiver}
   * @param {!function} handler Receive log message handler
   */
  set onReceiveLogHandler (handler) { // eslint-disable-line
    this.onReceiveLog = handler
  }
}

exports.Receiver = Receiver

/**
 * Fast Binary Encoding osa proxy
 */
class Proxy extends fbe.Receiver {
  /**
   * Initialize osa proxy with the given buffer
   * @param {!fbe.WriteBuffer} buffer Write buffer, defaults is new WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer, false)
  }

  // Proxy handlers

  /**
   * osa receive message handler
   * @this {!Proxy}
   * @param {!number} type Message type
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   * @returns {!boolean} Success flag
   */
  onReceive (type, buffer, offset, size) {
    switch (type) {
      default: break
    }
    return false
  }
}

exports.Proxy = Proxy

/**
 * Fast Binary Encoding osa client
 */
class Client extends fbe.Client {
  /**
   * Initialize osa client with the given buffers
   * @param {!fbe.WriteBuffer} sendBuffer Send buffer, defaults is new fbe.WriteBuffer()
   * @param {!fbe.WriteBuffer} receiveBuffer Receive buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (sendBuffer = new fbe.WriteBuffer(), receiveBuffer = new fbe.WriteBuffer()) {
    super(sendBuffer, receiveBuffer, false)
    this.onSendHandler = this.onSend
    this.onSendLogHandler = this.onSendLog
    this.onReceiveLogHandler = this.onReceiveLog
    this._timestamp = 0
    this._requests_by_id = new Map()
    this._requests_by_timestamp = new Map()
  }

  // Sender models accessors

  // Reset and watchdog methods

  /**
   * Reset the client
   * @this {!Client}
   */
  reset () {
    super.reset()
    this.resetRequests()
  }

  /**
   * Watchdog for timeouts
   * @this {!Client}
   * @param {!number} utc UTC timestamp
   */
  watchdog (utc) {
    this.watchdogRequests(utc)
  }

  // Send methods

  /**
   * Send value
   * @this {!Client}
   * @param {!object} value Value to send
   * @returns {!number} Sent bytes
   */
  send (value) {
    return 0
  }

  /**
   * Send message handler
   * @this {!Client}
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   */
  onSend (buffer, offset, size) {
    console.assert(true, 'osa.Client.onSend() not implemented!')
    debugger // eslint-disable-line
    return 0
  }

  /**
   * Setup send message handler
   * @this {!Client}
   * @param {!function} handler Send message handler
   */
  set onSendHandler (handler) { // eslint-disable-line
    this.onSend = handler
  }

  /**
   * Setup send log message handler
   * @this {!Client}
   * @param {!function} handler Send log message handler
   */
  set onSendLogHandler (handler) { // eslint-disable-line
    this.onSendLog = handler
  }

  // Receive handlers

  /**
   * osa receive message handler
   * @this {!Client}
   * @param {!number} type Message type
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   * @returns {!boolean} Success flag
   */
  onReceive (type, buffer, offset, size) {
    switch (type) {
      default: break
    }
    return false
  }

  /**
   * Setup receive log message handler
   * @this {!Client}
   * @param {!function} handler Receive log message handler
   */
  set onReceiveLogHandler (handler) { // eslint-disable-line
    this.onReceiveLog = handler
  }

  // Request methods

  /**
   * Request value
   * @this {!Client}
   * @param {!object} value Value to request
   * @param {!number} timeout Timeout in milliseconds (default is 0)
   * @returns {Promise} Response promise
   */
  request (value, timeout = 0) {
    let promise = new fbe.DeferredPromise()
    let current = Date.now()

    // Send the request message
    let serialized = this.send(value)
    if (serialized > 0) {
      // Calculate the unique timestamp
      this._timestamp = (current <= this._timestamp) ? this._timestamp + 1 : current

      // Register the request
      this._requests_by_id.set(value.id, [this._timestamp, timeout, promise])
      if (timeout > 0) {
        this._requests_by_timestamp.set(this._timestamp, value.id)
      }
    } else {
      promise.reject(new Error('Send request failed!'))
    }

    return promise
  }

  /**
   * Response value
   * @this {!Client}
   * @param {!object} value Value to response
   * @returns {!boolean} Response handle flag
   */
  response (value) {
    let item = this._requests_by_id.get(value.id)
    if (item != null) {
      let timestamp = item[0]
      let promise = item[2]
      promise.resolve(value)
      this._requests_by_id.delete(value.id)
      this._requests_by_timestamp.delete(timestamp)
      return true
    }
    return false
  }

  /**
   * Reject value
   * @this {!Client}
   * @param {!object} value Value to reject
   * @returns {!boolean} Reject handle flag
   */
  reject (value) {
    let item = this._requests_by_id.get(value.id)
    if (item != null) {
      let timestamp = item[0]
      let promise = item[2]
      promise.reject(value)
      this._requests_by_id.delete(value.id)
      this._requests_by_timestamp.delete(timestamp)
      return true
    }
    return false
  }

  /**
   * Reset client requests
   * @this {!Client}
   */
  resetRequests () {
    for (let [, value] of this._requests_by_id) {
      value[2].reject(new Error('Reset client!'))
    }
    this._requests_by_id.clear()
    this._requests_by_timestamp.clear()
  }

  /**
   * Watchdog client requests for timeouts
   * @this {!Client}
   * @param {!number} utc UTC timestamp in milliseconds
   */
  watchdogRequests (utc) {
    for (let [, value] of this._requests_by_timestamp) {
      let item = this._requests_by_id.get(value)
      let id = value
      let timestamp = item[0]
      let timespan = item[1]
      if ((timestamp + timespan) <= utc) {
        let promise = item[2]
        promise.reject(new Error('Timeout!'))
        this._requests_by_id.delete(id)
        this._requests_by_timestamp.delete(timestamp)
      }
    }
  }
}

exports.Client = Client

/**
 * Fast Binary Encoding osa final sender
 */
class FinalSender extends fbe.Sender {
  /**
   * Initialize osa sender with the given buffer
   * @param {!fbe.WriteBuffer} buffer Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer, true)
    this.onSendHandler = this.onSend
    this.onSendLogHandler = this.onSendLog
  }

  // Sender models accessors

  // Send methods

  /**
   * Send value
   * @this {!FinalSender}
   * @param {!object} value Value to send
   * @returns {!number} Sent bytes
   */
  send (value) {
    return 0
  }

  /**
   * Send message handler
   * @this {!FinalSender}
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   */
  onSend (buffer, offset, size) {
    console.assert(true, 'osa.Sender.onSend() not implemented!')
    debugger // eslint-disable-line
    return 0
  }

  /**
   * Setup send message handler
   * @this {!FinalSender}
   * @param {!function} handler Send message handler
   */
  set onSendHandler (handler) { // eslint-disable-line
    this.onSend = handler
  }

  /**
   * Setup send log message handler
   * @this {!FinalSender}
   * @param {!function} handler Send log message handler
   */
  set onSendLogHandler (handler) { // eslint-disable-line
    this.onSendLog = handler
  }
}

exports.FinalSender = FinalSender

/**
 * Fast Binary Encoding osa final receiver
 */
class FinalReceiver extends fbe.Receiver {
  /**
   * Initialize osa receiver with the given buffer
   * @param {!fbe.WriteBuffer} buffer Write buffer, defaults is new WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer, true)
    this.onReceiveLogHandler = this.onReceiveLog
  }

  // Receive handlers

  /**
   * osa receive message handler
   * @this {!FinalReceiver}
   * @param {!number} type Message type
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   * @returns {!boolean} Success flag
   */
  onReceive (type, buffer, offset, size) {
    switch (type) {
      default: break
    }
    return false
  }

  /**
   * Setup receive log message handler
   * @this {!FinalReceiver}
   * @param {!function} handler Receive log message handler
   */
  set onReceiveLogHandler (handler) { // eslint-disable-line
    this.onReceiveLog = handler
  }
}

exports.FinalReceiver = FinalReceiver

/**
 * Fast Binary Encoding osa final client
 */
class FinalClient extends fbe.Client {
  /**
   * Initialize osa client with the given buffers
   * @param {!fbe.WriteBuffer} sendBuffer Send buffer, defaults is new fbe.WriteBuffer()
   * @param {!fbe.WriteBuffer} receiveBuffer Receive buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (sendBuffer = new fbe.WriteBuffer(), receiveBuffer = new fbe.WriteBuffer()) {
    super(sendBuffer, receiveBuffer, true)
    this.onSendHandler = this.onSend
    this.onSendLogHandler = this.onSendLog
    this.onReceiveLogHandler = this.onReceiveLog
    this._timestamp = 0
    this._requests_by_id = new Map()
    this._requests_by_timestamp = new Map()
  }

  // Sender models accessors

  // Reset and watchdog methods

  /**
   * Reset the client
   * @this {!FinalClient}
   */
  reset () {
    super.reset()
    this.resetRequests()
  }

  /**
   * Watchdog for timeouts
   * @this {!FinalClient}
   * @param {!number} utc UTC timestamp
   */
  watchdog (utc) {
    this.watchdogRequests(utc)
  }

  // Send methods

  /**
   * Send value
   * @this {!FinalClient}
   * @param {!object} value Value to send
   * @returns {!number} Sent bytes
   */
  send (value) {
    return 0
  }

  /**
   * Send message handler
   * @this {!FinalClient}
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   */
  onSend (buffer, offset, size) {
    console.assert(true, 'osa.Client.onSend() not implemented!')
    debugger // eslint-disable-line
    return 0
  }

  /**
   * Setup send message handler
   * @this {!FinalClient}
   * @param {!function} handler Send message handler
   */
  set onSendHandler (handler) { // eslint-disable-line
    this.onSend = handler
  }

  /**
   * Setup send log message handler
   * @this {!FinalClient}
   * @param {!function} handler Send log message handler
   */
  set onSendLogHandler (handler) { // eslint-disable-line
    this.onSendLog = handler
  }

  // Receive handlers

  /**
   * osa receive message handler
   * @this {!FinalClient}
   * @param {!number} type Message type
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   * @returns {!boolean} Success flag
   */
  onReceive (type, buffer, offset, size) {
    switch (type) {
      default: break
    }
    return false
  }

  /**
   * Setup receive log message handler
   * @this {!FinalClient}
   * @param {!function} handler Receive log message handler
   */
  set onReceiveLogHandler (handler) { // eslint-disable-line
    this.onReceiveLog = handler
  }

  // Request methods

  /**
   * Request value
   * @this {!FinalClient}
   * @param {!object} value Value to request
   * @param {!number} timeout Timeout in milliseconds (default is 0)
   * @returns {Promise} Response promise
   */
  request (value, timeout = 0) {
    let promise = new fbe.DeferredPromise()
    let current = Date.now()

    // Send the request message
    let serialized = this.send(value)
    if (serialized > 0) {
      // Calculate the unique timestamp
      this._timestamp = (current <= this._timestamp) ? this._timestamp + 1 : current

      // Register the request
      this._requests_by_id.set(value.id, [this._timestamp, timeout, promise])
      if (timeout > 0) {
        this._requests_by_timestamp.set(this._timestamp, value.id)
      }
    } else {
      promise.reject(new Error('Send request failed!'))
    }

    return promise
  }

  /**
   * Response value
   * @this {!FinalClient}
   * @param {!object} value Value to response
   * @returns {!boolean} Response handle flag
   */
  response (value) {
    let item = this._requests_by_id.get(value.id)
    if (item != null) {
      let timestamp = item[0]
      let promise = item[2]
      promise.resolve(value)
      this._requests_by_id.delete(value.id)
      this._requests_by_timestamp.delete(timestamp)
      return true
    }
    return false
  }

  /**
   * Reject value
   * @this {!FinalClient}
   * @param {!object} value Value to reject
   * @returns {!boolean} Reject handle flag
   */
  reject (value) {
    let item = this._requests_by_id.get(value.id)
    if (item != null) {
      let timestamp = item[0]
      let promise = item[2]
      promise.reject(value)
      this._requests_by_id.delete(value.id)
      this._requests_by_timestamp.delete(timestamp)
      return true
    }
    return false
  }

  /**
   * Reset client requests
   * @this {!FinalClient}
   */
  resetRequests () {
    for (let [, value] of this._requests_by_id) {
      value[2].reject(new Error('Reset client!'))
    }
    this._requests_by_id.clear()
    this._requests_by_timestamp.clear()
  }

  /**
   * Watchdog client requests for timeouts
   * @this {!FinalClient}
   * @param {!number} utc UTC timestamp in milliseconds
   */
  watchdogRequests (utc) {
    for (let [, value] of this._requests_by_timestamp) {
      let item = this._requests_by_id.get(value)
      let id = value
      let timestamp = item[0]
      let timespan = item[1]
      if ((timestamp + timespan) <= utc) {
        let promise = item[2]
        promise.reject(new Error('Timeout!'))
        this._requests_by_id.delete(id)
        this._requests_by_timestamp.delete(timestamp)
      }
    }
  }
}

exports.FinalClient = FinalClient
