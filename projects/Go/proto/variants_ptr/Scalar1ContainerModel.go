//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: variants_ptr.fbe
// FBE version: 1.11.0.0
//------------------------------------------------------------------------------

package variants_ptr

import "errors"
import "fbeproj/proto/fbe"

// Workaround for Go unused imports issue
var _ = errors.New
var _ = fbe.Version

// Fast Binary Encoding Scalar1Container model
type Scalar1ContainerModel struct {
    // Model buffer
    buffer *fbe.Buffer

    // Field model
    model *FieldModelScalar1Container
}

// Create a new Scalar1Container model
func NewScalar1ContainerModel(buffer *fbe.Buffer) *Scalar1ContainerModel {
    return &Scalar1ContainerModel{buffer: buffer, model: NewFieldModelScalar1Container(buffer, 4)}
}

// Get the model buffer
func (m *Scalar1ContainerModel) Buffer() *fbe.Buffer { return m.buffer }
// Get the field model
func (m *Scalar1ContainerModel) Model() *FieldModelScalar1Container { return m.model }

// Get the model size
func (m *Scalar1ContainerModel) FBESize() int { return m.model.FBESize() + m.model.FBEExtra() }
// // Get the model type
func (m *Scalar1ContainerModel) FBEType() int { return m.model.FBEType() }

// Check if the struct value is valid
func (m *Scalar1ContainerModel) Verify() bool {
    if (m.buffer.Offset() + m.model.FBEOffset() - 4) > m.buffer.Size() {
        return false
    }

    fbeFullSize := int(fbe.ReadUInt32(m.buffer.Data(), m.buffer.Offset() + m.model.FBEOffset() - 4))
    if fbeFullSize < m.model.FBESize() {
        return false
    }

    return m.model.Verify()
}

// Create a new model (begin phase)
func (m *Scalar1ContainerModel) CreateBegin() int {
    fbeBegin := m.buffer.Allocate(4 + m.model.FBESize())
    return fbeBegin
}

// Create a new model (end phase)
func (m *Scalar1ContainerModel) CreateEnd(fbeBegin int) int {
    fbeEnd := m.buffer.Size()
    fbeFullSize := fbeEnd - fbeBegin
    fbe.WriteUInt32(m.buffer.Data(), m.buffer.Offset() + m.model.FBEOffset() - 4, uint32(fbeFullSize))
    return fbeFullSize
}

// Serialize the struct value
func (m *Scalar1ContainerModel) Serialize(value *Scalar1Container) (int, error) {
    fbeBegin := m.CreateBegin()
    err := m.model.Set(value)
    fbeFullSize := m.CreateEnd(fbeBegin)
    return fbeFullSize, err
}

// Deserialize the struct value
func (m *Scalar1ContainerModel) Deserialize() (*Scalar1Container, int, error) {
    value := NewScalar1Container()
    fbeFullSize, err := m.DeserializeValue(value)
    return value, fbeFullSize, err
}

// Deserialize the struct value by the given pointer
func (m *Scalar1ContainerModel) DeserializeValue(value *Scalar1Container) (int, error) {
    if (m.buffer.Offset() + m.model.FBEOffset() - 4) > m.buffer.Size() {
        value = NewScalar1Container()
        return 0, nil
    }

    fbeFullSize := int(fbe.ReadUInt32(m.buffer.Data(), m.buffer.Offset() + m.model.FBEOffset() - 4))
    if fbeFullSize < m.model.FBESize() {
        value = NewScalar1Container()
        return 0, errors.New("model is broken")
    }

    err := m.model.GetValue(value)
    return fbeFullSize, err
}

// Move to the next struct value
func (m *Scalar1ContainerModel) Next(prev int) {
    m.model.FBEShift(prev)
}
